<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Arrow (C++): arrow::compute Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Arrow (C++)
   </div>
   <div id="projectbrief">A columnar in-memory analytics layer designed to accelerate big data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacearrow.html">arrow</a></li><li class="navelem"><a class="el" href="namespacearrow_1_1compute.html">compute</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">arrow::compute Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacearrow_1_1compute_1_1array"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1array.html">array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1compute_1_1ops"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1ops.html">ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1compute_1_1scalar"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1scalar.html">scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1compute_1_1type"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1type.html">type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1compute_1_1value"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute_1_1value.html">value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_add_kernel.html">AddKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1compute_1_1_binary_kernel.html" title="An array-valued function of a two input arguments.">BinaryKernel</a> implementing Add operation.  <a href="classarrow_1_1compute_1_1_add_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html">AggregateFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html" title="AggregateFunction is an interface for Aggregates.">AggregateFunction</a> is an interface for Aggregates.  <a href="classarrow_1_1compute_1_1_aggregate_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_aggregate_function_static_state.html">AggregateFunctionStaticState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html" title="AggregateFunction is an interface for Aggregates.">AggregateFunction</a> partial implementation for static type state.  <a href="classarrow_1_1compute_1_1_aggregate_function_static_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_aggregate_unary_kernel.html">AggregateUnaryKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1compute_1_1_unary_kernel.html" title="An array-valued function of a single input argument.">UnaryKernel</a> implemented by an AggregateState.  <a href="classarrow_1_1compute_1_1_aggregate_unary_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_array_expr.html">ArrayExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_array_index_sequence.html">ArrayIndexSequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_benchmark_args_type.html">BenchmarkArgsType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>BenchmarkArgsType&lt; benchmark::internal::Benchmark *(benchmark::internal::Benchmark::*)(const std::vector&lt; Values &gt; &amp;)&gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_binary_kernel.html">BinaryKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array-valued function of a two input arguments.  <a href="classarrow_1_1compute_1_1_binary_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_cast_options.html">CastOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_compare_options.html">CompareOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_count_options.html">CountOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant type for various Arrow C++ data structures.  <a href="structarrow_1_1compute_1_1_datum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all analytic expressions.  <a href="classarrow_1_1compute_1_1_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_filter_kernel.html">FilterKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1compute_1_1_binary_kernel.html" title="An array-valued function of a two input arguments.">BinaryKernel</a> implementing Filter operation.  <a href="classarrow_1_1compute_1_1_filter_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_find_accumulator_type.html">FindAccumulatorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_find_accumulator_type_3_01_i_00_01enable__if__floating__point_3_01_i_01_4_01_4.html">FindAccumulatorType&lt; I, enable_if_floating_point&lt; I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_find_accumulator_type_3_01_i_00_01enable__if__signed__integer_3_01_i_01_4_01_4.html">FindAccumulatorType&lt; I, enable_if_signed_integer&lt; I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_find_accumulator_type_3_01_i_00_01enable__if__unsigned__integer_3_01_i_01_4_01_4.html">FindAccumulatorType&lt; I, enable_if_unsigned_integer&lt; I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for variables and options used by function evaluation.  <a href="classarrow_1_1compute_1_1_function_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_list_taker_impl.html">ListTakerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_logical_type.html">LogicalType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that represents either a single concrete value type or a group of related types, to help with expression type validation and other purposes.  <a href="classarrow_1_1compute_1_1_logical_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operation is a node in a computation graph, taking input data expression dependencies and emitting an output expression.  <a href="classarrow_1_1compute_1_1_operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_op_kernel.html">OpKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for operator kernels.  <a href="classarrow_1_1compute_1_1_op_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_range_index_sequence.html">RangeIndexSequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_regression_args.html">RegressionArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_scalar_expr.html">ScalarExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_sum_aggregate_function.html">SumAggregateFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_take_kernel.html">TakeKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1compute_1_1_binary_kernel.html" title="An array-valued function of a two input arguments.">BinaryKernel</a> implementing Take operation.  <a href="classarrow_1_1compute_1_1_take_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker.html">Taker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl.html">TakerImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_dictionary_type_01_4.html">TakerImpl&lt; IndexSequence, DictionaryType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_extension_type_01_4.html">TakerImpl&lt; IndexSequence, ExtensionType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_fixed_size_list_type_01_4.html">TakerImpl&lt; IndexSequence, FixedSizeListType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_large_list_type_01_4.html">TakerImpl&lt; IndexSequence, LargeListType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_list_type_01_4.html">TakerImpl&lt; IndexSequence, ListType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_map_type_01_4.html">TakerImpl&lt; IndexSequence, MapType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_null_type_01_4.html">TakerImpl&lt; IndexSequence, NullType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_struct_type_01_4.html">TakerImpl&lt; IndexSequence, StructType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_union_type_01_4.html">TakerImpl&lt; IndexSequence, UnionType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1compute_1_1_taker_make_impl.html">TakerMakeImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_unary_kernel.html">UnaryKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array-valued function of a single input argument.  <a href="classarrow_1_1compute_1_1_unary_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1compute_1_1_value_expr.html">ValueExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a data-generated expression with a fixed and known type.  <a href="classarrow_1_1compute_1_1_value_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abcdcabf38ba21c6ca54c9c2630045926"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#abcdcabf38ba21c6ca54c9c2630045926">ArgsType</a> = typename <a class="el" href="structarrow_1_1compute_1_1_benchmark_args_type.html">BenchmarkArgsType</a>&lt; decltype(&amp;benchmark::internal::Benchmark::Args)&gt;::type</td></tr>
<tr class="separator:abcdcabf38ba21c6ca54c9c2630045926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade436c20161be56a69cde0c8e044bd0e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:ade436c20161be56a69cde0c8e044bd0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ade436c20161be56a69cde0c8e044bd0e">enable_if_not_base_binary</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;!std::is_base_of&lt; <a class="el" href="classarrow_1_1_base_binary_type.html">BaseBinaryType</a>, T &gt;::value, R &gt;</td></tr>
<tr class="separator:ade436c20161be56a69cde0c8e044bd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92a8b9428e7982c9a32ff706b516744"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ad92a8b9428e7982c9a32ff706b516744">ArrowTypePtr</a> = std::shared_ptr&lt;::<a class="el" href="classarrow_1_1_data_type.html">arrow::DataType</a> &gt;</td></tr>
<tr class="separator:ad92a8b9428e7982c9a32ff706b516744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7741dfdaf5c06817fdbdaa539534a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a3d7741dfdaf5c06817fdbdaa539534a2">ExprPtr</a> = std::shared_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_expr.html">Expr</a> &gt;</td></tr>
<tr class="separator:a3d7741dfdaf5c06817fdbdaa539534a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af255a47e73df4040c1239b137018bb89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#af255a47e73df4040c1239b137018bb89">ConstOpPtr</a> = std::shared_ptr&lt; const <a class="el" href="classarrow_1_1compute_1_1_operation.html">Operation</a> &gt;</td></tr>
<tr class="separator:af255a47e73df4040c1239b137018bb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33a552016037f2813983a80b5fcaf50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ac33a552016037f2813983a80b5fcaf50">OpPtr</a> = std::shared_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_operation.html">Operation</a> &gt;</td></tr>
<tr class="separator:ac33a552016037f2813983a80b5fcaf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21de3825cdde68e67cd591917584b21b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a21de3825cdde68e67cd591917584b21b">LogicalTypePtr</a> = std::shared_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_logical_type.html">LogicalType</a> &gt;</td></tr>
<tr class="separator:a21de3825cdde68e67cd591917584b21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8c7314c2838c3f4df31d9027983e7b0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a8c7314c2838c3f4df31d9027983e7b0b">ValueRank</a> { <a class="el" href="namespacearrow_1_1compute.html#a8c7314c2838c3f4df31d9027983e7b0ba8f3d9a4b6a7b7f2c7afa61ca113d0db9">ValueRank::SCALAR</a>, 
<a class="el" href="namespacearrow_1_1compute.html#a8c7314c2838c3f4df31d9027983e7b0bacb4fb1757fb37c43cded35d3eb857c43">ValueRank::ARRAY</a>
 }</td></tr>
<tr class="memdesc:a8c7314c2838c3f4df31d9027983e7b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value cardinality: one or many.  <a href="namespacearrow_1_1compute.html#a8c7314c2838c3f4df31d9027983e7b0b">More...</a><br /></td></tr>
<tr class="separator:a8c7314c2838c3f4df31d9027983e7b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722101516c22b89bdf3f54ff6f90cd2e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a722101516c22b89bdf3f54ff6f90cd2e">CompareOperator</a> { <br />
&#160;&#160;<a class="el" href="namespacearrow_1_1compute.html#a722101516c22b89bdf3f54ff6f90cd2ea602792ae96607227306b00b948a49642">EQUAL</a>, 
<a class="el" href="namespacearrow_1_1compute.html#a722101516c22b89bdf3f54ff6f90cd2ea4bcbbc099f2f532f402c86415099f446">NOT_EQUAL</a>, 
<a class="el" href="namespacearrow_1_1compute.html#a722101516c22b89bdf3f54ff6f90cd2ea3da583275ccef5bb978f7c0caf0c93e8">GREATER</a>, 
<a class="el" href="namespacearrow_1_1compute.html#a722101516c22b89bdf3f54ff6f90cd2eaafce6452f6406693fc0b4736f343c19a">GREATER_EQUAL</a>, 
<br />
&#160;&#160;<a class="el" href="namespacearrow_1_1compute.html#a722101516c22b89bdf3f54ff6f90cd2eaece4bea22705948d598457047b45a713">LESS</a>, 
<a class="el" href="namespacearrow_1_1compute.html#a722101516c22b89bdf3f54ff6f90cd2eab8cba2f6e6f1cb0afed2d02ee7ed5afa">LESS_EQUAL</a>
<br />
 }</td></tr>
<tr class="separator:a722101516c22b89bdf3f54ff6f90cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a471b198ae0c536b6f694f9ca76800cc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a471b198ae0c536b6f694f9ca76800cc9">BenchmarkSetArgsWithSizes</a> (benchmark::internal::Benchmark *bench, const std::vector&lt; int64_t &gt; &amp;sizes=kMemorySizes)</td></tr>
<tr class="separator:a471b198ae0c536b6f694f9ca76800cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e989a6765f48fe18e0febfa4c4e2006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a3e989a6765f48fe18e0febfa4c4e2006">BenchmarkSetArgs</a> (benchmark::internal::Benchmark *bench)</td></tr>
<tr class="separator:a3e989a6765f48fe18e0febfa4c4e2006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200d700dfe799b541a272c3c05892c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a5200d700dfe799b541a272c3c05892c4">RegressionSetArgs</a> (benchmark::internal::Benchmark *bench)</td></tr>
<tr class="separator:a5200d700dfe799b541a272c3c05892c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb07c5f8cc6b295a7b39681058a1af39"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ObjectType &gt; </td></tr>
<tr class="memitem:acb07c5f8cc6b295a7b39681058a1af39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#acb07c5f8cc6b295a7b39681058a1af39">InheritsFrom</a> (const ObjectType *obj)</td></tr>
<tr class="separator:acb07c5f8cc6b295a7b39681058a1af39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137884557c4ada6b6c4b9f381fd7165b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ObjectType &gt; </td></tr>
<tr class="memitem:a137884557c4ada6b6c4b9f381fd7165b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a137884557c4ada6b6c4b9f381fd7165b">InheritsFrom</a> (const ObjectType &amp;obj)</td></tr>
<tr class="separator:a137884557c4ada6b6c4b9f381fd7165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc53dddd8a483d5a242c37aa655c5ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#abc53dddd8a483d5a242c37aa655c5ddc">GetScalarExpr</a> (<a class="el" href="namespacearrow_1_1compute.html#af255a47e73df4040c1239b137018bb89">ConstOpPtr</a> op, <a class="el" href="namespacearrow_1_1compute.html#a21de3825cdde68e67cd591917584b21b">LogicalTypePtr</a> ty, <a class="el" href="namespacearrow_1_1compute.html#a3d7741dfdaf5c06817fdbdaa539534a2">ExprPtr</a> *out)</td></tr>
<tr class="memdesc:abc53dddd8a483d5a242c37aa655c5ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1compute_1_1_scalar_expr.html">ScalarExpr</a> containing an <a class="el" href="classarrow_1_1compute_1_1_operation.html" title="An operation is a node in a computation graph, taking input data expression dependencies and emitting...">Operation</a> given a logical type.  <a href="namespacearrow_1_1compute.html#abc53dddd8a483d5a242c37aa655c5ddc">More...</a><br /></td></tr>
<tr class="separator:abc53dddd8a483d5a242c37aa655c5ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0444dc9ae8752dfc070c0583106d3193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a0444dc9ae8752dfc070c0583106d3193">GetArrayExpr</a> (<a class="el" href="namespacearrow_1_1compute.html#af255a47e73df4040c1239b137018bb89">ConstOpPtr</a> op, <a class="el" href="namespacearrow_1_1compute.html#a21de3825cdde68e67cd591917584b21b">LogicalTypePtr</a> ty, <a class="el" href="namespacearrow_1_1compute.html#a3d7741dfdaf5c06817fdbdaa539534a2">ExprPtr</a> *out)</td></tr>
<tr class="memdesc:a0444dc9ae8752dfc070c0583106d3193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="classarrow_1_1compute_1_1_array_expr.html">ArrayExpr</a> containing an <a class="el" href="classarrow_1_1compute_1_1_operation.html" title="An operation is a node in a computation graph, taking input data expression dependencies and emitting...">Operation</a> given a logical type.  <a href="namespacearrow_1_1compute.html#a0444dc9ae8752dfc070c0583106d3193">More...</a><br /></td></tr>
<tr class="separator:a0444dc9ae8752dfc070c0583106d3193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a49ecaa4199b437adbddfe1481f52e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a24a49ecaa4199b437adbddfe1481f52e">Add</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;lhs, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;rhs, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *result)</td></tr>
<tr class="memdesc:a24a49ecaa4199b437adbddfe1481f52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summarizes two arrays.  <a href="namespacearrow_1_1compute.html#a24a49ecaa4199b437adbddfe1481f52e">More...</a><br /></td></tr>
<tr class="separator:a24a49ecaa4199b437adbddfe1481f52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157d9c73ff1d5c9730a3f9fbb2a91286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a157d9c73ff1d5c9730a3f9fbb2a91286">Invert</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;value, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a157d9c73ff1d5c9730a3f9fbb2a91286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the values of a boolean datum.  <a href="namespacearrow_1_1compute.html#a157d9c73ff1d5c9730a3f9fbb2a91286">More...</a><br /></td></tr>
<tr class="separator:a157d9c73ff1d5c9730a3f9fbb2a91286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1effccba3cfc4b88a01a9ed5d0338db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a1effccba3cfc4b88a01a9ed5d0338db6">And</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;left, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;right, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a1effccba3cfc4b88a01a9ed5d0338db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AND of two boolean datums which always propagates nulls (null and false is null).  <a href="namespacearrow_1_1compute.html#a1effccba3cfc4b88a01a9ed5d0338db6">More...</a><br /></td></tr>
<tr class="separator:a1effccba3cfc4b88a01a9ed5d0338db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b66852874f97dedaae34b17a94f2ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ad3b66852874f97dedaae34b17a94f2ad">KleeneAnd</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;left, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;right, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:ad3b66852874f97dedaae34b17a94f2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise AND of two boolean datums with a Kleene truth table (null and false is false).  <a href="namespacearrow_1_1compute.html#ad3b66852874f97dedaae34b17a94f2ad">More...</a><br /></td></tr>
<tr class="separator:ad3b66852874f97dedaae34b17a94f2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c42e1e03467da2a48e841a1337be7f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a5c42e1e03467da2a48e841a1337be7f5">Or</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;left, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;right, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a5c42e1e03467da2a48e841a1337be7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise OR of two boolean datums which always propagates nulls (null and true is null).  <a href="namespacearrow_1_1compute.html#a5c42e1e03467da2a48e841a1337be7f5">More...</a><br /></td></tr>
<tr class="separator:a5c42e1e03467da2a48e841a1337be7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aefdd5a0890cf0824bdbc6f7e7ec561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a5aefdd5a0890cf0824bdbc6f7e7ec561">KleeneOr</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;left, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;right, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a5aefdd5a0890cf0824bdbc6f7e7ec561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise OR of two boolean datums with a Kleene truth table (null or true is true).  <a href="namespacearrow_1_1compute.html#a5aefdd5a0890cf0824bdbc6f7e7ec561">More...</a><br /></td></tr>
<tr class="separator:a5aefdd5a0890cf0824bdbc6f7e7ec561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af0c55adb14f8e018227e4575e0aa38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a4af0c55adb14f8e018227e4575e0aa38">Xor</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;left, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;right, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a4af0c55adb14f8e018227e4575e0aa38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise XOR of two boolean datums.  <a href="namespacearrow_1_1compute.html#a4af0c55adb14f8e018227e4575e0aa38">More...</a><br /></td></tr>
<tr class="separator:a4af0c55adb14f8e018227e4575e0aa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b785d94aca34a10de4d1218a2b924a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a1b785d94aca34a10de4d1218a2b924a3">GetCastFunction</a> (const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;in_type, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; to_type, const <a class="el" href="structarrow_1_1compute_1_1_cast_options.html">CastOptions</a> &amp;options, std::unique_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_unary_kernel.html">UnaryKernel</a> &gt; *kernel)</td></tr>
<tr class="separator:a1b785d94aca34a10de4d1218a2b924a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87994288b6e4b96a52d9fc32e579c9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a87994288b6e4b96a52d9fc32e579c9ec">Cast</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;value, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; to_type, const <a class="el" href="structarrow_1_1compute_1_1_cast_options.html">CastOptions</a> &amp;options, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *out)</td></tr>
<tr class="memdesc:a87994288b6e4b96a52d9fc32e579c9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast from one array type to another.  <a href="namespacearrow_1_1compute.html#a87994288b6e4b96a52d9fc32e579c9ec">More...</a><br /></td></tr>
<tr class="separator:a87994288b6e4b96a52d9fc32e579c9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6a3d4dda9ae8624603cea6da76dc55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#adf6a3d4dda9ae8624603cea6da76dc55">Cast</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;value, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; to_type, const <a class="el" href="structarrow_1_1compute_1_1_cast_options.html">CastOptions</a> &amp;options, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:adf6a3d4dda9ae8624603cea6da76dc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast from one value to another.  <a href="namespacearrow_1_1compute.html#adf6a3d4dda9ae8624603cea6da76dc55">More...</a><br /></td></tr>
<tr class="separator:adf6a3d4dda9ae8624603cea6da76dc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97e791761922ec76882bdca17c08808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ae97e791761922ec76882bdca17c08808">MakeCompareKernel</a> (const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;type, <a class="el" href="structarrow_1_1compute_1_1_compare_options.html">CompareOptions</a> options, std::shared_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_binary_kernel.html">BinaryKernel</a> &gt; *out)</td></tr>
<tr class="memdesc:ae97e791761922ec76882bdca17c08808"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1compute_1_1_binary_kernel.html" title="An array-valued function of a two input arguments.">BinaryKernel</a> bound implementing comparison.  <a href="namespacearrow_1_1compute.html#ae97e791761922ec76882bdca17c08808">More...</a><br /></td></tr>
<tr class="separator:ae97e791761922ec76882bdca17c08808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7e88adfcea48dd0aaec2d14a9d85ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#aaa7e88adfcea48dd0aaec2d14a9d85ab">Compare</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;left, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;right, struct <a class="el" href="structarrow_1_1compute_1_1_compare_options.html">CompareOptions</a> options, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:aaa7e88adfcea48dd0aaec2d14a9d85ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a numeric array with a scalar.  <a href="namespacearrow_1_1compute.html#aaa7e88adfcea48dd0aaec2d14a9d85ab">More...</a><br /></td></tr>
<tr class="separator:aaa7e88adfcea48dd0aaec2d14a9d85ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae585e5596b3e5c70eef8a916be23e7cb"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html">AggregateFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ae585e5596b3e5c70eef8a916be23e7cb">MakeCount</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_count_options.html">CountOptions</a> &amp;options)</td></tr>
<tr class="memdesc:ae585e5596b3e5c70eef8a916be23e7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Count function aggregate.  <a href="namespacearrow_1_1compute.html#ae585e5596b3e5c70eef8a916be23e7cb">More...</a><br /></td></tr>
<tr class="separator:ae585e5596b3e5c70eef8a916be23e7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa409c2094425f36d0d41f0c1d3335bac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#aa409c2094425f36d0d41f0c1d3335bac">Count</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_count_options.html">CountOptions</a> &amp;options, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;datum, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:aa409c2094425f36d0d41f0c1d3335bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count non-null (or null) values in an array.  <a href="namespacearrow_1_1compute.html#aa409c2094425f36d0d41f0c1d3335bac">More...</a><br /></td></tr>
<tr class="separator:aa409c2094425f36d0d41f0c1d3335bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775549b0138d5cc4f9b1d3380852b771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a775549b0138d5cc4f9b1d3380852b771">Count</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_count_options.html">CountOptions</a> &amp;options, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;array, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a775549b0138d5cc4f9b1d3380852b771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count non-null (or null) values in an array.  <a href="namespacearrow_1_1compute.html#a775549b0138d5cc4f9b1d3380852b771">More...</a><br /></td></tr>
<tr class="separator:a775549b0138d5cc4f9b1d3380852b771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddaf11808e069910139087ef7a60510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#aeddaf11808e069910139087ef7a60510">Filter</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;values, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;filter, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *out)</td></tr>
<tr class="memdesc:aeddaf11808e069910139087ef7a60510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter an array with a boolean selection filter.  <a href="namespacearrow_1_1compute.html#aeddaf11808e069910139087ef7a60510">More...</a><br /></td></tr>
<tr class="separator:aeddaf11808e069910139087ef7a60510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517e03df9b2158832ec8eb818d02bb25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a517e03df9b2158832ec8eb818d02bb25">Filter</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;values, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;filter, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *out)</td></tr>
<tr class="memdesc:a517e03df9b2158832ec8eb818d02bb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a chunked array with a boolean selection filter.  <a href="namespacearrow_1_1compute.html#a517e03df9b2158832ec8eb818d02bb25">More...</a><br /></td></tr>
<tr class="separator:a517e03df9b2158832ec8eb818d02bb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7086d5c6d5c61ae4a5d8ec6f0635506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ab7086d5c6d5c61ae4a5d8ec6f0635506">Filter</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;values, const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;filter, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *out)</td></tr>
<tr class="memdesc:ab7086d5c6d5c61ae4a5d8ec6f0635506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a chunked array with a boolean selection filter.  <a href="namespacearrow_1_1compute.html#ab7086d5c6d5c61ae4a5d8ec6f0635506">More...</a><br /></td></tr>
<tr class="separator:ab7086d5c6d5c61ae4a5d8ec6f0635506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581bb18d0337ca6e7fbf4faf7d8f8683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a581bb18d0337ca6e7fbf4faf7d8f8683">Filter</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &amp;batch, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;filter, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt; *out)</td></tr>
<tr class="memdesc:a581bb18d0337ca6e7fbf4faf7d8f8683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a record batch with a boolean selection filter.  <a href="namespacearrow_1_1compute.html#a581bb18d0337ca6e7fbf4faf7d8f8683">More...</a><br /></td></tr>
<tr class="separator:a581bb18d0337ca6e7fbf4faf7d8f8683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76a69da97f321c6813a44a1e9fc40a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ac76a69da97f321c6813a44a1e9fc40a3">Filter</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;table, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;filter, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out)</td></tr>
<tr class="memdesc:ac76a69da97f321c6813a44a1e9fc40a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a table with a boolean selection filter.  <a href="namespacearrow_1_1compute.html#ac76a69da97f321c6813a44a1e9fc40a3">More...</a><br /></td></tr>
<tr class="separator:ac76a69da97f321c6813a44a1e9fc40a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f498530814175ce7180160235046b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a57f498530814175ce7180160235046b6">Filter</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;table, const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;filter, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out)</td></tr>
<tr class="memdesc:a57f498530814175ce7180160235046b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a table with a boolean selection filter.  <a href="namespacearrow_1_1compute.html#a57f498530814175ce7180160235046b6">More...</a><br /></td></tr>
<tr class="separator:a57f498530814175ce7180160235046b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b34919ba0ebb6fa5534260c416796bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a4b34919ba0ebb6fa5534260c416796bf">Filter</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;values, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;filter, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a4b34919ba0ebb6fa5534260c416796bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter an array with a boolean selection filter.  <a href="namespacearrow_1_1compute.html#a4b34919ba0ebb6fa5534260c416796bf">More...</a><br /></td></tr>
<tr class="separator:a4b34919ba0ebb6fa5534260c416796bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d011093aecc73991bc11f65c4d0acb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a9d011093aecc73991bc11f65c4d0acb2">Unique</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;datum, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *out)</td></tr>
<tr class="memdesc:a9d011093aecc73991bc11f65c4d0acb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute unique elements from an array-like object.  <a href="namespacearrow_1_1compute.html#a9d011093aecc73991bc11f65c4d0acb2">More...</a><br /></td></tr>
<tr class="separator:a9d011093aecc73991bc11f65c4d0acb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca33d8dd6bff7dd79ceec269c86ff53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#adca33d8dd6bff7dd79ceec269c86ff53">ValueCounts</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;value, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *counts)</td></tr>
<tr class="memdesc:adca33d8dd6bff7dd79ceec269c86ff53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return counts of unique elements from an array-like object.  <a href="namespacearrow_1_1compute.html#adca33d8dd6bff7dd79ceec269c86ff53">More...</a><br /></td></tr>
<tr class="separator:adca33d8dd6bff7dd79ceec269c86ff53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb320b25453cee69ed5c8048bd0e0df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#abb320b25453cee69ed5c8048bd0e0df4">DictionaryEncode</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;data, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:abb320b25453cee69ed5c8048bd0e0df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary-encode values in an array-like object.  <a href="namespacearrow_1_1compute.html#abb320b25453cee69ed5c8048bd0e0df4">More...</a><br /></td></tr>
<tr class="separator:abb320b25453cee69ed5c8048bd0e0df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a7275ae0354ddfaa7ffe0d139497c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a10a7275ae0354ddfaa7ffe0d139497c1">IsIn</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;left, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;right, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a10a7275ae0354ddfaa7ffe0d139497c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsIn returns boolean values if the value is in both left and right arrays.  <a href="namespacearrow_1_1compute.html#a10a7275ae0354ddfaa7ffe0d139497c1">More...</a><br /></td></tr>
<tr class="separator:a10a7275ae0354ddfaa7ffe0d139497c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d9f7d89aaf495af9979791980edb84"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html">AggregateFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ae1d9f7d89aaf495af9979791980edb84">MakeMeanAggregateFunction</a> (const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;type, <a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context)</td></tr>
<tr class="separator:ae1d9f7d89aaf495af9979791980edb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51444316ac3eb35a81962e50b17d4967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a51444316ac3eb35a81962e50b17d4967">Mean</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;value, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *mean)</td></tr>
<tr class="memdesc:a51444316ac3eb35a81962e50b17d4967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean of a numeric array.  <a href="namespacearrow_1_1compute.html#a51444316ac3eb35a81962e50b17d4967">More...</a><br /></td></tr>
<tr class="separator:a51444316ac3eb35a81962e50b17d4967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7087b36a0180f6f86d4aa8a9fac3195b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a7087b36a0180f6f86d4aa8a9fac3195b">Mean</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;array, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *mean)</td></tr>
<tr class="memdesc:a7087b36a0180f6f86d4aa8a9fac3195b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean of a numeric array.  <a href="namespacearrow_1_1compute.html#a7087b36a0180f6f86d4aa8a9fac3195b">More...</a><br /></td></tr>
<tr class="separator:a7087b36a0180f6f86d4aa8a9fac3195b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64fb43adf02634e081f5ae1a79edaf9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html">AggregateFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ae64fb43adf02634e081f5ae1a79edaf9">MakeMinMaxAggregateFunction</a> (const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;type, <a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a> &amp;options)</td></tr>
<tr class="memdesc:ae64fb43adf02634e081f5ae1a79edaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Min/Max Kernel.  <a href="namespacearrow_1_1compute.html#ae64fb43adf02634e081f5ae1a79edaf9">More...</a><br /></td></tr>
<tr class="separator:ae64fb43adf02634e081f5ae1a79edaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6120ab7c72a0d165a5877cf989c427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a4d6120ab7c72a0d165a5877cf989c427">MinMax</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a> &amp;options, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;value, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a4d6120ab7c72a0d165a5877cf989c427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the min / max of a numeric array.  <a href="namespacearrow_1_1compute.html#a4d6120ab7c72a0d165a5877cf989c427">More...</a><br /></td></tr>
<tr class="separator:a4d6120ab7c72a0d165a5877cf989c427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441ab4f2826ce3134b2ab3ef633e48d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a441ab4f2826ce3134b2ab3ef633e48d1">MinMax</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a> &amp;options, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;array, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a441ab4f2826ce3134b2ab3ef633e48d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the min / max of a numeric array.  <a href="namespacearrow_1_1compute.html#a441ab4f2826ce3134b2ab3ef633e48d1">More...</a><br /></td></tr>
<tr class="separator:a441ab4f2826ce3134b2ab3ef633e48d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd113ddac905f26ddbbda6bfde05fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a0cd113ddac905f26ddbbda6bfde05fce">SortToIndices</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;values, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *offsets)</td></tr>
<tr class="memdesc:a0cd113ddac905f26ddbbda6bfde05fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indices that would sort an array.  <a href="namespacearrow_1_1compute.html#a0cd113ddac905f26ddbbda6bfde05fce">More...</a><br /></td></tr>
<tr class="separator:a0cd113ddac905f26ddbbda6bfde05fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2017d598da196b7ae05c13dc28be6176"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html">AggregateFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a2017d598da196b7ae05c13dc28be6176">MakeSumAggregateFunction</a> (const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;type, <a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context)</td></tr>
<tr class="memdesc:a2017d598da196b7ae05c13dc28be6176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Sum Kernel.  <a href="namespacearrow_1_1compute.html#a2017d598da196b7ae05c13dc28be6176">More...</a><br /></td></tr>
<tr class="separator:a2017d598da196b7ae05c13dc28be6176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3c165266ec1c0ed5fcbb23aca1d3e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a4a3c165266ec1c0ed5fcbb23aca1d3e9">Sum</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;value, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a4a3c165266ec1c0ed5fcbb23aca1d3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum values of a numeric array.  <a href="namespacearrow_1_1compute.html#a4a3c165266ec1c0ed5fcbb23aca1d3e9">More...</a><br /></td></tr>
<tr class="separator:a4a3c165266ec1c0ed5fcbb23aca1d3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b126c5b3c01992813c7856915255b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ab2b126c5b3c01992813c7856915255b6">Sum</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *context, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;array, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:ab2b126c5b3c01992813c7856915255b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum values of a numeric array.  <a href="namespacearrow_1_1compute.html#ab2b126c5b3c01992813c7856915255b6">More...</a><br /></td></tr>
<tr class="separator:ab2b126c5b3c01992813c7856915255b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e2888270afb2c338802c68199f1fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a92e2888270afb2c338802c68199f1fc5">Take</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;values, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;indices, const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;options, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *out)</td></tr>
<tr class="memdesc:a92e2888270afb2c338802c68199f1fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take from an array of values at indices in another array.  <a href="namespacearrow_1_1compute.html#a92e2888270afb2c338802c68199f1fc5">More...</a><br /></td></tr>
<tr class="separator:a92e2888270afb2c338802c68199f1fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5086b6a69e6c1df3872312cfd61b282a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a5086b6a69e6c1df3872312cfd61b282a">Take</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;values, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;indices, const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;options, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *out)</td></tr>
<tr class="memdesc:a5086b6a69e6c1df3872312cfd61b282a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take from a chunked array of values at indices in another array.  <a href="namespacearrow_1_1compute.html#a5086b6a69e6c1df3872312cfd61b282a">More...</a><br /></td></tr>
<tr class="separator:a5086b6a69e6c1df3872312cfd61b282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8d450c9eba5448bdc64763155f3b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#aec8d450c9eba5448bdc64763155f3b8d">Take</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;values, const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;indices, const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;options, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *out)</td></tr>
<tr class="memdesc:aec8d450c9eba5448bdc64763155f3b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take from a chunked array of values at indices in a chunked array.  <a href="namespacearrow_1_1compute.html#aec8d450c9eba5448bdc64763155f3b8d">More...</a><br /></td></tr>
<tr class="separator:aec8d450c9eba5448bdc64763155f3b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687b6cdf1dbf2a23a7bea26225fbd0ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a687b6cdf1dbf2a23a7bea26225fbd0ad">Take</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;values, const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;indices, const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;options, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *out)</td></tr>
<tr class="memdesc:a687b6cdf1dbf2a23a7bea26225fbd0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take from an array of values at indices in a chunked array.  <a href="namespacearrow_1_1compute.html#a687b6cdf1dbf2a23a7bea26225fbd0ad">More...</a><br /></td></tr>
<tr class="separator:a687b6cdf1dbf2a23a7bea26225fbd0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0baa336e53dc8ee574661ea65702cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a9d0baa336e53dc8ee574661ea65702cf">Take</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &amp;batch, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;indices, const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;options, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt; *out)</td></tr>
<tr class="memdesc:a9d0baa336e53dc8ee574661ea65702cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take from a record batch at indices in another array.  <a href="namespacearrow_1_1compute.html#a9d0baa336e53dc8ee574661ea65702cf">More...</a><br /></td></tr>
<tr class="separator:a9d0baa336e53dc8ee574661ea65702cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a653cee8ae18d2320c1c5d09678da7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ac7a653cee8ae18d2320c1c5d09678da7">Take</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;table, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;indices, const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;options, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out)</td></tr>
<tr class="memdesc:ac7a653cee8ae18d2320c1c5d09678da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take from a table at indices in an array.  <a href="namespacearrow_1_1compute.html#ac7a653cee8ae18d2320c1c5d09678da7">More...</a><br /></td></tr>
<tr class="separator:ac7a653cee8ae18d2320c1c5d09678da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f77351bea35215d159e1c03e975171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a04f77351bea35215d159e1c03e975171">Take</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;table, const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;indices, const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;options, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out)</td></tr>
<tr class="memdesc:a04f77351bea35215d159e1c03e975171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take from a table at indices in a chunked array.  <a href="namespacearrow_1_1compute.html#a04f77351bea35215d159e1c03e975171">More...</a><br /></td></tr>
<tr class="separator:a04f77351bea35215d159e1c03e975171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d28ff5bd18aa2eebe0a596db758c3bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a0d28ff5bd18aa2eebe0a596db758c3bb">Take</a> (<a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *ctx, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;values, const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;indices, const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;options, <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *out)</td></tr>
<tr class="memdesc:a0d28ff5bd18aa2eebe0a596db758c3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take from an array of values at indices in another array.  <a href="namespacearrow_1_1compute.html#a0d28ff5bd18aa2eebe0a596db758c3bb">More...</a><br /></td></tr>
<tr class="separator:a0d28ff5bd18aa2eebe0a596db758c3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac520849fea358849b66f86a378d540dd"><td class="memTemplParams" colspan="2">template&lt;bool SomeIndicesNull, bool SomeValuesNull, bool NeverOutOfBounds, typename IndexSequence , typename Visitor &gt; </td></tr>
<tr class="memitem:ac520849fea358849b66f86a378d540dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ac520849fea358849b66f86a378d540dd">VisitIndices</a> (IndexSequence indices, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;values, Visitor &amp;&amp;vis)</td></tr>
<tr class="memdesc:ac520849fea358849b66f86a378d540dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">visit indices from an IndexSequence while bounds checking  <a href="namespacearrow_1_1compute.html#ac520849fea358849b66f86a378d540dd">More...</a><br /></td></tr>
<tr class="separator:ac520849fea358849b66f86a378d540dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdcf44c088f89cf0c2ea88bcac9f9b2"><td class="memTemplParams" colspan="2">template&lt;bool SomeIndicesNull, bool SomeValuesNull, typename IndexSequence , typename Visitor &gt; </td></tr>
<tr class="memitem:a8cdcf44c088f89cf0c2ea88bcac9f9b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a8cdcf44c088f89cf0c2ea88bcac9f9b2">VisitIndices</a> (IndexSequence indices, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;values, Visitor &amp;&amp;vis)</td></tr>
<tr class="separator:a8cdcf44c088f89cf0c2ea88bcac9f9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf5e5f83e0bcd94bec510d8befbfaff"><td class="memTemplParams" colspan="2">template&lt;bool SomeIndicesNull, typename IndexSequence , typename Visitor &gt; </td></tr>
<tr class="memitem:abdf5e5f83e0bcd94bec510d8befbfaff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#abdf5e5f83e0bcd94bec510d8befbfaff">VisitIndices</a> (IndexSequence indices, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;values, Visitor &amp;&amp;vis)</td></tr>
<tr class="separator:abdf5e5f83e0bcd94bec510d8befbfaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e30e069b176830d83b3175738735fc"><td class="memTemplParams" colspan="2">template&lt;typename IndexSequence , typename Visitor &gt; </td></tr>
<tr class="memitem:a22e30e069b176830d83b3175738735fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a22e30e069b176830d83b3175738735fc">VisitIndices</a> (IndexSequence indices, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;values, Visitor &amp;&amp;vis)</td></tr>
<tr class="separator:a22e30e069b176830d83b3175738735fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6836fc8750a44e1d54c5950a3dc2f1ca"><td class="memItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a6836fc8750a44e1d54c5950a3dc2f1ca">kUnknownLength</a> = -1</td></tr>
<tr class="separator:a6836fc8750a44e1d54c5950a3dc2f1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb50c66aab2b6d66f9ec4b4a9ac7a9a7"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#afb50c66aab2b6d66f9ec4b4a9ac7a9a7">kValuesFieldName</a> []</td></tr>
<tr class="separator:afb50c66aab2b6d66f9ec4b4a9ac7a9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37632587e0949231b9b7e2d320c2f83"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#af37632587e0949231b9b7e2d320c2f83">kCountsFieldName</a> []</td></tr>
<tr class="separator:af37632587e0949231b9b7e2d320c2f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ee75b1f2835d78a3a66142b19491aa"><td class="memItemLeft" align="right" valign="top">const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#ac0ee75b1f2835d78a3a66142b19491aa">kValuesFieldIndex</a></td></tr>
<tr class="separator:ac0ee75b1f2835d78a3a66142b19491aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236c42d5a172823c7268ba5b4a86063e"><td class="memItemLeft" align="right" valign="top">const int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html#a236c42d5a172823c7268ba5b4a86063e">kCountsFieldIndex</a></td></tr>
<tr class="separator:a236c42d5a172823c7268ba5b4a86063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abcdcabf38ba21c6ca54c9c2630045926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdcabf38ba21c6ca54c9c2630045926">&#9670;&nbsp;</a></span>ArgsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow_1_1compute.html#abcdcabf38ba21c6ca54c9c2630045926">arrow::compute::ArgsType</a> = typedef typename <a class="el" href="structarrow_1_1compute_1_1_benchmark_args_type.html">BenchmarkArgsType</a>&lt;decltype(&amp;benchmark::internal::Benchmark::Args)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad92a8b9428e7982c9a32ff706b516744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92a8b9428e7982c9a32ff706b516744">&#9670;&nbsp;</a></span>ArrowTypePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow_1_1compute.html#ad92a8b9428e7982c9a32ff706b516744">arrow::compute::ArrowTypePtr</a> = typedef std::shared_ptr&lt;::<a class="el" href="classarrow_1_1_data_type.html">arrow::DataType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af255a47e73df4040c1239b137018bb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af255a47e73df4040c1239b137018bb89">&#9670;&nbsp;</a></span>ConstOpPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow_1_1compute.html#af255a47e73df4040c1239b137018bb89">arrow::compute::ConstOpPtr</a> = typedef std::shared_ptr&lt;const <a class="el" href="classarrow_1_1compute_1_1_operation.html">Operation</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade436c20161be56a69cde0c8e044bd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade436c20161be56a69cde0c8e044bd0e">&#9670;&nbsp;</a></span>enable_if_not_base_binary</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow_1_1compute.html#ade436c20161be56a69cde0c8e044bd0e">arrow::compute::enable_if_not_base_binary</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;!std::is_base_of&lt;<a class="el" href="classarrow_1_1_base_binary_type.html">BaseBinaryType</a>, T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d7741dfdaf5c06817fdbdaa539534a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7741dfdaf5c06817fdbdaa539534a2">&#9670;&nbsp;</a></span>ExprPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow_1_1compute.html#a3d7741dfdaf5c06817fdbdaa539534a2">arrow::compute::ExprPtr</a> = typedef std::shared_ptr&lt;<a class="el" href="classarrow_1_1compute_1_1_expr.html">Expr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21de3825cdde68e67cd591917584b21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21de3825cdde68e67cd591917584b21b">&#9670;&nbsp;</a></span>LogicalTypePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow_1_1compute.html#a21de3825cdde68e67cd591917584b21b">arrow::compute::LogicalTypePtr</a> = typedef std::shared_ptr&lt;<a class="el" href="classarrow_1_1compute_1_1_logical_type.html">LogicalType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac33a552016037f2813983a80b5fcaf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33a552016037f2813983a80b5fcaf50">&#9670;&nbsp;</a></span>OpPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow_1_1compute.html#ac33a552016037f2813983a80b5fcaf50">arrow::compute::OpPtr</a> = typedef std::shared_ptr&lt;<a class="el" href="classarrow_1_1compute_1_1_operation.html">Operation</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a722101516c22b89bdf3f54ff6f90cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722101516c22b89bdf3f54ff6f90cd2e">&#9670;&nbsp;</a></span>CompareOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacearrow_1_1compute.html#a722101516c22b89bdf3f54ff6f90cd2e">arrow::compute::CompareOperator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a722101516c22b89bdf3f54ff6f90cd2ea602792ae96607227306b00b948a49642"></a>EQUAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a722101516c22b89bdf3f54ff6f90cd2ea4bcbbc099f2f532f402c86415099f446"></a>NOT_EQUAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a722101516c22b89bdf3f54ff6f90cd2ea3da583275ccef5bb978f7c0caf0c93e8"></a>GREATER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a722101516c22b89bdf3f54ff6f90cd2eaafce6452f6406693fc0b4736f343c19a"></a>GREATER_EQUAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a722101516c22b89bdf3f54ff6f90cd2eaece4bea22705948d598457047b45a713"></a>LESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a722101516c22b89bdf3f54ff6f90cd2eab8cba2f6e6f1cb0afed2d02ee7ed5afa"></a>LESS_EQUAL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a8c7314c2838c3f4df31d9027983e7b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7314c2838c3f4df31d9027983e7b0b">&#9670;&nbsp;</a></span>ValueRank</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacearrow_1_1compute.html#a8c7314c2838c3f4df31d9027983e7b0b">arrow::compute::ValueRank</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The value cardinality: one or many. </p>
<p>These correspond to the <a class="el" href="structarrow_1_1_scalar.html" title="Base class for scalar values, representing a single value occupying an array &quot;slot&quot;.">arrow::Scalar</a> and <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">arrow::Array</a> types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8c7314c2838c3f4df31d9027983e7b0ba8f3d9a4b6a7b7f2c7afa61ca113d0db9"></a>SCALAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8c7314c2838c3f4df31d9027983e7b0bacb4fb1757fb37c43cded35d3eb857c43"></a>ARRAY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a24a49ecaa4199b437adbddfe1481f52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a49ecaa4199b437adbddfe1481f52e">&#9670;&nbsp;</a></span>Add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Summarizes two arrays. </p>
<p>Summarizes two arrays with the same length. The output is an array with same length and type as input. Types of both input arrays should be equal</p>
<p>For example given lhs = [1, null, 3], rhs = [4, 5, 6], the output will be [5, null, 7]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>the sum of first and second arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1effccba3cfc4b88a01a9ed5d0338db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1effccba3cfc4b88a01a9ed5d0338db6">&#9670;&nbsp;</a></span>And()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::And </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise AND of two boolean datums which always propagates nulls (null and false is null). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>left operand (array) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>right operand (array) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.11.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a3e989a6765f48fe18e0febfa4c4e2006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e989a6765f48fe18e0febfa4c4e2006">&#9670;&nbsp;</a></span>BenchmarkSetArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arrow::compute::BenchmarkSetArgs </td>
          <td>(</td>
          <td class="paramtype">benchmark::internal::Benchmark *&#160;</td>
          <td class="paramname"><em>bench</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a471b198ae0c536b6f694f9ca76800cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471b198ae0c536b6f694f9ca76800cc9">&#9670;&nbsp;</a></span>BenchmarkSetArgsWithSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arrow::compute::BenchmarkSetArgsWithSizes </td>
          <td>(</td>
          <td class="paramtype">benchmark::internal::Benchmark *&#160;</td>
          <td class="paramname"><em>bench</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em> = <code>kMemorySizes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87994288b6e4b96a52d9fc32e579c9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87994288b6e4b96a52d9fc32e579c9ec">&#9670;&nbsp;</a></span>Cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td>
          <td class="paramname"><em>to_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_cast_options.html">CastOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast from one array type to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>array to cast </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_type</td><td>type to cast to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>casting options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="adf6a3d4dda9ae8624603cea6da76dc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6a3d4dda9ae8624603cea6da76dc55">&#9670;&nbsp;</a></span>Cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td>
          <td class="paramname"><em>to_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_cast_options.html">CastOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast from one value to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>datum to cast </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_type</td><td>type to cast to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>casting options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.8.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="aaa7e88adfcea48dd0aaec2d14a9d85ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7e88adfcea48dd0aaec2d14a9d85ab">&#9670;&nbsp;</a></span>Compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structarrow_1_1compute_1_1_compare_options.html">CompareOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare a numeric array with a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>datum to compare, must be an <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>datum to compare, must be a <a class="el" href="structarrow_1_1_scalar.html" title="Base class for scalar values, representing a single value occupying an array &quot;slot&quot;.">Scalar</a> of the same type than left <a class="el" href="structarrow_1_1compute_1_1_datum.html" title="Variant type for various Arrow C++ data structures.">Datum</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>compare options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<p>Note on floating point arrays, this uses ieee-754 compare semantics.</p>
<dl class="section since"><dt>Since</dt><dd>0.14.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a775549b0138d5cc4f9b1d3380852b771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775549b0138d5cc4f9b1d3380852b771">&#9670;&nbsp;</a></span>Count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_count_options.html">CountOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count non-null (or null) values in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>counting options, see <a class="el" href="structarrow_1_1compute_1_1_count_options.html">CountOptions</a> for more information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>to count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.13.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="aa409c2094425f36d0d41f0c1d3335bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa409c2094425f36d0d41f0c1d3335bac">&#9670;&nbsp;</a></span>Count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_count_options.html">CountOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>datum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count non-null (or null) values in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>counting options, see <a class="el" href="structarrow_1_1compute_1_1_count_options.html">CountOptions</a> for more information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datum</td><td>to count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.13.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="abb320b25453cee69ed5c8048bd0e0df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb320b25453cee69ed5c8048bd0e0df4">&#9670;&nbsp;</a></span>DictionaryEncode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::DictionaryEncode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dictionary-encode values in an array-like object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>array-like input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>result with same shape and type as input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.8.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="aeddaf11808e069910139087ef7a60510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddaf11808e069910139087ef7a60510">&#9670;&nbsp;</a></span>Filter() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter an array with a boolean selection filter. </p>
<p>The output array will be populated with values from the input at positions where the selection filter is not 0. Nulls in the filter will result in nulls in the output.</p>
<p>For example given values = ["a", "b", "c", null, "e", "f"] and filter = [0, 1, 1, 0, null, 1], the output will be = ["b", "c", null, "f"]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>array to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>indicates which values should be filtered out </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a517e03df9b2158832ec8eb818d02bb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517e03df9b2158832ec8eb818d02bb25">&#9670;&nbsp;</a></span>Filter() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a chunked array with a boolean selection filter. </p>
<p>The output chunked array will be populated with values from the input at positions where the selection filter is not 0. Nulls in the filter will result in nulls in the output.</p>
<p>For example given values = ["a", "b", "c", null, "e", "f"] and filter = [0, 1, 1, 0, null, 1], the output will be = ["b", "c", null, "f"]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>chunked array to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>indicates which values should be filtered out </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting chunked array NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7086d5c6d5c61ae4a5d8ec6f0635506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7086d5c6d5c61ae4a5d8ec6f0635506">&#9670;&nbsp;</a></span>Filter() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a chunked array with a boolean selection filter. </p>
<p>The output chunked array will be populated with values from the input at positions where the selection filter is not 0. Nulls in the filter will result in nulls in the output.</p>
<p>For example given values = ["a", "b", "c", null, "e", "f"] and filter = [0, 1, 1, 0, null, 1], the output will be = ["b", "c", null, "f"]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>chunked array to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>indicates which values should be filtered out </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting chunked array NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b34919ba0ebb6fa5534260c416796bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b34919ba0ebb6fa5534260c416796bf">&#9670;&nbsp;</a></span>Filter() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter an array with a boolean selection filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>datum to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>indicates which values should be filtered out </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a581bb18d0337ca6e7fbf4faf7d8f8683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581bb18d0337ca6e7fbf4faf7d8f8683">&#9670;&nbsp;</a></span>Filter() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &amp;&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a record batch with a boolean selection filter. </p>
<p>The output record batch's columns will be populated with values from corresponding columns of the input at positions where the selection filter is not 0. Nulls in the filter will result in nulls in the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch</td><td>record batch to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>indicates which values should be filtered out </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting record batch NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac76a69da97f321c6813a44a1e9fc40a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76a69da97f321c6813a44a1e9fc40a3">&#9670;&nbsp;</a></span>Filter() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a table with a boolean selection filter. </p>
<p>The output table's columns will be populated with values from corresponding columns of the input at positions where the selection filter is not 0. Nulls in the filter will result in nulls in each column of the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>indicates which values should be filtered out </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting table NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57f498530814175ce7180160235046b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f498530814175ce7180160235046b6">&#9670;&nbsp;</a></span>Filter() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Filter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a table with a boolean selection filter. </p>
<p>The output record batch's columns will be populated with values from corresponding columns of the input at positions where the selection filter is not 0. Nulls in the filter will result in nulls in the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>record batch to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>indicates which values should be filtered out </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting record batch NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0444dc9ae8752dfc070c0583106d3193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0444dc9ae8752dfc070c0583106d3193">&#9670;&nbsp;</a></span>GetArrayExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::GetArrayExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacearrow_1_1compute.html#af255a47e73df4040c1239b137018bb89">ConstOpPtr</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearrow_1_1compute.html#a21de3825cdde68e67cd591917584b21b">LogicalTypePtr</a>&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearrow_1_1compute.html#a3d7741dfdaf5c06817fdbdaa539534a2">ExprPtr</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="classarrow_1_1compute_1_1_array_expr.html">ArrayExpr</a> containing an <a class="el" href="classarrow_1_1compute_1_1_operation.html" title="An operation is a node in a computation graph, taking input data expression dependencies and emitting...">Operation</a> given a logical type. </p>

</div>
</div>
<a id="a1b785d94aca34a10de4d1218a2b924a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b785d94aca34a10de4d1218a2b924a3">&#9670;&nbsp;</a></span>GetCastFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::GetCastFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>in_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td>
          <td class="paramname"><em>to_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_cast_options.html">CastOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_unary_kernel.html">UnaryKernel</a> &gt; *&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="abc53dddd8a483d5a242c37aa655c5ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc53dddd8a483d5a242c37aa655c5ddc">&#9670;&nbsp;</a></span>GetScalarExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::GetScalarExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacearrow_1_1compute.html#af255a47e73df4040c1239b137018bb89">ConstOpPtr</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearrow_1_1compute.html#a21de3825cdde68e67cd591917584b21b">LogicalTypePtr</a>&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacearrow_1_1compute.html#a3d7741dfdaf5c06817fdbdaa539534a2">ExprPtr</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1compute_1_1_scalar_expr.html">ScalarExpr</a> containing an <a class="el" href="classarrow_1_1compute_1_1_operation.html" title="An operation is a node in a computation graph, taking input data expression dependencies and emitting...">Operation</a> given a logical type. </p>

</div>
</div>
<a id="a137884557c4ada6b6c4b9f381fd7165b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137884557c4ada6b6c4b9f381fd7165b">&#9670;&nbsp;</a></span>InheritsFrom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::compute::InheritsFrom </td>
          <td>(</td>
          <td class="paramtype">const ObjectType &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb07c5f8cc6b295a7b39681058a1af39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb07c5f8cc6b295a7b39681058a1af39">&#9670;&nbsp;</a></span>InheritsFrom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::compute::InheritsFrom </td>
          <td>(</td>
          <td class="paramtype">const ObjectType *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a157d9c73ff1d5c9730a3f9fbb2a91286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157d9c73ff1d5c9730a3f9fbb2a91286">&#9670;&nbsp;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the values of a boolean datum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>datum to invert </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.11.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a10a7275ae0354ddfaa7ffe0d139497c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a7275ae0354ddfaa7ffe0d139497c1">&#9670;&nbsp;</a></span>IsIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::IsIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IsIn returns boolean values if the value is in both left and right arrays. </p>
<p>If null occurs in left, if null count in right is not 0, it returns true, else returns null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>array-like input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>array-like input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="ad3b66852874f97dedaae34b17a94f2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b66852874f97dedaae34b17a94f2ad">&#9670;&nbsp;</a></span>KleeneAnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::KleeneAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise AND of two boolean datums with a Kleene truth table (null and false is false). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>left operand (array) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>right operand (array) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a5aefdd5a0890cf0824bdbc6f7e7ec561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aefdd5a0890cf0824bdbc6f7e7ec561">&#9670;&nbsp;</a></span>KleeneOr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::KleeneOr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise OR of two boolean datums with a Kleene truth table (null or true is true). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>left operand (array) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>right operand (array) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="ae97e791761922ec76882bdca17c08808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97e791761922ec76882bdca17c08808">&#9670;&nbsp;</a></span>MakeCompareKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::MakeCompareKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_compare_options.html">CompareOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1compute_1_1_binary_kernel.html">BinaryKernel</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classarrow_1_1compute_1_1_binary_kernel.html" title="An array-valued function of a two input arguments.">BinaryKernel</a> bound implementing comparison. </p>

</div>
</div>
<a id="ae585e5596b3e5c70eef8a916be23e7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae585e5596b3e5c70eef8a916be23e7cb">&#9670;&nbsp;</a></span>MakeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html">AggregateFunction</a>&gt; arrow::compute::MakeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_count_options.html">CountOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Count function aggregate. </p>

</div>
</div>
<a id="ae1d9f7d89aaf495af9979791980edb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d9f7d89aaf495af9979791980edb84">&#9670;&nbsp;</a></span>MakeMeanAggregateFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html">AggregateFunction</a>&gt; arrow::compute::MakeMeanAggregateFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae64fb43adf02634e081f5ae1a79edaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64fb43adf02634e081f5ae1a79edaf9">&#9670;&nbsp;</a></span>MakeMinMaxAggregateFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html">AggregateFunction</a>&gt; arrow::compute::MakeMinMaxAggregateFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Min/Max Kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>required to specialize the kernel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>see <a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a> for more information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a2017d598da196b7ae05c13dc28be6176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2017d598da196b7ae05c13dc28be6176">&#9670;&nbsp;</a></span>MakeSumAggregateFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1compute_1_1_aggregate_function.html">AggregateFunction</a>&gt; arrow::compute::MakeSumAggregateFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Sum Kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>required to specialize the kernel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.13.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a7087b36a0180f6f86d4aa8a9fac3195b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7087b36a0180f6f86d4aa8a9fac3195b">&#9670;&nbsp;</a></span>Mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Mean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean of a numeric array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>to compute the mean </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>datum of the computed mean as a <a class="el" href="structarrow_1_1_double_scalar.html">DoubleScalar</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.13.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a51444316ac3eb35a81962e50b17d4967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51444316ac3eb35a81962e50b17d4967">&#9670;&nbsp;</a></span>Mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Mean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean of a numeric array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>datum to compute the mean, expecting <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>datum of the computed mean as a <a class="el" href="structarrow_1_1_double_scalar.html">DoubleScalar</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.13.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a441ab4f2826ce3134b2ab3ef633e48d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441ab4f2826ce3134b2ab3ef633e48d1">&#9670;&nbsp;</a></span>MinMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::MinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the min / max of a numeric array. </p>
<p>This function returns both the min and max as a collection. The resulting datum thus consists of two scalar datums: {Datum(min), Datum(max)}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>see <a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a> for more information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>input array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum containing a {min, max} collection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a4d6120ab7c72a0d165a5877cf989c427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6120ab7c72a0d165a5877cf989c427">&#9670;&nbsp;</a></span>MinMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::MinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the min / max of a numeric array. </p>
<p>This function returns both the min and max as a collection. The resulting datum thus consists of two scalar datums: {Datum(min), Datum(max)}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>see <a class="el" href="structarrow_1_1compute_1_1_min_max_options.html">MinMaxOptions</a> for more information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>input datum, expecting <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> or <a class="el" href="classarrow_1_1_chunked_array.html" title="A data structure managing a list of primitive Arrow arrays logically as one large array.">ChunkedArray</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum containing a {min, max} collection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>1.0.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a5c42e1e03467da2a48e841a1337be7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c42e1e03467da2a48e841a1337be7f5">&#9670;&nbsp;</a></span>Or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise OR of two boolean datums which always propagates nulls (null and true is null). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>left operand (array) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>right operand (array) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.11.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a5200d700dfe799b541a272c3c05892c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5200d700dfe799b541a272c3c05892c4">&#9670;&nbsp;</a></span>RegressionSetArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arrow::compute::RegressionSetArgs </td>
          <td>(</td>
          <td class="paramtype">benchmark::internal::Benchmark *&#160;</td>
          <td class="paramname"><em>bench</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cd113ddac905f26ddbbda6bfde05fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd113ddac905f26ddbbda6bfde05fce">&#9670;&nbsp;</a></span>SortToIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::SortToIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the indices that would sort an array. </p>
<p>Perform an indirect sort of array. The output array will contain indices that would sort an array, which would be the same length as input. Nulls will be stably partitioned to the end of the output.</p>
<p>For example given values = [null, 1, 3.3, null, 2, 5.3], the output will be [1, 4, 2, 5, 0, 3]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>array to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offsets</td><td>indices that would sort an array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2b126c5b3c01992813c7856915255b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b126c5b3c01992813c7856915255b6">&#9670;&nbsp;</a></span>Sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum values of a numeric array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>to sum </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.13.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a4a3c165266ec1c0ed5fcbb23aca1d3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3c165266ec1c0ed5fcbb23aca1d3e9">&#9670;&nbsp;</a></span>Sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum values of a numeric array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>datum to sum, expecting <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> or <a class="el" href="classarrow_1_1_chunked_array.html" title="A data structure managing a list of primitive Arrow arrays logically as one large array.">ChunkedArray</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.13.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="a92e2888270afb2c338802c68199f1fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e2888270afb2c338802c68199f1fc5">&#9670;&nbsp;</a></span>Take() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take from an array of values at indices in another array. </p>
<p>The output array will be of the same type as the input values array, with elements taken from the values array at the given indices. If an index is null then the taken element will be null.</p>
<p>For example given values = ["a", "b", "c", null, "e", "f"] and indices = [2, 1, null, 3], the output will be = [values[2], values[1], null, values[3]] = ["c", "b", null, null]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>array from which to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>which values to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a687b6cdf1dbf2a23a7bea26225fbd0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687b6cdf1dbf2a23a7bea26225fbd0ad">&#9670;&nbsp;</a></span>Take() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take from an array of values at indices in a chunked array. </p>
<p>The output chunked array will be of the same type as the input values array, with elements taken from the values array at the given indices. If an index is null then the taken element will be null. The chunks in the output array will align with the chunks in the indices.</p>
<p>For example given values = ["a", "b", "c", null, "e", "f"] and indices = [2, 1, null, 3], the output will be = [values[2], values[1], null, values[3]] = ["c", "b", null, null]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>array from which to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>which values to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting chunked array NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5086b6a69e6c1df3872312cfd61b282a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5086b6a69e6c1df3872312cfd61b282a">&#9670;&nbsp;</a></span>Take() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take from a chunked array of values at indices in another array. </p>
<p>The output chunked array will be of the same type as the input values array, with elements taken from the values array at the given indices. If an index is null then the taken element will be null.</p>
<p>For example given values = ["a", "b", "c", null, "e", "f"] and indices = [2, 1, null, 3], the output will be = [values[2], values[1], null, values[3]] = ["c", "b", null, null]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>chunked array from which to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>which values to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting chunked array NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec8d450c9eba5448bdc64763155f3b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8d450c9eba5448bdc64763155f3b8d">&#9670;&nbsp;</a></span>Take() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take from a chunked array of values at indices in a chunked array. </p>
<p>The output chunked array will be of the same type as the input values array, with elements taken from the values array at the given indices. If an index is null then the taken element will be null. The chunks in the output array will align with the chunks in the indices.</p>
<p>For example given values = ["a", "b", "c", null, "e", "f"] and indices = [2, 1, null, 3], the output will be = [values[2], values[1], null, values[3]] = ["c", "b", null, null]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>chunked array from which to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>which values to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting chunked array NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d28ff5bd18aa2eebe0a596db758c3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d28ff5bd18aa2eebe0a596db758c3bb">&#9670;&nbsp;</a></span>Take() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take from an array of values at indices in another array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>datum from which to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>which values to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d0baa336e53dc8ee574661ea65702cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0baa336e53dc8ee574661ea65702cf">&#9670;&nbsp;</a></span>Take() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &amp;&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take from a record batch at indices in another array. </p>
<p>The output batch will have the same schema as the input batch, with rows taken from the columns in the batch at the given indices. If an index is null then the taken element will be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch</td><td>record batch from which to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>which values to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting record batch NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a653cee8ae18d2320c1c5d09678da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a653cee8ae18d2320c1c5d09678da7">&#9670;&nbsp;</a></span>Take() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take from a table at indices in an array. </p>
<p>The output table will have the same schema as the input table, with rows taken from the columns in the table at the given indices. If an index is null then the taken element will be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table from which to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>which values to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting table NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04f77351bea35215d159e1c03e975171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f77351bea35215d159e1c03e975171">&#9670;&nbsp;</a></span>Take() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_take_options.html">TakeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take from a table at indices in a chunked array. </p>
<p>The output table will have the same schema as the input table, with rows taken from the values array at the given indices. If an index is null then the taken element will be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table from which to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>which values to take </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>options </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting table NOTE: Experimental API </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d011093aecc73991bc11f65c4d0acb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d011093aecc73991bc11f65c4d0acb2">&#9670;&nbsp;</a></span>Unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>datum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute unique elements from an array-like object. </p>
<p>Note if a null occurs in the input it will NOT be included in the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datum</td><td>array-like input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>result as <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.8.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="adca33d8dd6bff7dd79ceec269c86ff53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca33d8dd6bff7dd79ceec269c86ff53">&#9670;&nbsp;</a></span>ValueCounts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::ValueCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return counts of unique elements from an array-like object. </p>
<p>Note that the counts do not include counts for nulls in the array. These can be obtained separately from metadata.</p>
<p>For floating point arrays there is no attempt to normalize -0.0, 0.0 and NaN values which can lead to unexpected results if the input <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> has these values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>array-like input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counts</td><td>An array of &lt;input type "Values", int64_t "Counts"&gt; structs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.13.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<a id="ac520849fea358849b66f86a378d540dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac520849fea358849b66f86a378d540dd">&#9670;&nbsp;</a></span>VisitIndices() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool SomeIndicesNull, bool SomeValuesNull, bool NeverOutOfBounds, typename IndexSequence , typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::VisitIndices </td>
          <td>(</td>
          <td class="paramtype">IndexSequence&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>visit indices from an IndexSequence while bounds checking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>IndexSequence to visit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>array to bounds check against, if necessary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vis</td><td>index visitor, signature must be Status(int64_t index, bool is_valid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cdcf44c088f89cf0c2ea88bcac9f9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdcf44c088f89cf0c2ea88bcac9f9b2">&#9670;&nbsp;</a></span>VisitIndices() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool SomeIndicesNull, bool SomeValuesNull, typename IndexSequence , typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::VisitIndices </td>
          <td>(</td>
          <td class="paramtype">IndexSequence&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdf5e5f83e0bcd94bec510d8befbfaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf5e5f83e0bcd94bec510d8befbfaff">&#9670;&nbsp;</a></span>VisitIndices() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool SomeIndicesNull, typename IndexSequence , typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::VisitIndices </td>
          <td>(</td>
          <td class="paramtype">IndexSequence&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22e30e069b176830d83b3175738735fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e30e069b176830d83b3175738735fc">&#9670;&nbsp;</a></span>VisitIndices() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexSequence , typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::VisitIndices </td>
          <td>(</td>
          <td class="paramtype">IndexSequence&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4af0c55adb14f8e018227e4575e0aa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af0c55adb14f8e018227e4575e0aa38">&#9670;&nbsp;</a></span>Xor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::compute::Xor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1compute_1_1_function_context.html">FunctionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_datum.html">Datum</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element-wise XOR of two boolean datums. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>the <a class="el" href="classarrow_1_1compute_1_1_function_context.html" title="Container for variables and options used by function evaluation.">FunctionContext</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>left operand (array) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>right operand (array) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting datum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.11.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>API not yet finalized </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a236c42d5a172823c7268ba5b4a86063e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236c42d5a172823c7268ba5b4a86063e">&#9670;&nbsp;</a></span>kCountsFieldIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t arrow::compute::kCountsFieldIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af37632587e0949231b9b7e2d320c2f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37632587e0949231b9b7e2d320c2f83">&#9670;&nbsp;</a></span>kCountsFieldName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char arrow::compute::kCountsFieldName[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6836fc8750a44e1d54c5950a3dc2f1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6836fc8750a44e1d54c5950a3dc2f1ca">&#9670;&nbsp;</a></span>kUnknownLength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t arrow::compute::kUnknownLength = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0ee75b1f2835d78a3a66142b19491aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ee75b1f2835d78a3a66142b19491aa">&#9670;&nbsp;</a></span>kValuesFieldIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int32_t arrow::compute::kValuesFieldIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb50c66aab2b6d66f9ec4b4a9ac7a9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb50c66aab2b6d66f9ec4b4a9ac7a9a7">&#9670;&nbsp;</a></span>kValuesFieldName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char arrow::compute::kValuesFieldName[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107500873-1');
</script>
</body>
</html>
