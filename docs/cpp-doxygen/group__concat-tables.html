<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Arrow (C++): ConcatenateTables function.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Arrow (C++)
   </div>
   <div id="projectbrief">A columnar in-memory analytics layer designed to accelerate big data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ConcatenateTables function.</div>  </div>
</div><!--header-->
<div class="contents">

<p>ConcatenateTables function.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_concatenate_tables_options.html">arrow::ConcatenateTablesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the behavior of <a class="el" href="group__concat-tables.html#ga6272e4a6555d62afc43b2845d8616eb7" title="Construct table from multiple input tables.">ConcatenateTables()</a>.  <a href="structarrow_1_1_concatenate_tables_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2640fe6c89743e608e6e2495d5041d87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga2640fe6c89743e608e6e2495d5041d87">arrow::ChunkedArray::ChunkedArray</a> (const <a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a> &amp;<a class="el" href="group__concat-tables.html#gaf53b92e2594cbe9d84710256e295586a">chunks</a>)</td></tr>
<tr class="memdesc:ga2640fe6c89743e608e6e2495d5041d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a chunked array from a vector of arrays.  <a href="group__concat-tables.html#ga2640fe6c89743e608e6e2495d5041d87">More...</a><br /></td></tr>
<tr class="separator:ga2640fe6c89743e608e6e2495d5041d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09cbc488c79b1ee9d20526fc99d71d93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga09cbc488c79b1ee9d20526fc99d71d93">arrow::ChunkedArray::ChunkedArray</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; &amp;<a class="el" href="group__concat-tables.html#ga92ec02f5904ac3e4dac5328e44ebf0fb">chunk</a>)</td></tr>
<tr class="memdesc:ga09cbc488c79b1ee9d20526fc99d71d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a chunked array from a single <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a>.  <a href="group__concat-tables.html#ga09cbc488c79b1ee9d20526fc99d71d93">More...</a><br /></td></tr>
<tr class="separator:ga09cbc488c79b1ee9d20526fc99d71d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73d53d335133270c6653e5de0d352cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gae73d53d335133270c6653e5de0d352cc">arrow::ChunkedArray::ChunkedArray</a> (const <a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a> &amp;<a class="el" href="group__concat-tables.html#gaf53b92e2594cbe9d84710256e295586a">chunks</a>, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;<a class="el" href="group__concat-tables.html#gadb15afa228802d9fab0f3993a4f82df2">type</a>)</td></tr>
<tr class="memdesc:gae73d53d335133270c6653e5de0d352cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a chunked array from a vector of arrays and a data type.  <a href="group__concat-tables.html#gae73d53d335133270c6653e5de0d352cc">More...</a><br /></td></tr>
<tr class="separator:gae73d53d335133270c6653e5de0d352cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df41bf1a05cd1083a2c4502e0a85f87"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4df41bf1a05cd1083a2c4502e0a85f87">arrow::ChunkedArray::length</a> () const</td></tr>
<tr class="separator:ga4df41bf1a05cd1083a2c4502e0a85f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962541b044ac5a7a6a87499cef7957bb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga962541b044ac5a7a6a87499cef7957bb">arrow::ChunkedArray::null_count</a> () const</td></tr>
<tr class="separator:ga962541b044ac5a7a6a87499cef7957bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa477fd2e9a3ce9131d9d7f4391de52b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gafa477fd2e9a3ce9131d9d7f4391de52b">arrow::ChunkedArray::num_chunks</a> () const</td></tr>
<tr class="separator:gafa477fd2e9a3ce9131d9d7f4391de52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ec02f5904ac3e4dac5328e44ebf0fb"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga92ec02f5904ac3e4dac5328e44ebf0fb">arrow::ChunkedArray::chunk</a> (int i) const</td></tr>
<tr class="separator:ga92ec02f5904ac3e4dac5328e44ebf0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf53b92e2594cbe9d84710256e295586a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gaf53b92e2594cbe9d84710256e295586a">arrow::ChunkedArray::chunks</a> () const</td></tr>
<tr class="separator:gaf53b92e2594cbe9d84710256e295586a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99573028501f20b3f0707d85e8cce2ad"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga99573028501f20b3f0707d85e8cce2ad">arrow::ChunkedArray::Slice</a> (int64_t offset, int64_t <a class="el" href="group__concat-tables.html#ga4df41bf1a05cd1083a2c4502e0a85f87">length</a>) const</td></tr>
<tr class="memdesc:ga99573028501f20b3f0707d85e8cce2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-copy slice of the chunked array with the indicated offset and length.  <a href="group__concat-tables.html#ga99573028501f20b3f0707d85e8cce2ad">More...</a><br /></td></tr>
<tr class="separator:ga99573028501f20b3f0707d85e8cce2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf30b26c92cf037191e8574763e22a2e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gabf30b26c92cf037191e8574763e22a2e">arrow::ChunkedArray::Slice</a> (int64_t offset) const</td></tr>
<tr class="memdesc:gabf30b26c92cf037191e8574763e22a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice from offset until end of the chunked array.  <a href="group__concat-tables.html#gabf30b26c92cf037191e8574763e22a2e">More...</a><br /></td></tr>
<tr class="separator:gabf30b26c92cf037191e8574763e22a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d4af28e378addf17162ad421bc0cdd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga8d4af28e378addf17162ad421bc0cdd6">arrow::ChunkedArray::Flatten</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&gt; *out) const</td></tr>
<tr class="memdesc:ga8d4af28e378addf17162ad421bc0cdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten this chunked array as a vector of chunked arrays, one for each struct field.  <a href="group__concat-tables.html#ga8d4af28e378addf17162ad421bc0cdd6">More...</a><br /></td></tr>
<tr class="separator:ga8d4af28e378addf17162ad421bc0cdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d7f457d2b87d9e28045b69b1ae9efb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gad5d7f457d2b87d9e28045b69b1ae9efb">arrow::ChunkedArray::View</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;<a class="el" href="group__concat-tables.html#gadb15afa228802d9fab0f3993a4f82df2">type</a>, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *out) const</td></tr>
<tr class="memdesc:gad5d7f457d2b87d9e28045b69b1ae9efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-copy view of this chunked array with the given type.  <a href="group__concat-tables.html#gad5d7f457d2b87d9e28045b69b1ae9efb">More...</a><br /></td></tr>
<tr class="separator:gad5d7f457d2b87d9e28045b69b1ae9efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb15afa228802d9fab0f3993a4f82df2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gadb15afa228802d9fab0f3993a4f82df2">arrow::ChunkedArray::type</a> () const</td></tr>
<tr class="separator:gadb15afa228802d9fab0f3993a4f82df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ad74cc587d5d622c7e62cbf1b0b9f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gab7ad74cc587d5d622c7e62cbf1b0b9f9">arrow::ChunkedArray::Equals</a> (const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;other) const</td></tr>
<tr class="memdesc:gab7ad74cc587d5d622c7e62cbf1b0b9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two chunked arrays are equal.  <a href="group__concat-tables.html#gab7ad74cc587d5d622c7e62cbf1b0b9f9">More...</a><br /></td></tr>
<tr class="separator:gab7ad74cc587d5d622c7e62cbf1b0b9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c23032d122d1a87acf0bc2b2e52d54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga67c23032d122d1a87acf0bc2b2e52d54">arrow::ChunkedArray::Equals</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga67c23032d122d1a87acf0bc2b2e52d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two chunked arrays are equal.  <a href="group__concat-tables.html#ga67c23032d122d1a87acf0bc2b2e52d54">More...</a><br /></td></tr>
<tr class="separator:ga67c23032d122d1a87acf0bc2b2e52d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ca5def32987d58b7577db269e39520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga06ca5def32987d58b7577db269e39520">arrow::ChunkedArray::Validate</a> () const</td></tr>
<tr class="memdesc:ga06ca5def32987d58b7577db269e39520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform cheap validation checks to determine obvious inconsistencies within the chunk array's internal data.  <a href="group__concat-tables.html#ga06ca5def32987d58b7577db269e39520">More...</a><br /></td></tr>
<tr class="separator:ga06ca5def32987d58b7577db269e39520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85899961a35888fcdfed462418ba6498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga85899961a35888fcdfed462418ba6498">arrow::ChunkedArray::ValidateFull</a> () const</td></tr>
<tr class="memdesc:ga85899961a35888fcdfed462418ba6498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform extensive validation checks to determine inconsistencies within the chunk array's internal data.  <a href="group__concat-tables.html#ga85899961a35888fcdfed462418ba6498">More...</a><br /></td></tr>
<tr class="separator:ga85899961a35888fcdfed462418ba6498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ea1eed4818941b9b1eb98381e1b9690"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga7ea1eed4818941b9b1eb98381e1b9690">arrow::Table::~Table</a> ()=default</td></tr>
<tr class="separator:ga7ea1eed4818941b9b1eb98381e1b9690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d00d9d8140ce003e8497595f30ce210"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga1d00d9d8140ce003e8497595f30ce210">arrow::Table::Make</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &amp;<a class="el" href="group__concat-tables.html#ga8d8626acf4d00e2ac439c4f1cc7a054a">schema</a>, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&gt; &amp;<a class="el" href="group__concat-tables.html#ga89c30f4eb8b98a5ab126dc404c873bed">columns</a>, int64_t <a class="el" href="group__concat-tables.html#ga14665d44a57c45343b54c7997d5c92e5">num_rows</a>=-1)</td></tr>
<tr class="memdesc:ga1d00d9d8140ce003e8497595f30ce210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from schema and columns If columns is zero-length, the table's number of rows is zero.  <a href="group__concat-tables.html#ga1d00d9d8140ce003e8497595f30ce210">More...</a><br /></td></tr>
<tr class="separator:ga1d00d9d8140ce003e8497595f30ce210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7abc5b418a0288f56cb1d0742579cd37"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga7abc5b418a0288f56cb1d0742579cd37">arrow::Table::Make</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &amp;<a class="el" href="group__concat-tables.html#ga8d8626acf4d00e2ac439c4f1cc7a054a">schema</a>, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt;&gt; &amp;arrays, int64_t <a class="el" href="group__concat-tables.html#ga14665d44a57c45343b54c7997d5c92e5">num_rows</a>=-1)</td></tr>
<tr class="memdesc:ga7abc5b418a0288f56cb1d0742579cd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from schema and arrays.  <a href="group__concat-tables.html#ga7abc5b418a0288f56cb1d0742579cd37">More...</a><br /></td></tr>
<tr class="separator:ga7abc5b418a0288f56cb1d0742579cd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5f16e5671977e0d948d0e0865935fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gaec5f16e5671977e0d948d0e0865935fe">arrow::Table::FromRecordBatches</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;batches, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *table)</td></tr>
<tr class="memdesc:gaec5f16e5671977e0d948d0e0865935fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from RecordBatches, using schema supplied by the first <a class="el" href="classarrow_1_1_record_batch.html" title="Collection of equal-length arrays matching a particular Schema.">RecordBatch</a>.  <a href="group__concat-tables.html#gaec5f16e5671977e0d948d0e0865935fe">More...</a><br /></td></tr>
<tr class="separator:gaec5f16e5671977e0d948d0e0865935fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58cb404c3656b0f4f91911c1cc2c3e5f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga58cb404c3656b0f4f91911c1cc2c3e5f">arrow::Table::FromRecordBatches</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &amp;<a class="el" href="group__concat-tables.html#ga8d8626acf4d00e2ac439c4f1cc7a054a">schema</a>, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;batches, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *table)</td></tr>
<tr class="memdesc:ga58cb404c3656b0f4f91911c1cc2c3e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from RecordBatches, using supplied schema.  <a href="group__concat-tables.html#ga58cb404c3656b0f4f91911c1cc2c3e5f">More...</a><br /></td></tr>
<tr class="separator:ga58cb404c3656b0f4f91911c1cc2c3e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff130c5cbb35eda98f55d1e3d0fcfb0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga3ff130c5cbb35eda98f55d1e3d0fcfb0">arrow::Table::FromChunkedStructArray</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; &amp;array, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *table)</td></tr>
<tr class="memdesc:ga3ff130c5cbb35eda98f55d1e3d0fcfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from a chunked <a class="el" href="classarrow_1_1_struct_array.html" title="Concrete Array class for struct data.">StructArray</a>.  <a href="group__concat-tables.html#ga3ff130c5cbb35eda98f55d1e3d0fcfb0">More...</a><br /></td></tr>
<tr class="separator:ga3ff130c5cbb35eda98f55d1e3d0fcfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d8626acf4d00e2ac439c4f1cc7a054a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga8d8626acf4d00e2ac439c4f1cc7a054a">arrow::Table::schema</a> () const</td></tr>
<tr class="memdesc:ga8d8626acf4d00e2ac439c4f1cc7a054a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the table schema.  <a href="group__concat-tables.html#ga8d8626acf4d00e2ac439c4f1cc7a054a">More...</a><br /></td></tr>
<tr class="separator:ga8d8626acf4d00e2ac439c4f1cc7a054a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8096b001837e7ad277e00b50226fbbe6"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga8096b001837e7ad277e00b50226fbbe6">arrow::Table::column</a> (int i) const =0</td></tr>
<tr class="memdesc:ga8096b001837e7ad277e00b50226fbbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column by index.  <a href="group__concat-tables.html#ga8096b001837e7ad277e00b50226fbbe6">More...</a><br /></td></tr>
<tr class="separator:ga8096b001837e7ad277e00b50226fbbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c30f4eb8b98a5ab126dc404c873bed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga89c30f4eb8b98a5ab126dc404c873bed">arrow::Table::columns</a> () const</td></tr>
<tr class="memdesc:ga89c30f4eb8b98a5ab126dc404c873bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector of all columns for table.  <a href="group__concat-tables.html#ga89c30f4eb8b98a5ab126dc404c873bed">More...</a><br /></td></tr>
<tr class="separator:ga89c30f4eb8b98a5ab126dc404c873bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9df57298bb216a45d106d77ffa06def"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gad9df57298bb216a45d106d77ffa06def">arrow::Table::field</a> (int i) const</td></tr>
<tr class="memdesc:gad9df57298bb216a45d106d77ffa06def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column's field by index.  <a href="group__concat-tables.html#gad9df57298bb216a45d106d77ffa06def">More...</a><br /></td></tr>
<tr class="separator:gad9df57298bb216a45d106d77ffa06def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82dfb0b822b42639fa95344abc4b0d26"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga82dfb0b822b42639fa95344abc4b0d26">arrow::Table::fields</a> () const</td></tr>
<tr class="memdesc:ga82dfb0b822b42639fa95344abc4b0d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector of all fields for table.  <a href="group__concat-tables.html#ga82dfb0b822b42639fa95344abc4b0d26">More...</a><br /></td></tr>
<tr class="separator:ga82dfb0b822b42639fa95344abc4b0d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb8285ac5af45a9e931564edb4938fc"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga8fb8285ac5af45a9e931564edb4938fc">arrow::Table::Slice</a> (int64_t offset, int64_t length) const =0</td></tr>
<tr class="memdesc:ga8fb8285ac5af45a9e931564edb4938fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a zero-copy slice of the table with the indicated offset and length.  <a href="group__concat-tables.html#ga8fb8285ac5af45a9e931564edb4938fc">More...</a><br /></td></tr>
<tr class="separator:ga8fb8285ac5af45a9e931564edb4938fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3948de704790a778f8568f22e08bca55"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga3948de704790a778f8568f22e08bca55">arrow::Table::Slice</a> (int64_t offset) const</td></tr>
<tr class="memdesc:ga3948de704790a778f8568f22e08bca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice from first row at offset until end of the table.  <a href="group__concat-tables.html#ga3948de704790a778f8568f22e08bca55">More...</a><br /></td></tr>
<tr class="separator:ga3948de704790a778f8568f22e08bca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb02268cc5b63206615c88f26194b88c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gacb02268cc5b63206615c88f26194b88c">arrow::Table::GetColumnByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:gacb02268cc5b63206615c88f26194b88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column by name.  <a href="group__concat-tables.html#gacb02268cc5b63206615c88f26194b88c">More...</a><br /></td></tr>
<tr class="separator:gacb02268cc5b63206615c88f26194b88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab752d668ee7779cfff3cf6cf7e8612e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gab752d668ee7779cfff3cf6cf7e8612e8">arrow::Table::RemoveColumn</a> (int i, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out) const =0</td></tr>
<tr class="memdesc:gab752d668ee7779cfff3cf6cf7e8612e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove column from the table, producing a new <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>.  <a href="group__concat-tables.html#gab752d668ee7779cfff3cf6cf7e8612e8">More...</a><br /></td></tr>
<tr class="separator:gab752d668ee7779cfff3cf6cf7e8612e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe42b9c3dfa5fc6d1dcbcc1fed9177c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gabe42b9c3dfa5fc6d1dcbcc1fed9177c1">arrow::Table::AddColumn</a> (int i, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt; field_arg, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; <a class="el" href="group__concat-tables.html#ga8096b001837e7ad277e00b50226fbbe6">column</a>, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out) const =0</td></tr>
<tr class="memdesc:gabe42b9c3dfa5fc6d1dcbcc1fed9177c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add column to the table, producing a new <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>.  <a href="group__concat-tables.html#gabe42b9c3dfa5fc6d1dcbcc1fed9177c1">More...</a><br /></td></tr>
<tr class="separator:gabe42b9c3dfa5fc6d1dcbcc1fed9177c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41040be2a7e82cc45750f261f156daa1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga41040be2a7e82cc45750f261f156daa1">arrow::Table::SetColumn</a> (int i, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt; field_arg, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; <a class="el" href="group__concat-tables.html#ga8096b001837e7ad277e00b50226fbbe6">column</a>, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out) const =0</td></tr>
<tr class="memdesc:ga41040be2a7e82cc45750f261f156daa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a column in the table, producing a new <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>.  <a href="group__concat-tables.html#ga41040be2a7e82cc45750f261f156daa1">More...</a><br /></td></tr>
<tr class="separator:ga41040be2a7e82cc45750f261f156daa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a280d02d926b10484a2a4631c7fa305"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga1a280d02d926b10484a2a4631c7fa305">arrow::Table::ColumnNames</a> () const</td></tr>
<tr class="memdesc:ga1a280d02d926b10484a2a4631c7fa305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return names of all columns.  <a href="group__concat-tables.html#ga1a280d02d926b10484a2a4631c7fa305">More...</a><br /></td></tr>
<tr class="separator:ga1a280d02d926b10484a2a4631c7fa305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf58206871ca43cbac00e3df4aeea4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga2bf58206871ca43cbac00e3df4aeea4c">arrow::Table::RenameColumns</a> (const std::vector&lt; std::string &gt; &amp;names, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out) const</td></tr>
<tr class="memdesc:ga2bf58206871ca43cbac00e3df4aeea4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename columns with provided names.  <a href="group__concat-tables.html#ga2bf58206871ca43cbac00e3df4aeea4c">More...</a><br /></td></tr>
<tr class="separator:ga2bf58206871ca43cbac00e3df4aeea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f5891d984e4652f5482096ea32e6d5"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga53f5891d984e4652f5482096ea32e6d5">arrow::Table::ReplaceSchemaMetadata</a> (const std::shared_ptr&lt; const <a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a> &gt; &amp;metadata) const =0</td></tr>
<tr class="memdesc:ga53f5891d984e4652f5482096ea32e6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace schema key-value metadata with new metadata (EXPERIMENTAL)  <a href="group__concat-tables.html#ga53f5891d984e4652f5482096ea32e6d5">More...</a><br /></td></tr>
<tr class="separator:ga53f5891d984e4652f5482096ea32e6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga402e1699fd1434a6db15c5e93b2853cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga402e1699fd1434a6db15c5e93b2853cb">arrow::Table::Flatten</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out) const =0</td></tr>
<tr class="memdesc:ga402e1699fd1434a6db15c5e93b2853cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten the table, producing a new <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>.  <a href="group__concat-tables.html#ga402e1699fd1434a6db15c5e93b2853cb">More...</a><br /></td></tr>
<tr class="separator:ga402e1699fd1434a6db15c5e93b2853cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a93ccc812c7ee9992bc9138b53895e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4a93ccc812c7ee9992bc9138b53895e0">arrow::Table::Validate</a> () const =0</td></tr>
<tr class="memdesc:ga4a93ccc812c7ee9992bc9138b53895e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform cheap validation checks to determine obvious inconsistencies within the table's schema and internal data.  <a href="group__concat-tables.html#ga4a93ccc812c7ee9992bc9138b53895e0">More...</a><br /></td></tr>
<tr class="separator:ga4a93ccc812c7ee9992bc9138b53895e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5796527d5848794aff9b6b3107011dd7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga5796527d5848794aff9b6b3107011dd7">arrow::Table::ValidateFull</a> () const =0</td></tr>
<tr class="memdesc:ga5796527d5848794aff9b6b3107011dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform extensive validation checks to determine inconsistencies within the table's schema and internal data.  <a href="group__concat-tables.html#ga5796527d5848794aff9b6b3107011dd7">More...</a><br /></td></tr>
<tr class="separator:ga5796527d5848794aff9b6b3107011dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe71e003123973cdff9cfca40dc85e04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gabe71e003123973cdff9cfca40dc85e04">arrow::Table::num_columns</a> () const</td></tr>
<tr class="memdesc:gabe71e003123973cdff9cfca40dc85e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of columns in the table.  <a href="group__concat-tables.html#gabe71e003123973cdff9cfca40dc85e04">More...</a><br /></td></tr>
<tr class="separator:gabe71e003123973cdff9cfca40dc85e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14665d44a57c45343b54c7997d5c92e5"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga14665d44a57c45343b54c7997d5c92e5">arrow::Table::num_rows</a> () const</td></tr>
<tr class="memdesc:ga14665d44a57c45343b54c7997d5c92e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of rows (equal to each column's logical length)  <a href="group__concat-tables.html#ga14665d44a57c45343b54c7997d5c92e5">More...</a><br /></td></tr>
<tr class="separator:ga14665d44a57c45343b54c7997d5c92e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88daefc3dd59b28fc23372db55b67378"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga88daefc3dd59b28fc23372db55b67378">arrow::Table::Equals</a> (const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;other) const</td></tr>
<tr class="memdesc:ga88daefc3dd59b28fc23372db55b67378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if tables are equal.  <a href="group__concat-tables.html#ga88daefc3dd59b28fc23372db55b67378">More...</a><br /></td></tr>
<tr class="separator:ga88daefc3dd59b28fc23372db55b67378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8b72567643fa64cde6e88478f97cc1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gac8b72567643fa64cde6e88478f97cc1e">arrow::Table::CombineChunks</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *out) const</td></tr>
<tr class="memdesc:gac8b72567643fa64cde6e88478f97cc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new table by combining the chunks this table has.  <a href="group__concat-tables.html#gac8b72567643fa64cde6e88478f97cc1e">More...</a><br /></td></tr>
<tr class="separator:gac8b72567643fa64cde6e88478f97cc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd70d5a21ef0558472d6e594d3ceeb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gaebd70d5a21ef0558472d6e594d3ceeb2">arrow::Table::Table</a> ()</td></tr>
<tr class="separator:gaebd70d5a21ef0558472d6e594d3ceeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae1034b4c522d66da02ac1e17f30195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4ae1034b4c522d66da02ac1e17f30195">arrow::TableBatchReader::TableBatchReader</a> (const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;table)</td></tr>
<tr class="memdesc:ga4ae1034b4c522d66da02ac1e17f30195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classarrow_1_1_table_batch_reader.html" title="Compute a stream of record batches from a (possibly chunked) Table.">TableBatchReader</a> for the given table.  <a href="group__concat-tables.html#ga4ae1034b4c522d66da02ac1e17f30195">More...</a><br /></td></tr>
<tr class="separator:ga4ae1034b4c522d66da02ac1e17f30195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278674b3b9a78fdbccc3f3d52fc5d470"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga278674b3b9a78fdbccc3f3d52fc5d470">arrow::TableBatchReader::schema</a> () const override</td></tr>
<tr class="separator:ga278674b3b9a78fdbccc3f3d52fc5d470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d001eabe7404ee8e3d7a568eae0e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga31d001eabe7404ee8e3d7a568eae0e93">arrow::TableBatchReader::ReadNext</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt; *out) override</td></tr>
<tr class="memdesc:ga31d001eabe7404ee8e3d7a568eae0e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next record batch in the stream.  <a href="group__concat-tables.html#ga31d001eabe7404ee8e3d7a568eae0e93">More...</a><br /></td></tr>
<tr class="separator:ga31d001eabe7404ee8e3d7a568eae0e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga293c77d9e315f264bc84e770d357b089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga293c77d9e315f264bc84e770d357b089">arrow::TableBatchReader::set_chunksize</a> (int64_t chunksize)</td></tr>
<tr class="memdesc:ga293c77d9e315f264bc84e770d357b089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the desired maximum chunk size of record batches.  <a href="group__concat-tables.html#ga293c77d9e315f264bc84e770d357b089">More...</a><br /></td></tr>
<tr class="separator:ga293c77d9e315f264bc84e770d357b089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f99414177f1507f6efa3471cb650bbb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structarrow_1_1_concatenate_tables_options.html">ConcatenateTablesOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga1f99414177f1507f6efa3471cb650bbb">arrow::ConcatenateTablesOptions::Defaults</a> ()</td></tr>
<tr class="separator:ga1f99414177f1507f6efa3471cb650bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6272e4a6555d62afc43b2845d8616eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga6272e4a6555d62afc43b2845d8616eb7">arrow::ConcatenateTables</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt;&gt; &amp;tables, <a class="el" href="structarrow_1_1_concatenate_tables_options.html">ConcatenateTablesOptions</a> options=<a class="el" href="group__concat-tables.html#ga1f99414177f1507f6efa3471cb650bbb">ConcatenateTablesOptions::Defaults</a>(), <a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *memory_pool=<a class="el" href="namespacearrow.html#aebe81d544faaf827b8f32c5a80b99820">default_memory_pool</a>())</td></tr>
<tr class="memdesc:ga6272e4a6555d62afc43b2845d8616eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct table from multiple input tables.  <a href="group__concat-tables.html#ga6272e4a6555d62afc43b2845d8616eb7">More...</a><br /></td></tr>
<tr class="separator:ga6272e4a6555d62afc43b2845d8616eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b46a73d9d5aba02b66257039342c5a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4b46a73d9d5aba02b66257039342c5a3">arrow::PromoteTableToSchema</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; &amp;table, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &amp;<a class="el" href="group__schema-factories.html#ga97ac72c2a07228577c1d38b7747941a9">schema</a>, <a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool=<a class="el" href="namespacearrow.html#aebe81d544faaf827b8f32c5a80b99820">default_memory_pool</a>())</td></tr>
<tr class="memdesc:ga4b46a73d9d5aba02b66257039342c5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a table to conform to the given schema.  <a href="group__concat-tables.html#ga4b46a73d9d5aba02b66257039342c5a3">More...</a><br /></td></tr>
<tr class="separator:ga4b46a73d9d5aba02b66257039342c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga438707b92386f68a63348c30743bc159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga438707b92386f68a63348c30743bc159">arrow::ChunkedArray::chunks_</a></td></tr>
<tr class="separator:ga438707b92386f68a63348c30743bc159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2fc435340a18c488a3001ce88018c4"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4d2fc435340a18c488a3001ce88018c4">arrow::ChunkedArray::length_</a></td></tr>
<tr class="separator:ga4d2fc435340a18c488a3001ce88018c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ef30e6a7823f1666b0f50ecde903a7"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga45ef30e6a7823f1666b0f50ecde903a7">arrow::ChunkedArray::null_count_</a></td></tr>
<tr class="separator:ga45ef30e6a7823f1666b0f50ecde903a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42911a6e758dd14bcc47a2108eed7bd0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga42911a6e758dd14bcc47a2108eed7bd0">arrow::ChunkedArray::type_</a></td></tr>
<tr class="separator:ga42911a6e758dd14bcc47a2108eed7bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40375f7767ae6caea748d87e53aacb45"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga40375f7767ae6caea748d87e53aacb45">arrow::Table::schema_</a></td></tr>
<tr class="separator:ga40375f7767ae6caea748d87e53aacb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7b895c038e468dac1be8d27722ffa6"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga7b7b895c038e468dac1be8d27722ffa6">arrow::Table::num_rows_</a></td></tr>
<tr class="separator:ga7b7b895c038e468dac1be8d27722ffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c26f51a3023e3bc2eb6ae5a4510a9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#gac7c26f51a3023e3bc2eb6ae5a4510a9a">arrow::ConcatenateTablesOptions::unify_schemas</a> = false</td></tr>
<tr class="memdesc:gac7c26f51a3023e3bc2eb6ae5a4510a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the schemas of the tables will be first unified with fields of the same name being merged, according to <code>field_merge_options</code>, then each table will be promoted to the unified schema before being concatenated.  <a href="group__concat-tables.html#gac7c26f51a3023e3bc2eb6ae5a4510a9a">More...</a><br /></td></tr>
<tr class="separator:gac7c26f51a3023e3bc2eb6ae5a4510a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20181bbcd6ae25ba49cadf11c636d4b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarrow_1_1_field_1_1_merge_options.html">Field::MergeOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga20181bbcd6ae25ba49cadf11c636d4b3">arrow::ConcatenateTablesOptions::field_merge_options</a> = <a class="el" href="structarrow_1_1_field_1_1_merge_options.html#aad6ec10fe86793101bf688bbf9c9ad96">Field::MergeOptions::Defaults</a>()</td></tr>
<tr class="separator:ga20181bbcd6ae25ba49cadf11c636d4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ConcatenateTables function. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabe42b9c3dfa5fc6d1dcbcc1fed9177c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe42b9c3dfa5fc6d1dcbcc1fed9177c1">&#9670;&nbsp;</a></span>AddColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::AddColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt;&#160;</td>
          <td class="paramname"><em>field_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add column to the table, producing a new <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>. </p>

</div>
</div>
<a id="ga92ec02f5904ac3e4dac5328e44ebf0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ec02f5904ac3e4dac5328e44ebf0fb">&#9670;&nbsp;</a></span>chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_array.html">Array</a>&gt; arrow::ChunkedArray::chunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>chunk a particular chunk from the chunked array </dd></dl>

</div>
</div>
<a id="ga2640fe6c89743e608e6e2495d5041d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2640fe6c89743e608e6e2495d5041d87">&#9670;&nbsp;</a></span>ChunkedArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::ChunkedArray::ChunkedArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a> &amp;&#160;</td>
          <td class="paramname"><em>chunks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a chunked array from a vector of arrays. </p>
<p>The vector must be non-empty and all its elements must have the same data type. </p>

</div>
</div>
<a id="gae73d53d335133270c6653e5de0d352cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae73d53d335133270c6653e5de0d352cc">&#9670;&nbsp;</a></span>ChunkedArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arrow::ChunkedArray::ChunkedArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a> &amp;&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a chunked array from a vector of arrays and a data type. </p>
<p>As the data type is passed explicitly, the vector may be empty. </p>

</div>
</div>
<a id="ga09cbc488c79b1ee9d20526fc99d71d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09cbc488c79b1ee9d20526fc99d71d93">&#9670;&nbsp;</a></span>ChunkedArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::ChunkedArray::ChunkedArray </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a chunked array from a single <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a>. </p>

</div>
</div>
<a id="gaf53b92e2594cbe9d84710256e295586a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf53b92e2594cbe9d84710256e295586a">&#9670;&nbsp;</a></span>chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a>&amp; arrow::ChunkedArray::chunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8096b001837e7ad277e00b50226fbbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8096b001837e7ad277e00b50226fbbe6">&#9670;&nbsp;</a></span>column()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a>&gt; arrow::Table::column </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column by index. </p>

</div>
</div>
<a id="ga1a280d02d926b10484a2a4631c7fa305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a280d02d926b10484a2a4631c7fa305">&#9670;&nbsp;</a></span>ColumnNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; arrow::Table::ColumnNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return names of all columns. </p>

</div>
</div>
<a id="ga89c30f4eb8b98a5ab126dc404c873bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89c30f4eb8b98a5ab126dc404c873bed">&#9670;&nbsp;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a>&gt; &gt; arrow::Table::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return vector of all columns for table. </p>

</div>
</div>
<a id="gac8b72567643fa64cde6e88478f97cc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8b72567643fa64cde6e88478f97cc1e">&#9670;&nbsp;</a></span>CombineChunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::CombineChunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new table by combining the chunks this table has. </p>
<p>All the underlying chunks in the <a class="el" href="classarrow_1_1_chunked_array.html" title="A data structure managing a list of primitive Arrow arrays logically as one large array.">ChunkedArray</a> of each column are concatenated into zero or one chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The pool for buffer allocations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The table with chunks combined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6272e4a6555d62afc43b2845d8616eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6272e4a6555d62afc43b2845d8616eb7">&#9670;&nbsp;</a></span>ConcatenateTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt;std::shared_ptr&lt;<a class="el" href="classarrow_1_1_table.html">Table</a>&gt; &gt; arrow::ConcatenateTables </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1_concatenate_tables_options.html">ConcatenateTablesOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="group__concat-tables.html#ga1f99414177f1507f6efa3471cb650bbb">ConcatenateTablesOptions::Defaults</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>memory_pool</em> = <code><a class="el" href="namespacearrow.html#aebe81d544faaf827b8f32c5a80b99820">default_memory_pool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct table from multiple input tables. </p>

</div>
</div>
<a id="ga1f99414177f1507f6efa3471cb650bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f99414177f1507f6efa3471cb650bbb">&#9670;&nbsp;</a></span>Defaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structarrow_1_1_concatenate_tables_options.html">ConcatenateTablesOptions</a> arrow::ConcatenateTablesOptions::Defaults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gab7ad74cc587d5d622c7e62cbf1b0b9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ad74cc587d5d622c7e62cbf1b0b9f9">&#9670;&nbsp;</a></span>Equals() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::ChunkedArray::Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two chunked arrays are equal. </p>
<p>Two chunked arrays can be equal only if they have equal datatypes. However, they may be equal even if they have different chunkings. </p>

</div>
</div>
<a id="ga67c23032d122d1a87acf0bc2b2e52d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67c23032d122d1a87acf0bc2b2e52d54">&#9670;&nbsp;</a></span>Equals() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::ChunkedArray::Equals </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if two chunked arrays are equal. </p>

</div>
</div>
<a id="ga88daefc3dd59b28fc23372db55b67378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88daefc3dd59b28fc23372db55b67378">&#9670;&nbsp;</a></span>Equals() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::Table::Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if tables are equal. </p>
<p>Two tables can be equal only if they have equal schemas. However, they may be equal even if they have different chunkings. </p>

</div>
</div>
<a id="gad9df57298bb216a45d106d77ffa06def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9df57298bb216a45d106d77ffa06def">&#9670;&nbsp;</a></span>field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_field.html">Field</a>&gt; arrow::Table::field </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column's field by index. </p>

</div>
</div>
<a id="ga82dfb0b822b42639fa95344abc4b0d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82dfb0b822b42639fa95344abc4b0d26">&#9670;&nbsp;</a></span>fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classarrow_1_1_field.html">Field</a>&gt; &gt; arrow::Table::fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return vector of all fields for table. </p>

</div>
</div>
<a id="ga402e1699fd1434a6db15c5e93b2853cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga402e1699fd1434a6db15c5e93b2853cb">&#9670;&nbsp;</a></span>Flatten() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::Flatten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flatten the table, producing a new <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>. </p>
<p>Any column with a struct type will be flattened into multiple columns</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The pool for buffer allocations, if any </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The returned table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d4af28e378addf17162ad421bc0cdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d4af28e378addf17162ad421bc0cdd6">&#9670;&nbsp;</a></span>Flatten() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::ChunkedArray::Flatten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten this chunked array as a vector of chunked arrays, one for each struct field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The pool for buffer allocations, if any </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The resulting vector of arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ff130c5cbb35eda98f55d1e3d0fcfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ff130c5cbb35eda98f55d1e3d0fcfb0">&#9670;&nbsp;</a></span>FromChunkedStructArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::FromChunkedStructArray </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from a chunked <a class="el" href="classarrow_1_1_struct_array.html" title="Concrete Array class for struct data.">StructArray</a>. </p>
<p>One column will be produced for each field of the <a class="el" href="classarrow_1_1_struct_array.html" title="Concrete Array class for struct data.">StructArray</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>a chunked <a class="el" href="classarrow_1_1_struct_array.html" title="Concrete Array class for struct data.">StructArray</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">table</td><td>the returned table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="ga58cb404c3656b0f4f91911c1cc2c3e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58cb404c3656b0f4f91911c1cc2c3e5f">&#9670;&nbsp;</a></span>FromRecordBatches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::FromRecordBatches </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>batches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from RecordBatches, using supplied schema. </p>
<p>There may be zero record batches</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>the <a class="el" href="classarrow_1_1_schema.html" title="Sequence of arrow::Field objects describing the columns of a record batch or table data structure.">arrow::Schema</a> for each batch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batches</td><td>a std::vector of record batches </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">table</td><td>the returned table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="gaec5f16e5671977e0d948d0e0865935fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5f16e5671977e0d948d0e0865935fe">&#9670;&nbsp;</a></span>FromRecordBatches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::FromRecordBatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>batches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from RecordBatches, using schema supplied by the first <a class="el" href="classarrow_1_1_record_batch.html" title="Collection of equal-length arrays matching a particular Schema.">RecordBatch</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batches</td><td>a std::vector of record batches </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">table</td><td>the returned table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> Returns <a class="el" href="classarrow_1_1_status.html#aa388393c060f3b44316876a630190576" title="Return an error status for invalid data (for example a string that fails parsing)">Status::Invalid</a> if there is some problem </dd></dl>

</div>
</div>
<a id="gacb02268cc5b63206615c88f26194b88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb02268cc5b63206615c88f26194b88c">&#9670;&nbsp;</a></span>GetColumnByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a>&gt; arrow::Table::GetColumnByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a column by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>field name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> or null if no field was found </dd></dl>

</div>
</div>
<a id="ga4df41bf1a05cd1083a2c4502e0a85f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df41bf1a05cd1083a2c4502e0a85f87">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t arrow::ChunkedArray::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total length of the chunked array; computed on construction </dd></dl>

</div>
</div>
<a id="ga7abc5b418a0288f56cb1d0742579cd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7abc5b418a0288f56cb1d0742579cd37">&#9670;&nbsp;</a></span>Make() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classarrow_1_1_table.html">Table</a>&gt; arrow::Table::Make </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num_rows</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from schema and arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schema</td><td>The table schema (column types) </td></tr>
    <tr><td class="paramname">arrays</td><td>The table's columns as arrays </td></tr>
    <tr><td class="paramname">num_rows</td><td>number of rows in table, -1 (default) to infer from columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d00d9d8140ce003e8497595f30ce210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d00d9d8140ce003e8497595f30ce210">&#9670;&nbsp;</a></span>Make() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classarrow_1_1_table.html">Table</a>&gt; arrow::Table::Make </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num_rows</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> from schema and columns If columns is zero-length, the table's number of rows is zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schema</td><td>The table schema (column types) </td></tr>
    <tr><td class="paramname">columns</td><td>The table's columns as chunked arrays </td></tr>
    <tr><td class="paramname">num_rows</td><td>number of rows in table, -1 (default) to infer from columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga962541b044ac5a7a6a87499cef7957bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga962541b044ac5a7a6a87499cef7957bb">&#9670;&nbsp;</a></span>null_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t arrow::ChunkedArray::null_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of nulls among all chunks </dd></dl>

</div>
</div>
<a id="gafa477fd2e9a3ce9131d9d7f4391de52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa477fd2e9a3ce9131d9d7f4391de52b">&#9670;&nbsp;</a></span>num_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::ChunkedArray::num_chunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gabe71e003123973cdff9cfca40dc85e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe71e003123973cdff9cfca40dc85e04">&#9670;&nbsp;</a></span>num_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::Table::num_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of columns in the table. </p>

</div>
</div>
<a id="ga14665d44a57c45343b54c7997d5c92e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14665d44a57c45343b54c7997d5c92e5">&#9670;&nbsp;</a></span>num_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t arrow::Table::num_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of rows (equal to each column's logical length) </p>

</div>
</div>
<a id="ga4b46a73d9d5aba02b66257039342c5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b46a73d9d5aba02b66257039342c5a3">&#9670;&nbsp;</a></span>PromoteTableToSchema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt;std::shared_ptr&lt;<a class="el" href="classarrow_1_1_table.html">Table</a>&gt; &gt; arrow::PromoteTableToSchema </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em> = <code><a class="el" href="namespacearrow.html#aebe81d544faaf827b8f32c5a80b99820">default_memory_pool</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes a table to conform to the given schema. </p>
<p>If a field in the schema does not have a corresponding column in the table, a column of nulls will be added to the resulting table. If the corresponding column is of type Null, it will be promoted to the type specified by schema, with null values filled. Returns an error:</p><ul>
<li>if the corresponding column's type is not compatible with the schema.</li>
<li>if there is a column in the table that does not exist in the schema.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the input <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>the target schema to promote to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>The memory pool to be used if null-filled arrays need to be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31d001eabe7404ee8e3d7a568eae0e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d001eabe7404ee8e3d7a568eae0e93">&#9670;&nbsp;</a></span>ReadNext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::TableBatchReader::ReadNext </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt; *&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next record batch in the stream. </p>
<p>Return null for batch when reaching end of stream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">batch</td><td>the next loaded batch, null at end of stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

<p>Implements <a class="el" href="classarrow_1_1_record_batch_reader.html#aaffe944df9d8a4c3e6592eb2f8f78f9f">arrow::RecordBatchReader</a>.</p>

</div>
</div>
<a id="gab752d668ee7779cfff3cf6cf7e8612e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab752d668ee7779cfff3cf6cf7e8612e8">&#9670;&nbsp;</a></span>RemoveColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::RemoveColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove column from the table, producing a new <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>. </p>

</div>
</div>
<a id="ga2bf58206871ca43cbac00e3df4aeea4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf58206871ca43cbac00e3df4aeea4c">&#9670;&nbsp;</a></span>RenameColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::RenameColumns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename columns with provided names. </p>

</div>
</div>
<a id="ga53f5891d984e4652f5482096ea32e6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53f5891d984e4652f5482096ea32e6d5">&#9670;&nbsp;</a></span>ReplaceSchemaMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classarrow_1_1_table.html">Table</a>&gt; arrow::Table::ReplaceSchemaMetadata </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace schema key-value metadata with new metadata (EXPERIMENTAL) </p>
<dl class="section since"><dt>Since</dt><dd>0.5.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata</td><td>new <a class="el" href="classarrow_1_1_key_value_metadata.html" title="A container for key-value pair type metadata. Not thread-safe.">KeyValueMetadata</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a> </dd></dl>

</div>
</div>
<a id="ga8d8626acf4d00e2ac439c4f1cc7a054a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8626acf4d00e2ac439c4f1cc7a054a">&#9670;&nbsp;</a></span>schema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_schema.html">Schema</a>&gt; arrow::Table::schema </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the table schema. </p>

</div>
</div>
<a id="ga278674b3b9a78fdbccc3f3d52fc5d470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga278674b3b9a78fdbccc3f3d52fc5d470">&#9670;&nbsp;</a></span>schema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_schema.html">Schema</a>&gt; arrow::TableBatchReader::schema </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the shared schema of the record batches in the stream </dd></dl>

<p>Implements <a class="el" href="classarrow_1_1_record_batch_reader.html#ad2ded865a6720e61e4685cfd34ed377f">arrow::RecordBatchReader</a>.</p>

</div>
</div>
<a id="ga293c77d9e315f264bc84e770d357b089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga293c77d9e315f264bc84e770d357b089">&#9670;&nbsp;</a></span>set_chunksize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arrow::TableBatchReader::set_chunksize </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>chunksize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the desired maximum chunk size of record batches. </p>
<p>The actual chunk size of each record batch may be smaller, depending on actual chunking characteristics of each table column. </p>

</div>
</div>
<a id="ga41040be2a7e82cc45750f261f156daa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41040be2a7e82cc45750f261f156daa1">&#9670;&nbsp;</a></span>SetColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::SetColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt;&#160;</td>
          <td class="paramname"><em>field_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt;&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a column in the table, producing a new <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>. </p>

</div>
</div>
<a id="gabf30b26c92cf037191e8574763e22a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf30b26c92cf037191e8574763e22a2e">&#9670;&nbsp;</a></span>Slice() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a>&gt; arrow::ChunkedArray::Slice </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice from offset until end of the chunked array. </p>

</div>
</div>
<a id="ga3948de704790a778f8568f22e08bca55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3948de704790a778f8568f22e08bca55">&#9670;&nbsp;</a></span>Slice() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_table.html">Table</a>&gt; arrow::Table::Slice </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slice from first row at offset until end of the table. </p>

</div>
</div>
<a id="ga99573028501f20b3f0707d85e8cce2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99573028501f20b3f0707d85e8cce2ad">&#9670;&nbsp;</a></span>Slice() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a>&gt; arrow::ChunkedArray::Slice </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a zero-copy slice of the chunked array with the indicated offset and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>the position of the first element in the constructed slice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the length of the slice. If there are not enough elements in the chunked array, the length will be adjusted accordingly</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new object wrapped in std::shared_ptr&lt;ChunkedArray&gt; </dd></dl>

</div>
</div>
<a id="ga8fb8285ac5af45a9e931564edb4938fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb8285ac5af45a9e931564edb4938fc">&#9670;&nbsp;</a></span>Slice() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classarrow_1_1_table.html">Table</a>&gt; arrow::Table::Slice </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a zero-copy slice of the table with the indicated offset and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>the index of the first row in the constructed slice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the number of rows of the slice. If there are not enough rows in the table, the length will be adjusted accordingly</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new object wrapped in std::shared_ptr&lt;Table&gt; </dd></dl>

</div>
</div>
<a id="gaebd70d5a21ef0558472d6e594d3ceeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebd70d5a21ef0558472d6e594d3ceeb2">&#9670;&nbsp;</a></span>Table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::Table::Table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4ae1034b4c522d66da02ac1e17f30195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae1034b4c522d66da02ac1e17f30195">&#9670;&nbsp;</a></span>TableBatchReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::TableBatchReader::TableBatchReader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classarrow_1_1_table_batch_reader.html" title="Compute a stream of record batches from a (possibly chunked) Table.">TableBatchReader</a> for the given table. </p>

</div>
</div>
<a id="gadb15afa228802d9fab0f3993a4f82df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb15afa228802d9fab0f3993a4f82df2">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_data_type.html">DataType</a>&gt; arrow::ChunkedArray::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga06ca5def32987d58b7577db269e39520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06ca5def32987d58b7577db269e39520">&#9670;&nbsp;</a></span>Validate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::ChunkedArray::Validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform cheap validation checks to determine obvious inconsistencies within the chunk array's internal data. </p>
<p>This is O(k*m) where k is the number of array descendents, and m is the number of chunks.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="ga4a93ccc812c7ee9992bc9138b53895e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a93ccc812c7ee9992bc9138b53895e0">&#9670;&nbsp;</a></span>Validate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::Validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform cheap validation checks to determine obvious inconsistencies within the table's schema and internal data. </p>
<p>This is O(k*m) where k is the total number of field descendents, and m is the number of chunks.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="ga85899961a35888fcdfed462418ba6498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85899961a35888fcdfed462418ba6498">&#9670;&nbsp;</a></span>ValidateFull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::ChunkedArray::ValidateFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform extensive validation checks to determine inconsistencies within the chunk array's internal data. </p>
<p>This is O(k*n) where k is the number of array descendents, and n is the length in elements.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="ga5796527d5848794aff9b6b3107011dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5796527d5848794aff9b6b3107011dd7">&#9670;&nbsp;</a></span>ValidateFull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Table::ValidateFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform extensive validation checks to determine inconsistencies within the table's schema and internal data. </p>
<p>This is O(k*n) where k is the total number of field descendents, and n is the number of rows.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="gad5d7f457d2b87d9e28045b69b1ae9efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5d7f457d2b87d9e28045b69b1ae9efb">&#9670;&nbsp;</a></span>View()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::ChunkedArray::View </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a zero-copy view of this chunked array with the given type. </p>
<p>Calls <a class="el" href="classarrow_1_1_array.html#ad015904c8c6e5e2513c791fb577f2679" title="Construct a zero-copy view of this array with the given type.">Array::View</a> on each constituent chunk. Always succeeds if there are zero chunks </p>

</div>
</div>
<a id="ga7ea1eed4818941b9b1eb98381e1b9690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ea1eed4818941b9b1eb98381e1b9690">&#9670;&nbsp;</a></span>~Table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual arrow::Table::~Table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga438707b92386f68a63348c30743bc159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga438707b92386f68a63348c30743bc159">&#9670;&nbsp;</a></span>chunks_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a> arrow::ChunkedArray::chunks_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga20181bbcd6ae25ba49cadf11c636d4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20181bbcd6ae25ba49cadf11c636d4b3">&#9670;&nbsp;</a></span>field_merge_options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarrow_1_1_field_1_1_merge_options.html">Field::MergeOptions</a> arrow::ConcatenateTablesOptions::field_merge_options = <a class="el" href="structarrow_1_1_field_1_1_merge_options.html#aad6ec10fe86793101bf688bbf9c9ad96">Field::MergeOptions::Defaults</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4d2fc435340a18c488a3001ce88018c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2fc435340a18c488a3001ce88018c4">&#9670;&nbsp;</a></span>length_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t arrow::ChunkedArray::length_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga45ef30e6a7823f1666b0f50ecde903a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ef30e6a7823f1666b0f50ecde903a7">&#9670;&nbsp;</a></span>null_count_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t arrow::ChunkedArray::null_count_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7b7b895c038e468dac1be8d27722ffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b7b895c038e468dac1be8d27722ffa6">&#9670;&nbsp;</a></span>num_rows_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t arrow::Table::num_rows_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga40375f7767ae6caea748d87e53aacb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40375f7767ae6caea748d87e53aacb45">&#9670;&nbsp;</a></span>schema_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_schema.html">Schema</a>&gt; arrow::Table::schema_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga42911a6e758dd14bcc47a2108eed7bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42911a6e758dd14bcc47a2108eed7bd0">&#9670;&nbsp;</a></span>type_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_data_type.html">DataType</a>&gt; arrow::ChunkedArray::type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gac7c26f51a3023e3bc2eb6ae5a4510a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7c26f51a3023e3bc2eb6ae5a4510a9a">&#9670;&nbsp;</a></span>unify_schemas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::ConcatenateTablesOptions::unify_schemas = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, the schemas of the tables will be first unified with fields of the same name being merged, according to <code>field_merge_options</code>, then each table will be promoted to the unified schema before being concatenated. </p>
<p>Otherwise, all tables should have the same schema. Each column in the output table is the result of concatenating the corresponding columns in all input tables. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107500873-1');
</script>
</body>
</html>
