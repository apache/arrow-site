<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Arrow (C++): plasma</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Arrow (C++)
   </div>
   <div id="projectbrief">A columnar in-memory analytics layer designed to accelerate big data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">plasma </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>&lt;!&mdash; Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --&gt;</p>
<h1>Using the Plasma In-Memory Object Store from C++ </h1>
<p>Apache Arrow offers the ability to share your data structures among multiple processes simultaneously through Plasma, an in-memory object store.</p>
<p>Note that <b>the Plasma API is not stable</b>.</p>
<p>Plasma clients are processes that run on the same machine as the object store. They communicate with the object store over Unix domain sockets, and they read and write data in the object store through shared memory.</p>
<p>Plasma objects are immutable once they have been created.</p>
<p>The following goes over the basics so you can begin using Plasma in your big data applications.</p>
<h2>Starting the Plasma store </h2>
<p>To start running the Plasma object store so that clients may connect and access the data, run the following command:</p>
<div class="fragment"><div class="line">plasma_store_server -m 1000000000 -s /tmp/plasma</div>
</div><!-- fragment --><p>The <code>-m</code> flag specifies the size of the object store in bytes. The <code>-s</code> flag specifies the path of the Unix domain socket that the store will listen at.</p>
<p>Therefore, the above command initializes a Plasma store up to 1 GB of memory and sets the socket to <code>/tmp/plasma.</code></p>
<p>The Plasma store will remain available as long as the <code>plasma_store_server</code> process is running in a terminal window. Messages, such as alerts for disconnecting clients, may occasionally be output. To stop running the Plasma store, you can press <code>Ctrl-C</code> in the terminal window.</p>
<p>Alternatively, you can run the Plasma store in the background and ignore all message output with the following terminal command:</p>
<div class="fragment"><div class="line">plasma_store_server -m 1000000000 -s /tmp/plasma 1&gt; /dev/null 2&gt; /dev/null &amp;</div>
</div><!-- fragment --><p>The Plasma store will instead run silently in the background. To stop running the Plasma store in this case, issue the command below:</p>
<div class="fragment"><div class="line">killall plasma_store_server</div>
</div><!-- fragment --><h2>Creating a Plasma client </h2>
<p>Now that the Plasma object store is up and running, it is time to make a client process connect to it. To use the Plasma object store as a client, your application should initialize a <code><a class="el" href="classplasma_1_1_plasma_client.html">plasma::PlasmaClient</a></code> object and tell it to connect to the socket specified when starting up the Plasma object store.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plasma_2client_8h.html">plasma/client.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceplasma.html">plasma</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="comment">// Start up and connect a Plasma client.</span></div>
<div class="line">  <a class="code" href="classplasma_1_1_plasma_client.html">PlasmaClient</a> client;</div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#aec01341bd801c10abbfb1f31f1e9eaa2">Connect</a>(<span class="stringliteral">&quot;/tmp/plasma&quot;</span>));</div>
<div class="line">  <span class="comment">// Disconnect the Plasma client.</span></div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a82ff4d7b988c040aa46674a2fa907eff">Disconnect</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Save this program in a file <code>test.cc</code> and compile it with</p>
<div class="fragment"><div class="line">g++ test.cc `pkg-config --cflags --libs plasma` --std=c++11</div>
</div><!-- fragment --><p>Note that multiple clients can be created within the same process.</p>
<p>Note that a <code>PlasmaClient</code> object is <b>not thread safe</b>.</p>
<p>If the Plasma store is still running, you can now execute the <code>a.out</code> executable and the store will print something like</p>
<div class="fragment"><div class="line">Disconnecting client on fd 5</div>
</div><!-- fragment --><p>which shows that the client was successfully disconnected.</p>
<h2>Object IDs </h2>
<p>The Plasma object store uses twenty-byte identifiers for accessing objects stored in shared memory. Each object in the Plasma store should be associated with a unique ID. The Object ID is then a key that can be used by <b>any</b> client to fetch that object from the Plasma store.</p>
<p>Random generation of Object IDs is often good enough to ensure unique IDs. For test purposes, you can use the function <code>random_object_id</code> from the header <code>plasma/test-util.h</code> to generate random Object IDs, which uses a global random number generator. In your own applications, we recommend to generate a string of <code>ObjectID::size()</code> many random bytes using your own random number generator and pass them to <code>ObjectID::from_bytes</code> to generate the ObjectID.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;plasma/test-util.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Randomly generate an Object ID.</span></div>
<div class="line"><a class="code" href="namespaceplasma.html#adf1aa2f87f6f11e1993628f574e31e75">ObjectID</a> object_id = random_object_id();</div>
</div><!-- fragment --><p>Now, any connected client that knows the object's Object ID can access the same object from the Plasma object store. For easy transportation of Object IDs, you can convert/serialize an Object ID into a binary string and back as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// From ObjectID to binary string</span></div>
<div class="line"><a class="code" href="namespacestd.html">std</a>:<span class="keywordtype">string</span> id_string = object_id.binary();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// From binary string to ObjectID</span></div>
<div class="line"><a class="code" href="namespaceplasma.html#adf1aa2f87f6f11e1993628f574e31e75">ObjectID</a> id_object = ObjectID::from_binary(&amp;id_string);</div>
</div><!-- fragment --><p>You can also get a human readable representation of ObjectIDs in the same format that git uses for commit hashes by running <code>ObjectID::hex</code>.</p>
<p>Here is a test program you can run:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plasma_2client_8h.html">plasma/client.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;plasma/test-util.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceplasma.html">plasma</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <a class="code" href="classplasma_1_1_unique_i_d.html">ObjectID</a> object_id1 = random_object_id();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;object_id1 is &quot;</span> &lt;&lt; object_id1.<a class="code" href="classplasma_1_1_unique_i_d.html#a7d960f1c661c8bef8281d30f6a2019a7">hex</a>() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::string id_string = object_id1.<a class="code" href="classplasma_1_1_unique_i_d.html#a8646de53cd1ec9c3e4e68ba3f92a518a">binary</a>();</div>
<div class="line">  <a class="code" href="classplasma_1_1_unique_i_d.html">ObjectID</a> object_id2 = <a class="code" href="classplasma_1_1_unique_i_d.html#a35bce29897b79eb6215fbd1b9ebe99bb">ObjectID::from_binary</a>(id_string);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;object_id2 is &quot;</span> &lt;&lt; object_id2.<a class="code" href="classplasma_1_1_unique_i_d.html#a7d960f1c661c8bef8281d30f6a2019a7">hex</a>() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Creating an Object </h2>
<p>Now that you learned about Object IDs that are used to refer to objects, let's look at how objects can be stored in Plasma.</p>
<p>Storing objects is a two-stage process. First a buffer is allocated with a call to <code>Create</code>. Then it can be constructed in place by the client. Then it is made immutable and shared with other clients via a call to <code>Seal</code>.</p>
<p>The <code>Create</code> call blocks while the Plasma store allocates a buffer of the appropriate size. The client will then map the buffer into its own address space. At this point the object can be constructed in place using a pointer that was written by the <code>Create</code> command.</p>
<div class="fragment"><div class="line">int64_t data_size = 100;</div>
<div class="line"><span class="comment">// The address of the buffer allocated by the Plasma store will be written at</span></div>
<div class="line"><span class="comment">// this address.</span></div>
<div class="line">std::shared_ptr&lt;Buffer&gt; <a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>;</div>
<div class="line"><span class="comment">// Create a Plasma object by specifying its ID and size.</span></div>
<div class="line"><a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a2f00bd06c6a50a82b200884e84cd8d9d">Create</a>(object_id, data_size, NULL, 0, &amp;<a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>));</div>
</div><!-- fragment --><p>You can also specify metadata for the object; the third argument is the metadata (as raw bytes) and the fourth argument is the size of the metadata.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a Plasma object with metadata.</span></div>
<div class="line">int64_t data_size = 100;</div>
<div class="line">std::string metadata = <span class="stringliteral">&quot;{&#39;author&#39;: &#39;john&#39;}&quot;</span>;</div>
<div class="line">std::shared_ptr&lt;Buffer&gt; <a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>;</div>
<div class="line">client.<a class="code" href="classplasma_1_1_plasma_client.html#a2f00bd06c6a50a82b200884e84cd8d9d">Create</a>(object_id, data_size, (uint8_t*) metadata.data(), metadata.size(), &amp;<a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>);</div>
</div><!-- fragment --><p>Now that we've obtained a pointer to our object's data, we can write our data to it:</p>
<div class="fragment"><div class="line"><span class="comment">// Write some data for the Plasma object.</span></div>
<div class="line"><span class="keywordflow">for</span> (int64_t i = 0; i &lt; data_size; i++) {</div>
<div class="line">    <a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>[i] = static_cast&lt;uint8_t&gt;(i % 4);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When the client is done, the client <b>seals</b> the buffer, making the object immutable, and making it available to other Plasma clients:</p>
<div class="fragment"><div class="line"><span class="comment">// Seal the object. This makes it available for all clients.</span></div>
<div class="line">client.<a class="code" href="classplasma_1_1_plasma_client.html#ae06a7b43528f66b2dd28abf7138e5b6d">Seal</a>(object_id);</div>
</div><!-- fragment --><p>Here is an example that combines all these features:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plasma_2client_8h.html">plasma/client.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceplasma.html">plasma</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="comment">// Start up and connect a Plasma client.</span></div>
<div class="line">  <a class="code" href="classplasma_1_1_plasma_client.html">PlasmaClient</a> client;</div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#aec01341bd801c10abbfb1f31f1e9eaa2">Connect</a>(<span class="stringliteral">&quot;/tmp/plasma&quot;</span>));</div>
<div class="line">  <span class="comment">// Create an object with a fixed ObjectID.</span></div>
<div class="line">  <a class="code" href="classplasma_1_1_unique_i_d.html">ObjectID</a> object_id = <a class="code" href="classplasma_1_1_unique_i_d.html#a35bce29897b79eb6215fbd1b9ebe99bb">ObjectID::from_binary</a>(<span class="stringliteral">&quot;00000000000000000000&quot;</span>);</div>
<div class="line">  int64_t data_size = 1000;</div>
<div class="line">  std::shared_ptr&lt;Buffer&gt; <a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>;</div>
<div class="line">  std::string metadata = <span class="stringliteral">&quot;{&#39;author&#39;: &#39;john&#39;}&quot;</span>;</div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a2f00bd06c6a50a82b200884e84cd8d9d">Create</a>(object_id, data_size, (uint8_t*) metadata.data(), metadata.size(), &amp;<a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>));</div>
<div class="line">  <span class="comment">// Write some data into the object.</span></div>
<div class="line">  <span class="keyword">auto</span> d = <a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>-&gt;mutable_data();</div>
<div class="line">  <span class="keywordflow">for</span> (int64_t i = 0; i &lt; data_size; i++) {</div>
<div class="line">    d[i] = static_cast&lt;uint8_t&gt;(i % 4);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Seal the object.</span></div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#ae06a7b43528f66b2dd28abf7138e5b6d">Seal</a>(object_id));</div>
<div class="line">  <span class="comment">// Disconnect the client.</span></div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a82ff4d7b988c040aa46674a2fa907eff">Disconnect</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example can be compiled with</p>
<div class="fragment"><div class="line">g++ create.cc `pkg-config --cflags --libs plasma` --std=c++11 -o create</div>
</div><!-- fragment --><p>To verify that an object exists in the Plasma object store, you can call <code>PlasmaClient::Contains()</code> to check if an object has been created and sealed for a given Object ID. Note that this function will still return False if the object has been created, but not yet sealed:</p>
<div class="fragment"><div class="line"><span class="comment">// Check if an object has been created and sealed.</span></div>
<div class="line"><span class="keywordtype">bool</span> has_object;</div>
<div class="line">client.<a class="code" href="classplasma_1_1_plasma_client.html#af573b2ba35f48bf012393e9438ef086d">Contains</a>(object_id, &amp;has_object);</div>
<div class="line"><span class="keywordflow">if</span> (has_object) {</div>
<div class="line">    <span class="comment">// Object has been created and sealed, proceed</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Getting an Object </h2>
<p>After an object has been sealed, any client who knows the Object ID can get the object. To store the retrieved object contents, you should create an <code>ObjectBuffer</code>, then call <code>PlasmaClient::Get()</code> as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// Get from the Plasma store by Object ID.</span></div>
<div class="line">ObjectBuffer object_buffer;</div>
<div class="line">client.<a class="code" href="classplasma_1_1_plasma_client.html#a5b2626c32d557a57e66800027ba24b96">Get</a>(&amp;object_id, 1, -1, &amp;object_buffer);</div>
</div><!-- fragment --><p><code>PlasmaClient::Get()</code> isn't limited to fetching a single object from the Plasma store at once. You can specify an array of Object IDs and <code>ObjectBuffers</code> to fetch at once, so long as you also specify the number of objects being fetched:</p>
<div class="fragment"><div class="line"><span class="comment">// Get two objects at once from the Plasma store. This function</span></div>
<div class="line"><span class="comment">// call will block until both objects have been fetched.</span></div>
<div class="line">ObjectBuffer multiple_buffers[2];</div>
<div class="line"><a class="code" href="namespaceplasma.html#adf1aa2f87f6f11e1993628f574e31e75">ObjectID</a> multiple_ids[2] = {object_id1, object_id2};</div>
<div class="line">client.<a class="code" href="classplasma_1_1_plasma_client.html#a5b2626c32d557a57e66800027ba24b96">Get</a>(multiple_ids, 2, -1, multiple_buffers);</div>
</div><!-- fragment --><p>Since <code>PlasmaClient::Get()</code> is a blocking function call, it may be necessary to limit the amount of time the function is allowed to take when trying to fetch from the Plasma store. You can pass in a timeout in milliseconds when calling <code>PlasmaClient::Get().</code> To use <code>PlasmaClient::Get()</code> without a timeout, just pass in -1 like in the previous example calls:</p>
<div class="fragment"><div class="line"><span class="comment">// Make the function call give up fetching the object if it takes</span></div>
<div class="line"><span class="comment">// more than 100 milliseconds.</span></div>
<div class="line">int64_t timeout = 100;</div>
<div class="line">client.<a class="code" href="classplasma_1_1_plasma_client.html#a5b2626c32d557a57e66800027ba24b96">Get</a>(&amp;object_id, 1, timeout, &amp;object_buffer);</div>
</div><!-- fragment --><p>Finally, to access the object, you can access the <code>data</code> and <code>metadata</code> attributes of the <code>ObjectBuffer</code>. The <code>data</code> can be indexed like any array:</p>
<div class="fragment"><div class="line"><span class="comment">// Access object data.</span></div>
<div class="line">uint8_t* <a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a> = object_buffer.data;</div>
<div class="line">int64_t data_size = object_buffer.data_size;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access object metadata.</span></div>
<div class="line">uint8_t* metadata = object_buffer.metadata;</div>
<div class="line">uint8_t metadata_size = object_buffer.metadata_size;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Index into data array.</span></div>
<div class="line">uint8_t first_data_byte = <a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>[0];</div>
</div><!-- fragment --><p>Here is a longer example that shows these capabilities:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plasma_2client_8h.html">plasma/client.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceplasma.html">plasma</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="comment">// Start up and connect a Plasma client.</span></div>
<div class="line">  <a class="code" href="classplasma_1_1_plasma_client.html">PlasmaClient</a> client;</div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#aec01341bd801c10abbfb1f31f1e9eaa2">Connect</a>(<span class="stringliteral">&quot;/tmp/plasma&quot;</span>));</div>
<div class="line">  <a class="code" href="classplasma_1_1_unique_i_d.html">ObjectID</a> object_id = <a class="code" href="classplasma_1_1_unique_i_d.html#a35bce29897b79eb6215fbd1b9ebe99bb">ObjectID::from_binary</a>(<span class="stringliteral">&quot;00000000000000000000&quot;</span>);</div>
<div class="line">  <a class="code" href="structplasma_1_1_object_buffer.html">ObjectBuffer</a> object_buffer;</div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a5b2626c32d557a57e66800027ba24b96">Get</a>(&amp;object_id, 1, -1, &amp;object_buffer));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Retrieve object data.</span></div>
<div class="line">  <span class="keyword">auto</span> buffer = object_buffer.<a class="code" href="structplasma_1_1_object_buffer.html#ace0c6be03d13cc503d665fe976557558">data</a>;</div>
<div class="line">  <span class="keyword">const</span> uint8_t* <a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a> = buffer-&gt;data();</div>
<div class="line">  int64_t data_size = buffer-&gt;size();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check that the data agrees with what was written in the other process.</span></div>
<div class="line">  <span class="keywordflow">for</span> (int64_t i = 0; i &lt; data_size; i++) {</div>
<div class="line">    <a class="code" href="arrow_2util_2logging_8h.html#a389e6c69f3ba2e62c5a9e0372059f1a4">ARROW_CHECK</a>(<a class="code" href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">data</a>[i] == static_cast&lt;uint8_t&gt;(i % 4));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Disconnect the client.</span></div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a82ff4d7b988c040aa46674a2fa907eff">Disconnect</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you compile it with</p>
<div class="fragment"><div class="line">g++ get.cc `pkg-config --cflags --libs plasma` --std=c++11 -o get</div>
</div><!-- fragment --><p>and run it with <code>./get</code>, all the assertions will pass if you run the <code>create</code> example from above on the same Plasma store.</p>
<h2>Object Lifetime Management </h2>
<p>The Plasma store internally does reference counting to make sure objects that are mapped into the address space of one of the clients with <code>PlasmaClient::Get</code> are accessible. To unmap objects from a client, call <code>PlasmaClient::Release</code>. All objects that are mapped into a clients address space will automatically be released when the client is disconnected from the store (this happens even if the client process crashes or otherwise fails to call <code>Disconnect</code>).</p>
<p>If a new object is created and there is not enough space in the Plasma store, the store will evict the least recently used object (an object is in use if at least one client has gotten it but not released it).</p>
<h2>Object notifications </h2>
<p>Additionally, you can arrange to have Plasma notify you when objects are sealed in the object store. This may especially be handy when your program is collaborating with other Plasma clients, and needs to know when they make objects available.</p>
<p>First, you can subscribe your current Plasma client to such notifications by getting a file descriptor:</p>
<div class="fragment"><div class="line"><span class="comment">// Start receiving notifications into file_descriptor.</span></div>
<div class="line"><span class="keywordtype">int</span> fd;</div>
<div class="line"><a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a9975de6729ca214fa6cb8e9fe8abbb9a">Subscribe</a>(&amp;fd));</div>
</div><!-- fragment --><p>Once you have the file descriptor, you can have your current Plasma client wait to receive the next object notification. Object notifications include information such as Object ID, data size, and metadata size of the next newly available object:</p>
<div class="fragment"><div class="line"><span class="comment">// Receive notification of the next newly available object.</span></div>
<div class="line"><span class="comment">// Notification information is stored in object_id, data_size, and metadata_size</span></div>
<div class="line"><a class="code" href="namespaceplasma.html#adf1aa2f87f6f11e1993628f574e31e75">ObjectID</a> object_id;</div>
<div class="line">int64_t data_size;</div>
<div class="line">int64_t metadata_size;</div>
<div class="line"><a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a5cf17041829848e39e1bfe9ea66ed2c2">GetNotification</a>(fd, &amp;object_id, &amp;data_size, &amp;metadata_size));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the newly available object.</span></div>
<div class="line">ObjectBuffer object_buffer;</div>
<div class="line"><a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a5b2626c32d557a57e66800027ba24b96">Get</a>(&amp;object_id, 1, -1, &amp;object_buffer));</div>
</div><!-- fragment --><p>Here is a full program that shows this capability:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plasma_2client_8h.html">plasma/client.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceplasma.html">plasma</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="comment">// Start up and connect a Plasma client.</span></div>
<div class="line">  <a class="code" href="classplasma_1_1_plasma_client.html">PlasmaClient</a> client;</div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#aec01341bd801c10abbfb1f31f1e9eaa2">Connect</a>(<span class="stringliteral">&quot;/tmp/plasma&quot;</span>));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a9975de6729ca214fa6cb8e9fe8abbb9a">Subscribe</a>(&amp;fd));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classplasma_1_1_unique_i_d.html">ObjectID</a> object_id;</div>
<div class="line">  int64_t data_size;</div>
<div class="line">  int64_t metadata_size;</div>
<div class="line">  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a5cf17041829848e39e1bfe9ea66ed2c2">GetNotification</a>(fd, &amp;object_id, &amp;data_size, &amp;metadata_size));</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received object notification for object_id = &quot;</span></div>
<div class="line">              &lt;&lt; object_id.hex() &lt;&lt; <span class="stringliteral">&quot;, with data_size = &quot;</span> &lt;&lt; data_size</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;, and metadata_size = &quot;</span> &lt;&lt; metadata_size &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Disconnect the client.</span></div>
<div class="line">  <a class="code" href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a>(client.<a class="code" href="classplasma_1_1_plasma_client.html#a82ff4d7b988c040aa46674a2fa907eff">Disconnect</a>());</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you compile it with</p>
<div class="fragment"><div class="line">g++ subscribe.cc `pkg-config --cflags --libs plasma` --std=c++11 -o subscribe</div>
</div><!-- fragment --><p>and invoke <code>./create</code> and <code>./subscribe</code> while the Plasma store is running, you can observe the new object arriving. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aarrow_2util_2logging_8h_html_a389e6c69f3ba2e62c5a9e0372059f1a4"><div class="ttname"><a href="arrow_2util_2logging_8h.html#a389e6c69f3ba2e62c5a9e0372059f1a4">ARROW_CHECK</a></div><div class="ttdeci">#define ARROW_CHECK(condition)</div><div class="ttdef"><b>Definition:</b> logging.h:62</div></div>
<div class="ttc" id="aplasma_2client_8h_html"><div class="ttname"><a href="plasma_2client_8h.html">client.h</a></div></div>
<div class="ttc" id="aarrow_2util_2logging_8h_html_ab1dca026b4840fea1e82df4c176de6b3"><div class="ttname"><a href="arrow_2util_2logging_8h.html#ab1dca026b4840fea1e82df4c176de6b3">ARROW_CHECK_OK</a></div><div class="ttdeci">#define ARROW_CHECK_OK(s)</div><div class="ttdef"><b>Definition:</b> logging.h:81</div></div>
<div class="ttc" id="anamespaceplasma_html_adf1aa2f87f6f11e1993628f574e31e75"><div class="ttname"><a href="namespaceplasma.html#adf1aa2f87f6f11e1993628f574e31e75">plasma::ObjectID</a></div><div class="ttdeci">UniqueID ObjectID</div><div class="ttdef"><b>Definition:</b> common.h:78</div></div>
<div class="ttc" id="aclassplasma_1_1_plasma_client_html_a82ff4d7b988c040aa46674a2fa907eff"><div class="ttname"><a href="classplasma_1_1_plasma_client.html#a82ff4d7b988c040aa46674a2fa907eff">plasma::PlasmaClient::Disconnect</a></div><div class="ttdeci">Status Disconnect()</div><div class="ttdoc">Disconnect from the local plasma instance, including the local store and manager.</div></div>
<div class="ttc" id="anamespacemake__precompiled__bitcode_html_a4be8fd83a685b255381089b8c3ecb5a0"><div class="ttname"><a href="namespacemake__precompiled__bitcode.html#a4be8fd83a685b255381089b8c3ecb5a0">make_precompiled_bitcode.data</a></div><div class="ttdeci">data</div><div class="ttdef"><b>Definition:</b> make_precompiled_bitcode.py:45</div></div>
<div class="ttc" id="aclassplasma_1_1_unique_i_d_html_a8646de53cd1ec9c3e4e68ba3f92a518a"><div class="ttname"><a href="classplasma_1_1_unique_i_d.html#a8646de53cd1ec9c3e4e68ba3f92a518a">plasma::UniqueID::binary</a></div><div class="ttdeci">std::string binary() const</div></div>
<div class="ttc" id="aclassplasma_1_1_unique_i_d_html_a35bce29897b79eb6215fbd1b9ebe99bb"><div class="ttname"><a href="classplasma_1_1_unique_i_d.html#a35bce29897b79eb6215fbd1b9ebe99bb">plasma::UniqueID::from_binary</a></div><div class="ttdeci">static UniqueID from_binary(const std::string &amp;binary)</div></div>
<div class="ttc" id="anamespaceplasma_html"><div class="ttname"><a href="namespaceplasma.html">plasma</a></div><div class="ttdef"><b>Definition:</b> client.h:35</div></div>
<div class="ttc" id="aclassplasma_1_1_unique_i_d_html"><div class="ttname"><a href="classplasma_1_1_unique_i_d.html">plasma::UniqueID</a></div><div class="ttdef"><b>Definition:</b> common.h:63</div></div>
<div class="ttc" id="aclassplasma_1_1_plasma_client_html_ae06a7b43528f66b2dd28abf7138e5b6d"><div class="ttname"><a href="classplasma_1_1_plasma_client.html#ae06a7b43528f66b2dd28abf7138e5b6d">plasma::PlasmaClient::Seal</a></div><div class="ttdeci">Status Seal(const ObjectID &amp;object_id)</div><div class="ttdoc">Seal an object in the object store.</div></div>
<div class="ttc" id="aclassplasma_1_1_plasma_client_html_aec01341bd801c10abbfb1f31f1e9eaa2"><div class="ttname"><a href="classplasma_1_1_plasma_client.html#aec01341bd801c10abbfb1f31f1e9eaa2">plasma::PlasmaClient::Connect</a></div><div class="ttdeci">Status Connect(const std::string &amp;store_socket_name, const std::string &amp;manager_socket_name=&quot;&quot;, int release_delay=0, int num_retries=-1)</div><div class="ttdoc">Connect to the local plasma store.</div></div>
<div class="ttc" id="aclassplasma_1_1_plasma_client_html_a9975de6729ca214fa6cb8e9fe8abbb9a"><div class="ttname"><a href="classplasma_1_1_plasma_client.html#a9975de6729ca214fa6cb8e9fe8abbb9a">plasma::PlasmaClient::Subscribe</a></div><div class="ttdeci">Status Subscribe(int *fd)</div><div class="ttdoc">Subscribe to notifications when objects are sealed in the object store.</div></div>
<div class="ttc" id="aclassplasma_1_1_plasma_client_html_a5b2626c32d557a57e66800027ba24b96"><div class="ttname"><a href="classplasma_1_1_plasma_client.html#a5b2626c32d557a57e66800027ba24b96">plasma::PlasmaClient::Get</a></div><div class="ttdeci">Status Get(const std::vector&lt; ObjectID &gt; &amp;object_ids, int64_t timeout_ms, std::vector&lt; ObjectBuffer &gt; *object_buffers)</div><div class="ttdoc">Get some objects from the Plasma Store.</div></div>
<div class="ttc" id="aclassplasma_1_1_plasma_client_html_af573b2ba35f48bf012393e9438ef086d"><div class="ttname"><a href="classplasma_1_1_plasma_client.html#af573b2ba35f48bf012393e9438ef086d">plasma::PlasmaClient::Contains</a></div><div class="ttdeci">Status Contains(const ObjectID &amp;object_id, bool *has_object)</div><div class="ttdoc">Check if the object store contains a particular object and the object has been sealed.</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> common.h:151</div></div>
<div class="ttc" id="astructplasma_1_1_object_buffer_html"><div class="ttname"><a href="structplasma_1_1_object_buffer.html">plasma::ObjectBuffer</a></div><div class="ttdoc">Object buffer data structure.</div><div class="ttdef"><b>Definition:</b> client.h:38</div></div>
<div class="ttc" id="aclassplasma_1_1_plasma_client_html_a2f00bd06c6a50a82b200884e84cd8d9d"><div class="ttname"><a href="classplasma_1_1_plasma_client.html#a2f00bd06c6a50a82b200884e84cd8d9d">plasma::PlasmaClient::Create</a></div><div class="ttdeci">Status Create(const ObjectID &amp;object_id, int64_t data_size, const uint8_t *metadata, int64_t metadata_size, std::shared_ptr&lt; Buffer &gt; *data, int device_num=0)</div><div class="ttdoc">Create an object in the Plasma Store.</div></div>
<div class="ttc" id="aclassplasma_1_1_plasma_client_html"><div class="ttname"><a href="classplasma_1_1_plasma_client.html">plasma::PlasmaClient</a></div><div class="ttdef"><b>Definition:</b> client.h:47</div></div>
<div class="ttc" id="aclassplasma_1_1_unique_i_d_html_a7d960f1c661c8bef8281d30f6a2019a7"><div class="ttname"><a href="classplasma_1_1_unique_i_d.html#a7d960f1c661c8bef8281d30f6a2019a7">plasma::UniqueID::hex</a></div><div class="ttdeci">std::string hex() const</div></div>
<div class="ttc" id="aclassplasma_1_1_plasma_client_html_a5cf17041829848e39e1bfe9ea66ed2c2"><div class="ttname"><a href="classplasma_1_1_plasma_client.html#a5cf17041829848e39e1bfe9ea66ed2c2">plasma::PlasmaClient::GetNotification</a></div><div class="ttdeci">Status GetNotification(int fd, ObjectID *object_id, int64_t *data_size, int64_t *metadata_size)</div><div class="ttdoc">Receive next object notification for this client if Subscribe has been called.</div></div>
<div class="ttc" id="astructplasma_1_1_object_buffer_html_ace0c6be03d13cc503d665fe976557558"><div class="ttname"><a href="structplasma_1_1_object_buffer.html#ace0c6be03d13cc503d665fe976557558">plasma::ObjectBuffer::data</a></div><div class="ttdeci">std::shared_ptr&lt; Buffer &gt; data</div><div class="ttdoc">The data buffer.</div><div class="ttdef"><b>Definition:</b> client.h:40</div></div>
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107500873-1');
</script>
</body>
</html>
