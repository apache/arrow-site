<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Arrow (C++): arrow Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Arrow (C++)
   </div>
   <div id="projectbrief">A columnar in-memory analytics layer designed to accelerate big data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">arrow Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Top-level namespace for Apache Arrow C++ API.  
<a href="namespacearrow.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacearrow_1_1adapters"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1adapters.html">adapters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1compute"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1compute.html">compute</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1csv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1csv.html">csv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1cuda.html">cuda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1dataset"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1dataset.html">dataset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1flight"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1flight.html">flight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1fs"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1fs.html">fs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1hiveserver2"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1hiveserver2.html">hiveserver2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1io.html">io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1ipc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1ipc.html">ipc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1jni"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1jni.html">jni</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1json"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1json.html">json</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1py"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1py.html">py</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1stl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1stl.html">stl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacearrow_1_1util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow_1_1util.html">util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_adaptive_int_builder.html">AdaptiveIntBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_adaptive_u_int_builder.html">AdaptiveUIntBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> base type Immutable data array with some logical type and some length.  <a href="classarrow_1_1_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_array_builder.html">ArrayBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all data array builders.  <a href="classarrow_1_1_array_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_array_data.html">ArrayData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable container for generic Arrow array data.  <a href="structarrow_1_1_array_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_array_data_visitor.html">ArrayDataVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_array_data_visitor_3_01_boolean_type_01_4.html">ArrayDataVisitor&lt; BooleanType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_array_data_visitor_3_01_t_00_01enable__if__base__binary_3_01_t_01_4_01_4.html">ArrayDataVisitor&lt; T, enable_if_base_binary&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_array_data_visitor_3_01_t_00_01enable__if__fixed__size__binary_3_01_t_01_4_01_4.html">ArrayDataVisitor&lt; T, enable_if_fixed_size_binary&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_array_data_visitor_3_01_t_00_01enable__if__has__c__type_3_01_t_01_4_01_4.html">ArrayDataVisitor&lt; T, enable_if_has_c_type&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_array_visitor.html">ArrayVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_base_binary_array.html">BaseBinaryArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for variable-sized binary arrays, regardless of offset size and logical interpretation.  <a href="classarrow_1_1_base_binary_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_base_binary_builder.html">BaseBinaryBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_base_binary_scalar.html">BaseBinaryScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_base_binary_type.html">BaseBinaryType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all variable-size binary data types.  <a href="classarrow_1_1_base_binary_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_base_list_array.html">BaseListArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for variable-sized list arrays, regardless of offset size.  <a href="classarrow_1_1_base_list_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_base_list_builder.html">BaseListBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_base_list_scalar.html">BaseListScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_base_list_type.html">BaseListType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all variable-size list data types.  <a href="classarrow_1_1_base_list_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signed 128-bit integer in two's complement.  <a href="classarrow_1_1_basic_decimal128.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_basic_union_builder.html">BasicUnionBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_binary_array.html">BinaryArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for variable-size binary data.  <a href="classarrow_1_1_binary_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_binary_builder.html">BinaryBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder class for variable-length binary data.  <a href="classarrow_1_1_binary_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_binary_dictionary32_builder.html">BinaryDictionary32Builder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_binary_dictionary_builder.html">BinaryDictionaryBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_binary_scalar.html">BinaryScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_binary_type.html">BinaryType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for variable-size binary data.  <a href="classarrow_1_1_binary_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_boolean_array.html">BooleanArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for boolean data.  <a href="classarrow_1_1_boolean_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_boolean_builder.html">BooleanBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_boolean_scalar.html">BooleanScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_boolean_type.html">BooleanType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for boolean data.  <a href="classarrow_1_1_boolean_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_boundary_finder.html">BoundaryFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object containing a pointer to a piece of contiguous memory with a particular size.  <a href="classarrow_1_1_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_buffer_builder.html">BufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for incrementally building a contiguous chunk of in-memory data.  <a href="classarrow_1_1_buffer_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data structure managing a list of primitive Arrow arrays logically as one large array.  <a href="classarrow_1_1_chunked_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_chunker.html">Chunker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reusable block-based chunker for delimited data.  <a href="classarrow_1_1_chunker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_compression.html">Compression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_concatenate_tables_options.html">ConcatenateTablesOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the behavior of <a class="el" href="group__concat-tables.html#ga6272e4a6555d62afc43b2845d8616eb7" title="Construct table from multiple input tables.">ConcatenateTables()</a>.  <a href="structarrow_1_1_concatenate_tables_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_c_type_traits.html">CTypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_c_type_traits_3_01bool_01_4.html">CTypeTraits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_c_type_traits_3_01const_01char_01_5_01_4.html">CTypeTraits&lt; const char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_c_type_traits_3_01const_01char_07_6_08_0f_n_0e_4.html">CTypeTraits&lt; const char(&amp;)[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_c_type_traits_3_01_day_time_interval_type_1_1_day_milliseconds_01_4.html">CTypeTraits&lt; DayTimeIntervalType::DayMilliseconds &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_c_type_traits_3_01std_1_1string_01_4.html">CTypeTraits&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_c_type_traits_3_01std_1_1vector_3_01_c_type_01_4_01_4.html">CTypeTraits&lt; std::vector&lt; CType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_data_type.html">DataType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all data types.  <a href="classarrow_1_1_data_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_data_type_layout.html">DataTypeLayout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_date32_scalar.html">Date32Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_date32_type.html">Date32Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for 32-bit date data (as number of days since UNIX epoch)  <a href="classarrow_1_1_date32_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_date64_scalar.html">Date64Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_date64_type.html">Date64Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for 64-bit date data (as number of milliseconds since UNIX epoch)  <a href="classarrow_1_1_date64_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_date_scalar.html">DateScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_date_type.html">DateType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type class for date data.  <a href="classarrow_1_1_date_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_day_time_interval_array.html">DayTimeIntervalArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> of Day and Millisecond values.  <a href="classarrow_1_1_day_time_interval_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_day_time_interval_builder.html">DayTimeIntervalBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_day_time_interval_scalar.html">DayTimeIntervalScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_day_time_interval_type.html">DayTimeIntervalType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a number of days and milliseconds (fraction of day).  <a href="classarrow_1_1_day_time_interval_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_decimal128.html">Decimal128</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signed 128-bit integer in two's complement.  <a href="classarrow_1_1_decimal128.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_decimal128_array.html">Decimal128Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for 128-bit decimal data.  <a href="classarrow_1_1_decimal128_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_decimal128_builder.html">Decimal128Builder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_decimal128_scalar.html">Decimal128Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_decimal128_type.html">Decimal128Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for 128-bit decimal data.  <a href="classarrow_1_1_decimal128_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_decimal_type.html">DecimalType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type class for (fixed-size) decimal data.  <a href="classarrow_1_1_decimal_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_dense_union_builder.html">DenseUnionBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_dictionary32_builder.html">Dictionary32Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classarrow_1_1_dictionary_array.html" title="Array type for dictionary-encoded data with a data-dependent dictionary.">DictionaryArray</a> builder that always returns int32 dictionary indices so that data cast to dictionary form will have a consistent index type, e.g.  <a href="classarrow_1_1_dictionary32_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_dictionary_array.html">DictionaryArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> type for dictionary-encoded data with a data-dependent dictionary.  <a href="classarrow_1_1_dictionary_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_dictionary_builder.html">DictionaryBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classarrow_1_1_dictionary_array.html" title="Array type for dictionary-encoded data with a data-dependent dictionary.">DictionaryArray</a> builder that uses <a class="el" href="classarrow_1_1_adaptive_int_builder.html">AdaptiveIntBuilder</a> to return the smallest index size that can accommodate the dictionary indices.  <a href="classarrow_1_1_dictionary_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_dictionary_scalar.html">DictionaryScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_dictionary_type.html">DictionaryType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary-encoded value type with data-dependent dictionary.  <a href="classarrow_1_1_dictionary_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_dictionary_unifier.html">DictionaryUnifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for incremental dictionary unification.  <a href="classarrow_1_1_dictionary_unifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_double_scalar.html">DoubleScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_double_type.html">DoubleType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for 64-bit floating-point data (C "double")  <a href="classarrow_1_1_double_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_duration_scalar.html">DurationScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_duration_type.html">DurationType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_equal_options.html">EqualOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container of options for equality comparisons.  <a href="classarrow_1_1_equal_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_extension_array.html">ExtensionArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base array class for user-defined extension types.  <a href="classarrow_1_1_extension_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_extension_scalar.html">ExtensionScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_extension_type.html">ExtensionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for custom / user-defined types.  <a href="classarrow_1_1_extension_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_extension_type_registry.html">ExtensionTypeRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_field.html">Field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The combination of a field name and data type, with optional metadata.  <a href="classarrow_1_1_field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_filter_iterator.html">FilterIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_fixed_size_binary_array.html">FixedSizeBinaryArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for fixed-size binary data.  <a href="classarrow_1_1_fixed_size_binary_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_fixed_size_binary_builder.html">FixedSizeBinaryBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_fixed_size_binary_scalar.html">FixedSizeBinaryScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_fixed_size_binary_type.html">FixedSizeBinaryType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for fixed-size binary data.  <a href="classarrow_1_1_fixed_size_binary_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_fixed_size_list_array.html">FixedSizeListArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for fixed size list data.  <a href="classarrow_1_1_fixed_size_list_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_fixed_size_list_builder.html">FixedSizeListBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder class for fixed-length list array value types.  <a href="classarrow_1_1_fixed_size_list_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_fixed_size_list_scalar.html">FixedSizeListScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_fixed_size_list_type.html">FixedSizeListType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for fixed size list data.  <a href="classarrow_1_1_fixed_size_list_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_fixed_width_type.html">FixedWidthType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all fixed-width data types.  <a href="classarrow_1_1_fixed_width_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_flat_array.html">FlatArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-nested arrays.  <a href="classarrow_1_1_flat_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_flatten_iterator.html">FlattenIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1_flatten_iterator.html" title="FlattenIterator takes an iterator generating iterators and yields a unified iterator that flattens/co...">FlattenIterator</a> takes an iterator generating iterators and yields a unified iterator that flattens/concatenates in a single stream.  <a href="classarrow_1_1_flatten_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_floating_point_type.html">FloatingPointType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all floating-point data types.  <a href="classarrow_1_1_floating_point_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_float_scalar.html">FloatScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_float_type.html">FloatType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for 32-bit floating-point data (C "float")  <a href="classarrow_1_1_float_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_function_iterator.html">FunctionIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_half_float_scalar.html">HalfFloatScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_half_float_type.html">HalfFloatType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for 16-bit floating-point data.  <a href="classarrow_1_1_half_float_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_hash_util.html">HashUtil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to compute hash values.  <a href="classarrow_1_1_hash_util.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_int16_scalar.html">Int16Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_int16_type.html">Int16Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for signed 16-bit integer data.  <a href="classarrow_1_1_int16_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_int32_scalar.html">Int32Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_int32_type.html">Int32Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for signed 32-bit integer data.  <a href="classarrow_1_1_int32_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_int64_scalar.html">Int64Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_int64_type.html">Int64Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for signed 64-bit integer data.  <a href="classarrow_1_1_int64_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_int8_scalar.html">Int8Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_int8_type.html">Int8Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for signed 8-bit integer data.  <a href="classarrow_1_1_int8_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_integer_type.html">IntegerType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all integral data types.  <a href="classarrow_1_1_integer_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_interval_scalar.html">IntervalScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_interval_type.html">IntervalType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_iteration_traits.html">IterationTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_iteration_traits_3_01_iterator_3_01_t_01_4_01_4.html">IterationTraits&lt; Iterator&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_iteration_traits_3_01util_1_1optional_3_01_t_01_4_01_4.html">IterationTraits&lt; util::optional&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic <a class="el" href="classarrow_1_1_iterator.html" title="A generic Iterator that can return errors.">Iterator</a> that can return errors.  <a href="classarrow_1_1_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for key-value pair type metadata. Not thread-safe.  <a href="classarrow_1_1_key_value_metadata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_large_binary_array.html">LargeBinaryArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for large variable-size binary data.  <a href="classarrow_1_1_large_binary_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_large_binary_builder.html">LargeBinaryBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder class for large variable-length binary data.  <a href="classarrow_1_1_large_binary_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_large_binary_scalar.html">LargeBinaryScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_large_binary_type.html">LargeBinaryType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for large variable-size binary data.  <a href="classarrow_1_1_large_binary_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_large_list_array.html">LargeListArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for large list data (with 64-bit offsets)  <a href="classarrow_1_1_large_list_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_large_list_builder.html">LargeListBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder class for large variable-length list array value types.  <a href="classarrow_1_1_large_list_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_large_list_scalar.html">LargeListScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_large_list_type.html">LargeListType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for large list data.  <a href="classarrow_1_1_large_list_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_large_string_array.html">LargeStringArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for large variable-size string (utf-8) data.  <a href="classarrow_1_1_large_string_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_large_string_builder.html">LargeStringBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder class for large UTF8 strings.  <a href="classarrow_1_1_large_string_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_large_string_scalar.html">LargeStringScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_large_string_type.html">LargeStringType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for large variable-size string data, utf8-encoded.  <a href="classarrow_1_1_large_string_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_list_array.html">ListArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for list data.  <a href="classarrow_1_1_list_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_list_builder.html">ListBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder class for variable-length list array value types.  <a href="classarrow_1_1_list_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_list_scalar.html">ListScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_list_type.html">ListType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for list data.  <a href="classarrow_1_1_list_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_logging_memory_pool.html">LoggingMemoryPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_make_scalar_impl.html">MakeScalarImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_map_array.html">MapArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for map data.  <a href="classarrow_1_1_map_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_map_builder.html">MapBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder class for arrays of variable-size maps.  <a href="classarrow_1_1_map_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_map_iterator.html">MapIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1_map_iterator.html" title="MapIterator takes ownership of an iterator and a function to apply on every element.">MapIterator</a> takes ownership of an iterator and a function to apply on every element.  <a href="classarrow_1_1_map_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_map_scalar.html">MapScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_map_type.html">MapType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for map data.  <a href="classarrow_1_1_map_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for memory allocation.  <a href="classarrow_1_1_memory_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_month_interval_scalar.html">MonthIntervalScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_month_interval_type.html">MonthIntervalType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a some number of months.  <a href="classarrow_1_1_month_interval_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_mutable_buffer.html">MutableBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classarrow_1_1_buffer.html" title="Object containing a pointer to a piece of contiguous memory with a particular size.">Buffer</a> whose contents can be mutated. May or may not own its data.  <a href="classarrow_1_1_mutable_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_nested_type.html">NestedType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_null_array.html">NullArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degenerate null type <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a>.  <a href="classarrow_1_1_null_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_null_builder.html">NullBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_null_scalar.html">NullScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar value for <a class="el" href="classarrow_1_1_null_type.html" title="Concrete type class for always-null data.">NullType</a>. Never valid.  <a href="structarrow_1_1_null_scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_null_type.html">NullType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for always-null data.  <a href="classarrow_1_1_null_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_number_type.html">NumberType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all numeric data types.  <a href="classarrow_1_1_number_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for numeric data.  <a href="classarrow_1_1_numeric_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all Builders that emit an <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> of a scalar numerical type.  <a href="classarrow_1_1_numeric_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_numeric_scalar.html">NumericScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_numeric_tensor.html">NumericTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_parametric_type.html">ParametricType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all parametric data types.  <a href="classarrow_1_1_parametric_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_primitive_array.html">PrimitiveArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for arrays of fixed-size logical types.  <a href="classarrow_1_1_primitive_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_primitive_c_type.html">PrimitiveCType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all data types representing primitive values.  <a href="classarrow_1_1_primitive_c_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_proxy_memory_pool.html">ProxyMemoryPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for memory allocation.  <a href="classarrow_1_1_proxy_memory_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_readahead_iterator.html">ReadaheadIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Readahead iterator that iterates on the underlying iterator in a separate thread, getting up to N values in advance.  <a href="classarrow_1_1_readahead_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of equal-length arrays matching a particular <a class="el" href="classarrow_1_1_schema.html" title="Sequence of arrow::Field objects describing the columns of a record batch or table data structure.">Schema</a>.  <a href="classarrow_1_1_record_batch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_record_batch_builder.html">RecordBatchBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for creating record batches iteratively given a known schema.  <a href="classarrow_1_1_record_batch_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_record_batch_reader.html">RecordBatchReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface for reading stream of record batches.  <a href="classarrow_1_1_record_batch_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_resizable_buffer.html">ResizableBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable buffer that can be resized.  <a href="classarrow_1_1_resizable_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_result.html">Result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classarrow_1_1_result.html" title="A Result object either contains a value of type T or a Status object explaining why such a value is n...">Result</a> object either contains a value of type <code>T</code> or a <a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> object explaining why such a value is not present.  <a href="classarrow_1_1_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_scalar.html">Scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for scalar values, representing a single value occupying an array "slot".  <a href="structarrow_1_1_scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_scalar_visitor.html">ScalarVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_schema.html">Schema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of <a class="el" href="classarrow_1_1_field.html" title="The combination of a field name and data type, with optional metadata.">arrow::Field</a> objects describing the columns of a record batch or table data structure.  <a href="classarrow_1_1_schema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_schema_builder.html">SchemaBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class to incrementally construct/merge schemas.  <a href="classarrow_1_1_schema_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_sparse_c_o_o_index.html">SparseCOOIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: The index data for a COO sparse tensor.  <a href="classarrow_1_1_sparse_c_o_o_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_sparse_c_s_c_index.html">SparseCSCIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: The index data for a CSC sparse matrix.  <a href="classarrow_1_1_sparse_c_s_c_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_sparse_c_s_r_index.html">SparseCSRIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: The index data for a CSR sparse matrix.  <a href="classarrow_1_1_sparse_c_s_r_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_sparse_index.html">SparseIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: The base class for the index of a sparse tensor.  <a href="classarrow_1_1_sparse_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_sparse_tensor.html">SparseTensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: The base class of sparse tensor container.  <a href="classarrow_1_1_sparse_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_sparse_tensor_format.html">SparseTensorFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_sparse_tensor_impl.html">SparseTensorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: Concrete sparse tensor implementation classes with sparse index type.  <a href="classarrow_1_1_sparse_tensor_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_sparse_union_builder.html">SparseUnionBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_status.html">Status</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> outcome object (success or error)  <a href="classarrow_1_1_status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_status_detail.html">StatusDetail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque class that allows subsystems to retain additional information inside the <a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a>.  <a href="classarrow_1_1_status_detail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_string_array.html">StringArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for variable-size string (utf-8) data.  <a href="classarrow_1_1_string_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_string_builder.html">StringBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder class for UTF8 strings.  <a href="classarrow_1_1_string_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_string_dictionary32_builder.html">StringDictionary32Builder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_string_dictionary_builder.html">StringDictionaryBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_string_scalar.html">StringScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_string_type.html">StringType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for variable-size string data, utf8-encoded.  <a href="classarrow_1_1_string_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_struct_array.html">StructArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for struct data.  <a href="classarrow_1_1_struct_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_struct_builder.html">StructBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append, Resize and Reserve methods are acting on <a class="el" href="classarrow_1_1_struct_builder.html" title="Append, Resize and Reserve methods are acting on StructBuilder.">StructBuilder</a>.  <a href="classarrow_1_1_struct_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_struct_scalar.html">StructScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_struct_type.html">StructType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for struct data.  <a href="classarrow_1_1_struct_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_table.html">Table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical table as sequence of chunked arrays.  <a href="classarrow_1_1_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_table_batch_reader.html">TableBatchReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a stream of record batches from a (possibly chunked) <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>.  <a href="classarrow_1_1_table_batch_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_temporal_scalar.html">TemporalScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_temporal_type.html">TemporalType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for all date and time types.  <a href="classarrow_1_1_temporal_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_tensor.html">Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_time32_scalar.html">Time32Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_time32_type.html">Time32Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for 32-bit time data (as number of seconds or milliseconds since midnight)  <a href="classarrow_1_1_time32_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_time64_scalar.html">Time64Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_time64_type.html">Time64Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for 64-bit time data (as number of microseconds or nanoseconds since midnight)  <a href="classarrow_1_1_time64_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_time_scalar.html">TimeScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_timestamp_scalar.html">TimestampScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_timestamp_type.html">TimestampType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for datetime data (as number of seconds, milliseconds, microseconds or nanoseconds since UNIX epoch)  <a href="classarrow_1_1_timestamp_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_time_type.html">TimeType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type class for time data.  <a href="classarrow_1_1_time_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_time_unit.html">TimeUnit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type.html">Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_typed_buffer_builder.html">TypedBufferBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_typed_buffer_builder_3_01bool_01_4.html">TypedBufferBuilder&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classarrow_1_1_buffer_builder.html" title="A class for incrementally building a contiguous chunk of in-memory data.">BufferBuilder</a> for building a buffer containing a bitmap.  <a href="classarrow_1_1_typed_buffer_builder_3_01bool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_typed_buffer_builder_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__aritec42b86b747ba8f9be42ca702c779c07.html">TypedBufferBuilder&lt; T, typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value||std::is_standard_layout&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classarrow_1_1_buffer_builder.html" title="A class for incrementally building a contiguous chunk of in-memory data.">BufferBuilder</a> for building a buffer of arithmetic elements.  <a href="classarrow_1_1_typed_buffer_builder_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__aritec42b86b747ba8f9be42ca702c779c07.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits.html">TypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_binary_type_01_4.html">TypeTraits&lt; BinaryType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_boolean_type_01_4.html">TypeTraits&lt; BooleanType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_date32_type_01_4.html">TypeTraits&lt; Date32Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_date64_type_01_4.html">TypeTraits&lt; Date64Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_day_time_interval_type_01_4.html">TypeTraits&lt; DayTimeIntervalType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_decimal128_type_01_4.html">TypeTraits&lt; Decimal128Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_dictionary_type_01_4.html">TypeTraits&lt; DictionaryType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_duration_type_01_4.html">TypeTraits&lt; DurationType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_extension_type_01_4.html">TypeTraits&lt; ExtensionType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_fixed_size_binary_type_01_4.html">TypeTraits&lt; FixedSizeBinaryType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_fixed_size_list_type_01_4.html">TypeTraits&lt; FixedSizeListType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_half_float_type_01_4.html">TypeTraits&lt; HalfFloatType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_large_binary_type_01_4.html">TypeTraits&lt; LargeBinaryType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_large_list_type_01_4.html">TypeTraits&lt; LargeListType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_large_string_type_01_4.html">TypeTraits&lt; LargeStringType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_list_type_01_4.html">TypeTraits&lt; ListType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_map_type_01_4.html">TypeTraits&lt; MapType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_month_interval_type_01_4.html">TypeTraits&lt; MonthIntervalType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_null_type_01_4.html">TypeTraits&lt; NullType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_string_type_01_4.html">TypeTraits&lt; StringType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_struct_type_01_4.html">TypeTraits&lt; StructType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_time32_type_01_4.html">TypeTraits&lt; Time32Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_time64_type_01_4.html">TypeTraits&lt; Time64Type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_timestamp_type_01_4.html">TypeTraits&lt; TimestampType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_type_traits_3_01_union_type_01_4.html">TypeTraits&lt; UnionType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_type_visitor.html">TypeVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_u_int16_scalar.html">UInt16Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_u_int16_type.html">UInt16Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for unsigned 16-bit integer data.  <a href="classarrow_1_1_u_int16_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_u_int32_scalar.html">UInt32Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_u_int32_type.html">UInt32Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for unsigned 32-bit integer data.  <a href="classarrow_1_1_u_int32_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_u_int64_scalar.html">UInt64Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_u_int64_type.html">UInt64Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for unsigned 64-bit integer data.  <a href="classarrow_1_1_u_int64_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_u_int8_scalar.html">UInt8Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_u_int8_type.html">UInt8Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for unsigned 8-bit integer data.  <a href="classarrow_1_1_u_int8_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_union_array.html">UnionArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> class for union data.  <a href="classarrow_1_1_union_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_union_mode.html">UnionMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarrow_1_1_union_scalar.html">UnionScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_union_type.html">UnionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete type class for union data.  <a href="classarrow_1_1_union_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_vector_iterator.html">VectorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple iterator which yields the elements of a std::vector.  <a href="classarrow_1_1_vector_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1_vector_optional_iterator.html">VectorOptionalIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple iterator which yields the elements of a std::vector&lt;T&gt; as optional&lt;T&gt;.  <a href="classarrow_1_1_vector_optional_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a59bcac644b0f2cd8e7034643d09e23bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a59bcac644b0f2cd8e7034643d09e23bb">DecimalBuilder</a> = <a class="el" href="classarrow_1_1_decimal128_builder.html">Decimal128Builder</a></td></tr>
<tr class="separator:a59bcac644b0f2cd8e7034643d09e23bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab028f188008a82d790cd69ac351a3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#adab028f188008a82d790cd69ac351a3b">UInt8Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_u_int8_type.html">UInt8Type</a> &gt;</td></tr>
<tr class="separator:adab028f188008a82d790cd69ac351a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7720234c751cfa79a0d6d4e2014485"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a6f7720234c751cfa79a0d6d4e2014485">UInt16Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_u_int16_type.html">UInt16Type</a> &gt;</td></tr>
<tr class="separator:a6f7720234c751cfa79a0d6d4e2014485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e6101656a21b97a88179c8d1c453b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a54e6101656a21b97a88179c8d1c453b9">UInt32Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_u_int32_type.html">UInt32Type</a> &gt;</td></tr>
<tr class="separator:a54e6101656a21b97a88179c8d1c453b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1777cb0f7c98036ad6f078fa0f1a6829"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a1777cb0f7c98036ad6f078fa0f1a6829">UInt64Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_u_int64_type.html">UInt64Type</a> &gt;</td></tr>
<tr class="separator:a1777cb0f7c98036ad6f078fa0f1a6829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9675d2aecdd6ad622ee1358c358ba278"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a9675d2aecdd6ad622ee1358c358ba278">Int8Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_int8_type.html">Int8Type</a> &gt;</td></tr>
<tr class="separator:a9675d2aecdd6ad622ee1358c358ba278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ad5330bb34a045c6e87ecee875057e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ab5ad5330bb34a045c6e87ecee875057e">Int16Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_int16_type.html">Int16Type</a> &gt;</td></tr>
<tr class="separator:ab5ad5330bb34a045c6e87ecee875057e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031c893d8d592c7a099bb9bea3a25f86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a031c893d8d592c7a099bb9bea3a25f86">Int32Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_int32_type.html">Int32Type</a> &gt;</td></tr>
<tr class="separator:a031c893d8d592c7a099bb9bea3a25f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fa80026c56e0f1ff24b43c4dc33e61"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a08fa80026c56e0f1ff24b43c4dc33e61">Int64Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_int64_type.html">Int64Type</a> &gt;</td></tr>
<tr class="separator:a08fa80026c56e0f1ff24b43c4dc33e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87957f6c01fb918bb573f04c5188ca4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ae87957f6c01fb918bb573f04c5188ca4">HalfFloatBuilder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_half_float_type.html">HalfFloatType</a> &gt;</td></tr>
<tr class="separator:ae87957f6c01fb918bb573f04c5188ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7f8a9698e4a5b6e8c3884c2cf3aedb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#afc7f8a9698e4a5b6e8c3884c2cf3aedb">FloatBuilder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_float_type.html">FloatType</a> &gt;</td></tr>
<tr class="separator:afc7f8a9698e4a5b6e8c3884c2cf3aedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98cad76b29efffe92c6c88af8947873"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ab98cad76b29efffe92c6c88af8947873">DoubleBuilder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_double_type.html">DoubleType</a> &gt;</td></tr>
<tr class="separator:ab98cad76b29efffe92c6c88af8947873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d707f9cf680a2e01f48cc972e7aa7dd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Out  = void&gt; </td></tr>
<tr class="memitem:a2d707f9cf680a2e01f48cc972e7aa7dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a2d707f9cf680a2e01f48cc972e7aa7dd">enable_if_memoize</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; !std::is_same&lt; typename internal::DictionaryTraits&lt; T &gt;::MemoTableType, void &gt;::value, Out &gt;</td></tr>
<tr class="separator:a2d707f9cf680a2e01f48cc972e7aa7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b94ab6f22b2b71f032a996091499b7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Out  = void&gt; </td></tr>
<tr class="memitem:a4b94ab6f22b2b71f032a996091499b7b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a4b94ab6f22b2b71f032a996091499b7b">enable_if_no_memoize</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; std::is_same&lt; typename internal::DictionaryTraits&lt; T &gt;::MemoTableType, void &gt;::value, Out &gt;</td></tr>
<tr class="separator:a4b94ab6f22b2b71f032a996091499b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf659a72f5db1c837409580f11bd337"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a> = std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; &gt;</td></tr>
<tr class="separator:aecf659a72f5db1c837409580f11bd337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9162b62a545f10bb02754571cd7ec80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aa9162b62a545f10bb02754571cd7ec80">DecimalArray</a> = <a class="el" href="classarrow_1_1_decimal128_array.html">Decimal128Array</a></td></tr>
<tr class="separator:aa9162b62a545f10bb02754571cd7ec80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e0360de3fc4b7120b6b50f14a22786"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a26e0360de3fc4b7120b6b50f14a22786">BufferVector</a> = std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; &gt;</td></tr>
<tr class="separator:a26e0360de3fc4b7120b6b50f14a22786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b05a1d2db4d6cce70e2adc6ae983f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ac9b05a1d2db4d6cce70e2adc6ae983f9">SparseCOOTensor</a> = <a class="el" href="classarrow_1_1_sparse_tensor_impl.html">SparseTensorImpl</a>&lt; <a class="el" href="classarrow_1_1_sparse_c_o_o_index.html">SparseCOOIndex</a> &gt;</td></tr>
<tr class="memdesc:ac9b05a1d2db4d6cce70e2adc6ae983f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: <a class="el" href="structarrow_1_1_type.html">Type</a> alias for COO sparse tensor.  <a href="namespacearrow.html#ac9b05a1d2db4d6cce70e2adc6ae983f9">More...</a><br /></td></tr>
<tr class="separator:ac9b05a1d2db4d6cce70e2adc6ae983f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30853e74abee092db4aa50440dab9ce8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a30853e74abee092db4aa50440dab9ce8">SparseCSRMatrix</a> = <a class="el" href="classarrow_1_1_sparse_tensor_impl.html">SparseTensorImpl</a>&lt; <a class="el" href="classarrow_1_1_sparse_c_s_r_index.html">SparseCSRIndex</a> &gt;</td></tr>
<tr class="memdesc:a30853e74abee092db4aa50440dab9ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: <a class="el" href="structarrow_1_1_type.html">Type</a> alias for CSR sparse matrix.  <a href="namespacearrow.html#a30853e74abee092db4aa50440dab9ce8">More...</a><br /></td></tr>
<tr class="separator:a30853e74abee092db4aa50440dab9ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365a8eacbf769f8ce28bac334b84690c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a365a8eacbf769f8ce28bac334b84690c">SparseCSCMatrix</a> = <a class="el" href="classarrow_1_1_sparse_tensor_impl.html">SparseTensorImpl</a>&lt; <a class="el" href="classarrow_1_1_sparse_c_s_c_index.html">SparseCSCIndex</a> &gt;</td></tr>
<tr class="memdesc:a365a8eacbf769f8ce28bac334b84690c"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: <a class="el" href="structarrow_1_1_type.html">Type</a> alias for CSC sparse matrix.  <a href="namespacearrow.html#a365a8eacbf769f8ce28bac334b84690c">More...</a><br /></td></tr>
<tr class="separator:a365a8eacbf769f8ce28bac334b84690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98532acfa6b99a8c35c14d2484cd65bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a98532acfa6b99a8c35c14d2484cd65bb">RecordBatchIterator</a> = <a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt; &gt;</td></tr>
<tr class="separator:a98532acfa6b99a8c35c14d2484cd65bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea89658181e81c18b237da93d8294f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a3ea89658181e81c18b237da93d8294f7">Date32Array</a> = <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt; <a class="el" href="classarrow_1_1_date32_type.html">Date32Type</a> &gt;</td></tr>
<tr class="separator:a3ea89658181e81c18b237da93d8294f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa210dc2cd0cab7513343548d42c00000"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aa210dc2cd0cab7513343548d42c00000">Date32Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_date32_type.html">Date32Type</a> &gt;</td></tr>
<tr class="separator:aa210dc2cd0cab7513343548d42c00000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a45b66d455778ec8168f937379f22e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aa9a45b66d455778ec8168f937379f22e">Date64Array</a> = <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt; <a class="el" href="classarrow_1_1_date64_type.html">Date64Type</a> &gt;</td></tr>
<tr class="separator:aa9a45b66d455778ec8168f937379f22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7b5640cf95de8799d75b12f901b62a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#afd7b5640cf95de8799d75b12f901b62a">Date64Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_date64_type.html">Date64Type</a> &gt;</td></tr>
<tr class="separator:afd7b5640cf95de8799d75b12f901b62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97345da72ba3bedb03d2b93e8c039b19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a97345da72ba3bedb03d2b93e8c039b19">Time32Array</a> = <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt; <a class="el" href="classarrow_1_1_time32_type.html">Time32Type</a> &gt;</td></tr>
<tr class="separator:a97345da72ba3bedb03d2b93e8c039b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d407b259c6792c8b8bbb86959259721"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a8d407b259c6792c8b8bbb86959259721">Time32Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_time32_type.html">Time32Type</a> &gt;</td></tr>
<tr class="separator:a8d407b259c6792c8b8bbb86959259721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093e1d42b3a49745a128a04736b56fad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a093e1d42b3a49745a128a04736b56fad">Time64Array</a> = <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt; <a class="el" href="classarrow_1_1_time64_type.html">Time64Type</a> &gt;</td></tr>
<tr class="separator:a093e1d42b3a49745a128a04736b56fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d18a383e3cc604c5add634bde4980"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a682d18a383e3cc604c5add634bde4980">Time64Builder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_time64_type.html">Time64Type</a> &gt;</td></tr>
<tr class="separator:a682d18a383e3cc604c5add634bde4980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da84bd82ad0d204965fe95d134a6c08"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a8da84bd82ad0d204965fe95d134a6c08">TimestampArray</a> = <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt; <a class="el" href="classarrow_1_1_timestamp_type.html">TimestampType</a> &gt;</td></tr>
<tr class="separator:a8da84bd82ad0d204965fe95d134a6c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c24ba298ea48738e160ebcf6133aa2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7c24ba298ea48738e160ebcf6133aa2f">TimestampBuilder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_timestamp_type.html">TimestampType</a> &gt;</td></tr>
<tr class="separator:a7c24ba298ea48738e160ebcf6133aa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182e773860b508e71ad82e8aa2b9556c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a182e773860b508e71ad82e8aa2b9556c">MonthIntervalArray</a> = <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt; <a class="el" href="classarrow_1_1_month_interval_type.html">MonthIntervalType</a> &gt;</td></tr>
<tr class="separator:a182e773860b508e71ad82e8aa2b9556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f513441e20a820ba699fb943d527e03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a8f513441e20a820ba699fb943d527e03">MonthIntervalBuilder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_month_interval_type.html">MonthIntervalType</a> &gt;</td></tr>
<tr class="separator:a8f513441e20a820ba699fb943d527e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cfa546dbecd78fdb541518d7867fe0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a44cfa546dbecd78fdb541518d7867fe0">DurationArray</a> = <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt; <a class="el" href="classarrow_1_1_duration_type.html">DurationType</a> &gt;</td></tr>
<tr class="separator:a44cfa546dbecd78fdb541518d7867fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd4592209b60fc1aa1d6fc1f2d0f7bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aefd4592209b60fc1aa1d6fc1f2d0f7bf">DurationBuilder</a> = <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt; <a class="el" href="classarrow_1_1_duration_type.html">DurationType</a> &gt;</td></tr>
<tr class="separator:aefd4592209b60fc1aa1d6fc1f2d0f7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffa941ae85f4dd1545a9fad796324c6"><td class="memTemplParams" colspan="2">template&lt;bool B, typename T  = void&gt; </td></tr>
<tr class="memitem:a6ffa941ae85f4dd1545a9fad796324c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a> = typename std::enable_if&lt; B, T &gt;::type</td></tr>
<tr class="separator:a6ffa941ae85f4dd1545a9fad796324c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae823a76b8a9209b0553bd12b92f7628e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae823a76b8a9209b0553bd12b92f7628e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ae823a76b8a9209b0553bd12b92f7628e">is_null_type</a> = std::is_same&lt; <a class="el" href="classarrow_1_1_null_type.html">NullType</a>, T &gt;</td></tr>
<tr class="separator:ae823a76b8a9209b0553bd12b92f7628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefffb639efbe0f7bd75e2a302b7f772e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:aefffb639efbe0f7bd75e2a302b7f772e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aefffb639efbe0f7bd75e2a302b7f772e">enable_if_null</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#ae823a76b8a9209b0553bd12b92f7628e">is_null_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:aefffb639efbe0f7bd75e2a302b7f772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1505b20d54161f765534e652d0c20118"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1505b20d54161f765534e652d0c20118"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a1505b20d54161f765534e652d0c20118">is_boolean_type</a> = std::is_same&lt; <a class="el" href="classarrow_1_1_boolean_type.html">BooleanType</a>, T &gt;</td></tr>
<tr class="separator:a1505b20d54161f765534e652d0c20118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafae5fb16a0ba015d3d5dc0ba94c059"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:acafae5fb16a0ba015d3d5dc0ba94c059"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#acafae5fb16a0ba015d3d5dc0ba94c059">enable_if_boolean</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a1505b20d54161f765534e652d0c20118">is_boolean_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:acafae5fb16a0ba015d3d5dc0ba94c059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17762801d38e85bb19ba347db78c9e38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17762801d38e85bb19ba347db78c9e38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a17762801d38e85bb19ba347db78c9e38">is_number_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_number_type.html">NumberType</a>, T &gt;</td></tr>
<tr class="separator:a17762801d38e85bb19ba347db78c9e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7630f411a876624d7d347e59dea8ef70"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a7630f411a876624d7d347e59dea8ef70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7630f411a876624d7d347e59dea8ef70">enable_if_number</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a17762801d38e85bb19ba347db78c9e38">is_number_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a7630f411a876624d7d347e59dea8ef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3858c2a0029df0a836908cd00da27a73"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3858c2a0029df0a836908cd00da27a73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a3858c2a0029df0a836908cd00da27a73">is_integer_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_integer_type.html">IntegerType</a>, T &gt;</td></tr>
<tr class="separator:a3858c2a0029df0a836908cd00da27a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231590a53c16996c8c7b698333f1ed82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a231590a53c16996c8c7b698333f1ed82"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a231590a53c16996c8c7b698333f1ed82">enable_if_integer</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a3858c2a0029df0a836908cd00da27a73">is_integer_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a231590a53c16996c8c7b698333f1ed82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dd2b914ad4a61e400eb59894d23a70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20dd2b914ad4a61e400eb59894d23a70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a20dd2b914ad4a61e400eb59894d23a70">is_signed_integer_type</a> = std::integral_constant&lt; bool, <a class="el" href="namespacearrow.html#a3858c2a0029df0a836908cd00da27a73">is_integer_type</a>&lt; T &gt;::value &amp;&amp;std::is_signed&lt; typename T::c_type &gt;::value &gt;</td></tr>
<tr class="separator:a20dd2b914ad4a61e400eb59894d23a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f130ef645ae790fb2b596b1123e6d1e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a5f130ef645ae790fb2b596b1123e6d1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a5f130ef645ae790fb2b596b1123e6d1e">enable_if_signed_integer</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a20dd2b914ad4a61e400eb59894d23a70">is_signed_integer_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a5f130ef645ae790fb2b596b1123e6d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbff722ac55605b6945c47d8a99feb53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbff722ac55605b6945c47d8a99feb53"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#afbff722ac55605b6945c47d8a99feb53">is_unsigned_integer_type</a> = std::integral_constant&lt; bool, <a class="el" href="namespacearrow.html#a3858c2a0029df0a836908cd00da27a73">is_integer_type</a>&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; typename T::c_type &gt;::value &gt;</td></tr>
<tr class="separator:afbff722ac55605b6945c47d8a99feb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2160429e178313ac15141e7277e763"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a9b2160429e178313ac15141e7277e763"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a9b2160429e178313ac15141e7277e763">enable_if_unsigned_integer</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#afbff722ac55605b6945c47d8a99feb53">is_unsigned_integer_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a9b2160429e178313ac15141e7277e763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39920d433ba89ea20da9e9ff52ba0de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab39920d433ba89ea20da9e9ff52ba0de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ab39920d433ba89ea20da9e9ff52ba0de">is_floating_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_floating_point_type.html">FloatingPointType</a>, T &gt;</td></tr>
<tr class="separator:ab39920d433ba89ea20da9e9ff52ba0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dddaa868c5f1b0f2b0642192f16f29b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a9dddaa868c5f1b0f2b0642192f16f29b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a9dddaa868c5f1b0f2b0642192f16f29b">enable_if_floating_point</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#ab39920d433ba89ea20da9e9ff52ba0de">is_floating_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a9dddaa868c5f1b0f2b0642192f16f29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b7471bd6e7d3ae3f2a996cca113ac5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8b7471bd6e7d3ae3f2a996cca113ac5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#af8b7471bd6e7d3ae3f2a996cca113ac5">is_half_float_type</a> = std::is_same&lt; <a class="el" href="classarrow_1_1_half_float_type.html">HalfFloatType</a>, T &gt;</td></tr>
<tr class="separator:af8b7471bd6e7d3ae3f2a996cca113ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60fed4e396b94591b87566731a74a7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:ad60fed4e396b94591b87566731a74a7a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ad60fed4e396b94591b87566731a74a7a">enable_if_half_float</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#af8b7471bd6e7d3ae3f2a996cca113ac5">is_half_float_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:ad60fed4e396b94591b87566731a74a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b18703d712bea4f0e5565ebaf84ed74"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b18703d712bea4f0e5565ebaf84ed74"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7b18703d712bea4f0e5565ebaf84ed74">is_base_binary_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_base_binary_type.html">BaseBinaryType</a>, T &gt;</td></tr>
<tr class="separator:a7b18703d712bea4f0e5565ebaf84ed74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adfa6f41eb212d569e8c644b9815bd8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a5adfa6f41eb212d569e8c644b9815bd8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a5adfa6f41eb212d569e8c644b9815bd8">enable_if_base_binary</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a7b18703d712bea4f0e5565ebaf84ed74">is_base_binary_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a5adfa6f41eb212d569e8c644b9815bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b69802ef6353c58cbbf30df4457bf7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57b69802ef6353c58cbbf30df4457bf7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a57b69802ef6353c58cbbf30df4457bf7">is_any_binary_type</a> = std::integral_constant&lt; bool, std::is_same&lt; <a class="el" href="classarrow_1_1_binary_type.html">BinaryType</a>, T &gt;::value||std::is_same&lt; <a class="el" href="classarrow_1_1_large_binary_type.html">LargeBinaryType</a>, T &gt;::value &gt;</td></tr>
<tr class="separator:a57b69802ef6353c58cbbf30df4457bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40d4db05ea1b3772a900c4a0dc1d6df"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:aa40d4db05ea1b3772a900c4a0dc1d6df"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aa40d4db05ea1b3772a900c4a0dc1d6df">enable_if_any_binary</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a57b69802ef6353c58cbbf30df4457bf7">is_any_binary_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:aa40d4db05ea1b3772a900c4a0dc1d6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45709f39fa2d7508b0068c6e493acc5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45709f39fa2d7508b0068c6e493acc5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a45709f39fa2d7508b0068c6e493acc5b">is_string_like_type</a> = std::integral_constant&lt; bool, <a class="el" href="namespacearrow.html#a7b18703d712bea4f0e5565ebaf84ed74">is_base_binary_type</a>&lt; T &gt;::value &amp;&amp;T::is_utf8 &gt;</td></tr>
<tr class="separator:a45709f39fa2d7508b0068c6e493acc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb96642403fdce64b1f1f1189a859e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a4eb96642403fdce64b1f1f1189a859e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a4eb96642403fdce64b1f1f1189a859e4">enable_if_string_like</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a45709f39fa2d7508b0068c6e493acc5b">is_string_like_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a4eb96642403fdce64b1f1f1189a859e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1f61cca333813d5652f9cf7bc54c00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f1f61cca333813d5652f9cf7bc54c00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a0f1f61cca333813d5652f9cf7bc54c00">is_fixed_size_binary_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_fixed_size_binary_type.html">FixedSizeBinaryType</a>, T &gt;</td></tr>
<tr class="separator:a0f1f61cca333813d5652f9cf7bc54c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf9cd29f578b7221cbd8cf4183d0d80"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:aaaf9cd29f578b7221cbd8cf4183d0d80"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aaaf9cd29f578b7221cbd8cf4183d0d80">enable_if_fixed_size_binary</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a0f1f61cca333813d5652f9cf7bc54c00">is_fixed_size_binary_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:aaaf9cd29f578b7221cbd8cf4183d0d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31da5300521aeadb8c39244e672aad20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a31da5300521aeadb8c39244e672aad20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a31da5300521aeadb8c39244e672aad20">is_binary_like_type</a> = std::integral_constant&lt; bool,(<a class="el" href="namespacearrow.html#a7b18703d712bea4f0e5565ebaf84ed74">is_base_binary_type</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="namespacearrow.html#a45709f39fa2d7508b0068c6e493acc5b">is_string_like_type</a>&lt; T &gt;::value)||<a class="el" href="namespacearrow.html#a0f1f61cca333813d5652f9cf7bc54c00">is_fixed_size_binary_type</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:a31da5300521aeadb8c39244e672aad20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e76ad2a1ac1cc895d9ef4429596e89"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a07e76ad2a1ac1cc895d9ef4429596e89"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a07e76ad2a1ac1cc895d9ef4429596e89">enable_if_binary_like</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a31da5300521aeadb8c39244e672aad20">is_binary_like_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a07e76ad2a1ac1cc895d9ef4429596e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104b6b0fbbfcaf5420f1e4efbe06e6a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a104b6b0fbbfcaf5420f1e4efbe06e6a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a104b6b0fbbfcaf5420f1e4efbe06e6a0">is_decimal_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_decimal_type.html">DecimalType</a>, T &gt;</td></tr>
<tr class="separator:a104b6b0fbbfcaf5420f1e4efbe06e6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1111b82ec23da8d84da2b9aaca4bc936"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a1111b82ec23da8d84da2b9aaca4bc936"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a1111b82ec23da8d84da2b9aaca4bc936">enable_if_decimal</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a104b6b0fbbfcaf5420f1e4efbe06e6a0">is_decimal_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a1111b82ec23da8d84da2b9aaca4bc936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f27de2e50e048565bb9606bb7603d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29f27de2e50e048565bb9606bb7603d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a29f27de2e50e048565bb9606bb7603d6">is_nested_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_nested_type.html">NestedType</a>, T &gt;</td></tr>
<tr class="separator:a29f27de2e50e048565bb9606bb7603d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afc66a9dd979542bb7691353facc725"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a5afc66a9dd979542bb7691353facc725"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a5afc66a9dd979542bb7691353facc725">enable_if_nested</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a29f27de2e50e048565bb9606bb7603d6">is_nested_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a5afc66a9dd979542bb7691353facc725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f549e14653c8041a6d947fb881ce470"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f549e14653c8041a6d947fb881ce470"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7f549e14653c8041a6d947fb881ce470">is_base_list_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_base_list_type.html">BaseListType</a>, T &gt;</td></tr>
<tr class="separator:a7f549e14653c8041a6d947fb881ce470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a29d51e29e6246523d1f7404ccf8f12"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a4a29d51e29e6246523d1f7404ccf8f12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a4a29d51e29e6246523d1f7404ccf8f12">enable_if_base_list</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a7f549e14653c8041a6d947fb881ce470">is_base_list_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a4a29d51e29e6246523d1f7404ccf8f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0fa3fa76eca92942333e08afbf5e2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d0fa3fa76eca92942333e08afbf5e2c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a2d0fa3fa76eca92942333e08afbf5e2c">is_fixed_size_list_type</a> = std::is_same&lt; <a class="el" href="classarrow_1_1_fixed_size_list_type.html">FixedSizeListType</a>, T &gt;</td></tr>
<tr class="separator:a2d0fa3fa76eca92942333e08afbf5e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5fd9fcbc47d7a271bc3e8acffb7419"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a5d5fd9fcbc47d7a271bc3e8acffb7419"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a5d5fd9fcbc47d7a271bc3e8acffb7419">enable_if_fixed_size_list</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a2d0fa3fa76eca92942333e08afbf5e2c">is_fixed_size_list_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a5d5fd9fcbc47d7a271bc3e8acffb7419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6af17dcffa6518fe03a0e26d084814"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b6af17dcffa6518fe03a0e26d084814"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a2b6af17dcffa6518fe03a0e26d084814">is_list_like_type</a> = std::integral_constant&lt; bool, <a class="el" href="namespacearrow.html#a7f549e14653c8041a6d947fb881ce470">is_base_list_type</a>&lt; T &gt;::value||<a class="el" href="namespacearrow.html#a2d0fa3fa76eca92942333e08afbf5e2c">is_fixed_size_list_type</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:a2b6af17dcffa6518fe03a0e26d084814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391a75a25d56b15b309a520d42b7696d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a391a75a25d56b15b309a520d42b7696d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a391a75a25d56b15b309a520d42b7696d">enable_if_list_like</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a2b6af17dcffa6518fe03a0e26d084814">is_list_like_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a391a75a25d56b15b309a520d42b7696d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc4639f9805d2ff49d79770577683bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7cc4639f9805d2ff49d79770577683bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7cc4639f9805d2ff49d79770577683bb">is_struct_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_struct_type.html">StructType</a>, T &gt;</td></tr>
<tr class="separator:a7cc4639f9805d2ff49d79770577683bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524c1cd0f2b105e5ad18a1410aafcba0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a524c1cd0f2b105e5ad18a1410aafcba0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a524c1cd0f2b105e5ad18a1410aafcba0">enable_if_struct</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a7cc4639f9805d2ff49d79770577683bb">is_struct_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a524c1cd0f2b105e5ad18a1410aafcba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8ba17a03d55c0a45607ce41c506e6b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a8ba17a03d55c0a45607ce41c506e6b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a8a8ba17a03d55c0a45607ce41c506e6b">is_union_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_union_type.html">UnionType</a>, T &gt;</td></tr>
<tr class="separator:a8a8ba17a03d55c0a45607ce41c506e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6364f401be8babca103e18af1154c6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:ada6364f401be8babca103e18af1154c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ada6364f401be8babca103e18af1154c6">enable_if_union</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a8a8ba17a03d55c0a45607ce41c506e6b">is_union_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:ada6364f401be8babca103e18af1154c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad747b7b43421fb8bcb9e41e2b9ccc5e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad747b7b43421fb8bcb9e41e2b9ccc5e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ad747b7b43421fb8bcb9e41e2b9ccc5e7">is_temporal_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_temporal_type.html">TemporalType</a>, T &gt;</td></tr>
<tr class="separator:ad747b7b43421fb8bcb9e41e2b9ccc5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead9c608ea64700fc81a28485d675cce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:aead9c608ea64700fc81a28485d675cce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aead9c608ea64700fc81a28485d675cce">enable_if_temporal</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#ad747b7b43421fb8bcb9e41e2b9ccc5e7">is_temporal_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:aead9c608ea64700fc81a28485d675cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201c518970c17cdce4d402b68510edee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a201c518970c17cdce4d402b68510edee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a201c518970c17cdce4d402b68510edee">is_date_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_date_type.html">DateType</a>, T &gt;</td></tr>
<tr class="separator:a201c518970c17cdce4d402b68510edee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bd19f17d8bafe6e5be8f1b6a293466"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a95bd19f17d8bafe6e5be8f1b6a293466"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a95bd19f17d8bafe6e5be8f1b6a293466">enable_if_date</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a201c518970c17cdce4d402b68510edee">is_date_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a95bd19f17d8bafe6e5be8f1b6a293466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa20abe6646670908e927e14fe48f238"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa20abe6646670908e927e14fe48f238"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aaa20abe6646670908e927e14fe48f238">is_time_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_time_type.html">TimeType</a>, T &gt;</td></tr>
<tr class="separator:aaa20abe6646670908e927e14fe48f238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d121c21d9bf722d5630549f91de2494"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a9d121c21d9bf722d5630549f91de2494"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a9d121c21d9bf722d5630549f91de2494">enable_if_time</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#aaa20abe6646670908e927e14fe48f238">is_time_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a9d121c21d9bf722d5630549f91de2494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4fc09acf6524064a074ffc9c8269ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc4fc09acf6524064a074ffc9c8269ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#abc4fc09acf6524064a074ffc9c8269ea">is_timestamp_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_timestamp_type.html">TimestampType</a>, T &gt;</td></tr>
<tr class="separator:abc4fc09acf6524064a074ffc9c8269ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f916e587fb352a2ac375ca35cb3434"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a34f916e587fb352a2ac375ca35cb3434"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a34f916e587fb352a2ac375ca35cb3434">enable_if_timestamp</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#abc4fc09acf6524064a074ffc9c8269ea">is_timestamp_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a34f916e587fb352a2ac375ca35cb3434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8b36624157a2c34db12f20a54a20e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e8b36624157a2c34db12f20a54a20e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a9e8b36624157a2c34db12f20a54a20e4">is_duration_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_duration_type.html">DurationType</a>, T &gt;</td></tr>
<tr class="separator:a9e8b36624157a2c34db12f20a54a20e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af862a54186228d55eedb5e96a177d816"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:af862a54186228d55eedb5e96a177d816"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#af862a54186228d55eedb5e96a177d816">enable_if_duration</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a9e8b36624157a2c34db12f20a54a20e4">is_duration_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:af862a54186228d55eedb5e96a177d816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ba5d87672cd108fd3b167fd258fb54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59ba5d87672cd108fd3b167fd258fb54"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a59ba5d87672cd108fd3b167fd258fb54">is_interval_type</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_interval_type.html">IntervalType</a>, T &gt;</td></tr>
<tr class="separator:a59ba5d87672cd108fd3b167fd258fb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119121074b7bfa291143daba4f5cd7f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a119121074b7bfa291143daba4f5cd7f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a119121074b7bfa291143daba4f5cd7f0">enable_if_interval</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a59ba5d87672cd108fd3b167fd258fb54">is_interval_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a119121074b7bfa291143daba4f5cd7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f81113b89cbe368312906d2ea05455"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5f81113b89cbe368312906d2ea05455"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#af5f81113b89cbe368312906d2ea05455">is_primitive_ctype</a> = std::is_base_of&lt; <a class="el" href="classarrow_1_1_primitive_c_type.html">PrimitiveCType</a>, T &gt;</td></tr>
<tr class="separator:af5f81113b89cbe368312906d2ea05455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8463908634b0318bee5971d05f00386"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:ac8463908634b0318bee5971d05f00386"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ac8463908634b0318bee5971d05f00386">enable_if_primitive_ctype</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#af5f81113b89cbe368312906d2ea05455">is_primitive_ctype</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:ac8463908634b0318bee5971d05f00386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d618f8e1fb33c3f4ecc90094dc9eec9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d618f8e1fb33c3f4ecc90094dc9eec9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a1d618f8e1fb33c3f4ecc90094dc9eec9">has_c_type</a> = std::integral_constant&lt; bool, <a class="el" href="namespacearrow.html#af5f81113b89cbe368312906d2ea05455">is_primitive_ctype</a>&lt; T &gt;::value||<a class="el" href="namespacearrow.html#ad747b7b43421fb8bcb9e41e2b9ccc5e7">is_temporal_type</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:a1d618f8e1fb33c3f4ecc90094dc9eec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e090acba4674b10ca16691401701bd6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a7e090acba4674b10ca16691401701bd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7e090acba4674b10ca16691401701bd6">enable_if_has_c_type</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a1d618f8e1fb33c3f4ecc90094dc9eec9">has_c_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a7e090acba4674b10ca16691401701bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4444a0309da790a63c0856fb90e635b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4444a0309da790a63c0856fb90e635b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a4444a0309da790a63c0856fb90e635b7">has_string_view</a> = std::integral_constant&lt; bool, <a class="el" href="namespacearrow.html#a31da5300521aeadb8c39244e672aad20">is_binary_like_type</a>&lt; T &gt;::value||<a class="el" href="namespacearrow.html#a45709f39fa2d7508b0068c6e493acc5b">is_string_like_type</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:a4444a0309da790a63c0856fb90e635b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94667b305c94aaad1ed7c2b667a24fad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a94667b305c94aaad1ed7c2b667a24fad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a94667b305c94aaad1ed7c2b667a24fad">enable_if_has_string_view</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a4444a0309da790a63c0856fb90e635b7">has_string_view</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a94667b305c94aaad1ed7c2b667a24fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775977292719f9e7ace109475c3d497b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a775977292719f9e7ace109475c3d497b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a775977292719f9e7ace109475c3d497b">is_8bit_int</a> = std::integral_constant&lt; bool, std::is_same&lt; <a class="el" href="classarrow_1_1_u_int8_type.html">UInt8Type</a>, T &gt;::value||std::is_same&lt; <a class="el" href="classarrow_1_1_int8_type.html">Int8Type</a>, T &gt;::value &gt;</td></tr>
<tr class="separator:a775977292719f9e7ace109475c3d497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28ec25ca257b62697c39d4bf10cab62"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:ac28ec25ca257b62697c39d4bf10cab62"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ac28ec25ca257b62697c39d4bf10cab62">enable_if_8bit_int</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a775977292719f9e7ace109475c3d497b">is_8bit_int</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:ac28ec25ca257b62697c39d4bf10cab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3a809d6228febd9b9cd5257de92971"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e3a809d6228febd9b9cd5257de92971"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a0e3a809d6228febd9b9cd5257de92971">is_paramater_free_type</a> = std::integral_constant&lt; bool, <a class="el" href="structarrow_1_1_type_traits.html">TypeTraits</a>&lt; T &gt;::is_parameter_free &gt;</td></tr>
<tr class="separator:a0e3a809d6228febd9b9cd5257de92971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7d9fa36c6e17e9653179705ab1f49d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a6c7d9fa36c6e17e9653179705ab1f49d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a6c7d9fa36c6e17e9653179705ab1f49d">enable_if_parameter_free</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a0e3a809d6228febd9b9cd5257de92971">is_paramater_free_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a6c7d9fa36c6e17e9653179705ab1f49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e9f94af3f7a0c4ed946c23c731e453"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51e9f94af3f7a0c4ed946c23c731e453"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a51e9f94af3f7a0c4ed946c23c731e453">is_physical_signed_integer_type</a> = std::integral_constant&lt; bool, <a class="el" href="namespacearrow.html#a20dd2b914ad4a61e400eb59894d23a70">is_signed_integer_type</a>&lt; T &gt;::value||(<a class="el" href="namespacearrow.html#ad747b7b43421fb8bcb9e41e2b9ccc5e7">is_temporal_type</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="namespacearrow.html#a1d618f8e1fb33c3f4ecc90094dc9eec9">has_c_type</a>&lt; T &gt;::value)&gt;</td></tr>
<tr class="separator:a51e9f94af3f7a0c4ed946c23c731e453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec365fc8dcb7c75493dae0eef4871118"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:aec365fc8dcb7c75493dae0eef4871118"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aec365fc8dcb7c75493dae0eef4871118">enable_if_physical_signed_integer</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a51e9f94af3f7a0c4ed946c23c731e453">is_physical_signed_integer_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:aec365fc8dcb7c75493dae0eef4871118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c99ff90cd175919ff6aabcb854287d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c99ff90cd175919ff6aabcb854287d0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a6c99ff90cd175919ff6aabcb854287d0">is_physical_unsigned_integer_type</a> = std::integral_constant&lt; bool, <a class="el" href="namespacearrow.html#afbff722ac55605b6945c47d8a99feb53">is_unsigned_integer_type</a>&lt; T &gt;::value||<a class="el" href="namespacearrow.html#af8b7471bd6e7d3ae3f2a996cca113ac5">is_half_float_type</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:a6c99ff90cd175919ff6aabcb854287d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1f2397f5492a98c6a9aaf17c5afe84"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a8e1f2397f5492a98c6a9aaf17c5afe84"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a8e1f2397f5492a98c6a9aaf17c5afe84">enable_if_physical_unsigned_integer</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a6c99ff90cd175919ff6aabcb854287d0">is_physical_unsigned_integer_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a8e1f2397f5492a98c6a9aaf17c5afe84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bec5260c0be3e093d9bfc1bfc4249cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bec5260c0be3e093d9bfc1bfc4249cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a9bec5260c0be3e093d9bfc1bfc4249cb">is_physical_floating_type</a> = std::integral_constant&lt; bool, <a class="el" href="namespacearrow.html#ab39920d433ba89ea20da9e9ff52ba0de">is_floating_type</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="namespacearrow.html#af8b7471bd6e7d3ae3f2a996cca113ac5">is_half_float_type</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:a9bec5260c0be3e093d9bfc1bfc4249cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d501b2058862ff8b769dfbf48ba4cd6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a6d501b2058862ff8b769dfbf48ba4cd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a6d501b2058862ff8b769dfbf48ba4cd6">enable_if_physical_floating_point</a> = <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; <a class="el" href="namespacearrow.html#a9bec5260c0be3e093d9bfc1bfc4249cb">is_physical_floating_type</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:a6d501b2058862ff8b769dfbf48ba4cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a331ad1dbd1c157c8be168cb6548d188f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188f">StatusCode</a> : char { <br />
&#160;&#160;<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fae0aa021e21dddbd6d8cecec71e9cf564">StatusCode::OK</a> = 0, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fab498327feeb51430af73e07deac268fd">StatusCode::OutOfMemory</a> = 1, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fac84999914a408f8c02b4122a49df6e00">StatusCode::KeyError</a> = 2, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa137bf8cff2d59f0883c600f9524b3eed">StatusCode::TypeError</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa4bbb8f967da6d1a610596d7257179c2b">StatusCode::Invalid</a> = 4, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa5206bd7472156351d2d9a99633ac9580">StatusCode::IOError</a> = 5, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa65f55acee27ef038c04505e05dbf6c35">StatusCode::CapacityError</a> = 6, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188faeb6ff05a2e9b0485ea84cbe3809e36ed">StatusCode::IndexError</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fabfaef30f1c8011c5cefa38ae470fb7aa">StatusCode::UnknownError</a> = 9, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa997ca4ce119685f40f03a9a8a6c5346e">StatusCode::NotImplemented</a> = 10, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa64353c9071b50ec2fe6b90ed122471a8">StatusCode::SerializationError</a> = 11, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa92f049e5e1d59cc2f960d1974c50e072">StatusCode::RError</a> = 13, 
<br />
&#160;&#160;<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa8a938435e76704025c8ab2b7f7a7ca52">StatusCode::CodeGenError</a> = 40, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa70b5374da923fd3b982ac38c1fd20bc3">StatusCode::ExpressionValidationError</a> = 41, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa6e129f00c2572c6d267cf433bc9ad99e">StatusCode::ExecutionError</a> = 42, 
<a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188fa89b69484680b18e9179e826c6e023805">StatusCode::AlreadyExists</a> = 45
<br />
 }</td></tr>
<tr class="separator:a331ad1dbd1c157c8be168cb6548d188f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04410292f01b108a8a8af3c7077afcda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a04410292f01b108a8a8af3c7077afcda">DateUnit</a> : char { <a class="el" href="namespacearrow.html#a04410292f01b108a8a8af3c7077afcdaa5b1d59b5451c06afb65ab1bc2713cfb4">DateUnit::DAY</a> = 0, 
<a class="el" href="namespacearrow.html#a04410292f01b108a8a8af3c7077afcdaa8f06f9f0a1efa42a2ad3ec880b0a1f70">DateUnit::MILLI</a> = 1
 }</td></tr>
<tr class="separator:a04410292f01b108a8a8af3c7077afcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a966e51cab768580c6f9a9427f34d2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a57a966e51cab768580c6f9a9427f34d2">DecimalStatus</a> { <a class="el" href="namespacearrow.html#a57a966e51cab768580c6f9a9427f34d2a8c632159fa131f09d04f94e3cbcd8782">DecimalStatus::kSuccess</a>, 
<a class="el" href="namespacearrow.html#a57a966e51cab768580c6f9a9427f34d2a41ef173591458a0b06e7f793fb7ed46c">DecimalStatus::kDivideByZero</a>, 
<a class="el" href="namespacearrow.html#a57a966e51cab768580c6f9a9427f34d2aae5484a6f25ec42ff2fc33b0fc8bc2d5">DecimalStatus::kOverflow</a>, 
<a class="el" href="namespacearrow.html#a57a966e51cab768580c6f9a9427f34d2ac1d48c17e57675d19e1fdb51b625e8c3">DecimalStatus::kRescaleDataLoss</a>
 }</td></tr>
<tr class="separator:a57a966e51cab768580c6f9a9427f34d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a832b1cd8b78ca5af346b5ff1bc0d8df5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a832b1cd8b78ca5af346b5ff1bc0d8df5">Concatenate</a> (const <a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a> &amp;arrays, <a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *out)</td></tr>
<tr class="memdesc:a832b1cd8b78ca5af346b5ff1bc0d8df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate arrays.  <a href="namespacearrow.html#a832b1cd8b78ca5af346b5ff1bc0d8df5">More...</a><br /></td></tr>
<tr class="separator:a832b1cd8b78ca5af346b5ff1bc0d8df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d16f62627582ce40fcb90f88471c67e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_struct_array.html">StructArray</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a0d16f62627582ce40fcb90f88471c67e">Diff</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;base, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;target, <a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool)</td></tr>
<tr class="memdesc:a0d16f62627582ce40fcb90f88471c67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two arrays, returning an edit script which expresses the difference between them.  <a href="namespacearrow.html#a0d16f62627582ce40fcb90f88471c67e">More...</a><br /></td></tr>
<tr class="separator:a0d16f62627582ce40fcb90f88471c67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00d7d4fc1efa5afee3a1a0b228f7817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ac00d7d4fc1efa5afee3a1a0b228f7817">VisitEditScript</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;edits, const std::function&lt; <a class="el" href="classarrow_1_1_status.html">Status</a>(int64_t delete_begin, int64_t delete_end, int64_t insert_begin, int64_t insert_end)&gt; &amp;visitor)</td></tr>
<tr class="memdesc:ac00d7d4fc1efa5afee3a1a0b228f7817"><td class="mdescLeft">&#160;</td><td class="mdescRight">visitor interface for easy traversal of an edit script  <a href="namespacearrow.html#ac00d7d4fc1efa5afee3a1a0b228f7817">More...</a><br /></td></tr>
<tr class="separator:ac00d7d4fc1efa5afee3a1a0b228f7817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edcc7f88dec3ddcfcd8ccf1882cb833"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7edcc7f88dec3ddcfcd8ccf1882cb833">MakeArray</a> (const std::shared_ptr&lt; <a class="el" href="structarrow_1_1_array_data.html">ArrayData</a> &gt; &amp;data)</td></tr>
<tr class="memdesc:a7edcc7f88dec3ddcfcd8ccf1882cb833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a strongly-typed <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance from generic <a class="el" href="structarrow_1_1_array_data.html" title="Mutable container for generic Arrow array data.">ArrayData</a>.  <a href="namespacearrow.html#a7edcc7f88dec3ddcfcd8ccf1882cb833">More...</a><br /></td></tr>
<tr class="separator:a7edcc7f88dec3ddcfcd8ccf1882cb833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215f8e56eb8f3c0c6ce42f6bd2456f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a215f8e56eb8f3c0c6ce42f6bd2456f29">MakeArrayOfNull</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;type, int64_t length, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *out)</td></tr>
<tr class="memdesc:a215f8e56eb8f3c0c6ce42f6bd2456f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a strongly-typed <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance with all elements null.  <a href="namespacearrow.html#a215f8e56eb8f3c0c6ce42f6bd2456f29">More...</a><br /></td></tr>
<tr class="separator:a215f8e56eb8f3c0c6ce42f6bd2456f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca90ffe324b4b915c0bfa4a048f73952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aca90ffe324b4b915c0bfa4a048f73952">MakeArrayOfNull</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;type, int64_t length, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *out)</td></tr>
<tr class="memdesc:aca90ffe324b4b915c0bfa4a048f73952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a strongly-typed <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance with all elements null.  <a href="namespacearrow.html#aca90ffe324b4b915c0bfa4a048f73952">More...</a><br /></td></tr>
<tr class="separator:aca90ffe324b4b915c0bfa4a048f73952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4593951e6af46e335bd41121192e6c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#af4593951e6af46e335bd41121192e6c4">MakeArrayFromScalar</a> (const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;scalar, int64_t length, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *out)</td></tr>
<tr class="memdesc:af4593951e6af46e335bd41121192e6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance whose slots are the given scalar.  <a href="namespacearrow.html#af4593951e6af46e335bd41121192e6c4">More...</a><br /></td></tr>
<tr class="separator:af4593951e6af46e335bd41121192e6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bc3e67510177ec60c965a2e59d310a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ae5bc3e67510177ec60c965a2e59d310a">MakeArrayFromScalar</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;scalar, int64_t length, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *out)</td></tr>
<tr class="memdesc:ae5bc3e67510177ec60c965a2e59d310a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a strongly-typed <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance with all elements null.  <a href="namespacearrow.html#ae5bc3e67510177ec60c965a2e59d310a">More...</a><br /></td></tr>
<tr class="separator:ae5bc3e67510177ec60c965a2e59d310a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c8f98a2874248eb7d5658ccee5718e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-slicing-functions.html#ga44c8f98a2874248eb7d5658ccee5718e">SliceMutableBuffer</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; &amp;buffer, const int64_t offset, const int64_t length)</td></tr>
<tr class="memdesc:ga44c8f98a2874248eb7d5658ccee5718e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like SliceBuffer, but construct a mutable buffer slice.  <a href="group__buffer-slicing-functions.html#ga44c8f98a2874248eb7d5658ccee5718e">More...</a><br /></td></tr>
<tr class="separator:ga44c8f98a2874248eb7d5658ccee5718e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff11ee23eb038410107ea5246f2fb330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#gaff11ee23eb038410107ea5246f2fb330">AllocateBuffer</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, const int64_t size, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; *out)</td></tr>
<tr class="memdesc:gaff11ee23eb038410107ea5246f2fb330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a fixed size mutable buffer from a memory pool, zero its padding.  <a href="group__buffer-allocation-functions.html#gaff11ee23eb038410107ea5246f2fb330">More...</a><br /></td></tr>
<tr class="separator:gaff11ee23eb038410107ea5246f2fb330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9698aacbd4ac435cc0cb676e2cb1fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#gad9698aacbd4ac435cc0cb676e2cb1fe0">AllocateBuffer</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, const int64_t size, std::unique_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; *out)</td></tr>
<tr class="memdesc:gad9698aacbd4ac435cc0cb676e2cb1fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a fixed size mutable buffer from a memory pool, zero its padding.  <a href="group__buffer-allocation-functions.html#gad9698aacbd4ac435cc0cb676e2cb1fe0">More...</a><br /></td></tr>
<tr class="separator:gad9698aacbd4ac435cc0cb676e2cb1fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d3ff86145cc77724a56967ea8a3f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#gae4d3ff86145cc77724a56967ea8a3f5f">AllocateBuffer</a> (const int64_t size, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; *out)</td></tr>
<tr class="memdesc:gae4d3ff86145cc77724a56967ea8a3f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a fixed-size mutable buffer from the default memory pool.  <a href="group__buffer-allocation-functions.html#gae4d3ff86145cc77724a56967ea8a3f5f">More...</a><br /></td></tr>
<tr class="separator:gae4d3ff86145cc77724a56967ea8a3f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f0e830cd9d1892b243dda5cc66429a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#ga06f0e830cd9d1892b243dda5cc66429a">AllocateBuffer</a> (const int64_t size, std::unique_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; *out)</td></tr>
<tr class="memdesc:ga06f0e830cd9d1892b243dda5cc66429a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a fixed-size mutable buffer from the default memory pool.  <a href="group__buffer-allocation-functions.html#ga06f0e830cd9d1892b243dda5cc66429a">More...</a><br /></td></tr>
<tr class="separator:ga06f0e830cd9d1892b243dda5cc66429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3ce000978a518fad942be4a54e9870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#ga9c3ce000978a518fad942be4a54e9870">AllocateResizableBuffer</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, const int64_t size, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_resizable_buffer.html">ResizableBuffer</a> &gt; *out)</td></tr>
<tr class="memdesc:ga9c3ce000978a518fad942be4a54e9870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a resizeable buffer from a memory pool, zero its padding.  <a href="group__buffer-allocation-functions.html#ga9c3ce000978a518fad942be4a54e9870">More...</a><br /></td></tr>
<tr class="separator:ga9c3ce000978a518fad942be4a54e9870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fdac7fee8638d46c79b8136aa38c956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#ga2fdac7fee8638d46c79b8136aa38c956">AllocateResizableBuffer</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, const int64_t size, std::unique_ptr&lt; <a class="el" href="classarrow_1_1_resizable_buffer.html">ResizableBuffer</a> &gt; *out)</td></tr>
<tr class="memdesc:ga2fdac7fee8638d46c79b8136aa38c956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a resizeable buffer from a memory pool, zero its padding.  <a href="group__buffer-allocation-functions.html#ga2fdac7fee8638d46c79b8136aa38c956">More...</a><br /></td></tr>
<tr class="separator:ga2fdac7fee8638d46c79b8136aa38c956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80acc74f413afe7f8ed46cde85a5a80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#gaa80acc74f413afe7f8ed46cde85a5a80">AllocateResizableBuffer</a> (const int64_t size, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_resizable_buffer.html">ResizableBuffer</a> &gt; *out)</td></tr>
<tr class="memdesc:gaa80acc74f413afe7f8ed46cde85a5a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a resizeable buffer from the default memory pool.  <a href="group__buffer-allocation-functions.html#gaa80acc74f413afe7f8ed46cde85a5a80">More...</a><br /></td></tr>
<tr class="separator:gaa80acc74f413afe7f8ed46cde85a5a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eb313aa6e6d83310dcc2a951875b9d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#ga6eb313aa6e6d83310dcc2a951875b9d2">AllocateResizableBuffer</a> (const int64_t size, std::unique_ptr&lt; <a class="el" href="classarrow_1_1_resizable_buffer.html">ResizableBuffer</a> &gt; *out)</td></tr>
<tr class="memdesc:ga6eb313aa6e6d83310dcc2a951875b9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a resizeable buffer from the default memory pool.  <a href="group__buffer-allocation-functions.html#ga6eb313aa6e6d83310dcc2a951875b9d2">More...</a><br /></td></tr>
<tr class="separator:ga6eb313aa6e6d83310dcc2a951875b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c20471c43a7a35eaabf2506d5b533e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#ga93c20471c43a7a35eaabf2506d5b533e">AllocateBitmap</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, int64_t length, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; *out)</td></tr>
<tr class="memdesc:ga93c20471c43a7a35eaabf2506d5b533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a bitmap buffer from a memory pool no guarantee on values is provided.  <a href="group__buffer-allocation-functions.html#ga93c20471c43a7a35eaabf2506d5b533e">More...</a><br /></td></tr>
<tr class="separator:ga93c20471c43a7a35eaabf2506d5b533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79907066edd38d36e95c56673aa46a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#ga79907066edd38d36e95c56673aa46a3b">AllocateEmptyBitmap</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, int64_t length, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; *out)</td></tr>
<tr class="memdesc:ga79907066edd38d36e95c56673aa46a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a zero-initialized bitmap buffer from a memory pool.  <a href="group__buffer-allocation-functions.html#ga79907066edd38d36e95c56673aa46a3b">More...</a><br /></td></tr>
<tr class="separator:ga79907066edd38d36e95c56673aa46a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c62ce65a76507d648998fc260e5ead1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#ga2c62ce65a76507d648998fc260e5ead1">AllocateEmptyBitmap</a> (int64_t length, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; *out)</td></tr>
<tr class="memdesc:ga2c62ce65a76507d648998fc260e5ead1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a zero-initialized bitmap buffer from the default memory pool.  <a href="group__buffer-allocation-functions.html#ga2c62ce65a76507d648998fc260e5ead1">More...</a><br /></td></tr>
<tr class="separator:ga2c62ce65a76507d648998fc260e5ead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga193a7618d4456e8d4f40d305c8d683f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer-allocation-functions.html#ga193a7618d4456e8d4f40d305c8d683f1">ConcatenateBuffers</a> (const <a class="el" href="namespacearrow.html#a26e0360de3fc4b7120b6b50f14a22786">BufferVector</a> &amp;buffers, <a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_buffer.html">Buffer</a> &gt; *out)</td></tr>
<tr class="memdesc:ga193a7618d4456e8d4f40d305c8d683f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate multiple buffers into a single buffer.  <a href="group__buffer-allocation-functions.html#ga193a7618d4456e8d4f40d305c8d683f1">More...</a><br /></td></tr>
<tr class="separator:ga193a7618d4456e8d4f40d305c8d683f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08900491dab187842698af9cca156b17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a08900491dab187842698af9cca156b17">MakeBuilder</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;type, std::unique_ptr&lt; <a class="el" href="classarrow_1_1_array_builder.html">ArrayBuilder</a> &gt; *out)</td></tr>
<tr class="memdesc:a08900491dab187842698af9cca156b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="classarrow_1_1_array_builder.html" title="Base class for all data array builders.">ArrayBuilder</a> corresponding to the data type.  <a href="namespacearrow.html#a08900491dab187842698af9cca156b17">More...</a><br /></td></tr>
<tr class="separator:a08900491dab187842698af9cca156b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f56be53f725a2959311b30c314f94fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a5f56be53f725a2959311b30c314f94fb">MakeDictionaryBuilder</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;type, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; &amp;<a class="el" href="group__type-factories.html#ga36f61c68b2a04a9d179cb56ff1186c59">dictionary</a>, std::unique_ptr&lt; <a class="el" href="classarrow_1_1_array_builder.html">ArrayBuilder</a> &gt; *out)</td></tr>
<tr class="memdesc:a5f56be53f725a2959311b30c314f94fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="classarrow_1_1_dictionary_builder.html" title="A DictionaryArray builder that uses AdaptiveIntBuilder to return the smallest index size that can acc...">DictionaryBuilder</a> initialized optionally with a pre-existing dictionary.  <a href="namespacearrow.html#a5f56be53f725a2959311b30c314f94fb">More...</a><br /></td></tr>
<tr class="separator:a5f56be53f725a2959311b30c314f94fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ecf91f56f47a6d73b95e09d05b4de9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aa2ecf91f56f47a6d73b95e09d05b4de9">ArrayEquals</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;left, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;right, const <a class="el" href="classarrow_1_1_equal_options.html">EqualOptions</a> &amp;=<a class="el" href="classarrow_1_1_equal_options.html#aceb7c9984ead6d5a79ba4a725193d452">EqualOptions::Defaults</a>())</td></tr>
<tr class="memdesc:aa2ecf91f56f47a6d73b95e09d05b4de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the arrays are exactly equal.  <a href="namespacearrow.html#aa2ecf91f56f47a6d73b95e09d05b4de9">More...</a><br /></td></tr>
<tr class="separator:aa2ecf91f56f47a6d73b95e09d05b4de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0127366929daceea11e1143498477446"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a0127366929daceea11e1143498477446">TensorEquals</a> (const <a class="el" href="classarrow_1_1_tensor.html">Tensor</a> &amp;left, const <a class="el" href="classarrow_1_1_tensor.html">Tensor</a> &amp;right, const <a class="el" href="classarrow_1_1_equal_options.html">EqualOptions</a> &amp;=<a class="el" href="classarrow_1_1_equal_options.html#aceb7c9984ead6d5a79ba4a725193d452">EqualOptions::Defaults</a>())</td></tr>
<tr class="separator:a0127366929daceea11e1143498477446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b3683df6eb152e214ab74b9861cc0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a68b3683df6eb152e214ab74b9861cc0f">SparseTensorEquals</a> (const <a class="el" href="classarrow_1_1_sparse_tensor.html">SparseTensor</a> &amp;left, const <a class="el" href="classarrow_1_1_sparse_tensor.html">SparseTensor</a> &amp;right)</td></tr>
<tr class="memdesc:a68b3683df6eb152e214ab74b9861cc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: Returns true if the given sparse tensors are exactly equal.  <a href="namespacearrow.html#a68b3683df6eb152e214ab74b9861cc0f">More...</a><br /></td></tr>
<tr class="separator:a68b3683df6eb152e214ab74b9861cc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d896fc0a4a06fa37f6da05a1a0da44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a73d896fc0a4a06fa37f6da05a1a0da44">ArrayApproxEquals</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;left, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;right, const <a class="el" href="classarrow_1_1_equal_options.html">EqualOptions</a> &amp;=<a class="el" href="classarrow_1_1_equal_options.html#aceb7c9984ead6d5a79ba4a725193d452">EqualOptions::Defaults</a>())</td></tr>
<tr class="memdesc:a73d896fc0a4a06fa37f6da05a1a0da44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the arrays are approximately equal.  <a href="namespacearrow.html#a73d896fc0a4a06fa37f6da05a1a0da44">More...</a><br /></td></tr>
<tr class="separator:a73d896fc0a4a06fa37f6da05a1a0da44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4576fdd48ce9e8484b30e3b94fd00d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a1d4576fdd48ce9e8484b30e3b94fd00d">ArrayRangeEquals</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;left, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;right, int64_t start_idx, int64_t end_idx, int64_t other_start_idx)</td></tr>
<tr class="memdesc:a1d4576fdd48ce9e8484b30e3b94fd00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if indicated equal-length segment of arrays is exactly equal.  <a href="namespacearrow.html#a1d4576fdd48ce9e8484b30e3b94fd00d">More...</a><br /></td></tr>
<tr class="separator:a1d4576fdd48ce9e8484b30e3b94fd00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234135e3a4408f77e2bbf4719f040ee9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a234135e3a4408f77e2bbf4719f040ee9">TypeEquals</a> (const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;left, const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;right, bool check_metadata=true)</td></tr>
<tr class="memdesc:a234135e3a4408f77e2bbf4719f040ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the type metadata are exactly equal.  <a href="namespacearrow.html#a234135e3a4408f77e2bbf4719f040ee9">More...</a><br /></td></tr>
<tr class="separator:a234135e3a4408f77e2bbf4719f040ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e9a5cf615bc758d9cdbe7e6da611c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a17e9a5cf615bc758d9cdbe7e6da611c8">ScalarEquals</a> (const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;left, const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;right)</td></tr>
<tr class="memdesc:a17e9a5cf615bc758d9cdbe7e6da611c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if scalars are equal.  <a href="namespacearrow.html#a17e9a5cf615bc758d9cdbe7e6da611c8">More...</a><br /></td></tr>
<tr class="separator:a17e9a5cf615bc758d9cdbe7e6da611c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac71528443df3a53855482472db00f9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aac71528443df3a53855482472db00f9d">RegisterExtensionType</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1_extension_type.html">ExtensionType</a> &gt; type)</td></tr>
<tr class="memdesc:aac71528443df3a53855482472db00f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an extension type globally.  <a href="namespacearrow.html#aac71528443df3a53855482472db00f9d">More...</a><br /></td></tr>
<tr class="separator:aac71528443df3a53855482472db00f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab162fa7ed427af976c48637d541325be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ab162fa7ed427af976c48637d541325be">UnregisterExtensionType</a> (const std::string &amp;type_name)</td></tr>
<tr class="memdesc:ab162fa7ed427af976c48637d541325be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an extension type from the global registry.  <a href="namespacearrow.html#ab162fa7ed427af976c48637d541325be">More...</a><br /></td></tr>
<tr class="separator:ab162fa7ed427af976c48637d541325be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb2b23cadfc295fdafbddb144f695ca"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_extension_type.html">ExtensionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a2fb2b23cadfc295fdafbddb144f695ca">GetExtensionType</a> (const std::string &amp;type_name)</td></tr>
<tr class="memdesc:a2fb2b23cadfc295fdafbddb144f695ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an extension type from the global registry.  <a href="namespacearrow.html#a2fb2b23cadfc295fdafbddb144f695ca">More...</a><br /></td></tr>
<tr class="separator:a2fb2b23cadfc295fdafbddb144f695ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2dcf4f3003c334c3a337d65657e4c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aab2dcf4f3003c334c3a337d65657e4c5">system_memory_pool</a> ()</td></tr>
<tr class="memdesc:aab2dcf4f3003c334c3a337d65657e4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a process-wide memory pool based on the system allocator.  <a href="namespacearrow.html#aab2dcf4f3003c334c3a337d65657e4c5">More...</a><br /></td></tr>
<tr class="separator:aab2dcf4f3003c334c3a337d65657e4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e44d557d9f98ba7a42bbcba1fb7698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a07e44d557d9f98ba7a42bbcba1fb7698">jemalloc_memory_pool</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> **out)</td></tr>
<tr class="memdesc:a07e44d557d9f98ba7a42bbcba1fb7698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a process-wide memory pool based on jemalloc.  <a href="namespacearrow.html#a07e44d557d9f98ba7a42bbcba1fb7698">More...</a><br /></td></tr>
<tr class="separator:a07e44d557d9f98ba7a42bbcba1fb7698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ebc0eb6975ac95276758b9a171c82d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ad0ebc0eb6975ac95276758b9a171c82d">jemalloc_set_decay_ms</a> (int ms)</td></tr>
<tr class="memdesc:ad0ebc0eb6975ac95276758b9a171c82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set jemalloc memory page purging behavior for future-created arenas to the indicated number of milliseconds.  <a href="namespacearrow.html#ad0ebc0eb6975ac95276758b9a171c82d">More...</a><br /></td></tr>
<tr class="separator:ad0ebc0eb6975ac95276758b9a171c82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03def88fd1ab05b0df699df9c3b9754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#af03def88fd1ab05b0df699df9c3b9754">mimalloc_memory_pool</a> (<a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> **out)</td></tr>
<tr class="memdesc:af03def88fd1ab05b0df699df9c3b9754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a process-wide memory pool based on mimalloc.  <a href="namespacearrow.html#af03def88fd1ab05b0df699df9c3b9754">More...</a><br /></td></tr>
<tr class="separator:af03def88fd1ab05b0df699df9c3b9754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737bc52e404537e2dbb14e110e78daaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a737bc52e404537e2dbb14e110e78daaa">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &amp;batch, int indent, std::ostream *sink)</td></tr>
<tr class="memdesc:a737bc52e404537e2dbb14e110e78daaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print human-readable representation of <a class="el" href="classarrow_1_1_record_batch.html" title="Collection of equal-length arrays matching a particular Schema.">RecordBatch</a>.  <a href="namespacearrow.html#a737bc52e404537e2dbb14e110e78daaa">More...</a><br /></td></tr>
<tr class="separator:a737bc52e404537e2dbb14e110e78daaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1797b746b75cf6af1b6809b5932b1fe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a1797b746b75cf6af1b6809b5932b1fe8">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &amp;batch, const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;options, std::ostream *sink)</td></tr>
<tr class="separator:a1797b746b75cf6af1b6809b5932b1fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051589b1255ab558754828c44e2dd04b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a051589b1255ab558754828c44e2dd04b">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;table, const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;options, std::ostream *sink)</td></tr>
<tr class="memdesc:a051589b1255ab558754828c44e2dd04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print human-readable representation of <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>.  <a href="namespacearrow.html#a051589b1255ab558754828c44e2dd04b">More...</a><br /></td></tr>
<tr class="separator:a051589b1255ab558754828c44e2dd04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e646aac1cf6c89685b5d161377a236b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a5e646aac1cf6c89685b5d161377a236b">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;arr, int indent, std::ostream *sink)</td></tr>
<tr class="memdesc:a5e646aac1cf6c89685b5d161377a236b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print human-readable representation of <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a>.  <a href="namespacearrow.html#a5e646aac1cf6c89685b5d161377a236b">More...</a><br /></td></tr>
<tr class="separator:a5e646aac1cf6c89685b5d161377a236b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e25f267b13e3a61947a9dfd93b92f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aa1e25f267b13e3a61947a9dfd93b92f3">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;arr, const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;options, std::ostream *sink)</td></tr>
<tr class="memdesc:aa1e25f267b13e3a61947a9dfd93b92f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print human-readable representation of <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a>.  <a href="namespacearrow.html#aa1e25f267b13e3a61947a9dfd93b92f3">More...</a><br /></td></tr>
<tr class="separator:aa1e25f267b13e3a61947a9dfd93b92f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b7f013ed791d08a9e4e3b9ec8a3f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ac6b7f013ed791d08a9e4e3b9ec8a3f54">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;arr, const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;options, std::string *result)</td></tr>
<tr class="memdesc:ac6b7f013ed791d08a9e4e3b9ec8a3f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print human-readable representation of <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a>.  <a href="namespacearrow.html#ac6b7f013ed791d08a9e4e3b9ec8a3f54">More...</a><br /></td></tr>
<tr class="separator:ac6b7f013ed791d08a9e4e3b9ec8a3f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1396ab6f5f1e481bcaf595dd7a6427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aed1396ab6f5f1e481bcaf595dd7a6427">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;chunked_arr, const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;options, std::ostream *sink)</td></tr>
<tr class="memdesc:aed1396ab6f5f1e481bcaf595dd7a6427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print human-readable representation of <a class="el" href="classarrow_1_1_chunked_array.html" title="A data structure managing a list of primitive Arrow arrays logically as one large array.">ChunkedArray</a>.  <a href="namespacearrow.html#aed1396ab6f5f1e481bcaf595dd7a6427">More...</a><br /></td></tr>
<tr class="separator:aed1396ab6f5f1e481bcaf595dd7a6427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac5ddf6d8603e6d0230a2768b42be4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a1ac5ddf6d8603e6d0230a2768b42be4a">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;chunked_arr, const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;options, std::string *result)</td></tr>
<tr class="memdesc:a1ac5ddf6d8603e6d0230a2768b42be4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print human-readable representation of <a class="el" href="classarrow_1_1_chunked_array.html" title="A data structure managing a list of primitive Arrow arrays logically as one large array.">ChunkedArray</a>.  <a href="namespacearrow.html#a1ac5ddf6d8603e6d0230a2768b42be4a">More...</a><br /></td></tr>
<tr class="separator:a1ac5ddf6d8603e6d0230a2768b42be4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9706f4e03928551a9e24db5c205e5521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a9706f4e03928551a9e24db5c205e5521">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_schema.html">Schema</a> &amp;<a class="el" href="group__schema-factories.html#ga97ac72c2a07228577c1d38b7747941a9">schema</a>, const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;options, std::ostream *sink)</td></tr>
<tr class="separator:a9706f4e03928551a9e24db5c205e5521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc6b3a8c2c471161f3b4c6c61e86aad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a4dc6b3a8c2c471161f3b4c6c61e86aad">PrettyPrint</a> (const <a class="el" href="classarrow_1_1_schema.html">Schema</a> &amp;<a class="el" href="group__schema-factories.html#ga97ac72c2a07228577c1d38b7747941a9">schema</a>, const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;options, std::string *result)</td></tr>
<tr class="separator:a4dc6b3a8c2c471161f3b4c6c61e86aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc529837f8c4825ef5ae3ecee7e614d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#acc529837f8c4825ef5ae3ecee7e614d5">DebugPrint</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;arr, int indent)</td></tr>
<tr class="separator:acc529837f8c4825ef5ae3ecee7e614d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7096f428f7abf51444aae487cb689a02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7096f428f7abf51444aae487cb689a02">MakeRecordBatchReader</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;batches, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; <a class="el" href="group__schema-factories.html#ga97ac72c2a07228577c1d38b7747941a9">schema</a>, std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch_reader.html">RecordBatchReader</a> &gt; *out)</td></tr>
<tr class="memdesc:a7096f428f7abf51444aae487cb689a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_record_batch_reader.html" title="Abstract interface for reading stream of record batches.">RecordBatchReader</a> from a vector of <a class="el" href="classarrow_1_1_record_batch.html" title="Collection of equal-length arrays matching a particular Schema.">RecordBatch</a>.  <a href="namespacearrow.html#a7096f428f7abf51444aae487cb689a02">More...</a><br /></td></tr>
<tr class="separator:a7096f428f7abf51444aae487cb689a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7072e41124f0528a0d802cb27315e009"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7072e41124f0528a0d802cb27315e009">MakeNullScalar</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;type)</td></tr>
<tr class="separator:a7072e41124f0528a0d802cb27315e009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cda6feb53b26ea439df86b2a534ea7"><td class="memTemplParams" colspan="2">template&lt;typename Value &gt; </td></tr>
<tr class="memitem:ab2cda6feb53b26ea439df86b2a534ea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ab2cda6feb53b26ea439df86b2a534ea7">MakeScalar</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;type, Value &amp;&amp;value)</td></tr>
<tr class="separator:ab2cda6feb53b26ea439df86b2a534ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d94a22489c2d88b5ece3464f6757b5c"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename Traits  = CTypeTraits&lt;typename std::decay&lt;Value&gt;::type&gt;, typename ScalarType  = typename Traits::ScalarType, typename Enable  = decltype(ScalarType(std::declval&lt;Value&gt;(),                                                Traits::type_singleton()))&gt; </td></tr>
<tr class="memitem:a6d94a22489c2d88b5ece3464f6757b5c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a6d94a22489c2d88b5ece3464f6757b5c">MakeScalar</a> (Value value)</td></tr>
<tr class="memdesc:a6d94a22489c2d88b5ece3464f6757b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">type inferring scalar factory  <a href="namespacearrow.html#a6d94a22489c2d88b5ece3464f6757b5c">More...</a><br /></td></tr>
<tr class="separator:a6d94a22489c2d88b5ece3464f6757b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3bae9d69b7544f4bfe67f6c60ceb1e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ade3bae9d69b7544f4bfe67f6c60ceb1e">MakeScalar</a> (std::string value)</td></tr>
<tr class="separator:ade3bae9d69b7544f4bfe67f6c60ceb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6272e4a6555d62afc43b2845d8616eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga6272e4a6555d62afc43b2845d8616eb7">ConcatenateTables</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt;&gt; &amp;tables, <a class="el" href="structarrow_1_1_concatenate_tables_options.html">ConcatenateTablesOptions</a> options=<a class="el" href="group__concat-tables.html#ga1f99414177f1507f6efa3471cb650bbb">ConcatenateTablesOptions::Defaults</a>(), <a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *memory_pool=<a class="el" href="namespacearrow.html#aebe81d544faaf827b8f32c5a80b99820">default_memory_pool</a>())</td></tr>
<tr class="memdesc:ga6272e4a6555d62afc43b2845d8616eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct table from multiple input tables.  <a href="group__concat-tables.html#ga6272e4a6555d62afc43b2845d8616eb7">More...</a><br /></td></tr>
<tr class="separator:ga6272e4a6555d62afc43b2845d8616eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b46a73d9d5aba02b66257039342c5a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__concat-tables.html#ga4b46a73d9d5aba02b66257039342c5a3">PromoteTableToSchema</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_table.html">Table</a> &gt; &amp;table, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &amp;<a class="el" href="group__schema-factories.html#ga97ac72c2a07228577c1d38b7747941a9">schema</a>, <a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *pool=<a class="el" href="namespacearrow.html#aebe81d544faaf827b8f32c5a80b99820">default_memory_pool</a>())</td></tr>
<tr class="memdesc:ga4b46a73d9d5aba02b66257039342c5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a table to conform to the given schema.  <a href="group__concat-tables.html#ga4b46a73d9d5aba02b66257039342c5a3">More...</a><br /></td></tr>
<tr class="separator:ga4b46a73d9d5aba02b66257039342c5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5709505547e744fa9cf7ddb09b1c2984"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a5709505547e744fa9cf7ddb09b1c2984">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;type)</td></tr>
<tr class="separator:a5709505547e744fa9cf7ddb09b1c2984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0877817f90cecf7a3b19a199b7195e2d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a0877817f90cecf7a3b19a199b7195e2d">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structarrow_1_1_time_unit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit)</td></tr>
<tr class="separator:a0877817f90cecf7a3b19a199b7195e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaf5c20d8caef81e01621a3cad7cc9c2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gacaf5c20d8caef81e01621a3cad7cc9c2">fixed_size_binary</a> (int32_t byte_width)</td></tr>
<tr class="memdesc:gacaf5c20d8caef81e01621a3cad7cc9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_fixed_size_binary_type.html" title="Concrete type class for fixed-size binary data.">FixedSizeBinaryType</a> instance.  <a href="group__type-factories.html#gacaf5c20d8caef81e01621a3cad7cc9c2">More...</a><br /></td></tr>
<tr class="separator:gacaf5c20d8caef81e01621a3cad7cc9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3390964f23814ab08c9604158f727883"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga3390964f23814ab08c9604158f727883">decimal</a> (int32_t precision, int32_t scale)</td></tr>
<tr class="memdesc:ga3390964f23814ab08c9604158f727883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_decimal128_type.html" title="Concrete type class for 128-bit decimal data.">Decimal128Type</a> instance.  <a href="group__type-factories.html#ga3390964f23814ab08c9604158f727883">More...</a><br /></td></tr>
<tr class="separator:ga3390964f23814ab08c9604158f727883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e7157554937088556275ed4b6485d3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga20e7157554937088556275ed4b6485d3">list</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt; &amp;value_type)</td></tr>
<tr class="memdesc:ga20e7157554937088556275ed4b6485d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_list_type.html" title="Concrete type class for list data.">ListType</a> instance from its child <a class="el" href="classarrow_1_1_field.html" title="The combination of a field name and data type, with optional metadata.">Field</a> type.  <a href="group__type-factories.html#ga20e7157554937088556275ed4b6485d3">More...</a><br /></td></tr>
<tr class="separator:ga20e7157554937088556275ed4b6485d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf7acea41aa557cf249bc91b50c8044"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga1bf7acea41aa557cf249bc91b50c8044">list</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;value_type)</td></tr>
<tr class="memdesc:ga1bf7acea41aa557cf249bc91b50c8044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_list_type.html" title="Concrete type class for list data.">ListType</a> instance from its child <a class="el" href="classarrow_1_1_data_type.html" title="Base class for all data types.">DataType</a>.  <a href="group__type-factories.html#ga1bf7acea41aa557cf249bc91b50c8044">More...</a><br /></td></tr>
<tr class="separator:ga1bf7acea41aa557cf249bc91b50c8044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14066c45deb0167842e3e7bd7c545ec0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga14066c45deb0167842e3e7bd7c545ec0">large_list</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt; &amp;value_type)</td></tr>
<tr class="memdesc:ga14066c45deb0167842e3e7bd7c545ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_large_list_type.html" title="Concrete type class for large list data.">LargeListType</a> instance from its child <a class="el" href="classarrow_1_1_field.html" title="The combination of a field name and data type, with optional metadata.">Field</a> type.  <a href="group__type-factories.html#ga14066c45deb0167842e3e7bd7c545ec0">More...</a><br /></td></tr>
<tr class="separator:ga14066c45deb0167842e3e7bd7c545ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37378b9cb539ee9284c44e2efaafff8f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga37378b9cb539ee9284c44e2efaafff8f">large_list</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;value_type)</td></tr>
<tr class="memdesc:ga37378b9cb539ee9284c44e2efaafff8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_large_list_type.html" title="Concrete type class for large list data.">LargeListType</a> instance from its child <a class="el" href="classarrow_1_1_data_type.html" title="Base class for all data types.">DataType</a>.  <a href="group__type-factories.html#ga37378b9cb539ee9284c44e2efaafff8f">More...</a><br /></td></tr>
<tr class="separator:ga37378b9cb539ee9284c44e2efaafff8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464d9a4f0c307d935593d4aa4ff44846"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga464d9a4f0c307d935593d4aa4ff44846">map</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;key_type, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;value_type, bool keys_sorted=false)</td></tr>
<tr class="memdesc:ga464d9a4f0c307d935593d4aa4ff44846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_map_type.html" title="Concrete type class for map data.">MapType</a> instance from its key and value DataTypes.  <a href="group__type-factories.html#ga464d9a4f0c307d935593d4aa4ff44846">More...</a><br /></td></tr>
<tr class="separator:ga464d9a4f0c307d935593d4aa4ff44846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5bb35da3242368660a754a0d47e518b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gad5bb35da3242368660a754a0d47e518b">fixed_size_list</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt; &amp;value_type, int32_t list_size)</td></tr>
<tr class="memdesc:gad5bb35da3242368660a754a0d47e518b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_fixed_size_list_type.html" title="Concrete type class for fixed size list data.">FixedSizeListType</a> instance from its child <a class="el" href="classarrow_1_1_field.html" title="The combination of a field name and data type, with optional metadata.">Field</a> type.  <a href="group__type-factories.html#gad5bb35da3242368660a754a0d47e518b">More...</a><br /></td></tr>
<tr class="separator:gad5bb35da3242368660a754a0d47e518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09fb55b2d07e324f1560a8eeb142e2ed"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga09fb55b2d07e324f1560a8eeb142e2ed">fixed_size_list</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;value_type, int32_t list_size)</td></tr>
<tr class="memdesc:ga09fb55b2d07e324f1560a8eeb142e2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_fixed_size_list_type.html" title="Concrete type class for fixed size list data.">FixedSizeListType</a> instance from its child <a class="el" href="classarrow_1_1_data_type.html" title="Base class for all data types.">DataType</a>.  <a href="group__type-factories.html#ga09fb55b2d07e324f1560a8eeb142e2ed">More...</a><br /></td></tr>
<tr class="separator:ga09fb55b2d07e324f1560a8eeb142e2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a09df951503764895e56db3fe5d053c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga4a09df951503764895e56db3fe5d053c">duration</a> (<a class="el" href="structarrow_1_1_time_unit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit)</td></tr>
<tr class="memdesc:ga4a09df951503764895e56db3fe5d053c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Duration instance (naming use _type to avoid namespace conflict with built in time clases).  <a href="group__type-factories.html#ga4a09df951503764895e56db3fe5d053c">More...</a><br /></td></tr>
<tr class="separator:ga4a09df951503764895e56db3fe5d053c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81643b6c32e9c11375084c074567cba0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga81643b6c32e9c11375084c074567cba0">day_time_interval</a> ()</td></tr>
<tr class="memdesc:ga81643b6c32e9c11375084c074567cba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_day_time_interval_type.html" title="Represents a number of days and milliseconds (fraction of day).">DayTimeIntervalType</a> instance.  <a href="group__type-factories.html#ga81643b6c32e9c11375084c074567cba0">More...</a><br /></td></tr>
<tr class="separator:ga81643b6c32e9c11375084c074567cba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c6cebcb8e66ada1ea7bbfe5d4c8978"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gaf3c6cebcb8e66ada1ea7bbfe5d4c8978">month_interval</a> ()</td></tr>
<tr class="memdesc:gaf3c6cebcb8e66ada1ea7bbfe5d4c8978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_month_interval_type.html" title="Represents a some number of months.">MonthIntervalType</a> instance.  <a href="group__type-factories.html#gaf3c6cebcb8e66ada1ea7bbfe5d4c8978">More...</a><br /></td></tr>
<tr class="separator:gaf3c6cebcb8e66ada1ea7bbfe5d4c8978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862528838ca7d12e13c09edc02bb6151"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga862528838ca7d12e13c09edc02bb6151">timestamp</a> (<a class="el" href="structarrow_1_1_time_unit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit)</td></tr>
<tr class="memdesc:ga862528838ca7d12e13c09edc02bb6151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_timestamp_type.html" title="Concrete type class for datetime data (as number of seconds, milliseconds, microseconds or nanosecond...">TimestampType</a> instance from its unit.  <a href="group__type-factories.html#ga862528838ca7d12e13c09edc02bb6151">More...</a><br /></td></tr>
<tr class="separator:ga862528838ca7d12e13c09edc02bb6151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58fe6ad4ca179979515028f11d8abbca"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga58fe6ad4ca179979515028f11d8abbca">timestamp</a> (<a class="el" href="structarrow_1_1_time_unit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit, const std::string &amp;timezone)</td></tr>
<tr class="memdesc:ga58fe6ad4ca179979515028f11d8abbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_timestamp_type.html" title="Concrete type class for datetime data (as number of seconds, milliseconds, microseconds or nanosecond...">TimestampType</a> instance from its unit and timezone.  <a href="group__type-factories.html#ga58fe6ad4ca179979515028f11d8abbca">More...</a><br /></td></tr>
<tr class="separator:ga58fe6ad4ca179979515028f11d8abbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e76c6504af1c30799b5b4d7e737305"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gae2e76c6504af1c30799b5b4d7e737305">time32</a> (<a class="el" href="structarrow_1_1_time_unit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit)</td></tr>
<tr class="memdesc:gae2e76c6504af1c30799b5b4d7e737305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 32-bit time type instance.  <a href="group__type-factories.html#gae2e76c6504af1c30799b5b4d7e737305">More...</a><br /></td></tr>
<tr class="separator:gae2e76c6504af1c30799b5b4d7e737305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6f30b7153111da33e446965b5531e3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga7f6f30b7153111da33e446965b5531e3">time64</a> (<a class="el" href="structarrow_1_1_time_unit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a> unit)</td></tr>
<tr class="memdesc:ga7f6f30b7153111da33e446965b5531e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 64-bit time type instance.  <a href="group__type-factories.html#ga7f6f30b7153111da33e446965b5531e3">More...</a><br /></td></tr>
<tr class="separator:ga7f6f30b7153111da33e446965b5531e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa9f64b1f9435636482c7cc65ec47ecd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gafa9f64b1f9435636482c7cc65ec47ecd">struct_</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt;&gt; &amp;fields)</td></tr>
<tr class="memdesc:gafa9f64b1f9435636482c7cc65ec47ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_struct_type.html" title="Concrete type class for struct data.">StructType</a> instance.  <a href="group__type-factories.html#gafa9f64b1f9435636482c7cc65ec47ecd">More...</a><br /></td></tr>
<tr class="separator:gafa9f64b1f9435636482c7cc65ec47ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476046674d06cb75a111694064beae36"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga476046674d06cb75a111694064beae36">union_</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt;&gt; &amp;child_fields, const std::vector&lt; int8_t &gt; &amp;type_codes, <a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dac">UnionMode::type</a> mode=<a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60">UnionMode::SPARSE</a>)</td></tr>
<tr class="memdesc:ga476046674d06cb75a111694064beae36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_union_type.html" title="Concrete type class for union data.">UnionType</a> instance.  <a href="group__type-factories.html#ga476046674d06cb75a111694064beae36">More...</a><br /></td></tr>
<tr class="separator:ga476046674d06cb75a111694064beae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3781bbe8baac73138ad864fa53735490"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga3781bbe8baac73138ad864fa53735490">union_</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt;&gt; &amp;child_fields, <a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dac">UnionMode::type</a> mode=<a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60">UnionMode::SPARSE</a>)</td></tr>
<tr class="memdesc:ga3781bbe8baac73138ad864fa53735490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_union_type.html" title="Concrete type class for union data.">UnionType</a> instance.  <a href="group__type-factories.html#ga3781bbe8baac73138ad864fa53735490">More...</a><br /></td></tr>
<tr class="separator:ga3781bbe8baac73138ad864fa53735490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16c955b465c8bfe339b624fd605fb3a2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga16c955b465c8bfe339b624fd605fb3a2">union_</a> (<a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dac">UnionMode::type</a> mode=<a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60">UnionMode::SPARSE</a>)</td></tr>
<tr class="memdesc:ga16c955b465c8bfe339b624fd605fb3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_union_type.html" title="Concrete type class for union data.">UnionType</a> instance.  <a href="group__type-factories.html#ga16c955b465c8bfe339b624fd605fb3a2">More...</a><br /></td></tr>
<tr class="separator:ga16c955b465c8bfe339b624fd605fb3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae8cac474f002c3be857a88bf9497972"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gaae8cac474f002c3be857a88bf9497972">union_</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt;&gt; &amp;children, const std::vector&lt; std::string &gt; &amp;field_names, const std::vector&lt; int8_t &gt; &amp;type_codes, <a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dac">UnionMode::type</a> mode=<a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60">UnionMode::SPARSE</a>)</td></tr>
<tr class="memdesc:gaae8cac474f002c3be857a88bf9497972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_union_type.html" title="Concrete type class for union data.">UnionType</a> instance.  <a href="group__type-factories.html#gaae8cac474f002c3be857a88bf9497972">More...</a><br /></td></tr>
<tr class="separator:gaae8cac474f002c3be857a88bf9497972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga009d36e7c16f62a9e192394da9a94c7c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga009d36e7c16f62a9e192394da9a94c7c">union_</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt;&gt; &amp;children, const std::vector&lt; std::string &gt; &amp;field_names, <a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dac">UnionMode::type</a> mode=<a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60">UnionMode::SPARSE</a>)</td></tr>
<tr class="memdesc:ga009d36e7c16f62a9e192394da9a94c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_union_type.html" title="Concrete type class for union data.">UnionType</a> instance.  <a href="group__type-factories.html#ga009d36e7c16f62a9e192394da9a94c7c">More...</a><br /></td></tr>
<tr class="separator:ga009d36e7c16f62a9e192394da9a94c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1ec5ec1af98b0dc19aee59fdaa442a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gabe1ec5ec1af98b0dc19aee59fdaa442a">union_</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt;&gt; &amp;children, <a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dac">UnionMode::type</a> mode=<a class="el" href="structarrow_1_1_union_mode.html#a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60">UnionMode::SPARSE</a>)</td></tr>
<tr class="memdesc:gabe1ec5ec1af98b0dc19aee59fdaa442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_union_type.html" title="Concrete type class for union data.">UnionType</a> instance.  <a href="group__type-factories.html#gabe1ec5ec1af98b0dc19aee59fdaa442a">More...</a><br /></td></tr>
<tr class="separator:gabe1ec5ec1af98b0dc19aee59fdaa442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f61c68b2a04a9d179cb56ff1186c59"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga36f61c68b2a04a9d179cb56ff1186c59">dictionary</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;index_type, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;dict_type, bool ordered=false)</td></tr>
<tr class="memdesc:ga36f61c68b2a04a9d179cb56ff1186c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_dictionary_type.html" title="Dictionary-encoded value type with data-dependent dictionary.">DictionaryType</a> instance.  <a href="group__type-factories.html#ga36f61c68b2a04a9d179cb56ff1186c59">More...</a><br /></td></tr>
<tr class="separator:ga36f61c68b2a04a9d179cb56ff1186c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4918ab359f54d2544f8fa29b7ba88efe"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schema-factories.html#ga4918ab359f54d2544f8fa29b7ba88efe">field</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;type, bool nullable=true, const std::shared_ptr&lt; const <a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a> &gt; &amp;metadata=<a class="el" href="macros_8h.html#a3ef7eab8cd0e570b6586628cc9d5ccab">NULLPTR</a>)</td></tr>
<tr class="memdesc:ga4918ab359f54d2544f8fa29b7ba88efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_field.html" title="The combination of a field name and data type, with optional metadata.">Field</a> instance.  <a href="group__schema-factories.html#ga4918ab359f54d2544f8fa29b7ba88efe">More...</a><br /></td></tr>
<tr class="separator:ga4918ab359f54d2544f8fa29b7ba88efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97ac72c2a07228577c1d38b7747941a9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schema-factories.html#ga97ac72c2a07228577c1d38b7747941a9">schema</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt;&gt; &amp;fields, const std::shared_ptr&lt; const <a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a> &gt; &amp;metadata=<a class="el" href="macros_8h.html#a3ef7eab8cd0e570b6586628cc9d5ccab">NULLPTR</a>)</td></tr>
<tr class="memdesc:ga97ac72c2a07228577c1d38b7747941a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_schema.html" title="Sequence of arrow::Field objects describing the columns of a record batch or table data structure.">Schema</a> instance.  <a href="group__schema-factories.html#ga97ac72c2a07228577c1d38b7747941a9">More...</a><br /></td></tr>
<tr class="separator:ga97ac72c2a07228577c1d38b7747941a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bfaca962de2f2069b78b27cdf28bcd6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schema-factories.html#ga4bfaca962de2f2069b78b27cdf28bcd6">schema</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_field.html">Field</a> &gt;&gt; &amp;&amp;fields, const std::shared_ptr&lt; const <a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a> &gt; &amp;metadata=<a class="el" href="macros_8h.html#a3ef7eab8cd0e570b6586628cc9d5ccab">NULLPTR</a>)</td></tr>
<tr class="memdesc:ga4bfaca962de2f2069b78b27cdf28bcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_schema.html" title="Sequence of arrow::Field objects describing the columns of a record batch or table data structure.">Schema</a> instance.  <a href="group__schema-factories.html#ga4bfaca962de2f2069b78b27cdf28bcd6">More...</a><br /></td></tr>
<tr class="separator:ga4bfaca962de2f2069b78b27cdf28bcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8d7384b0a61a9a15cfdca6c39c4ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#abc8d7384b0a61a9a15cfdca6c39c4ded">UnifySchemas</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt;&gt; &amp;schemas, <a class="el" href="structarrow_1_1_field_1_1_merge_options.html">Field::MergeOptions</a> field_merge_options=<a class="el" href="structarrow_1_1_field_1_1_merge_options.html#aad6ec10fe86793101bf688bbf9c9ad96">Field::MergeOptions::Defaults</a>())</td></tr>
<tr class="memdesc:abc8d7384b0a61a9a15cfdca6c39c4ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unifies schemas by merging fields by name.  <a href="namespacearrow.html#abc8d7384b0a61a9a15cfdca6c39c4ded">More...</a><br /></td></tr>
<tr class="separator:abc8d7384b0a61a9a15cfdca6c39c4ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf642d53dac1a6b6b686fb5984d33bc9a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gaf642d53dac1a6b6b686fb5984d33bc9a">null</a> ()</td></tr>
<tr class="memdesc:gaf642d53dac1a6b6b686fb5984d33bc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_null_type.html" title="Concrete type class for always-null data.">NullType</a> instance.  <a href="group__type-factories.html#gaf642d53dac1a6b6b686fb5984d33bc9a">More...</a><br /></td></tr>
<tr class="separator:gaf642d53dac1a6b6b686fb5984d33bc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e585e8f1c25a9751ac9381a274df057"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga1e585e8f1c25a9751ac9381a274df057">boolean</a> ()</td></tr>
<tr class="memdesc:ga1e585e8f1c25a9751ac9381a274df057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_boolean_type.html" title="Concrete type class for boolean data.">BooleanType</a> instance.  <a href="group__type-factories.html#ga1e585e8f1c25a9751ac9381a274df057">More...</a><br /></td></tr>
<tr class="separator:ga1e585e8f1c25a9751ac9381a274df057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c09bf26bc03f0fb0c84a0277215dd67"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga9c09bf26bc03f0fb0c84a0277215dd67">int8</a> ()</td></tr>
<tr class="memdesc:ga9c09bf26bc03f0fb0c84a0277215dd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_int8_type.html" title="Concrete type class for signed 8-bit integer data.">Int8Type</a> instance.  <a href="group__type-factories.html#ga9c09bf26bc03f0fb0c84a0277215dd67">More...</a><br /></td></tr>
<tr class="separator:ga9c09bf26bc03f0fb0c84a0277215dd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034c5c703e15039fe76af412d349734d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga034c5c703e15039fe76af412d349734d">int16</a> ()</td></tr>
<tr class="memdesc:ga034c5c703e15039fe76af412d349734d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_int16_type.html" title="Concrete type class for signed 16-bit integer data.">Int16Type</a> instance.  <a href="group__type-factories.html#ga034c5c703e15039fe76af412d349734d">More...</a><br /></td></tr>
<tr class="separator:ga034c5c703e15039fe76af412d349734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f6bfe394347f77befa2143297ad541"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga86f6bfe394347f77befa2143297ad541">int32</a> ()</td></tr>
<tr class="memdesc:ga86f6bfe394347f77befa2143297ad541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_int32_type.html" title="Concrete type class for signed 32-bit integer data.">Int32Type</a> instance.  <a href="group__type-factories.html#ga86f6bfe394347f77befa2143297ad541">More...</a><br /></td></tr>
<tr class="separator:ga86f6bfe394347f77befa2143297ad541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga733b16be653069b8d926529662e34e79"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga733b16be653069b8d926529662e34e79">int64</a> ()</td></tr>
<tr class="memdesc:ga733b16be653069b8d926529662e34e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_int64_type.html" title="Concrete type class for signed 64-bit integer data.">Int64Type</a> instance.  <a href="group__type-factories.html#ga733b16be653069b8d926529662e34e79">More...</a><br /></td></tr>
<tr class="separator:ga733b16be653069b8d926529662e34e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4891a423be213550cc24e8ebe830673f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga4891a423be213550cc24e8ebe830673f">uint8</a> ()</td></tr>
<tr class="memdesc:ga4891a423be213550cc24e8ebe830673f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_u_int8_type.html" title="Concrete type class for unsigned 8-bit integer data.">UInt8Type</a> instance.  <a href="group__type-factories.html#ga4891a423be213550cc24e8ebe830673f">More...</a><br /></td></tr>
<tr class="separator:ga4891a423be213550cc24e8ebe830673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f1e44bc2ab9b465b6e7b601eb48f0a0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga9f1e44bc2ab9b465b6e7b601eb48f0a0">uint16</a> ()</td></tr>
<tr class="memdesc:ga9f1e44bc2ab9b465b6e7b601eb48f0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_u_int16_type.html" title="Concrete type class for unsigned 16-bit integer data.">UInt16Type</a> instance.  <a href="group__type-factories.html#ga9f1e44bc2ab9b465b6e7b601eb48f0a0">More...</a><br /></td></tr>
<tr class="separator:ga9f1e44bc2ab9b465b6e7b601eb48f0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae80e510cfb2931ac18c73cba0be6d894"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gae80e510cfb2931ac18c73cba0be6d894">uint32</a> ()</td></tr>
<tr class="memdesc:gae80e510cfb2931ac18c73cba0be6d894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_u_int32_type.html" title="Concrete type class for unsigned 32-bit integer data.">UInt32Type</a> instance.  <a href="group__type-factories.html#gae80e510cfb2931ac18c73cba0be6d894">More...</a><br /></td></tr>
<tr class="separator:gae80e510cfb2931ac18c73cba0be6d894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae548d03275f4afaa97a269774ce6930c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gae548d03275f4afaa97a269774ce6930c">uint64</a> ()</td></tr>
<tr class="memdesc:gae548d03275f4afaa97a269774ce6930c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_u_int64_type.html" title="Concrete type class for unsigned 64-bit integer data.">UInt64Type</a> instance.  <a href="group__type-factories.html#gae548d03275f4afaa97a269774ce6930c">More...</a><br /></td></tr>
<tr class="separator:gae548d03275f4afaa97a269774ce6930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fac9b6739876df09be8b82d70b26734"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga4fac9b6739876df09be8b82d70b26734">float16</a> ()</td></tr>
<tr class="memdesc:ga4fac9b6739876df09be8b82d70b26734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_half_float_type.html" title="Concrete type class for 16-bit floating-point data.">HalfFloatType</a> instance.  <a href="group__type-factories.html#ga4fac9b6739876df09be8b82d70b26734">More...</a><br /></td></tr>
<tr class="separator:ga4fac9b6739876df09be8b82d70b26734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48fca9d26feda61c8255ec3c44a2078c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga48fca9d26feda61c8255ec3c44a2078c">float32</a> ()</td></tr>
<tr class="memdesc:ga48fca9d26feda61c8255ec3c44a2078c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_float_type.html" title="Concrete type class for 32-bit floating-point data (C &quot;float&quot;)">FloatType</a> instance.  <a href="group__type-factories.html#ga48fca9d26feda61c8255ec3c44a2078c">More...</a><br /></td></tr>
<tr class="separator:ga48fca9d26feda61c8255ec3c44a2078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6f514320a9b037ab161fa97db73b970"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gab6f514320a9b037ab161fa97db73b970">float64</a> ()</td></tr>
<tr class="memdesc:gab6f514320a9b037ab161fa97db73b970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_double_type.html" title="Concrete type class for 64-bit floating-point data (C &quot;double&quot;)">DoubleType</a> instance.  <a href="group__type-factories.html#gab6f514320a9b037ab161fa97db73b970">More...</a><br /></td></tr>
<tr class="separator:gab6f514320a9b037ab161fa97db73b970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63178820a26f6ecb894ad35963ca981a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga63178820a26f6ecb894ad35963ca981a">utf8</a> ()</td></tr>
<tr class="memdesc:ga63178820a26f6ecb894ad35963ca981a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_string_type.html" title="Concrete type class for variable-size string data, utf8-encoded.">StringType</a> instance.  <a href="group__type-factories.html#ga63178820a26f6ecb894ad35963ca981a">More...</a><br /></td></tr>
<tr class="separator:ga63178820a26f6ecb894ad35963ca981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc42ef32dc897b3bee1dea124cefab86"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gacc42ef32dc897b3bee1dea124cefab86">large_utf8</a> ()</td></tr>
<tr class="memdesc:gacc42ef32dc897b3bee1dea124cefab86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_large_string_type.html" title="Concrete type class for large variable-size string data, utf8-encoded.">LargeStringType</a> instance.  <a href="group__type-factories.html#gacc42ef32dc897b3bee1dea124cefab86">More...</a><br /></td></tr>
<tr class="separator:gacc42ef32dc897b3bee1dea124cefab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c3979f26a439e78d048bbac84a9232"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga66c3979f26a439e78d048bbac84a9232">binary</a> ()</td></tr>
<tr class="memdesc:ga66c3979f26a439e78d048bbac84a9232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_binary_type.html" title="Concrete type class for variable-size binary data.">BinaryType</a> instance.  <a href="group__type-factories.html#ga66c3979f26a439e78d048bbac84a9232">More...</a><br /></td></tr>
<tr class="separator:ga66c3979f26a439e78d048bbac84a9232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41a46c979c848fee62212f2e49a8d8c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gad41a46c979c848fee62212f2e49a8d8c">large_binary</a> ()</td></tr>
<tr class="memdesc:gad41a46c979c848fee62212f2e49a8d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_large_binary_type.html" title="Concrete type class for large variable-size binary data.">LargeBinaryType</a> instance.  <a href="group__type-factories.html#gad41a46c979c848fee62212f2e49a8d8c">More...</a><br /></td></tr>
<tr class="separator:gad41a46c979c848fee62212f2e49a8d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac15fddc26c629cd5a2cb67f432739e8e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#gac15fddc26c629cd5a2cb67f432739e8e">date32</a> ()</td></tr>
<tr class="memdesc:gac15fddc26c629cd5a2cb67f432739e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_date32_type.html" title="Concrete type class for 32-bit date data (as number of days since UNIX epoch)">Date32Type</a> instance.  <a href="group__type-factories.html#gac15fddc26c629cd5a2cb67f432739e8e">More...</a><br /></td></tr>
<tr class="separator:gac15fddc26c629cd5a2cb67f432739e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga540dd093466c265aa411a65f29e950b2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__type-factories.html#ga540dd093466c265aa411a65f29e950b2">date64</a> ()</td></tr>
<tr class="memdesc:ga540dd093466c265aa411a65f29e950b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classarrow_1_1_date64_type.html" title="Concrete type class for 64-bit date data (as number of milliseconds since UNIX epoch)">Date64Type</a> instance.  <a href="group__type-factories.html#ga540dd093466c265aa411a65f29e950b2">More...</a><br /></td></tr>
<tr class="separator:ga540dd093466c265aa411a65f29e950b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe81d544faaf827b8f32c5a80b99820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aebe81d544faaf827b8f32c5a80b99820">default_memory_pool</a> ()</td></tr>
<tr class="memdesc:aebe81d544faaf827b8f32c5a80b99820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the process-wide default memory pool.  <a href="namespacearrow.html#aebe81d544faaf827b8f32c5a80b99820">More...</a><br /></td></tr>
<tr class="separator:aebe81d544faaf827b8f32c5a80b99820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf9e156c4a8a01745d20c33a22f1f28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#acbf9e156c4a8a01745d20c33a22f1f28">operator==</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:acbf9e156c4a8a01745d20c33a22f1f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e5d5239907d98d4d80c80616f8bee7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ae7e5d5239907d98d4d80c80616f8bee7">operator!=</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:ae7e5d5239907d98d4d80c80616f8bee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193e2bb54c6f5de5e388b2edd534a57c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a193e2bb54c6f5de5e388b2edd534a57c">operator&lt;</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:a193e2bb54c6f5de5e388b2edd534a57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb54a5f01d82053eb4779c29aabd9a89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#acb54a5f01d82053eb4779c29aabd9a89">operator&lt;=</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:acb54a5f01d82053eb4779c29aabd9a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80697b084df40ebe8094fee62e8e5192"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a80697b084df40ebe8094fee62e8e5192">operator&gt;</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:a80697b084df40ebe8094fee62e8e5192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b97ff62146c0a0e2aeb702b9fddb77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a92b97ff62146c0a0e2aeb702b9fddb77">operator&gt;=</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:a92b97ff62146c0a0e2aeb702b9fddb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae9b9602fea3bcd4bf6d9a45c011f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a4ae9b9602fea3bcd4bf6d9a45c011f4d">operator-</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;operand)</td></tr>
<tr class="separator:a4ae9b9602fea3bcd4bf6d9a45c011f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf501b98a8ee4d346febfa3e96bc8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a7cf501b98a8ee4d346febfa3e96bc8e7">operator~</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;operand)</td></tr>
<tr class="separator:a7cf501b98a8ee4d346febfa3e96bc8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e15d3146feab799b2bac1848f2df94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ae8e15d3146feab799b2bac1848f2df94">operator+</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:ae8e15d3146feab799b2bac1848f2df94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f136f8caf36352437cc51b126ad2ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ab9f136f8caf36352437cc51b126ad2ee">operator-</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:ab9f136f8caf36352437cc51b126ad2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6773885c4f560a78057a4455d422a7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ab6773885c4f560a78057a4455d422a7f">operator*</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:ab6773885c4f560a78057a4455d422a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a236ea3b1930a4f78adcbdf0832ba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a79a236ea3b1930a4f78adcbdf0832ba8">operator/</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:a79a236ea3b1930a4f78adcbdf0832ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f812806d0a240278b246de398438bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a52f812806d0a240278b246de398438bc">operator%</a> (const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;left, const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;right)</td></tr>
<tr class="separator:a52f812806d0a240278b246de398438bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc24abeb218eea1d217a52c7ed0a4a0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_boundary_finder.html">BoundaryFinder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#acbc24abeb218eea1d217a52c7ed0a4a0">MakeNewlineBoundaryFinder</a> ()</td></tr>
<tr class="separator:acbc24abeb218eea1d217a52c7ed0a4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe9311bc4b5b80d1cc42102bb1542ab"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename Ret  = typename internal::call_traits::return_type&lt;Fn&gt;::ValueType&gt; </td></tr>
<tr class="memitem:afbe9311bc4b5b80d1cc42102bb1542ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; Ret &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#afbe9311bc4b5b80d1cc42102bb1542ab">MakeFunctionIterator</a> (Fn fn)</td></tr>
<tr class="memdesc:afbe9311bc4b5b80d1cc42102bb1542ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="classarrow_1_1_iterator.html" title="A generic Iterator that can return errors.">Iterator</a> which invokes a callable on Next()  <a href="namespacearrow.html#afbe9311bc4b5b80d1cc42102bb1542ab">More...</a><br /></td></tr>
<tr class="separator:afbe9311bc4b5b80d1cc42102bb1542ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88b501daab08dda0e148de95dd68d94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac88b501daab08dda0e148de95dd68d94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ac88b501daab08dda0e148de95dd68d94">MakeEmptyIterator</a> ()</td></tr>
<tr class="separator:ac88b501daab08dda0e148de95dd68d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab926f5eb39c55824dd5a7cf146ca867e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab926f5eb39c55824dd5a7cf146ca867e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ab926f5eb39c55824dd5a7cf146ca867e">MakeErrorIterator</a> (<a class="el" href="classarrow_1_1_status.html">Status</a> s)</td></tr>
<tr class="separator:ab926f5eb39c55824dd5a7cf146ca867e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260d67d2d8f74d6bef570dc730982fee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a260d67d2d8f74d6bef570dc730982fee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a260d67d2d8f74d6bef570dc730982fee">MakeVectorIterator</a> (std::vector&lt; T &gt; v)</td></tr>
<tr class="separator:a260d67d2d8f74d6bef570dc730982fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c8b32dbbc2e7415d1e286ca132c006"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34c8b32dbbc2e7415d1e286ca132c006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; <a class="el" href="namespacearrow_1_1util.html#a37597d23d580458d4547f817e2943744">util::optional</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a34c8b32dbbc2e7415d1e286ca132c006">MakeVectorOptionalIterator</a> (std::vector&lt; T &gt; v)</td></tr>
<tr class="separator:a34c8b32dbbc2e7415d1e286ca132c006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0739021d27a4ce9b060cd1d0fb537821"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename From  = internal::call_traits::argument_type&lt;0, Fn&gt;, typename To  = internal::call_traits::return_type&lt;Fn&gt;&gt; </td></tr>
<tr class="memitem:a0739021d27a4ce9b060cd1d0fb537821"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a0739021d27a4ce9b060cd1d0fb537821">MakeMapIterator</a> (Fn <a class="el" href="group__type-factories.html#ga464d9a4f0c307d935593d4aa4ff44846">map</a>, <a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; From &gt; it)</td></tr>
<tr class="memdesc:a0739021d27a4ce9b060cd1d0fb537821"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classarrow_1_1_map_iterator.html" title="MapIterator takes ownership of an iterator and a function to apply on every element.">MapIterator</a> takes ownership of an iterator and a function to apply on every element.  <a href="namespacearrow.html#a0739021d27a4ce9b060cd1d0fb537821">More...</a><br /></td></tr>
<tr class="separator:a0739021d27a4ce9b060cd1d0fb537821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b921bf603b379a7e9a25236ec3fe79"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename From  = internal::call_traits::argument_type&lt;0, Fn&gt;, typename To  = typename internal::call_traits::return_type&lt;Fn&gt;::ValueType&gt; </td></tr>
<tr class="memitem:a91b921bf603b379a7e9a25236ec3fe79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a91b921bf603b379a7e9a25236ec3fe79">MakeMaybeMapIterator</a> (Fn <a class="el" href="group__type-factories.html#ga464d9a4f0c307d935593d4aa4ff44846">map</a>, <a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; From &gt; it)</td></tr>
<tr class="memdesc:a91b921bf603b379a7e9a25236ec3fe79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classarrow_1_1_map_iterator.html" title="MapIterator takes ownership of an iterator and a function to apply on every element.">MapIterator</a>, but where the function can fail.  <a href="namespacearrow.html#a91b921bf603b379a7e9a25236ec3fe79">More...</a><br /></td></tr>
<tr class="separator:a91b921bf603b379a7e9a25236ec3fe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c38fa56ca1c43c4b0a2acd98de9624"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename From  = typename internal::call_traits::argument_type&lt;0, Fn&gt;, typename Ret  = typename internal::call_traits::return_type&lt;Fn&gt;::ValueType, typename To  = typename std::tuple_element&lt;0, Ret&gt;::type, typename Enable  = typename std::enable_if&lt;std::is_same&lt;        typename std::tuple_element&lt;1, Ret&gt;::type, FilterIterator::Action&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a62c38fa56ca1c43c4b0a2acd98de9624"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a62c38fa56ca1c43c4b0a2acd98de9624">MakeFilterIterator</a> (Fn filter, <a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; From &gt; it)</td></tr>
<tr class="memdesc:a62c38fa56ca1c43c4b0a2acd98de9624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classarrow_1_1_map_iterator.html" title="MapIterator takes ownership of an iterator and a function to apply on every element.">MapIterator</a>, but where the function can fail or reject elements.  <a href="namespacearrow.html#a62c38fa56ca1c43c4b0a2acd98de9624">More...</a><br /></td></tr>
<tr class="separator:a62c38fa56ca1c43c4b0a2acd98de9624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6975d6cac55ba9bd6b286030381b862c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6975d6cac55ba9bd6b286030381b862c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a6975d6cac55ba9bd6b286030381b862c">MakeFlattenIterator</a> (<a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; <a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; T &gt;&gt; it)</td></tr>
<tr class="separator:a6975d6cac55ba9bd6b286030381b862c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b7dc6954a6f27fc0e3b1ea4db551d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a664b7dc6954a6f27fc0e3b1ea4db551d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; <a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a664b7dc6954a6f27fc0e3b1ea4db551d">MakeReadaheadIterator</a> (<a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; T &gt; it, int readahead_queue_size)</td></tr>
<tr class="separator:a664b7dc6954a6f27fc0e3b1ea4db551d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b06732381cac7996882e17c245290a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ae2b06732381cac7996882e17c245290a">key_value_metadata</a> (const std::unordered_map&lt; std::string, std::string &gt; &amp;pairs)</td></tr>
<tr class="memdesc:ae2b06732381cac7996882e17c245290a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_key_value_metadata.html" title="A container for key-value pair type metadata. Not thread-safe.">KeyValueMetadata</a> instance.  <a href="namespacearrow.html#ae2b06732381cac7996882e17c245290a">More...</a><br /></td></tr>
<tr class="separator:ae2b06732381cac7996882e17c245290a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11383090fb23bb3b0fe7e623247aa297"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a11383090fb23bb3b0fe7e623247aa297">key_value_metadata</a> (const std::vector&lt; std::string &gt; &amp;keys, const std::vector&lt; std::string &gt; &amp;values)</td></tr>
<tr class="memdesc:a11383090fb23bb3b0fe7e623247aa297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classarrow_1_1_key_value_metadata.html" title="A container for key-value pair type metadata. Not thread-safe.">KeyValueMetadata</a> instance.  <a href="namespacearrow.html#a11383090fb23bb3b0fe7e623247aa297">More...</a><br /></td></tr>
<tr class="separator:a11383090fb23bb3b0fe7e623247aa297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc96e2a2b4dca763befd1d172134ac2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a2cc96e2a2b4dca763befd1d172134ac2">HexEncode</a> (const uint8_t *data, size_t length)</td></tr>
<tr class="separator:a2cc96e2a2b4dca763befd1d172134ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0898d30c6a1068bbfc1ccf9064aa8ec"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#af0898d30c6a1068bbfc1ccf9064aa8ec">Escape</a> (const char *data, size_t length)</td></tr>
<tr class="separator:af0898d30c6a1068bbfc1ccf9064aa8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ac42e0d52b7800aafbbbcf2587b5d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a98ac42e0d52b7800aafbbbcf2587b5d6">HexEncode</a> (const char *data, size_t length)</td></tr>
<tr class="separator:a98ac42e0d52b7800aafbbbcf2587b5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c7f8cdc8482addd98d3066653080d0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ad3c7f8cdc8482addd98d3066653080d0">HexEncode</a> (util::string_view str)</td></tr>
<tr class="separator:ad3c7f8cdc8482addd98d3066653080d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438db68959b2071de6b71a919316da0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ad438db68959b2071de6b71a919316da0">Escape</a> (util::string_view str)</td></tr>
<tr class="separator:ad438db68959b2071de6b71a919316da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b66debdce0800121a0b573cb4f51344"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a5b66debdce0800121a0b573cb4f51344">ParseHexValue</a> (const char *data, uint8_t *out)</td></tr>
<tr class="separator:a5b66debdce0800121a0b573cb4f51344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187c243ea680906ebe9d2c20ab311940"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a187c243ea680906ebe9d2c20ab311940">GetCpuThreadPoolCapacity</a> ()</td></tr>
<tr class="memdesc:a187c243ea680906ebe9d2c20ab311940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the capacity of the global thread pool.  <a href="namespacearrow.html#a187c243ea680906ebe9d2c20ab311940">More...</a><br /></td></tr>
<tr class="separator:a187c243ea680906ebe9d2c20ab311940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa103995039a823ac5ce376994562f06d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#aa103995039a823ac5ce376994562f06d">SetCpuThreadPoolCapacity</a> (int threads)</td></tr>
<tr class="memdesc:aa103995039a823ac5ce376994562f06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the capacity of the global thread pool.  <a href="namespacearrow.html#aa103995039a823ac5ce376994562f06d">More...</a><br /></td></tr>
<tr class="separator:aa103995039a823ac5ce376994562f06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431bd46d978673b1b00afc3049776c49"><td class="memTemplParams" colspan="2">template&lt;typename VISITOR &gt; </td></tr>
<tr class="memitem:a431bd46d978673b1b00afc3049776c49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a431bd46d978673b1b00afc3049776c49">VisitTypeInline</a> (const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;type, VISITOR *visitor)</td></tr>
<tr class="separator:a431bd46d978673b1b00afc3049776c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f912387c238cd2feef3c242c0647d2b"><td class="memTemplParams" colspan="2">template&lt;typename VISITOR &gt; </td></tr>
<tr class="memitem:a2f912387c238cd2feef3c242c0647d2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a2f912387c238cd2feef3c242c0647d2b">VisitArrayInline</a> (const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;array, VISITOR *visitor)</td></tr>
<tr class="separator:a2f912387c238cd2feef3c242c0647d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511650783e127b8c2acb1326b9b94e7a"><td class="memTemplParams" colspan="2">template&lt;typename VISITOR &gt; </td></tr>
<tr class="memitem:a511650783e127b8c2acb1326b9b94e7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a511650783e127b8c2acb1326b9b94e7a">VisitScalarInline</a> (const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;scalar, VISITOR *visitor)</td></tr>
<tr class="separator:a511650783e127b8c2acb1326b9b94e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4cd38814abf185253aa1c8f68c9ca5ab"><td class="memItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a4cd38814abf185253aa1c8f68c9ca5ab">kMinBuilderCapacity</a> = 1 &lt;&lt; 5</td></tr>
<tr class="separator:a4cd38814abf185253aa1c8f68c9ca5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64d5a2a0d35fbe0ae87fc18d2a5c0ee"><td class="memItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ab64d5a2a0d35fbe0ae87fc18d2a5c0ee">kListMaximumElements</a> = std::numeric_limits&lt;int32_t&gt;::max() - 1</td></tr>
<tr class="separator:ab64d5a2a0d35fbe0ae87fc18d2a5c0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4f8bc1a6b7bfa3386005a0bede3640"><td class="memItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a6c4f8bc1a6b7bfa3386005a0bede3640">kBinaryMemoryLimit</a> = std::numeric_limits&lt;int32_t&gt;::max() - 1</td></tr>
<tr class="separator:a6c4f8bc1a6b7bfa3386005a0bede3640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fa6d3c9abcfa1251baa24ff731782e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::function&lt; <a class="el" href="classarrow_1_1_status.html">Status</a>(const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;edits, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;base, const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;target)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#af7fa6d3c9abcfa1251baa24ff731782e">MakeUnifiedDiffFormatter</a> (const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;type, std::ostream *os)</td></tr>
<tr class="memdesc:af7fa6d3c9abcfa1251baa24ff731782e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a function which will format an edit script in unified diff format to os, given base and target arrays of type  <a href="namespacearrow.html#af7fa6d3c9abcfa1251baa24ff731782e">More...</a><br /></td></tr>
<tr class="separator:af7fa6d3c9abcfa1251baa24ff731782e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc89c993234944fd7bdbdfe95812080"><td class="memItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a2bc89c993234944fd7bdbdfe95812080">kUnknownNullCount</a> = -1</td></tr>
<tr class="separator:a2bc89c993234944fd7bdbdfe95812080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f613bf6f0e5a50bd9a89c767d8004d1"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#a0f613bf6f0e5a50bd9a89c767d8004d1">kExtensionTypeKeyName</a> []</td></tr>
<tr class="separator:a0f613bf6f0e5a50bd9a89c767d8004d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac532e4d8906ecf870014f5a4bbb1382c"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacearrow.html#ac532e4d8906ecf870014f5a4bbb1382c">kExtensionMetadataKeyName</a> []</td></tr>
<tr class="separator:ac532e4d8906ecf870014f5a4bbb1382c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Top-level namespace for Apache Arrow C++ API. </p>
<p>Server-side APIs to implement authentication for Flight.</p>
<p>Implementation of Flight RPC client using gRPC. API should be.</p>
<p>User-defined extension types.</p>
<p>Logic for automatically determining the structure of multi-file dataset with possible partitioning according to available partitioning.</p>
<p>EXPERIMENTAL in 0.13.0 </p><dl class="section since"><dt>Since</dt><dd>0.13.0 </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aecf659a72f5db1c837409580f11bd337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf659a72f5db1c837409580f11bd337">&#9670;&nbsp;</a></span>ArrayVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; &gt; <a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">arrow::ArrayVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26e0360de3fc4b7120b6b50f14a22786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e0360de3fc4b7120b6b50f14a22786">&#9670;&nbsp;</a></span>BufferVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a26e0360de3fc4b7120b6b50f14a22786">arrow::BufferVector</a> = typedef std::vector&lt;std::shared_ptr&lt;<a class="el" href="classarrow_1_1_buffer.html">Buffer</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ea89658181e81c18b237da93d8294f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea89658181e81c18b237da93d8294f7">&#9670;&nbsp;</a></span>Date32Array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a3ea89658181e81c18b237da93d8294f7">arrow::Date32Array</a> = typedef <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt;<a class="el" href="classarrow_1_1_date32_type.html">Date32Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa210dc2cd0cab7513343548d42c00000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa210dc2cd0cab7513343548d42c00000">&#9670;&nbsp;</a></span>Date32Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aa210dc2cd0cab7513343548d42c00000">arrow::Date32Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_date32_type.html">Date32Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9a45b66d455778ec8168f937379f22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a45b66d455778ec8168f937379f22e">&#9670;&nbsp;</a></span>Date64Array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aa9a45b66d455778ec8168f937379f22e">arrow::Date64Array</a> = typedef <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt;<a class="el" href="classarrow_1_1_date64_type.html">Date64Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd7b5640cf95de8799d75b12f901b62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7b5640cf95de8799d75b12f901b62a">&#9670;&nbsp;</a></span>Date64Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#afd7b5640cf95de8799d75b12f901b62a">arrow::Date64Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_date64_type.html">Date64Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9162b62a545f10bb02754571cd7ec80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9162b62a545f10bb02754571cd7ec80">&#9670;&nbsp;</a></span>DecimalArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aa9162b62a545f10bb02754571cd7ec80">arrow::DecimalArray</a> = typedef <a class="el" href="classarrow_1_1_decimal128_array.html">Decimal128Array</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59bcac644b0f2cd8e7034643d09e23bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bcac644b0f2cd8e7034643d09e23bb">&#9670;&nbsp;</a></span>DecimalBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a59bcac644b0f2cd8e7034643d09e23bb">arrow::DecimalBuilder</a> = typedef <a class="el" href="classarrow_1_1_decimal128_builder.html">Decimal128Builder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab98cad76b29efffe92c6c88af8947873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98cad76b29efffe92c6c88af8947873">&#9670;&nbsp;</a></span>DoubleBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ab98cad76b29efffe92c6c88af8947873">arrow::DoubleBuilder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_double_type.html">DoubleType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44cfa546dbecd78fdb541518d7867fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cfa546dbecd78fdb541518d7867fe0">&#9670;&nbsp;</a></span>DurationArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a44cfa546dbecd78fdb541518d7867fe0">arrow::DurationArray</a> = typedef <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt;<a class="el" href="classarrow_1_1_duration_type.html">DurationType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefd4592209b60fc1aa1d6fc1f2d0f7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd4592209b60fc1aa1d6fc1f2d0f7bf">&#9670;&nbsp;</a></span>DurationBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aefd4592209b60fc1aa1d6fc1f2d0f7bf">arrow::DurationBuilder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_duration_type.html">DurationType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac28ec25ca257b62697c39d4bf10cab62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28ec25ca257b62697c39d4bf10cab62">&#9670;&nbsp;</a></span>enable_if_8bit_int</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ac28ec25ca257b62697c39d4bf10cab62">arrow::enable_if_8bit_int</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a775977292719f9e7ace109475c3d497b">is_8bit_int</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa40d4db05ea1b3772a900c4a0dc1d6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40d4db05ea1b3772a900c4a0dc1d6df">&#9670;&nbsp;</a></span>enable_if_any_binary</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aa40d4db05ea1b3772a900c4a0dc1d6df">arrow::enable_if_any_binary</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a57b69802ef6353c58cbbf30df4457bf7">is_any_binary_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5adfa6f41eb212d569e8c644b9815bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adfa6f41eb212d569e8c644b9815bd8">&#9670;&nbsp;</a></span>enable_if_base_binary</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a5adfa6f41eb212d569e8c644b9815bd8">arrow::enable_if_base_binary</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a7b18703d712bea4f0e5565ebaf84ed74">is_base_binary_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a29d51e29e6246523d1f7404ccf8f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a29d51e29e6246523d1f7404ccf8f12">&#9670;&nbsp;</a></span>enable_if_base_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a4a29d51e29e6246523d1f7404ccf8f12">arrow::enable_if_base_list</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a7f549e14653c8041a6d947fb881ce470">is_base_list_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07e76ad2a1ac1cc895d9ef4429596e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e76ad2a1ac1cc895d9ef4429596e89">&#9670;&nbsp;</a></span>enable_if_binary_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a07e76ad2a1ac1cc895d9ef4429596e89">arrow::enable_if_binary_like</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a31da5300521aeadb8c39244e672aad20">is_binary_like_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acafae5fb16a0ba015d3d5dc0ba94c059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafae5fb16a0ba015d3d5dc0ba94c059">&#9670;&nbsp;</a></span>enable_if_boolean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#acafae5fb16a0ba015d3d5dc0ba94c059">arrow::enable_if_boolean</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a1505b20d54161f765534e652d0c20118">is_boolean_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95bd19f17d8bafe6e5be8f1b6a293466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bd19f17d8bafe6e5be8f1b6a293466">&#9670;&nbsp;</a></span>enable_if_date</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a95bd19f17d8bafe6e5be8f1b6a293466">arrow::enable_if_date</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a201c518970c17cdce4d402b68510edee">is_date_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1111b82ec23da8d84da2b9aaca4bc936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1111b82ec23da8d84da2b9aaca4bc936">&#9670;&nbsp;</a></span>enable_if_decimal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a1111b82ec23da8d84da2b9aaca4bc936">arrow::enable_if_decimal</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a104b6b0fbbfcaf5420f1e4efbe06e6a0">is_decimal_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af862a54186228d55eedb5e96a177d816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af862a54186228d55eedb5e96a177d816">&#9670;&nbsp;</a></span>enable_if_duration</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#af862a54186228d55eedb5e96a177d816">arrow::enable_if_duration</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a9e8b36624157a2c34db12f20a54a20e4">is_duration_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaaf9cd29f578b7221cbd8cf4183d0d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf9cd29f578b7221cbd8cf4183d0d80">&#9670;&nbsp;</a></span>enable_if_fixed_size_binary</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aaaf9cd29f578b7221cbd8cf4183d0d80">arrow::enable_if_fixed_size_binary</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a0f1f61cca333813d5652f9cf7bc54c00">is_fixed_size_binary_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d5fd9fcbc47d7a271bc3e8acffb7419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5fd9fcbc47d7a271bc3e8acffb7419">&#9670;&nbsp;</a></span>enable_if_fixed_size_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a5d5fd9fcbc47d7a271bc3e8acffb7419">arrow::enable_if_fixed_size_list</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a2d0fa3fa76eca92942333e08afbf5e2c">is_fixed_size_list_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dddaa868c5f1b0f2b0642192f16f29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dddaa868c5f1b0f2b0642192f16f29b">&#9670;&nbsp;</a></span>enable_if_floating_point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a9dddaa868c5f1b0f2b0642192f16f29b">arrow::enable_if_floating_point</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#ab39920d433ba89ea20da9e9ff52ba0de">is_floating_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad60fed4e396b94591b87566731a74a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60fed4e396b94591b87566731a74a7a">&#9670;&nbsp;</a></span>enable_if_half_float</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ad60fed4e396b94591b87566731a74a7a">arrow::enable_if_half_float</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#af8b7471bd6e7d3ae3f2a996cca113ac5">is_half_float_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e090acba4674b10ca16691401701bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e090acba4674b10ca16691401701bd6">&#9670;&nbsp;</a></span>enable_if_has_c_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a7e090acba4674b10ca16691401701bd6">arrow::enable_if_has_c_type</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a1d618f8e1fb33c3f4ecc90094dc9eec9">has_c_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94667b305c94aaad1ed7c2b667a24fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94667b305c94aaad1ed7c2b667a24fad">&#9670;&nbsp;</a></span>enable_if_has_string_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a94667b305c94aaad1ed7c2b667a24fad">arrow::enable_if_has_string_view</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a4444a0309da790a63c0856fb90e635b7">has_string_view</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a231590a53c16996c8c7b698333f1ed82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231590a53c16996c8c7b698333f1ed82">&#9670;&nbsp;</a></span>enable_if_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a231590a53c16996c8c7b698333f1ed82">arrow::enable_if_integer</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a3858c2a0029df0a836908cd00da27a73">is_integer_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a119121074b7bfa291143daba4f5cd7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119121074b7bfa291143daba4f5cd7f0">&#9670;&nbsp;</a></span>enable_if_interval</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a119121074b7bfa291143daba4f5cd7f0">arrow::enable_if_interval</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a59ba5d87672cd108fd3b167fd258fb54">is_interval_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a391a75a25d56b15b309a520d42b7696d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391a75a25d56b15b309a520d42b7696d">&#9670;&nbsp;</a></span>enable_if_list_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a391a75a25d56b15b309a520d42b7696d">arrow::enable_if_list_like</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a2b6af17dcffa6518fe03a0e26d084814">is_list_like_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d707f9cf680a2e01f48cc972e7aa7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d707f9cf680a2e01f48cc972e7aa7dd">&#9670;&nbsp;</a></span>enable_if_memoize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Out  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a2d707f9cf680a2e01f48cc972e7aa7dd">arrow::enable_if_memoize</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; !std::is_same&lt;typename internal::DictionaryTraits&lt;T&gt;::MemoTableType, void&gt;::value, Out&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5afc66a9dd979542bb7691353facc725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afc66a9dd979542bb7691353facc725">&#9670;&nbsp;</a></span>enable_if_nested</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a5afc66a9dd979542bb7691353facc725">arrow::enable_if_nested</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a29f27de2e50e048565bb9606bb7603d6">is_nested_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b94ab6f22b2b71f032a996091499b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b94ab6f22b2b71f032a996091499b7b">&#9670;&nbsp;</a></span>enable_if_no_memoize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Out  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a4b94ab6f22b2b71f032a996091499b7b">arrow::enable_if_no_memoize</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt; std::is_same&lt;typename internal::DictionaryTraits&lt;T&gt;::MemoTableType, void&gt;::value, Out&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefffb639efbe0f7bd75e2a302b7f772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefffb639efbe0f7bd75e2a302b7f772e">&#9670;&nbsp;</a></span>enable_if_null</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aefffb639efbe0f7bd75e2a302b7f772e">arrow::enable_if_null</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#ae823a76b8a9209b0553bd12b92f7628e">is_null_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7630f411a876624d7d347e59dea8ef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7630f411a876624d7d347e59dea8ef70">&#9670;&nbsp;</a></span>enable_if_number</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a7630f411a876624d7d347e59dea8ef70">arrow::enable_if_number</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a17762801d38e85bb19ba347db78c9e38">is_number_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c7d9fa36c6e17e9653179705ab1f49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7d9fa36c6e17e9653179705ab1f49d">&#9670;&nbsp;</a></span>enable_if_parameter_free</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a6c7d9fa36c6e17e9653179705ab1f49d">arrow::enable_if_parameter_free</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a0e3a809d6228febd9b9cd5257de92971">is_paramater_free_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d501b2058862ff8b769dfbf48ba4cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d501b2058862ff8b769dfbf48ba4cd6">&#9670;&nbsp;</a></span>enable_if_physical_floating_point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a6d501b2058862ff8b769dfbf48ba4cd6">arrow::enable_if_physical_floating_point</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a9bec5260c0be3e093d9bfc1bfc4249cb">is_physical_floating_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec365fc8dcb7c75493dae0eef4871118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec365fc8dcb7c75493dae0eef4871118">&#9670;&nbsp;</a></span>enable_if_physical_signed_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aec365fc8dcb7c75493dae0eef4871118">arrow::enable_if_physical_signed_integer</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a51e9f94af3f7a0c4ed946c23c731e453">is_physical_signed_integer_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e1f2397f5492a98c6a9aaf17c5afe84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1f2397f5492a98c6a9aaf17c5afe84">&#9670;&nbsp;</a></span>enable_if_physical_unsigned_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a8e1f2397f5492a98c6a9aaf17c5afe84">arrow::enable_if_physical_unsigned_integer</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a6c99ff90cd175919ff6aabcb854287d0">is_physical_unsigned_integer_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8463908634b0318bee5971d05f00386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8463908634b0318bee5971d05f00386">&#9670;&nbsp;</a></span>enable_if_primitive_ctype</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ac8463908634b0318bee5971d05f00386">arrow::enable_if_primitive_ctype</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#af5f81113b89cbe368312906d2ea05455">is_primitive_ctype</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f130ef645ae790fb2b596b1123e6d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f130ef645ae790fb2b596b1123e6d1e">&#9670;&nbsp;</a></span>enable_if_signed_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a5f130ef645ae790fb2b596b1123e6d1e">arrow::enable_if_signed_integer</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a20dd2b914ad4a61e400eb59894d23a70">is_signed_integer_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4eb96642403fdce64b1f1f1189a859e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb96642403fdce64b1f1f1189a859e4">&#9670;&nbsp;</a></span>enable_if_string_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a4eb96642403fdce64b1f1f1189a859e4">arrow::enable_if_string_like</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a45709f39fa2d7508b0068c6e493acc5b">is_string_like_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a524c1cd0f2b105e5ad18a1410aafcba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524c1cd0f2b105e5ad18a1410aafcba0">&#9670;&nbsp;</a></span>enable_if_struct</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a524c1cd0f2b105e5ad18a1410aafcba0">arrow::enable_if_struct</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a7cc4639f9805d2ff49d79770577683bb">is_struct_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ffa941ae85f4dd1545a9fad796324c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffa941ae85f4dd1545a9fad796324c6">&#9670;&nbsp;</a></span>enable_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, typename T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">arrow::enable_if_t</a> = typedef typename std::enable_if&lt;B, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aead9c608ea64700fc81a28485d675cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead9c608ea64700fc81a28485d675cce">&#9670;&nbsp;</a></span>enable_if_temporal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aead9c608ea64700fc81a28485d675cce">arrow::enable_if_temporal</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#ad747b7b43421fb8bcb9e41e2b9ccc5e7">is_temporal_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d121c21d9bf722d5630549f91de2494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d121c21d9bf722d5630549f91de2494">&#9670;&nbsp;</a></span>enable_if_time</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a9d121c21d9bf722d5630549f91de2494">arrow::enable_if_time</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#aaa20abe6646670908e927e14fe48f238">is_time_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34f916e587fb352a2ac375ca35cb3434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f916e587fb352a2ac375ca35cb3434">&#9670;&nbsp;</a></span>enable_if_timestamp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a34f916e587fb352a2ac375ca35cb3434">arrow::enable_if_timestamp</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#abc4fc09acf6524064a074ffc9c8269ea">is_timestamp_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada6364f401be8babca103e18af1154c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6364f401be8babca103e18af1154c6">&#9670;&nbsp;</a></span>enable_if_union</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ada6364f401be8babca103e18af1154c6">arrow::enable_if_union</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#a8a8ba17a03d55c0a45607ce41c506e6b">is_union_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b2160429e178313ac15141e7277e763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2160429e178313ac15141e7277e763">&#9670;&nbsp;</a></span>enable_if_unsigned_integer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a9b2160429e178313ac15141e7277e763">arrow::enable_if_unsigned_integer</a> = typedef <a class="el" href="namespacearrow.html#a6ffa941ae85f4dd1545a9fad796324c6">enable_if_t</a>&lt;<a class="el" href="namespacearrow.html#afbff722ac55605b6945c47d8a99feb53">is_unsigned_integer_type</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc7f8a9698e4a5b6e8c3884c2cf3aedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7f8a9698e4a5b6e8c3884c2cf3aedb">&#9670;&nbsp;</a></span>FloatBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#afc7f8a9698e4a5b6e8c3884c2cf3aedb">arrow::FloatBuilder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_float_type.html">FloatType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae87957f6c01fb918bb573f04c5188ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87957f6c01fb918bb573f04c5188ca4">&#9670;&nbsp;</a></span>HalfFloatBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ae87957f6c01fb918bb573f04c5188ca4">arrow::HalfFloatBuilder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_half_float_type.html">HalfFloatType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d618f8e1fb33c3f4ecc90094dc9eec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d618f8e1fb33c3f4ecc90094dc9eec9">&#9670;&nbsp;</a></span>has_c_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a1d618f8e1fb33c3f4ecc90094dc9eec9">arrow::has_c_type</a> = typedef std::integral_constant&lt;bool, <a class="el" href="namespacearrow.html#af5f81113b89cbe368312906d2ea05455">is_primitive_ctype</a>&lt;T&gt;::value || <a class="el" href="namespacearrow.html#ad747b7b43421fb8bcb9e41e2b9ccc5e7">is_temporal_type</a>&lt;T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4444a0309da790a63c0856fb90e635b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4444a0309da790a63c0856fb90e635b7">&#9670;&nbsp;</a></span>has_string_view</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a4444a0309da790a63c0856fb90e635b7">arrow::has_string_view</a> = typedef std::integral_constant&lt;bool, <a class="el" href="namespacearrow.html#a31da5300521aeadb8c39244e672aad20">is_binary_like_type</a>&lt;T&gt;::value || <a class="el" href="namespacearrow.html#a45709f39fa2d7508b0068c6e493acc5b">is_string_like_type</a>&lt;T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5ad5330bb34a045c6e87ecee875057e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ad5330bb34a045c6e87ecee875057e">&#9670;&nbsp;</a></span>Int16Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ab5ad5330bb34a045c6e87ecee875057e">arrow::Int16Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_int16_type.html">Int16Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a031c893d8d592c7a099bb9bea3a25f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031c893d8d592c7a099bb9bea3a25f86">&#9670;&nbsp;</a></span>Int32Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a031c893d8d592c7a099bb9bea3a25f86">arrow::Int32Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_int32_type.html">Int32Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08fa80026c56e0f1ff24b43c4dc33e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fa80026c56e0f1ff24b43c4dc33e61">&#9670;&nbsp;</a></span>Int64Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a08fa80026c56e0f1ff24b43c4dc33e61">arrow::Int64Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_int64_type.html">Int64Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9675d2aecdd6ad622ee1358c358ba278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9675d2aecdd6ad622ee1358c358ba278">&#9670;&nbsp;</a></span>Int8Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a9675d2aecdd6ad622ee1358c358ba278">arrow::Int8Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_int8_type.html">Int8Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a775977292719f9e7ace109475c3d497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775977292719f9e7ace109475c3d497b">&#9670;&nbsp;</a></span>is_8bit_int</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a775977292719f9e7ace109475c3d497b">arrow::is_8bit_int</a> = typedef std::integral_constant&lt;bool, std::is_same&lt;<a class="el" href="classarrow_1_1_u_int8_type.html">UInt8Type</a>, T&gt;::value || std::is_same&lt;<a class="el" href="classarrow_1_1_int8_type.html">Int8Type</a>, T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57b69802ef6353c58cbbf30df4457bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b69802ef6353c58cbbf30df4457bf7">&#9670;&nbsp;</a></span>is_any_binary_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a57b69802ef6353c58cbbf30df4457bf7">arrow::is_any_binary_type</a> = typedef std::integral_constant&lt;bool, std::is_same&lt;<a class="el" href="classarrow_1_1_binary_type.html">BinaryType</a>, T&gt;::value || std::is_same&lt;<a class="el" href="classarrow_1_1_large_binary_type.html">LargeBinaryType</a>, T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b18703d712bea4f0e5565ebaf84ed74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b18703d712bea4f0e5565ebaf84ed74">&#9670;&nbsp;</a></span>is_base_binary_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a7b18703d712bea4f0e5565ebaf84ed74">arrow::is_base_binary_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_base_binary_type.html">BaseBinaryType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f549e14653c8041a6d947fb881ce470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f549e14653c8041a6d947fb881ce470">&#9670;&nbsp;</a></span>is_base_list_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a7f549e14653c8041a6d947fb881ce470">arrow::is_base_list_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_base_list_type.html">BaseListType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31da5300521aeadb8c39244e672aad20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31da5300521aeadb8c39244e672aad20">&#9670;&nbsp;</a></span>is_binary_like_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a31da5300521aeadb8c39244e672aad20">arrow::is_binary_like_type</a> = typedef std::integral_constant&lt;bool, (<a class="el" href="namespacearrow.html#a7b18703d712bea4f0e5565ebaf84ed74">is_base_binary_type</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="namespacearrow.html#a45709f39fa2d7508b0068c6e493acc5b">is_string_like_type</a>&lt;T&gt;::value) || <a class="el" href="namespacearrow.html#a0f1f61cca333813d5652f9cf7bc54c00">is_fixed_size_binary_type</a>&lt;T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1505b20d54161f765534e652d0c20118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1505b20d54161f765534e652d0c20118">&#9670;&nbsp;</a></span>is_boolean_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a1505b20d54161f765534e652d0c20118">arrow::is_boolean_type</a> = typedef std::is_same&lt;<a class="el" href="classarrow_1_1_boolean_type.html">BooleanType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a201c518970c17cdce4d402b68510edee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201c518970c17cdce4d402b68510edee">&#9670;&nbsp;</a></span>is_date_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a201c518970c17cdce4d402b68510edee">arrow::is_date_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_date_type.html">DateType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a104b6b0fbbfcaf5420f1e4efbe06e6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104b6b0fbbfcaf5420f1e4efbe06e6a0">&#9670;&nbsp;</a></span>is_decimal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a104b6b0fbbfcaf5420f1e4efbe06e6a0">arrow::is_decimal_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_decimal_type.html">DecimalType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e8b36624157a2c34db12f20a54a20e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8b36624157a2c34db12f20a54a20e4">&#9670;&nbsp;</a></span>is_duration_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a9e8b36624157a2c34db12f20a54a20e4">arrow::is_duration_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_duration_type.html">DurationType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f1f61cca333813d5652f9cf7bc54c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1f61cca333813d5652f9cf7bc54c00">&#9670;&nbsp;</a></span>is_fixed_size_binary_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a0f1f61cca333813d5652f9cf7bc54c00">arrow::is_fixed_size_binary_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_fixed_size_binary_type.html">FixedSizeBinaryType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d0fa3fa76eca92942333e08afbf5e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0fa3fa76eca92942333e08afbf5e2c">&#9670;&nbsp;</a></span>is_fixed_size_list_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a2d0fa3fa76eca92942333e08afbf5e2c">arrow::is_fixed_size_list_type</a> = typedef std::is_same&lt;<a class="el" href="classarrow_1_1_fixed_size_list_type.html">FixedSizeListType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab39920d433ba89ea20da9e9ff52ba0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39920d433ba89ea20da9e9ff52ba0de">&#9670;&nbsp;</a></span>is_floating_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ab39920d433ba89ea20da9e9ff52ba0de">arrow::is_floating_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_floating_point_type.html">FloatingPointType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8b7471bd6e7d3ae3f2a996cca113ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b7471bd6e7d3ae3f2a996cca113ac5">&#9670;&nbsp;</a></span>is_half_float_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#af8b7471bd6e7d3ae3f2a996cca113ac5">arrow::is_half_float_type</a> = typedef std::is_same&lt;<a class="el" href="classarrow_1_1_half_float_type.html">HalfFloatType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3858c2a0029df0a836908cd00da27a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3858c2a0029df0a836908cd00da27a73">&#9670;&nbsp;</a></span>is_integer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a3858c2a0029df0a836908cd00da27a73">arrow::is_integer_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_integer_type.html">IntegerType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59ba5d87672cd108fd3b167fd258fb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ba5d87672cd108fd3b167fd258fb54">&#9670;&nbsp;</a></span>is_interval_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a59ba5d87672cd108fd3b167fd258fb54">arrow::is_interval_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_interval_type.html">IntervalType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b6af17dcffa6518fe03a0e26d084814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6af17dcffa6518fe03a0e26d084814">&#9670;&nbsp;</a></span>is_list_like_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a2b6af17dcffa6518fe03a0e26d084814">arrow::is_list_like_type</a> = typedef std::integral_constant&lt;bool, <a class="el" href="namespacearrow.html#a7f549e14653c8041a6d947fb881ce470">is_base_list_type</a>&lt;T&gt;::value || <a class="el" href="namespacearrow.html#a2d0fa3fa76eca92942333e08afbf5e2c">is_fixed_size_list_type</a>&lt;T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29f27de2e50e048565bb9606bb7603d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f27de2e50e048565bb9606bb7603d6">&#9670;&nbsp;</a></span>is_nested_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a29f27de2e50e048565bb9606bb7603d6">arrow::is_nested_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_nested_type.html">NestedType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae823a76b8a9209b0553bd12b92f7628e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae823a76b8a9209b0553bd12b92f7628e">&#9670;&nbsp;</a></span>is_null_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ae823a76b8a9209b0553bd12b92f7628e">arrow::is_null_type</a> = typedef std::is_same&lt;<a class="el" href="classarrow_1_1_null_type.html">NullType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17762801d38e85bb19ba347db78c9e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17762801d38e85bb19ba347db78c9e38">&#9670;&nbsp;</a></span>is_number_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a17762801d38e85bb19ba347db78c9e38">arrow::is_number_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_number_type.html">NumberType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e3a809d6228febd9b9cd5257de92971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3a809d6228febd9b9cd5257de92971">&#9670;&nbsp;</a></span>is_paramater_free_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a0e3a809d6228febd9b9cd5257de92971">arrow::is_paramater_free_type</a> = typedef std::integral_constant&lt;bool, <a class="el" href="structarrow_1_1_type_traits.html">TypeTraits</a>&lt;T&gt;::is_parameter_free&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bec5260c0be3e093d9bfc1bfc4249cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bec5260c0be3e093d9bfc1bfc4249cb">&#9670;&nbsp;</a></span>is_physical_floating_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a9bec5260c0be3e093d9bfc1bfc4249cb">arrow::is_physical_floating_type</a> = typedef std::integral_constant&lt;bool, <a class="el" href="namespacearrow.html#ab39920d433ba89ea20da9e9ff52ba0de">is_floating_type</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="namespacearrow.html#af8b7471bd6e7d3ae3f2a996cca113ac5">is_half_float_type</a>&lt;T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51e9f94af3f7a0c4ed946c23c731e453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e9f94af3f7a0c4ed946c23c731e453">&#9670;&nbsp;</a></span>is_physical_signed_integer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a51e9f94af3f7a0c4ed946c23c731e453">arrow::is_physical_signed_integer_type</a> = typedef std::integral_constant&lt;bool, <a class="el" href="namespacearrow.html#a20dd2b914ad4a61e400eb59894d23a70">is_signed_integer_type</a>&lt;T&gt;::value || (<a class="el" href="namespacearrow.html#ad747b7b43421fb8bcb9e41e2b9ccc5e7">is_temporal_type</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="namespacearrow.html#a1d618f8e1fb33c3f4ecc90094dc9eec9">has_c_type</a>&lt;T&gt;::value)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c99ff90cd175919ff6aabcb854287d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c99ff90cd175919ff6aabcb854287d0">&#9670;&nbsp;</a></span>is_physical_unsigned_integer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a6c99ff90cd175919ff6aabcb854287d0">arrow::is_physical_unsigned_integer_type</a> = typedef std::integral_constant&lt;bool, <a class="el" href="namespacearrow.html#afbff722ac55605b6945c47d8a99feb53">is_unsigned_integer_type</a>&lt;T&gt;::value || <a class="el" href="namespacearrow.html#af8b7471bd6e7d3ae3f2a996cca113ac5">is_half_float_type</a>&lt;T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5f81113b89cbe368312906d2ea05455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f81113b89cbe368312906d2ea05455">&#9670;&nbsp;</a></span>is_primitive_ctype</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#af5f81113b89cbe368312906d2ea05455">arrow::is_primitive_ctype</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_primitive_c_type.html">PrimitiveCType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20dd2b914ad4a61e400eb59894d23a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20dd2b914ad4a61e400eb59894d23a70">&#9670;&nbsp;</a></span>is_signed_integer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a20dd2b914ad4a61e400eb59894d23a70">arrow::is_signed_integer_type</a> = typedef std::integral_constant&lt;bool, <a class="el" href="namespacearrow.html#a3858c2a0029df0a836908cd00da27a73">is_integer_type</a>&lt;T&gt;::value &amp;&amp; std::is_signed&lt;typename T::c_type&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45709f39fa2d7508b0068c6e493acc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45709f39fa2d7508b0068c6e493acc5b">&#9670;&nbsp;</a></span>is_string_like_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a45709f39fa2d7508b0068c6e493acc5b">arrow::is_string_like_type</a> = typedef std::integral_constant&lt;bool, <a class="el" href="namespacearrow.html#a7b18703d712bea4f0e5565ebaf84ed74">is_base_binary_type</a>&lt;T&gt;::value &amp;&amp; T::is_utf8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cc4639f9805d2ff49d79770577683bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc4639f9805d2ff49d79770577683bb">&#9670;&nbsp;</a></span>is_struct_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a7cc4639f9805d2ff49d79770577683bb">arrow::is_struct_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_struct_type.html">StructType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad747b7b43421fb8bcb9e41e2b9ccc5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad747b7b43421fb8bcb9e41e2b9ccc5e7">&#9670;&nbsp;</a></span>is_temporal_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ad747b7b43421fb8bcb9e41e2b9ccc5e7">arrow::is_temporal_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_temporal_type.html">TemporalType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa20abe6646670908e927e14fe48f238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa20abe6646670908e927e14fe48f238">&#9670;&nbsp;</a></span>is_time_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#aaa20abe6646670908e927e14fe48f238">arrow::is_time_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_time_type.html">TimeType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc4fc09acf6524064a074ffc9c8269ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4fc09acf6524064a074ffc9c8269ea">&#9670;&nbsp;</a></span>is_timestamp_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#abc4fc09acf6524064a074ffc9c8269ea">arrow::is_timestamp_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_timestamp_type.html">TimestampType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a8ba17a03d55c0a45607ce41c506e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8ba17a03d55c0a45607ce41c506e6b">&#9670;&nbsp;</a></span>is_union_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a8a8ba17a03d55c0a45607ce41c506e6b">arrow::is_union_type</a> = typedef std::is_base_of&lt;<a class="el" href="classarrow_1_1_union_type.html">UnionType</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbff722ac55605b6945c47d8a99feb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbff722ac55605b6945c47d8a99feb53">&#9670;&nbsp;</a></span>is_unsigned_integer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#afbff722ac55605b6945c47d8a99feb53">arrow::is_unsigned_integer_type</a> = typedef std::integral_constant&lt;bool, <a class="el" href="namespacearrow.html#a3858c2a0029df0a836908cd00da27a73">is_integer_type</a>&lt;T&gt;::value &amp;&amp; std::is_unsigned&lt;typename T::c_type&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a182e773860b508e71ad82e8aa2b9556c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182e773860b508e71ad82e8aa2b9556c">&#9670;&nbsp;</a></span>MonthIntervalArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a182e773860b508e71ad82e8aa2b9556c">arrow::MonthIntervalArray</a> = typedef <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt;<a class="el" href="classarrow_1_1_month_interval_type.html">MonthIntervalType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f513441e20a820ba699fb943d527e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f513441e20a820ba699fb943d527e03">&#9670;&nbsp;</a></span>MonthIntervalBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a8f513441e20a820ba699fb943d527e03">arrow::MonthIntervalBuilder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_month_interval_type.html">MonthIntervalType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98532acfa6b99a8c35c14d2484cd65bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98532acfa6b99a8c35c14d2484cd65bb">&#9670;&nbsp;</a></span>RecordBatchIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a98532acfa6b99a8c35c14d2484cd65bb">arrow::RecordBatchIterator</a> = typedef <a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;std::shared_ptr&lt;<a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9b05a1d2db4d6cce70e2adc6ae983f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b05a1d2db4d6cce70e2adc6ae983f9">&#9670;&nbsp;</a></span>SparseCOOTensor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#ac9b05a1d2db4d6cce70e2adc6ae983f9">arrow::SparseCOOTensor</a> = typedef <a class="el" href="classarrow_1_1_sparse_tensor_impl.html">SparseTensorImpl</a>&lt;<a class="el" href="classarrow_1_1_sparse_c_o_o_index.html">SparseCOOIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EXPERIMENTAL: <a class="el" href="structarrow_1_1_type.html">Type</a> alias for COO sparse tensor. </p>

</div>
</div>
<a id="a365a8eacbf769f8ce28bac334b84690c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365a8eacbf769f8ce28bac334b84690c">&#9670;&nbsp;</a></span>SparseCSCMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a365a8eacbf769f8ce28bac334b84690c">arrow::SparseCSCMatrix</a> = typedef <a class="el" href="classarrow_1_1_sparse_tensor_impl.html">SparseTensorImpl</a>&lt;<a class="el" href="classarrow_1_1_sparse_c_s_c_index.html">SparseCSCIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EXPERIMENTAL: <a class="el" href="structarrow_1_1_type.html">Type</a> alias for CSC sparse matrix. </p>

</div>
</div>
<a id="a30853e74abee092db4aa50440dab9ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30853e74abee092db4aa50440dab9ce8">&#9670;&nbsp;</a></span>SparseCSRMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a30853e74abee092db4aa50440dab9ce8">arrow::SparseCSRMatrix</a> = typedef <a class="el" href="classarrow_1_1_sparse_tensor_impl.html">SparseTensorImpl</a>&lt;<a class="el" href="classarrow_1_1_sparse_c_s_r_index.html">SparseCSRIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EXPERIMENTAL: <a class="el" href="structarrow_1_1_type.html">Type</a> alias for CSR sparse matrix. </p>

</div>
</div>
<a id="a97345da72ba3bedb03d2b93e8c039b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97345da72ba3bedb03d2b93e8c039b19">&#9670;&nbsp;</a></span>Time32Array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a97345da72ba3bedb03d2b93e8c039b19">arrow::Time32Array</a> = typedef <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt;<a class="el" href="classarrow_1_1_time32_type.html">Time32Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d407b259c6792c8b8bbb86959259721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d407b259c6792c8b8bbb86959259721">&#9670;&nbsp;</a></span>Time32Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a8d407b259c6792c8b8bbb86959259721">arrow::Time32Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_time32_type.html">Time32Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a093e1d42b3a49745a128a04736b56fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093e1d42b3a49745a128a04736b56fad">&#9670;&nbsp;</a></span>Time64Array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a093e1d42b3a49745a128a04736b56fad">arrow::Time64Array</a> = typedef <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt;<a class="el" href="classarrow_1_1_time64_type.html">Time64Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a682d18a383e3cc604c5add634bde4980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682d18a383e3cc604c5add634bde4980">&#9670;&nbsp;</a></span>Time64Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a682d18a383e3cc604c5add634bde4980">arrow::Time64Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_time64_type.html">Time64Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8da84bd82ad0d204965fe95d134a6c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da84bd82ad0d204965fe95d134a6c08">&#9670;&nbsp;</a></span>TimestampArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a8da84bd82ad0d204965fe95d134a6c08">arrow::TimestampArray</a> = typedef <a class="el" href="classarrow_1_1_numeric_array.html">NumericArray</a>&lt;<a class="el" href="classarrow_1_1_timestamp_type.html">TimestampType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c24ba298ea48738e160ebcf6133aa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c24ba298ea48738e160ebcf6133aa2f">&#9670;&nbsp;</a></span>TimestampBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a7c24ba298ea48738e160ebcf6133aa2f">arrow::TimestampBuilder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_timestamp_type.html">TimestampType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f7720234c751cfa79a0d6d4e2014485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7720234c751cfa79a0d6d4e2014485">&#9670;&nbsp;</a></span>UInt16Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a6f7720234c751cfa79a0d6d4e2014485">arrow::UInt16Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_u_int16_type.html">UInt16Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54e6101656a21b97a88179c8d1c453b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e6101656a21b97a88179c8d1c453b9">&#9670;&nbsp;</a></span>UInt32Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a54e6101656a21b97a88179c8d1c453b9">arrow::UInt32Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_u_int32_type.html">UInt32Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1777cb0f7c98036ad6f078fa0f1a6829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1777cb0f7c98036ad6f078fa0f1a6829">&#9670;&nbsp;</a></span>UInt64Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#a1777cb0f7c98036ad6f078fa0f1a6829">arrow::UInt64Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_u_int64_type.html">UInt64Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adab028f188008a82d790cd69ac351a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab028f188008a82d790cd69ac351a3b">&#9670;&nbsp;</a></span>UInt8Builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacearrow.html#adab028f188008a82d790cd69ac351a3b">arrow::UInt8Builder</a> = typedef <a class="el" href="classarrow_1_1_numeric_builder.html">NumericBuilder</a>&lt;<a class="el" href="classarrow_1_1_u_int8_type.html">UInt8Type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a04410292f01b108a8a8af3c7077afcda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04410292f01b108a8a8af3c7077afcda">&#9670;&nbsp;</a></span>DateUnit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacearrow.html#a04410292f01b108a8a8af3c7077afcda">arrow::DateUnit</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04410292f01b108a8a8af3c7077afcdaa5b1d59b5451c06afb65ab1bc2713cfb4"></a>DAY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04410292f01b108a8a8af3c7077afcdaa8f06f9f0a1efa42a2ad3ec880b0a1f70"></a>MILLI&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a57a966e51cab768580c6f9a9427f34d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a966e51cab768580c6f9a9427f34d2">&#9670;&nbsp;</a></span>DecimalStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacearrow.html#a57a966e51cab768580c6f9a9427f34d2">arrow::DecimalStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a57a966e51cab768580c6f9a9427f34d2a8c632159fa131f09d04f94e3cbcd8782"></a>kSuccess&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a57a966e51cab768580c6f9a9427f34d2a41ef173591458a0b06e7f793fb7ed46c"></a>kDivideByZero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a57a966e51cab768580c6f9a9427f34d2aae5484a6f25ec42ff2fc33b0fc8bc2d5"></a>kOverflow&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a57a966e51cab768580c6f9a9427f34d2ac1d48c17e57675d19e1fdb51b625e8c3"></a>kRescaleDataLoss&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a331ad1dbd1c157c8be168cb6548d188f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331ad1dbd1c157c8be168cb6548d188f">&#9670;&nbsp;</a></span>StatusCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacearrow.html#a331ad1dbd1c157c8be168cb6548d188f">arrow::StatusCode</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fae0aa021e21dddbd6d8cecec71e9cf564"></a>OK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fab498327feeb51430af73e07deac268fd"></a>OutOfMemory&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fac84999914a408f8c02b4122a49df6e00"></a>KeyError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa137bf8cff2d59f0883c600f9524b3eed"></a>TypeError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa5206bd7472156351d2d9a99633ac9580"></a>IOError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa65f55acee27ef038c04505e05dbf6c35"></a>CapacityError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188faeb6ff05a2e9b0485ea84cbe3809e36ed"></a>IndexError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fabfaef30f1c8011c5cefa38ae470fb7aa"></a>UnknownError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa997ca4ce119685f40f03a9a8a6c5346e"></a>NotImplemented&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa64353c9071b50ec2fe6b90ed122471a8"></a>SerializationError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa92f049e5e1d59cc2f960d1974c50e072"></a>RError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa8a938435e76704025c8ab2b7f7a7ca52"></a>CodeGenError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa70b5374da923fd3b982ac38c1fd20bc3"></a>ExpressionValidationError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa6e129f00c2572c6d267cf433bc9ad99e"></a>ExecutionError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a331ad1dbd1c157c8be168cb6548d188fa89b69484680b18e9179e826c6e023805"></a>AlreadyExists&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a73d896fc0a4a06fa37f6da05a1a0da44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d896fc0a4a06fa37f6da05a1a0da44">&#9670;&nbsp;</a></span>ArrayApproxEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::ArrayApproxEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_equal_options.html">EqualOptions</a> &amp;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="classarrow_1_1_equal_options.html#aceb7c9984ead6d5a79ba4a725193d452">EqualOptions::Defaults</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the arrays are approximately equal. </p>
<p>For non-floating point types, this is equivalent to ArrayEquals(left, right) </p>

</div>
</div>
<a id="aa2ecf91f56f47a6d73b95e09d05b4de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ecf91f56f47a6d73b95e09d05b4de9">&#9670;&nbsp;</a></span>ArrayEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::ArrayEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_equal_options.html">EqualOptions</a> &amp;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="classarrow_1_1_equal_options.html#aceb7c9984ead6d5a79ba4a725193d452">EqualOptions::Defaults</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the arrays are exactly equal. </p>

</div>
</div>
<a id="a1d4576fdd48ce9e8484b30e3b94fd00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4576fdd48ce9e8484b30e3b94fd00d">&#9670;&nbsp;</a></span>ArrayRangeEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::ArrayRangeEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>end_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>other_start_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if indicated equal-length segment of arrays is exactly equal. </p>

</div>
</div>
<a id="a832b1cd8b78ca5af346b5ff1bc0d8df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832b1cd8b78ca5af346b5ff1bc0d8df5">&#9670;&nbsp;</a></span>Concatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::Concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacearrow.html#aecf659a72f5db1c837409580f11bd337">ArrayVector</a> &amp;&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arrays</td><td>a vector of arrays to be concatenated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>memory to store the result will be allocated from this memory pool </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the resulting concatenated array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="acc529837f8c4825ef5ae3ecee7e614d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc529837f8c4825ef5ae3ecee7e614d5">&#9670;&nbsp;</a></span>DebugPrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::DebugPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebe81d544faaf827b8f32c5a80b99820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe81d544faaf827b8f32c5a80b99820">&#9670;&nbsp;</a></span>default_memory_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a>* arrow::default_memory_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the process-wide default memory pool. </p>

</div>
</div>
<a id="a0d16f62627582ce40fcb90f88471c67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d16f62627582ce40fcb90f88471c67e">&#9670;&nbsp;</a></span>Diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt;std::shared_ptr&lt;<a class="el" href="classarrow_1_1_struct_array.html">StructArray</a>&gt; &gt; arrow::Diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two arrays, returning an edit script which expresses the difference between them. </p>
<p>An edit script is an array of struct(insert: bool, run_length: int64_t). Each element of "insert" determines whether an element was inserted into (true) or deleted from (false) base. Each insertion or deletion is followed by a run of elements which are unchanged from base to target; the length of this run is stored in "run_length". (Note that the edit script begins and ends with a run of shared elements but both fields of the struct must have the same length. To accomodate this the first element of "insert" should be ignored.)</p>
<p>For example for base "hlloo" and target "hello", the edit script would be [ {"insert": false, "run_length": 1}, // leading run of length 1 ("h") {"insert": true, "run_length": 3}, // insert("e") then a run of length 3 ("llo") {"insert": false, "run_length": 0} // delete("o") then an empty run ]</p>
<p>Diffing arrays containing nulls is not currently supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>baseline for comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>an array of identical type to base whose elements differ from base's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>memory to store the result will be allocated from this memory pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an edit script array which can be applied to base to produce target </dd></dl>

</div>
</div>
<a id="af0898d30c6a1068bbfc1ccf9064aa8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0898d30c6a1068bbfc1ccf9064aa8ec">&#9670;&nbsp;</a></span>Escape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string arrow::Escape </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad438db68959b2071de6b71a919316da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad438db68959b2071de6b71a919316da0">&#9670;&nbsp;</a></span>Escape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string arrow::Escape </td>
          <td>(</td>
          <td class="paramtype">util::string_view&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a187c243ea680906ebe9d2c20ab311940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187c243ea680906ebe9d2c20ab311940">&#9670;&nbsp;</a></span>GetCpuThreadPoolCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::GetCpuThreadPoolCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the capacity of the global thread pool. </p>
<p>Return the number of worker threads in the thread pool to which Arrow dispatches various CPU-bound tasks. This is an ideal number, not necessarily the exact number of threads at a given point in time.</p>
<p>You can change this number using <a class="el" href="namespacearrow.html#aa103995039a823ac5ce376994562f06d" title="Set the capacity of the global thread pool.">SetCpuThreadPoolCapacity()</a>. </p>

</div>
</div>
<a id="a2fb2b23cadfc295fdafbddb144f695ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb2b23cadfc295fdafbddb144f695ca">&#9670;&nbsp;</a></span>GetExtensionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_extension_type.html">ExtensionType</a>&gt; arrow::GetExtensionType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an extension type from the global registry. </p>
<p>Returns nullptr if not found. This method is thread-safe </p><dl class="section return"><dt>Returns</dt><dd>the globally-registered extension type </dd></dl>

</div>
</div>
<a id="a98ac42e0d52b7800aafbbbcf2587b5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ac42e0d52b7800aafbbbcf2587b5d6">&#9670;&nbsp;</a></span>HexEncode() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string arrow::HexEncode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cc96e2a2b4dca763befd1d172134ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc96e2a2b4dca763befd1d172134ac2">&#9670;&nbsp;</a></span>HexEncode() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string arrow::HexEncode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3c7f8cdc8482addd98d3066653080d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c7f8cdc8482addd98d3066653080d0">&#9670;&nbsp;</a></span>HexEncode() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string arrow::HexEncode </td>
          <td>(</td>
          <td class="paramtype">util::string_view&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07e44d557d9f98ba7a42bbcba1fb7698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e44d557d9f98ba7a42bbcba1fb7698">&#9670;&nbsp;</a></span>jemalloc_memory_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::jemalloc_memory_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> **&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a process-wide memory pool based on jemalloc. </p>
<p>May return NotImplemented if jemalloc is not available. </p>

</div>
</div>
<a id="ad0ebc0eb6975ac95276758b9a171c82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ebc0eb6975ac95276758b9a171c82d">&#9670;&nbsp;</a></span>jemalloc_set_decay_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::jemalloc_set_decay_ms </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set jemalloc memory page purging behavior for future-created arenas to the indicated number of milliseconds. </p>
<p>See dirty_decay_ms and muzzy_decay_ms options in jemalloc for a description of what these do. The default is configured to 1000 (1 second) which releases memory more aggressively to the operating system than the jemalloc default of 10 seconds. If you set the value to 0, dirty / muzzy pages will be released immediately rather than with a time decay, but this may reduce application performance. </p>

</div>
</div>
<a id="ae2b06732381cac7996882e17c245290a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b06732381cac7996882e17c245290a">&#9670;&nbsp;</a></span>key_value_metadata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a>&gt; arrow::key_value_metadata </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classarrow_1_1_key_value_metadata.html" title="A container for key-value pair type metadata. Not thread-safe.">KeyValueMetadata</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>key-value mapping </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11383090fb23bb3b0fe7e623247aa297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11383090fb23bb3b0fe7e623247aa297">&#9670;&nbsp;</a></span>key_value_metadata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_key_value_metadata.html">KeyValueMetadata</a>&gt; arrow::key_value_metadata </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classarrow_1_1_key_value_metadata.html" title="A container for key-value pair type metadata. Not thread-safe.">KeyValueMetadata</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>sequence of metadata keys </td></tr>
    <tr><td class="paramname">values</td><td>sequence of corresponding metadata values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7edcc7f88dec3ddcfcd8ccf1882cb833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edcc7f88dec3ddcfcd8ccf1882cb833">&#9670;&nbsp;</a></span>MakeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_array.html">Array</a>&gt; arrow::MakeArray </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structarrow_1_1_array_data.html">ArrayData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a strongly-typed <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance from generic <a class="el" href="structarrow_1_1_array_data.html" title="Mutable container for generic Arrow array data.">ArrayData</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the array contents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance </dd></dl>

</div>
</div>
<a id="af4593951e6af46e335bd41121192e6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4593951e6af46e335bd41121192e6c4">&#9670;&nbsp;</a></span>MakeArrayFromScalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::MakeArrayFromScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance whose slots are the given scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>the value with which to fill the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the array length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5bc3e67510177ec60c965a2e59d310a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bc3e67510177ec60c965a2e59d310a">&#9670;&nbsp;</a></span>MakeArrayFromScalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::MakeArrayFromScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a strongly-typed <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance with all elements null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>the pool from which memory for this array will be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>the value with which to fill the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the array length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a215f8e56eb8f3c0c6ce42f6bd2456f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215f8e56eb8f3c0c6ce42f6bd2456f29">&#9670;&nbsp;</a></span>MakeArrayOfNull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::MakeArrayOfNull </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a strongly-typed <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance with all elements null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the array type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the array length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca90ffe324b4b915c0bfa4a048f73952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca90ffe324b4b915c0bfa4a048f73952">&#9670;&nbsp;</a></span>MakeArrayOfNull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::MakeArrayOfNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a strongly-typed <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance with all elements null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>the pool from which memory for this array will be allocated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>the array type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>the array length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>resulting <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a> instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08900491dab187842698af9cca156b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08900491dab187842698af9cca156b17">&#9670;&nbsp;</a></span>MakeBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::MakeBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classarrow_1_1_array_builder.html">ArrayBuilder</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty <a class="el" href="classarrow_1_1_array_builder.html" title="Base class for all data array builders.">ArrayBuilder</a> corresponding to the data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>the <a class="el" href="classarrow_1_1_memory_pool.html" title="Base class for memory allocation.">MemoryPool</a> to use for allocations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>an instance of <a class="el" href="classarrow_1_1_dictionary_type.html" title="Dictionary-encoded value type with data-dependent dictionary.">DictionaryType</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the created <a class="el" href="classarrow_1_1_array_builder.html" title="Base class for all data array builders.">ArrayBuilder</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f56be53f725a2959311b30c314f94fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f56be53f725a2959311b30c314f94fb">&#9670;&nbsp;</a></span>MakeDictionaryBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::MakeDictionaryBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classarrow_1_1_array_builder.html">ArrayBuilder</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty <a class="el" href="classarrow_1_1_dictionary_builder.html" title="A DictionaryArray builder that uses AdaptiveIntBuilder to return the smallest index size that can acc...">DictionaryBuilder</a> initialized optionally with a pre-existing dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td>the <a class="el" href="classarrow_1_1_memory_pool.html" title="Base class for memory allocation.">MemoryPool</a> to use for allocations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>an instance of <a class="el" href="classarrow_1_1_dictionary_type.html" title="Dictionary-encoded value type with data-dependent dictionary.">DictionaryType</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dictionary</td><td>the initial dictionary, if any. May be nullptr </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the created <a class="el" href="classarrow_1_1_array_builder.html" title="Base class for all data array builders.">ArrayBuilder</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac88b501daab08dda0e148de95dd68d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88b501daab08dda0e148de95dd68d94">&#9670;&nbsp;</a></span>MakeEmptyIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;T&gt; arrow::MakeEmptyIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab926f5eb39c55824dd5a7cf146ca867e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab926f5eb39c55824dd5a7cf146ca867e">&#9670;&nbsp;</a></span>MakeErrorIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;T&gt; arrow::MakeErrorIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_status.html">Status</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62c38fa56ca1c43c4b0a2acd98de9624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c38fa56ca1c43c4b0a2acd98de9624">&#9670;&nbsp;</a></span>MakeFilterIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename From  = typename internal::call_traits::argument_type&lt;0, Fn&gt;, typename Ret  = typename internal::call_traits::return_type&lt;Fn&gt;::ValueType, typename To  = typename std::tuple_element&lt;0, Ret&gt;::type, typename Enable  = typename std::enable_if&lt;std::is_same&lt;        typename std::tuple_element&lt;1, Ret&gt;::type, FilterIterator::Action&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;To&gt; arrow::MakeFilterIterator </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; From &gt;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classarrow_1_1_map_iterator.html" title="MapIterator takes ownership of an iterator and a function to apply on every element.">MapIterator</a>, but where the function can fail or reject elements. </p>

</div>
</div>
<a id="a6975d6cac55ba9bd6b286030381b862c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6975d6cac55ba9bd6b286030381b862c">&#9670;&nbsp;</a></span>MakeFlattenIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;T&gt; arrow::MakeFlattenIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; <a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbe9311bc4b5b80d1cc42102bb1542ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe9311bc4b5b80d1cc42102bb1542ab">&#9670;&nbsp;</a></span>MakeFunctionIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename Ret  = typename internal::call_traits::return_type&lt;Fn&gt;::ValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;Ret&gt; arrow::MakeFunctionIterator </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="classarrow_1_1_iterator.html" title="A generic Iterator that can return errors.">Iterator</a> which invokes a callable on Next() </p>

</div>
</div>
<a id="a0739021d27a4ce9b060cd1d0fb537821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0739021d27a4ce9b060cd1d0fb537821">&#9670;&nbsp;</a></span>MakeMapIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename From  = internal::call_traits::argument_type&lt;0, Fn&gt;, typename To  = internal::call_traits::return_type&lt;Fn&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;To&gt; arrow::MakeMapIterator </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; From &gt;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classarrow_1_1_map_iterator.html" title="MapIterator takes ownership of an iterator and a function to apply on every element.">MapIterator</a> takes ownership of an iterator and a function to apply on every element. </p>
<p>The mapped function is not allowed to fail. </p>

</div>
</div>
<a id="a91b921bf603b379a7e9a25236ec3fe79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b921bf603b379a7e9a25236ec3fe79">&#9670;&nbsp;</a></span>MakeMaybeMapIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename From  = internal::call_traits::argument_type&lt;0, Fn&gt;, typename To  = typename internal::call_traits::return_type&lt;Fn&gt;::ValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;To&gt; arrow::MakeMaybeMapIterator </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; From &gt;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classarrow_1_1_map_iterator.html" title="MapIterator takes ownership of an iterator and a function to apply on every element.">MapIterator</a>, but where the function can fail. </p>

</div>
</div>
<a id="acbc24abeb218eea1d217a52c7ed0a4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc24abeb218eea1d217a52c7ed0a4a0">&#9670;&nbsp;</a></span>MakeNewlineBoundaryFinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1_boundary_finder.html">BoundaryFinder</a>&gt; arrow::MakeNewlineBoundaryFinder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7072e41124f0528a0d802cb27315e009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7072e41124f0528a0d802cb27315e009">&#9670;&nbsp;</a></span>MakeNullScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structarrow_1_1_scalar.html">Scalar</a>&gt; arrow::MakeNullScalar </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a664b7dc6954a6f27fc0e3b1ea4db551d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664b7dc6954a6f27fc0e3b1ea4db551d">&#9670;&nbsp;</a></span>MakeReadaheadIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt;<a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;T&gt; &gt; arrow::MakeReadaheadIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>readahead_queue_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7096f428f7abf51444aae487cb689a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7096f428f7abf51444aae487cb689a02">&#9670;&nbsp;</a></span>MakeRecordBatchReader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::MakeRecordBatchReader </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>batches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_record_batch_reader.html">RecordBatchReader</a> &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classarrow_1_1_record_batch_reader.html" title="Abstract interface for reading stream of record batches.">RecordBatchReader</a> from a vector of <a class="el" href="classarrow_1_1_record_batch.html" title="Collection of equal-length arrays matching a particular Schema.">RecordBatch</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">batches</td><td>the vector of <a class="el" href="classarrow_1_1_record_batch.html" title="Collection of equal-length arrays matching a particular Schema.">RecordBatch</a> to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">schema</td><td>schema to conform to. Will be inferred from the first element if not provided. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output pointer to store the <a class="el" href="classarrow_1_1_record_batch_reader.html" title="Abstract interface for reading stream of record batches.">RecordBatchReader</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="ab2cda6feb53b26ea439df86b2a534ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cda6feb53b26ea439df86b2a534ea7">&#9670;&nbsp;</a></span>MakeScalar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt;std::shared_ptr&lt;<a class="el" href="structarrow_1_1_scalar.html">Scalar</a>&gt; &gt; arrow::MakeScalar </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade3bae9d69b7544f4bfe67f6c60ceb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3bae9d69b7544f4bfe67f6c60ceb1e">&#9670;&nbsp;</a></span>MakeScalar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structarrow_1_1_scalar.html">Scalar</a>&gt; arrow::MakeScalar </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d94a22489c2d88b5ece3464f6757b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d94a22489c2d88b5ece3464f6757b5c">&#9670;&nbsp;</a></span>MakeScalar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value , typename Traits  = CTypeTraits&lt;typename std::decay&lt;Value&gt;::type&gt;, typename ScalarType  = typename Traits::ScalarType, typename Enable  = decltype(ScalarType(std::declval&lt;Value&gt;(),                                                Traits::type_singleton()))&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structarrow_1_1_scalar.html">Scalar</a>&gt; arrow::MakeScalar </td>
          <td>(</td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type inferring scalar factory </p>

</div>
</div>
<a id="a260d67d2d8f74d6bef570dc730982fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260d67d2d8f74d6bef570dc730982fee">&#9670;&nbsp;</a></span>MakeVectorIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;T&gt; arrow::MakeVectorIterator </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34c8b32dbbc2e7415d1e286ca132c006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c8b32dbbc2e7415d1e286ca132c006">&#9670;&nbsp;</a></span>MakeVectorOptionalIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_iterator.html">Iterator</a>&lt;<a class="el" href="namespacearrow_1_1util.html#a37597d23d580458d4547f817e2943744">util::optional</a>&lt;T&gt; &gt; arrow::MakeVectorOptionalIterator </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af03def88fd1ab05b0df699df9c3b9754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03def88fd1ab05b0df699df9c3b9754">&#9670;&nbsp;</a></span>mimalloc_memory_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::mimalloc_memory_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a> **&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a process-wide memory pool based on mimalloc. </p>
<p>May return NotImplemented if mimalloc is not available. </p>

</div>
</div>
<a id="ae7e5d5239907d98d4d80c80616f8bee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e5d5239907d98d4d80c80616f8bee7">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52f812806d0a240278b246de398438bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f812806d0a240278b246de398438bc">&#9670;&nbsp;</a></span>operator%()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> arrow::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6773885c4f560a78057a4455d422a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6773885c4f560a78057a4455d422a7f">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> arrow::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8e15d3146feab799b2bac1848f2df94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e15d3146feab799b2bac1848f2df94">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> arrow::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9f136f8caf36352437cc51b126ad2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f136f8caf36352437cc51b126ad2ee">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> arrow::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ae9b9602fea3bcd4bf6d9a45c011f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae9b9602fea3bcd4bf6d9a45c011f4d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> arrow::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79a236ea3b1930a4f78adcbdf0832ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a236ea3b1930a4f78adcbdf0832ba8">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> arrow::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a193e2bb54c6f5de5e388b2edd534a57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193e2bb54c6f5de5e388b2edd534a57c">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5709505547e744fa9cf7ddb09b1c2984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5709505547e744fa9cf7ddb09b1c2984">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; arrow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0877817f90cecf7a3b19a199b7195e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0877817f90cecf7a3b19a199b7195e2d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; arrow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1_time_unit.html#a561ef51c3755bd873f8f86f5bc4ec1ff">TimeUnit::type</a>&#160;</td>
          <td class="paramname"><em>unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb54a5f01d82053eb4779c29aabd9a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb54a5f01d82053eb4779c29aabd9a89">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbf9e156c4a8a01745d20c33a22f1f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf9e156c4a8a01745d20c33a22f1f28">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80697b084df40ebe8094fee62e8e5192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80697b084df40ebe8094fee62e8e5192">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92b97ff62146c0a0e2aeb702b9fddb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b97ff62146c0a0e2aeb702b9fddb77">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cf501b98a8ee4d346febfa3e96bc8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf501b98a8ee4d346febfa3e96bc8e7">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> arrow::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_basic_decimal128.html">BasicDecimal128</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b66debdce0800121a0b573cb4f51344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b66debdce0800121a0b573cb4f51344">&#9670;&nbsp;</a></span>ParseHexValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::ParseHexValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1e25f267b13e3a61947a9dfd93b92f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e25f267b13e3a61947a9dfd93b92f3">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print human-readable representation of <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a>. </p>

</div>
</div>
<a id="ac6b7f013ed791d08a9e4e3b9ec8a3f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b7f013ed791d08a9e4e3b9ec8a3f54">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print human-readable representation of <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a>. </p>

</div>
</div>
<a id="a5e646aac1cf6c89685b5d161377a236b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e646aac1cf6c89685b5d161377a236b">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print human-readable representation of <a class="el" href="classarrow_1_1_array.html" title="Array base type Immutable data array with some logical type and some length.">Array</a>. </p>

</div>
</div>
<a id="aed1396ab6f5f1e481bcaf595dd7a6427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1396ab6f5f1e481bcaf595dd7a6427">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>chunked_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print human-readable representation of <a class="el" href="classarrow_1_1_chunked_array.html" title="A data structure managing a list of primitive Arrow arrays logically as one large array.">ChunkedArray</a>. </p>

</div>
</div>
<a id="a1ac5ddf6d8603e6d0230a2768b42be4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac5ddf6d8603e6d0230a2768b42be4a">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_chunked_array.html">ChunkedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>chunked_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print human-readable representation of <a class="el" href="classarrow_1_1_chunked_array.html" title="A data structure managing a list of primitive Arrow arrays logically as one large array.">ChunkedArray</a>. </p>

</div>
</div>
<a id="a1797b746b75cf6af1b6809b5932b1fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1797b746b75cf6af1b6809b5932b1fe8">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &amp;&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a737bc52e404537e2dbb14e110e78daaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737bc52e404537e2dbb14e110e78daaa">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_record_batch.html">RecordBatch</a> &amp;&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print human-readable representation of <a class="el" href="classarrow_1_1_record_batch.html" title="Collection of equal-length arrays matching a particular Schema.">RecordBatch</a>. </p>

</div>
</div>
<a id="a9706f4e03928551a9e24db5c205e5521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9706f4e03928551a9e24db5c205e5521">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_schema.html">Schema</a> &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4dc6b3a8c2c471161f3b4c6c61e86aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc6b3a8c2c471161f3b4c6c61e86aad">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_schema.html">Schema</a> &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a051589b1255ab558754828c44e2dd04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051589b1255ab558754828c44e2dd04b">&#9670;&nbsp;</a></span>PrettyPrint() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::PrettyPrint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_table.html">Table</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_pretty_print_options.html">PrettyPrintOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print human-readable representation of <a class="el" href="classarrow_1_1_table.html" title="Logical table as sequence of chunked arrays.">Table</a>. </p>

</div>
</div>
<a id="aac71528443df3a53855482472db00f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac71528443df3a53855482472db00f9d">&#9670;&nbsp;</a></span>RegisterExtensionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::RegisterExtensionType </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_extension_type.html">ExtensionType</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an extension type globally. </p>
<p>The name returned by the type's extension_name() method should be unique. This method is thread-safe </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>an instance of the extension type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> </dd></dl>

</div>
</div>
<a id="a17e9a5cf615bc758d9cdbe7e6da611c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e9a5cf615bc758d9cdbe7e6da611c8">&#9670;&nbsp;</a></span>ScalarEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::ScalarEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if scalars are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>a <a class="el" href="structarrow_1_1_scalar.html" title="Base class for scalar values, representing a single value occupying an array &quot;slot&quot;.">Scalar</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>a <a class="el" href="structarrow_1_1_scalar.html" title="Base class for scalar values, representing a single value occupying an array &quot;slot&quot;.">Scalar</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa103995039a823ac5ce376994562f06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa103995039a823ac5ce376994562f06d">&#9670;&nbsp;</a></span>SetCpuThreadPoolCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::SetCpuThreadPoolCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the capacity of the global thread pool. </p>
<p>Set the number of worker threads int the thread pool to which Arrow dispatches various CPU-bound tasks.</p>
<p>The current number is returned by <a class="el" href="namespacearrow.html#a187c243ea680906ebe9d2c20ab311940" title="Get the capacity of the global thread pool.">GetCpuThreadPoolCapacity()</a>. </p>

</div>
</div>
<a id="a68b3683df6eb152e214ab74b9861cc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b3683df6eb152e214ab74b9861cc0f">&#9670;&nbsp;</a></span>SparseTensorEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::SparseTensorEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_sparse_tensor.html">SparseTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_sparse_tensor.html">SparseTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EXPERIMENTAL: Returns true if the given sparse tensors are exactly equal. </p>

</div>
</div>
<a id="aab2dcf4f3003c334c3a337d65657e4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2dcf4f3003c334c3a337d65657e4c5">&#9670;&nbsp;</a></span>system_memory_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_memory_pool.html">MemoryPool</a>* arrow::system_memory_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a process-wide memory pool based on the system allocator. </p>

</div>
</div>
<a id="a0127366929daceea11e1143498477446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0127366929daceea11e1143498477446">&#9670;&nbsp;</a></span>TensorEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::TensorEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_equal_options.html">EqualOptions</a> &amp;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="classarrow_1_1_equal_options.html#aceb7c9984ead6d5a79ba4a725193d452">EqualOptions::Defaults</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a234135e3a4408f77e2bbf4719f040ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234135e3a4408f77e2bbf4719f040ee9">&#9670;&nbsp;</a></span>TypeEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::TypeEquals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_metadata</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the type metadata are exactly equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>a <a class="el" href="classarrow_1_1_data_type.html" title="Base class for all data types.">DataType</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>a <a class="el" href="classarrow_1_1_data_type.html" title="Base class for all data types.">DataType</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">check_metadata</td><td>whether to compare <a class="el" href="classarrow_1_1_key_value_metadata.html" title="A container for key-value pair type metadata. Not thread-safe.">KeyValueMetadata</a> for child fields </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc8d7384b0a61a9a15cfdca6c39c4ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8d7384b0a61a9a15cfdca6c39c4ded">&#9670;&nbsp;</a></span>UnifySchemas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt;std::shared_ptr&lt;<a class="el" href="classarrow_1_1_schema.html">Schema</a>&gt; &gt; arrow::UnifySchemas </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_schema.html">Schema</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>schemas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1_field_1_1_merge_options.html">Field::MergeOptions</a>&#160;</td>
          <td class="paramname"><em>field_merge_options</em> = <code><a class="el" href="structarrow_1_1_field_1_1_merge_options.html#aad6ec10fe86793101bf688bbf9c9ad96">Field::MergeOptions::Defaults</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unifies schemas by merging fields by name. </p>
<p>The behavior of field merging can be controlled via <code><a class="el" href="structarrow_1_1_field_1_1_merge_options.html" title="Options that control the behavior of MergeWith.">Field::MergeOptions</a></code>.</p>
<p>The resulting schema will contain the union of fields from all schemas. Fields with the same name will be merged. See <code><a class="el" href="structarrow_1_1_field_1_1_merge_options.html" title="Options that control the behavior of MergeWith.">Field::MergeOptions</a></code>.</p><ul>
<li>They are expected to be mergeable under provided <code>field_merge_options</code>.</li>
<li>The unified field will inherit the metadata from the schema where that field is first defined.</li>
<li>The first N fields in the schema will be ordered the same as the N fields in the first schema. The resulting schema will inherit its metadata from the first input schema. Returns an error if:</li>
<li>Any input schema contains fields with duplicate names.</li>
<li>Fields of the same name are not mergeable. </li>
</ul>

</div>
</div>
<a id="ab162fa7ed427af976c48637d541325be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab162fa7ed427af976c48637d541325be">&#9670;&nbsp;</a></span>UnregisterExtensionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::UnregisterExtensionType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an extension type from the global registry. </p>
<p>This method is thread-safe </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_name</td><td>the unique name of a registered extension type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classarrow_1_1_status.html" title="Status outcome object (success or error)">Status</a> error if the type name is unknown </dd></dl>

</div>
</div>
<a id="a2f912387c238cd2feef3c242c0647d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f912387c238cd2feef3c242c0647d2b">&#9670;&nbsp;</a></span>VisitArrayInline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VISITOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::VisitArrayInline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VISITOR *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac00d7d4fc1efa5afee3a1a0b228f7817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00d7d4fc1efa5afee3a1a0b228f7817">&#9670;&nbsp;</a></span>VisitEditScript()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::VisitEditScript </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>edits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classarrow_1_1_status.html">Status</a>(int64_t delete_begin, int64_t delete_end, int64_t insert_begin, int64_t insert_end)&gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>visitor interface for easy traversal of an edit script </p>
<p>visitor will be called for each hunk of insertions and deletions. </p>

</div>
</div>
<a id="a511650783e127b8c2acb1326b9b94e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511650783e127b8c2acb1326b9b94e7a">&#9670;&nbsp;</a></span>VisitScalarInline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VISITOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::VisitScalarInline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structarrow_1_1_scalar.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VISITOR *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a431bd46d978673b1b00afc3049776c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431bd46d978673b1b00afc3049776c49">&#9670;&nbsp;</a></span>VisitTypeInline()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VISITOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_status.html">Status</a> arrow::VisitTypeInline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VISITOR *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6c4f8bc1a6b7bfa3386005a0bede3640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4f8bc1a6b7bfa3386005a0bede3640">&#9670;&nbsp;</a></span>kBinaryMemoryLimit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t arrow::kBinaryMemoryLimit = std::numeric_limits&lt;int32_t&gt;::max() - 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac532e4d8906ecf870014f5a4bbb1382c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac532e4d8906ecf870014f5a4bbb1382c">&#9670;&nbsp;</a></span>kExtensionMetadataKeyName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char arrow::kExtensionMetadataKeyName[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f613bf6f0e5a50bd9a89c767d8004d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f613bf6f0e5a50bd9a89c767d8004d1">&#9670;&nbsp;</a></span>kExtensionTypeKeyName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char arrow::kExtensionTypeKeyName[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab64d5a2a0d35fbe0ae87fc18d2a5c0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64d5a2a0d35fbe0ae87fc18d2a5c0ee">&#9670;&nbsp;</a></span>kListMaximumElements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t arrow::kListMaximumElements = std::numeric_limits&lt;int32_t&gt;::max() - 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cd38814abf185253aa1c8f68c9ca5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd38814abf185253aa1c8f68c9ca5ab">&#9670;&nbsp;</a></span>kMinBuilderCapacity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t arrow::kMinBuilderCapacity = 1 &lt;&lt; 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bc89c993234944fd7bdbdfe95812080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc89c993234944fd7bdbdfe95812080">&#9670;&nbsp;</a></span>kUnknownNullCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t arrow::kUnknownNullCount = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7fa6d3c9abcfa1251baa24ff731782e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fa6d3c9abcfa1251baa24ff731782e">&#9670;&nbsp;</a></span>MakeUnifiedDiffFormatter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::function&lt;<a class="el" href="classarrow_1_1_status.html">Status</a>(const <a class="el" href="classarrow_1_1_array.html">Array</a>&amp; edits, const <a class="el" href="classarrow_1_1_array.html">Array</a>&amp; base, const <a class="el" href="classarrow_1_1_array.html">Array</a>&amp; target)&gt; &gt; arrow::MakeUnifiedDiffFormatter(const <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &amp;type, std::ostream *os)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a function which will format an edit script in unified diff format to os, given base and target arrays of type </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107500873-1');
</script>
</body>
</html>
