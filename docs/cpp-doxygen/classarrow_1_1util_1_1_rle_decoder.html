<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Arrow (C++): arrow::util::RleDecoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Arrow (C++)
   </div>
   <div id="projectbrief">A columnar in-memory analytics layer designed to accelerate big data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacearrow.html">arrow</a></li><li class="navelem"><a class="el" href="namespacearrow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html">RleDecoder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classarrow_1_1util_1_1_rle_decoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">arrow::util::RleDecoder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility classes to do run length encoding (RLE) for fixed bit width values.  
 <a href="classarrow_1_1util_1_1_rle_decoder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rle__encoding_8h_source.html">arrow/util/rle_encoding.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaebb3e3674a08e0cdf1c7658e562543a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#aaebb3e3674a08e0cdf1c7658e562543a">RleDecoder</a> (const uint8_t *buffer, int buffer_len, int bit_width)</td></tr>
<tr class="memdesc:aaebb3e3674a08e0cdf1c7658e562543a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a decoder object.  <a href="classarrow_1_1util_1_1_rle_decoder.html#aaebb3e3674a08e0cdf1c7658e562543a">More...</a><br /></td></tr>
<tr class="separator:aaebb3e3674a08e0cdf1c7658e562543a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ddb7000f17bb7c694217afcacaf47c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#a25ddb7000f17bb7c694217afcacaf47c">RleDecoder</a> ()</td></tr>
<tr class="separator:a25ddb7000f17bb7c694217afcacaf47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4424bd7ca2e897d429f94ee0d8d2d219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#a4424bd7ca2e897d429f94ee0d8d2d219">Reset</a> (const uint8_t *buffer, int buffer_len, int bit_width)</td></tr>
<tr class="separator:a4424bd7ca2e897d429f94ee0d8d2d219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf113d49f938fcfeb11431e186d62d11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf113d49f938fcfeb11431e186d62d11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#adf113d49f938fcfeb11431e186d62d11">Get</a> (T *val)</td></tr>
<tr class="memdesc:adf113d49f938fcfeb11431e186d62d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next value. Returns false if there are no more.  <a href="classarrow_1_1util_1_1_rle_decoder.html#adf113d49f938fcfeb11431e186d62d11">More...</a><br /></td></tr>
<tr class="separator:adf113d49f938fcfeb11431e186d62d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fddb45e23c7d3b0210f0851d3c91764"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fddb45e23c7d3b0210f0851d3c91764"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#a5fddb45e23c7d3b0210f0851d3c91764">GetBatch</a> (T *values, int batch_size)</td></tr>
<tr class="memdesc:a5fddb45e23c7d3b0210f0851d3c91764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a batch of values. Returns the number of decoded elements.  <a href="classarrow_1_1util_1_1_rle_decoder.html#a5fddb45e23c7d3b0210f0851d3c91764">More...</a><br /></td></tr>
<tr class="separator:a5fddb45e23c7d3b0210f0851d3c91764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c2ad67c5159f3ab3dce3fa5a4a156d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9c2ad67c5159f3ab3dce3fa5a4a156d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#ac9c2ad67c5159f3ab3dce3fa5a4a156d">GetBatchSpaced</a> (int batch_size, int null_count, const uint8_t *valid_bits, int64_t valid_bits_offset, T *out)</td></tr>
<tr class="memdesc:ac9c2ad67c5159f3ab3dce3fa5a4a156d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like GetBatch but add spacing for null entries.  <a href="classarrow_1_1util_1_1_rle_decoder.html#ac9c2ad67c5159f3ab3dce3fa5a4a156d">More...</a><br /></td></tr>
<tr class="separator:ac9c2ad67c5159f3ab3dce3fa5a4a156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d8657695e1eb843bc8cf2a28496163"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03d8657695e1eb843bc8cf2a28496163"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#a03d8657695e1eb843bc8cf2a28496163">GetBatchWithDict</a> (const T *<a class="el" href="group__type-factories.html#ga36f61c68b2a04a9d179cb56ff1186c59">dictionary</a>, T *values, int batch_size)</td></tr>
<tr class="memdesc:a03d8657695e1eb843bc8cf2a28496163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like GetBatch but the values are then decoded using the provided dictionary.  <a href="classarrow_1_1util_1_1_rle_decoder.html#a03d8657695e1eb843bc8cf2a28496163">More...</a><br /></td></tr>
<tr class="separator:a03d8657695e1eb843bc8cf2a28496163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043469bdcbb740ab399428fa3dfed3e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a043469bdcbb740ab399428fa3dfed3e0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#a043469bdcbb740ab399428fa3dfed3e0">GetBatchWithDictSpaced</a> (const T *<a class="el" href="group__type-factories.html#ga36f61c68b2a04a9d179cb56ff1186c59">dictionary</a>, T *values, int batch_size, int null_count, const uint8_t *valid_bits, int64_t valid_bits_offset)</td></tr>
<tr class="memdesc:a043469bdcbb740ab399428fa3dfed3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like GetBatchWithDict but add spacing for null entries.  <a href="classarrow_1_1util_1_1_rle_decoder.html#a043469bdcbb740ab399428fa3dfed3e0">More...</a><br /></td></tr>
<tr class="separator:a043469bdcbb740ab399428fa3dfed3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abc4bbe1847bd0dd04a51f81972d846e7"><td class="memItemLeft" align="right" valign="top">BitUtil::BitReader&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#abc4bbe1847bd0dd04a51f81972d846e7">bit_reader_</a></td></tr>
<tr class="separator:abc4bbe1847bd0dd04a51f81972d846e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e57698def7bfd3cc7da70cb2979835"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#a43e57698def7bfd3cc7da70cb2979835">bit_width_</a></td></tr>
<tr class="memdesc:a43e57698def7bfd3cc7da70cb2979835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits needed to encode the value. Must be between 0 and 64.  <a href="classarrow_1_1util_1_1_rle_decoder.html#a43e57698def7bfd3cc7da70cb2979835">More...</a><br /></td></tr>
<tr class="separator:a43e57698def7bfd3cc7da70cb2979835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5083cb6107087bce883571c34f37b619"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#a5083cb6107087bce883571c34f37b619">current_value_</a></td></tr>
<tr class="separator:a5083cb6107087bce883571c34f37b619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf07474143a68d83a5b51ef57c41647"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#aedf07474143a68d83a5b51ef57c41647">repeat_count_</a></td></tr>
<tr class="separator:aedf07474143a68d83a5b51ef57c41647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90554cf78d8b7c49bf9b759fdcae65c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_decoder.html#ab90554cf78d8b7c49bf9b759fdcae65c">literal_count_</a></td></tr>
<tr class="separator:ab90554cf78d8b7c49bf9b759fdcae65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility classes to do run length encoding (RLE) for fixed bit width values. </p>
<p>If runs are sufficiently long, RLE is used, otherwise, the values are just bit-packed (literal encoding). For both types of runs, there is a byte-aligned indicator which encodes the length of the run and the type of the run. This encoding has the benefit that when there aren't any long enough runs, values are always decoded at fixed (can be precomputed) bit offsets OR both the value and the run length are byte aligned. This allows for very efficient decoding implementations. The encoding is: encoded-block := run* run := literal-run | repeated-run literal-run := literal-indicator &lt; literal bytes &gt; repeated-run := repeated-indicator &lt; repeated value. padded to byte boundary &gt; literal-indicator := varint_encode( number_of_groups &lt;&lt; 1 | 1) repeated-indicator := varint_encode( number_of_repetitions &lt;&lt; 1 ) Each run is preceded by a varint. The varint's least significant bit is used to indicate whether the run is a literal run or a repeated run. The rest of the varint is used to determine the length of the run (eg how many times the value repeats). In the case of literal runs, the run length is always a multiple of 8 (i.e. encode in groups of 8), so that no matter the bit-width of the value, the sequence will end on a byte boundary without padding. Given that we know it is a multiple of 8, we store the number of 8-groups rather than the actual number of encoded ints. (This means that the total number of encoded values can not be determined from the encoded data, since the number of values in the last group may not be a multiple of 8). For the last group of literal runs, we pad the group to 8 with zeros. This allows for 8 at a time decoding on the read side without the need for additional checks. There is a break-even point when it is more storage efficient to do run length encoding. For 1 bit-width values, that point is 8 values. They require 2 bytes for both the repeated encoding or the literal encoding. This value can always be computed based on the bit-width. TODO: think about how to use this for strings. The bit packing isn't quite the same. </p><h2>Examples with bit-width 1 (eg encoding booleans): </h2>
<p>100 1s followed by 100 0s: &lt;varint(100 &lt;&lt; 1)&gt; &lt;1, padded to 1 byte&gt; &lt;varint(100 &lt;&lt; 1)&gt; &lt;0, padded to 1 byte&gt;</p><ul>
<li>(total 4 bytes) alternating 1s and 0s (200 total): 200 ints = 25 groups of 8 &lt;varint((25 &lt;&lt; 1) | 1)&gt; &lt;25 bytes of values, bitpacked&gt; (total 26 bytes, 1 byte overhead) Decoder class for RLE encoded data. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaebb3e3674a08e0cdf1c7658e562543a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebb3e3674a08e0cdf1c7658e562543a">&#9670;&nbsp;</a></span>RleDecoder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::util::RleDecoder::RleDecoder </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a decoder object. </p>
<p>buffer/buffer_len is the decoded data. bit_width is the width of each value (before encoding). </p>

</div>
</div>
<a id="a25ddb7000f17bb7c694217afcacaf47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ddb7000f17bb7c694217afcacaf47c">&#9670;&nbsp;</a></span>RleDecoder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::util::RleDecoder::RleDecoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adf113d49f938fcfeb11431e186d62d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf113d49f938fcfeb11431e186d62d11">&#9670;&nbsp;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::util::RleDecoder::Get </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the next value. Returns false if there are no more. </p>

</div>
</div>
<a id="a5fddb45e23c7d3b0210f0851d3c91764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fddb45e23c7d3b0210f0851d3c91764">&#9670;&nbsp;</a></span>GetBatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::util::RleDecoder::GetBatch </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a batch of values. Returns the number of decoded elements. </p>

</div>
</div>
<a id="ac9c2ad67c5159f3ab3dce3fa5a4a156d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c2ad67c5159f3ab3dce3fa5a4a156d">&#9670;&nbsp;</a></span>GetBatchSpaced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::util::RleDecoder::GetBatchSpaced </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>null_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>valid_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>valid_bits_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like GetBatch but add spacing for null entries. </p>

</div>
</div>
<a id="a03d8657695e1eb843bc8cf2a28496163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d8657695e1eb843bc8cf2a28496163">&#9670;&nbsp;</a></span>GetBatchWithDict()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::util::RleDecoder::GetBatchWithDict </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like GetBatch but the values are then decoded using the provided dictionary. </p>

</div>
</div>
<a id="a043469bdcbb740ab399428fa3dfed3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043469bdcbb740ab399428fa3dfed3e0">&#9670;&nbsp;</a></span>GetBatchWithDictSpaced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::util::RleDecoder::GetBatchWithDictSpaced </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>null_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>valid_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>valid_bits_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like GetBatchWithDict but add spacing for null entries. </p>
<p>Null entries will be zero-initialized in <code>values</code> to avoid leaking private data. </p>

</div>
</div>
<a id="a4424bd7ca2e897d429f94ee0d8d2d219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4424bd7ca2e897d429f94ee0d8d2d219">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arrow::util::RleDecoder::Reset </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abc4bbe1847bd0dd04a51f81972d846e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4bbe1847bd0dd04a51f81972d846e7">&#9670;&nbsp;</a></span>bit_reader_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BitUtil::BitReader arrow::util::RleDecoder::bit_reader_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43e57698def7bfd3cc7da70cb2979835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e57698def7bfd3cc7da70cb2979835">&#9670;&nbsp;</a></span>bit_width_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::util::RleDecoder::bit_width_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of bits needed to encode the value. Must be between 0 and 64. </p>

</div>
</div>
<a id="a5083cb6107087bce883571c34f37b619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5083cb6107087bce883571c34f37b619">&#9670;&nbsp;</a></span>current_value_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t arrow::util::RleDecoder::current_value_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab90554cf78d8b7c49bf9b759fdcae65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90554cf78d8b7c49bf9b759fdcae65c">&#9670;&nbsp;</a></span>literal_count_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t arrow::util::RleDecoder::literal_count_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aedf07474143a68d83a5b51ef57c41647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf07474143a68d83a5b51ef57c41647">&#9670;&nbsp;</a></span>repeat_count_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t arrow::util::RleDecoder::repeat_count_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/wesm/code/arrow/cpp/src/arrow/util/<a class="el" href="rle__encoding_8h_source.html">rle_encoding.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107500873-1');
</script>
</body>
</html>
