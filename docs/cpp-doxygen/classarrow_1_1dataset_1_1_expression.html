<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Arrow (C++): arrow::dataset::Expression Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Arrow (C++)
   </div>
   <div id="projectbrief">A columnar in-memory analytics layer designed to accelerate big data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacearrow.html">arrow</a></li><li class="navelem"><a class="el" href="namespacearrow_1_1dataset.html">dataset</a></li><li class="navelem"><a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classarrow_1_1dataset_1_1_expression-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">arrow::dataset::Expression Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents an expression tree.  
 <a href="classarrow_1_1dataset_1_1_expression.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="arrow_2dataset_2filter_8h_source.html">arrow/dataset/filter.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for arrow::dataset::Expression:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classarrow_1_1dataset_1_1_expression.png" usemap="#arrow::dataset::Expression_map" alt=""/>
  <map id="arrow::dataset::Expression_map" name="arrow::dataset::Expression_map">
<area href="classarrow_1_1dataset_1_1_binary_expression.html" title="Base class for an expression with exactly two operands." alt="arrow::dataset::BinaryExpression" shape="rect" coords="642,56,1274,80"/>
<area href="classarrow_1_1dataset_1_1_custom_expression.html" alt="arrow::dataset::CustomExpression" shape="rect" coords="1284,56,1916,80"/>
<area href="classarrow_1_1dataset_1_1_field_expression.html" title="Represents a reference to a field." alt="arrow::dataset::FieldExpression" shape="rect" coords="1926,56,2558,80"/>
<area href="classarrow_1_1dataset_1_1_scalar_expression.html" title="Represents a scalar value; thin wrapper around arrow::Scalar." alt="arrow::dataset::ScalarExpression" shape="rect" coords="2568,56,3200,80"/>
<area href="classarrow_1_1dataset_1_1_unary_expression.html" title="Base class for an expression with exactly one operand." alt="arrow::dataset::UnaryExpression" shape="rect" coords="3210,56,3842,80"/>
<area href="classarrow_1_1dataset_1_1_expression_impl.html" alt="arrow::dataset::ExpressionImpl&lt; BinaryExpression, AndExpression, ExpressionType::AND &gt;" shape="rect" coords="0,112,632,136"/>
<area href="classarrow_1_1dataset_1_1_expression_impl.html" alt="arrow::dataset::ExpressionImpl&lt; BinaryExpression, ComparisonExpression, ExpressionType::COMPARISON &gt;" shape="rect" coords="642,112,1274,136"/>
<area href="classarrow_1_1dataset_1_1_expression_impl.html" alt="arrow::dataset::ExpressionImpl&lt; BinaryExpression, OrExpression, ExpressionType::OR &gt;" shape="rect" coords="1284,112,1916,136"/>
<area href="classarrow_1_1dataset_1_1_expression_impl.html" alt="arrow::dataset::ExpressionImpl&lt; UnaryExpression, CastExpression, ExpressionType::CAST &gt;" shape="rect" coords="2247,112,2879,136"/>
<area href="classarrow_1_1dataset_1_1_expression_impl.html" alt="arrow::dataset::ExpressionImpl&lt; UnaryExpression, InExpression, ExpressionType::IN &gt;" shape="rect" coords="2889,112,3521,136"/>
<area href="classarrow_1_1dataset_1_1_expression_impl.html" alt="arrow::dataset::ExpressionImpl&lt; UnaryExpression, IsValidExpression, ExpressionType::IS_VALID &gt;" shape="rect" coords="3531,112,4163,136"/>
<area href="classarrow_1_1dataset_1_1_expression_impl.html" alt="arrow::dataset::ExpressionImpl&lt; UnaryExpression, NotExpression, ExpressionType::NOT &gt;" shape="rect" coords="4173,112,4805,136"/>
<area href="classarrow_1_1dataset_1_1_and_expression.html" alt="arrow::dataset::AndExpression" shape="rect" coords="0,168,632,192"/>
<area href="classarrow_1_1dataset_1_1_comparison_expression.html" alt="arrow::dataset::ComparisonExpression" shape="rect" coords="642,168,1274,192"/>
<area href="classarrow_1_1dataset_1_1_or_expression.html" alt="arrow::dataset::OrExpression" shape="rect" coords="1284,168,1916,192"/>
<area href="classarrow_1_1dataset_1_1_cast_expression.html" title="Explicitly cast an expression to a different type." alt="arrow::dataset::CastExpression" shape="rect" coords="2247,168,2879,192"/>
<area href="classarrow_1_1dataset_1_1_in_expression.html" alt="arrow::dataset::InExpression" shape="rect" coords="2889,168,3521,192"/>
<area href="classarrow_1_1dataset_1_1_is_valid_expression.html" alt="arrow::dataset::IsValidExpression" shape="rect" coords="3531,168,4163,192"/>
<area href="classarrow_1_1dataset_1_1_not_expression.html" alt="arrow::dataset::NotExpression" shape="rect" coords="4173,168,4805,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ace247255d88029192703e49bcb468c7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#ace247255d88029192703e49bcb468c7a">Expression</a> (<a class="el" href="structarrow_1_1dataset_1_1_expression_type.html#aa055f8b51338c1fa7f7dda520053b4d5">ExpressionType::type</a> <a class="el" href="classarrow_1_1dataset_1_1_expression.html#a26c748fc0b8eb3ffa800bd957a019d39">type</a>)</td></tr>
<tr class="separator:ace247255d88029192703e49bcb468c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadfb3da0cb488e984d342be1ed9ae36"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#aeadfb3da0cb488e984d342be1ed9ae36">~Expression</a> ()=default</td></tr>
<tr class="separator:aeadfb3da0cb488e984d342be1ed9ae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c952a05b1090e1ec15adbe7ed712ea6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a8c952a05b1090e1ec15adbe7ed712ea6">Equals</a> (const <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &amp;other) const =0</td></tr>
<tr class="memdesc:a8c952a05b1090e1ec15adbe7ed712ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the expressions are identical; does not check for equivalence.  <a href="classarrow_1_1dataset_1_1_expression.html#a8c952a05b1090e1ec15adbe7ed712ea6">More...</a><br /></td></tr>
<tr class="separator:a8c952a05b1090e1ec15adbe7ed712ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2080b195e1999f973c7ceb7e0978a13e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a2080b195e1999f973c7ceb7e0978a13e">Equals</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &gt; &amp;other) const</td></tr>
<tr class="separator:a2080b195e1999f973c7ceb7e0978a13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f49c9a8081e757c4d399073785f171"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = decltype(MakeScalar(std::declval&lt;T&gt;()))&gt; </td></tr>
<tr class="memitem:a55f49c9a8081e757c4d399073785f171"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a55f49c9a8081e757c4d399073785f171">Equals</a> (T &amp;&amp;t) const</td></tr>
<tr class="memdesc:a55f49c9a8081e757c4d399073785f171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for the common case of checking for equality to a specific scalar.  <a href="classarrow_1_1dataset_1_1_expression.html#a55f49c9a8081e757c4d399073785f171">More...</a><br /></td></tr>
<tr class="separator:a55f49c9a8081e757c4d399073785f171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5d308f61bdb2ec2074b662ea33f760"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a8e5d308f61bdb2ec2074b662ea33f760">IsNull</a> () const</td></tr>
<tr class="memdesc:a8e5d308f61bdb2ec2074b662ea33f760"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, this <a class="el" href="classarrow_1_1dataset_1_1_expression.html" title="Represents an expression tree.">Expression</a> is a <a class="el" href="classarrow_1_1dataset_1_1_scalar_expression.html" title="Represents a scalar value; thin wrapper around arrow::Scalar.">ScalarExpression</a> wrapping a null scalar.  <a href="classarrow_1_1dataset_1_1_expression.html#a8e5d308f61bdb2ec2074b662ea33f760">More...</a><br /></td></tr>
<tr class="separator:a8e5d308f61bdb2ec2074b662ea33f760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1073c67366c820875c3825e867419050"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classarrow_1_1_result.html">Result</a>&lt; std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a1073c67366c820875c3825e867419050">Validate</a> (const <a class="el" href="classarrow_1_1_schema.html">Schema</a> &amp;<a class="el" href="group__schema-factories.html#ga97ac72c2a07228577c1d38b7747941a9">schema</a>) const =0</td></tr>
<tr class="memdesc:a1073c67366c820875c3825e867419050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate this expression for execution against a schema.  <a href="classarrow_1_1dataset_1_1_expression.html#a1073c67366c820875c3825e867419050">More...</a><br /></td></tr>
<tr class="separator:a1073c67366c820875c3825e867419050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf8311867209fd28af7f0fdf6b26b33"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a5cf8311867209fd28af7f0fdf6b26b33">Assume</a> (const <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &amp;given) const</td></tr>
<tr class="memdesc:a5cf8311867209fd28af7f0fdf6b26b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify to an equivalent <a class="el" href="classarrow_1_1dataset_1_1_expression.html" title="Represents an expression tree.">Expression</a> given assumed constraints on input.  <a href="classarrow_1_1dataset_1_1_expression.html#a5cf8311867209fd28af7f0fdf6b26b33">More...</a><br /></td></tr>
<tr class="separator:a5cf8311867209fd28af7f0fdf6b26b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94bb5128873b3955ef1079dbfa59a05"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#aa94bb5128873b3955ef1079dbfa59a05">Assume</a> (const std::shared_ptr&lt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &gt; &amp;given) const</td></tr>
<tr class="separator:aa94bb5128873b3955ef1079dbfa59a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd37d50f9235db97d98299dedde5deb8"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#acd37d50f9235db97d98299dedde5deb8">ToString</a> () const =0</td></tr>
<tr class="memdesc:acd37d50f9235db97d98299dedde5deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a debug string representing this expression  <a href="classarrow_1_1dataset_1_1_expression.html#acd37d50f9235db97d98299dedde5deb8">More...</a><br /></td></tr>
<tr class="separator:acd37d50f9235db97d98299dedde5deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c748fc0b8eb3ffa800bd957a019d39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarrow_1_1dataset_1_1_expression_type.html#aa055f8b51338c1fa7f7dda520053b4d5">ExpressionType::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a26c748fc0b8eb3ffa800bd957a019d39">type</a> () const</td></tr>
<tr class="memdesc:a26c748fc0b8eb3ffa800bd957a019d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the expression's type identifier.  <a href="classarrow_1_1dataset_1_1_expression.html#a26c748fc0b8eb3ffa800bd957a019d39">More...</a><br /></td></tr>
<tr class="separator:a26c748fc0b8eb3ffa800bd957a019d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4baacac016afb9b00f41113dd05f602"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#ab4baacac016afb9b00f41113dd05f602">Copy</a> () const =0</td></tr>
<tr class="memdesc:ab4baacac016afb9b00f41113dd05f602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy this expression into a shared pointer.  <a href="classarrow_1_1dataset_1_1_expression.html#ab4baacac016afb9b00f41113dd05f602">More...</a><br /></td></tr>
<tr class="separator:ab4baacac016afb9b00f41113dd05f602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce811a47927451199574abff5bab72a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1dataset_1_1_in_expression.html">InExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a5ce811a47927451199574abff5bab72a">In</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt; set) const</td></tr>
<tr class="separator:a5ce811a47927451199574abff5bab72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac665b2a07ec4247f0af1ada25340a294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1dataset_1_1_is_valid_expression.html">IsValidExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#ac665b2a07ec4247f0af1ada25340a294">IsValid</a> () const</td></tr>
<tr class="separator:ac665b2a07ec4247f0af1ada25340a294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c73de7e4be70d94decb62d73d9679f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1dataset_1_1_cast_expression.html">CastExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a67c73de7e4be70d94decb62d73d9679f">CastTo</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html#a26c748fc0b8eb3ffa800bd957a019d39">type</a>, <a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a> options=<a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a>()) const</td></tr>
<tr class="separator:a67c73de7e4be70d94decb62d73d9679f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b8f7274bf46ffb4c9d63c54182eed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1dataset_1_1_cast_expression.html">CastExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#aa3b8f7274bf46ffb4c9d63c54182eed3">CastLike</a> (const <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &amp;expr, <a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a> options=<a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a>()) const</td></tr>
<tr class="separator:aa3b8f7274bf46ffb4c9d63c54182eed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93e79be7899dc8a3aa063d92748d6d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarrow_1_1dataset_1_1_cast_expression.html">CastExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#ab93e79be7899dc8a3aa063d92748d6d1">CastLike</a> (std::shared_ptr&lt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &gt; expr, <a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a> options=<a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a>()) const</td></tr>
<tr class="separator:ab93e79be7899dc8a3aa063d92748d6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4f70ea37a6b7d7e542b1d806e65305f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structarrow_1_1dataset_1_1_expression_type.html#aa055f8b51338c1fa7f7dda520053b4d5">ExpressionType::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1dataset_1_1_expression.html#a4f70ea37a6b7d7e542b1d806e65305f4">type_</a></td></tr>
<tr class="separator:a4f70ea37a6b7d7e542b1d806e65305f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an expression tree. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ace247255d88029192703e49bcb468c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace247255d88029192703e49bcb468c7a">&#9670;&nbsp;</a></span>Expression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::dataset::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structarrow_1_1dataset_1_1_expression_type.html#aa055f8b51338c1fa7f7dda520053b4d5">ExpressionType::type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeadfb3da0cb488e984d342be1ed9ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadfb3da0cb488e984d342be1ed9ae36">&#9670;&nbsp;</a></span>~Expression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual arrow::dataset::Expression::~Expression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5cf8311867209fd28af7f0fdf6b26b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf8311867209fd28af7f0fdf6b26b33">&#9670;&nbsp;</a></span>Assume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a>&gt; arrow::dataset::Expression::Assume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>given</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify to an equivalent <a class="el" href="classarrow_1_1dataset_1_1_expression.html" title="Represents an expression tree.">Expression</a> given assumed constraints on input. </p>
<p>This can be used to do less filtering work using predicate push down.</p>
<p>Both expressions must pass validation against a schema before Assume may be used.</p>
<p>Two expressions can be considered equivalent for a given subset of possible inputs if they yield identical results. Formally, if given.Evaluate(input).Equals(input) then Assume guarantees that: expr.Assume(given).Evaluate(input).Equals(expr.Evaluate(input))</p>
<p>For example if we are given that all inputs will satisfy ("a"_ == 1) then the expression ("a"_ &gt; 0 and "b"_ &gt; 0) is equivalent to ("b"_ &gt; 0). It is impossible that the comparison ("a"_ &gt; 0) will evaluate false given ("a"_ == 1), so both expressions will yield identical results. Thus we can write: ("a"_ &gt; 0 and "b"_ &gt; 0).Assume("a"_ == 1).Equals("b"_ &gt; 0)</p>
<p>filter.Assume(partition) is trivial if filter and partition are disjoint or if partition is a subset of filter. FIXME(bkietz) write this better</p><ul>
<li>If the two are disjoint, then (false) may be substituted for filter.</li>
<li>If partition is a subset of filter then (true) may be substituted for filter.</li>
</ul>
<p>filter.Assume(partition) is straightforward if both filter and partition are simple comparisons.</p><ul>
<li>filter may be a superset of partition, in which case the filter is satisfied by all inputs: ("a"_ &gt; 0).Assume("a"_ == 1).Equals(true)</li>
<li>filter may be disjoint with partition, in which case there are no inputs which satisfy filter: ("a"_ &lt; 0).Assume("a"_ == 1).Equals(false)</li>
<li>If neither of these is the case, partition provides no information which can simplify filter: ("a"_ == 1).Assume("a"_ &gt; 0).Equals("a"_ == 1) ("a"_ == 1).Assume("b"_ == 1).Equals("a"_ == 1)</li>
</ul>
<p>If filter is compound, Assume can be distributed across the boolean operator. To prove this is valid, we again demonstrate that the simplified expression will yield identical results. For conjunction of filters lhs and rhs: (lhs.Assume(p) and rhs.Assume(p)).Evaluate(input) == Intersection(lhs.Assume(p).Evaluate(input), rhs.Assume(p).Evaluate(input)) == Intersection(lhs.Evaluate(input), rhs.Evaluate(input)) == (lhs and rhs).Evaluate(input)</p><ul>
<li>The proof for disjunction is symmetric; just replace Intersection with Union. Thus we can write: (lhs and rhs).Assume(p).Equals(lhs.Assume(p) and rhs.Assume(p)) (lhs or rhs).Assume(p).Equals(lhs.Assume(p) or rhs.Assume(p))</li>
<li>For negation: (not e.Assume(p)).Evaluate(input) == Difference(input, e.Assume(p).Evaluate(input)) == Difference(input, e.Evaluate(input)) == (not e).Evaluate(input)</li>
<li>Thus we can write: (not e).Assume(p).Equals(not e.Assume(p))</li>
</ul>
<p>If the partition expression is a conjunction then each of its subexpressions is true for all input and can be used independently: filter.Assume(lhs).Assume(rhs).Evaluate(input) == filter.Assume(lhs).Evaluate(input) == filter.Evaluate(input)</p><ul>
<li>Thus we can write: filter.Assume(lhs and rhs).Equals(filter.Assume(lhs).Assume(rhs))</li>
</ul>
<p>FIXME(bkietz) disjunction proof filter.Assume(lhs or rhs).Equals(filter.Assume(lhs) and filter.Assume(rhs))</p><ul>
<li>This may not result in a simpler expression so it is only used when filter.Assume(lhs).Equals(filter.Assume(rhs))</li>
</ul>
<p>If the partition expression is a negation then we can use the above relations by replacing comparisons with their complements and using the properties: (not (a and b)).Equals(not a or not b) (not (a or b)).Equals(not a and not b) </p>

<p>Reimplemented in <a class="el" href="classarrow_1_1dataset_1_1_cast_expression.html#a4b831d793a60be2707d5f3c336c45f76">arrow::dataset::CastExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_in_expression.html#accf3ab14e766a02bb4de69fc16bfb78f">arrow::dataset::InExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_is_valid_expression.html#a68cc36296e26491ae9b4cdde347a2794">arrow::dataset::IsValidExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_not_expression.html#a7a6fc4ee6b7d09b59a5e9bd37bccb7b7">arrow::dataset::NotExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_or_expression.html#a571fd457bca2d81b302427d5a641c13d">arrow::dataset::OrExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_and_expression.html#a207f428a3d8b05161469e30daa2c4750">arrow::dataset::AndExpression</a>, and <a class="el" href="classarrow_1_1dataset_1_1_comparison_expression.html#a3414ab1b56fbb8c25bd79bc22e4a7ae6">arrow::dataset::ComparisonExpression</a>.</p>

</div>
</div>
<a id="aa94bb5128873b3955ef1079dbfa59a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94bb5128873b3955ef1079dbfa59a05">&#9670;&nbsp;</a></span>Assume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a>&gt; arrow::dataset::Expression::Assume </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>given</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b8f7274bf46ffb4c9d63c54182eed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b8f7274bf46ffb4c9d63c54182eed3">&#9670;&nbsp;</a></span>CastLike() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1dataset_1_1_cast_expression.html">CastExpression</a> arrow::dataset::Expression::CastLike </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab93e79be7899dc8a3aa063d92748d6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93e79be7899dc8a3aa063d92748d6d1">&#9670;&nbsp;</a></span>CastLike() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1dataset_1_1_cast_expression.html">CastExpression</a> arrow::dataset::Expression::CastLike </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &gt;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67c73de7e4be70d94decb62d73d9679f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c73de7e4be70d94decb62d73d9679f">&#9670;&nbsp;</a></span>CastTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1dataset_1_1_cast_expression.html">CastExpression</a> arrow::dataset::Expression::CastTo </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_data_type.html">DataType</a> &gt;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structarrow_1_1compute_1_1_cast_options.html">compute::CastOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4baacac016afb9b00f41113dd05f602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4baacac016afb9b00f41113dd05f602">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::shared_ptr&lt;<a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a>&gt; arrow::dataset::Expression::Copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy this expression into a shared pointer. </p>

<p>Implemented in <a class="el" href="classarrow_1_1dataset_1_1_field_expression.html#a8f1b716f7818cbd3220c439a2e79c29a">arrow::dataset::FieldExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_scalar_expression.html#aac62a4bc3d38d8082b4aa8f61b216664">arrow::dataset::ScalarExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_expression_impl.html#a6efe2a97203c4253061884774b261fa7">arrow::dataset::ExpressionImpl&lt; UnaryExpression, NotExpression, ExpressionType::NOT &gt;</a>, <a class="el" href="classarrow_1_1dataset_1_1_expression_impl.html#a6efe2a97203c4253061884774b261fa7">arrow::dataset::ExpressionImpl&lt; UnaryExpression, InExpression, ExpressionType::IN &gt;</a>, <a class="el" href="classarrow_1_1dataset_1_1_expression_impl.html#a6efe2a97203c4253061884774b261fa7">arrow::dataset::ExpressionImpl&lt; BinaryExpression, ComparisonExpression, ExpressionType::COMPARISON &gt;</a>, <a class="el" href="classarrow_1_1dataset_1_1_expression_impl.html#a6efe2a97203c4253061884774b261fa7">arrow::dataset::ExpressionImpl&lt; BinaryExpression, AndExpression, ExpressionType::AND &gt;</a>, <a class="el" href="classarrow_1_1dataset_1_1_expression_impl.html#a6efe2a97203c4253061884774b261fa7">arrow::dataset::ExpressionImpl&lt; BinaryExpression, OrExpression, ExpressionType::OR &gt;</a>, <a class="el" href="classarrow_1_1dataset_1_1_expression_impl.html#a6efe2a97203c4253061884774b261fa7">arrow::dataset::ExpressionImpl&lt; UnaryExpression, IsValidExpression, ExpressionType::IS_VALID &gt;</a>, and <a class="el" href="classarrow_1_1dataset_1_1_expression_impl.html#a6efe2a97203c4253061884774b261fa7">arrow::dataset::ExpressionImpl&lt; UnaryExpression, CastExpression, ExpressionType::CAST &gt;</a>.</p>

</div>
</div>
<a id="a8c952a05b1090e1ec15adbe7ed712ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c952a05b1090e1ec15adbe7ed712ea6">&#9670;&nbsp;</a></span>Equals() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool arrow::dataset::Expression::Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the expressions are identical; does not check for equivalence. </p>
<p>For example, (A and B) is not equal to (B and A) nor is (A and not A) equal to (false). </p>

<p>Implemented in <a class="el" href="classarrow_1_1dataset_1_1_field_expression.html#ad6071bd8d7747d7d33f2a135d403fc70">arrow::dataset::FieldExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_scalar_expression.html#a9fa18fb3f05a4fa28c3a29db1e20514c">arrow::dataset::ScalarExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_comparison_expression.html#ad8705821278fadf57533d601970bb710">arrow::dataset::ComparisonExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_binary_expression.html#a502e2a91f6c0e6aa61f450fd0e914117">arrow::dataset::BinaryExpression</a>, and <a class="el" href="classarrow_1_1dataset_1_1_unary_expression.html#a5781cb87864a15770ba7fd4b23c7bf5b">arrow::dataset::UnaryExpression</a>.</p>

</div>
</div>
<a id="a2080b195e1999f973c7ceb7e0978a13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2080b195e1999f973c7ceb7e0978a13e">&#9670;&nbsp;</a></span>Equals() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::dataset::Expression::Equals </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classarrow_1_1dataset_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55f49c9a8081e757c4d399073785f171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f49c9a8081e757c4d399073785f171">&#9670;&nbsp;</a></span>Equals() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::dataset::Expression::Equals </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for the common case of checking for equality to a specific scalar. </p>

</div>
</div>
<a id="a5ce811a47927451199574abff5bab72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce811a47927451199574abff5bab72a">&#9670;&nbsp;</a></span>In()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1dataset_1_1_in_expression.html">InExpression</a> arrow::dataset::Expression::In </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classarrow_1_1_array.html">Array</a> &gt;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e5d308f61bdb2ec2074b662ea33f760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5d308f61bdb2ec2074b662ea33f760">&#9670;&nbsp;</a></span>IsNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::dataset::Expression::IsNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, this <a class="el" href="classarrow_1_1dataset_1_1_expression.html" title="Represents an expression tree.">Expression</a> is a <a class="el" href="classarrow_1_1dataset_1_1_scalar_expression.html" title="Represents a scalar value; thin wrapper around arrow::Scalar.">ScalarExpression</a> wrapping a null scalar. </p>

</div>
</div>
<a id="ac665b2a07ec4247f0af1ada25340a294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac665b2a07ec4247f0af1ada25340a294">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarrow_1_1dataset_1_1_is_valid_expression.html">IsValidExpression</a> arrow::dataset::Expression::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd37d50f9235db97d98299dedde5deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd37d50f9235db97d98299dedde5deb8">&#9670;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string arrow::dataset::Expression::ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a debug string representing this expression </p>

<p>Implemented in <a class="el" href="classarrow_1_1dataset_1_1_field_expression.html#afb489412780876ed217cf6a81ff256cb">arrow::dataset::FieldExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_scalar_expression.html#ab720167a80c6244bfa84e1cf30f213d8">arrow::dataset::ScalarExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_cast_expression.html#a8f17eb2e0e2fee7a734503097dbc0475">arrow::dataset::CastExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_in_expression.html#a1c314782ec9e4682e7b2f710e50078fe">arrow::dataset::InExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_is_valid_expression.html#ae9268702c95414fba541ab57f0f8cc07">arrow::dataset::IsValidExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_not_expression.html#a745c7fec120d79fce049d42270c1b60a">arrow::dataset::NotExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_or_expression.html#a563d79e10c50d6028c3e661d3eb1b0db">arrow::dataset::OrExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_and_expression.html#aa42e76ceec3797cc26cc791d94f04414">arrow::dataset::AndExpression</a>, and <a class="el" href="classarrow_1_1dataset_1_1_comparison_expression.html#afb54c43e6ed0005e345651eac188fbd7">arrow::dataset::ComparisonExpression</a>.</p>

</div>
</div>
<a id="a26c748fc0b8eb3ffa800bd957a019d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c748fc0b8eb3ffa800bd957a019d39">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarrow_1_1dataset_1_1_expression_type.html#aa055f8b51338c1fa7f7dda520053b4d5">ExpressionType::type</a> arrow::dataset::Expression::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the expression's type identifier. </p>

</div>
</div>
<a id="a1073c67366c820875c3825e867419050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1073c67366c820875c3825e867419050">&#9670;&nbsp;</a></span>Validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classarrow_1_1_result.html">Result</a>&lt;std::shared_ptr&lt;<a class="el" href="classarrow_1_1_data_type.html">DataType</a>&gt; &gt; arrow::dataset::Expression::Validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarrow_1_1_schema.html">Schema</a> &amp;&#160;</td>
          <td class="paramname"><em>schema</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate this expression for execution against a schema. </p>
<p>This will check that all reference fields are present (fields not in the schema will be replaced with null) and all subexpressions are executable. Returns the type to which this expression will evaluate. </p>

<p>Implemented in <a class="el" href="classarrow_1_1dataset_1_1_field_expression.html#ae3c0c467490c9a5428b52279cab501fd">arrow::dataset::FieldExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_scalar_expression.html#a7303c16da3123ee96085fc29a12e1244">arrow::dataset::ScalarExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_cast_expression.html#a9e12a6b26c33b2d8e560e8ecd2ec1ec9">arrow::dataset::CastExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_in_expression.html#a817e1de48eab774117aef2a3c8fab693">arrow::dataset::InExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_is_valid_expression.html#aab5fbdcac2dcfd41a1aab46625bccebf">arrow::dataset::IsValidExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_not_expression.html#a522f9f8abdc0393ce60803e70117d6a5">arrow::dataset::NotExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_or_expression.html#a359f4524a454a1191986c54165e9438d">arrow::dataset::OrExpression</a>, <a class="el" href="classarrow_1_1dataset_1_1_and_expression.html#a47e66fb78bd4e72211cf628bc272c333">arrow::dataset::AndExpression</a>, and <a class="el" href="classarrow_1_1dataset_1_1_comparison_expression.html#a1e11d7629bf57719dbd3ec26fc97c6e9">arrow::dataset::ComparisonExpression</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4f70ea37a6b7d7e542b1d806e65305f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f70ea37a6b7d7e542b1d806e65305f4">&#9670;&nbsp;</a></span>type_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structarrow_1_1dataset_1_1_expression_type.html#aa055f8b51338c1fa7f7dda520053b4d5">ExpressionType::type</a> arrow::dataset::Expression::type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/wesm/code/arrow/cpp/src/arrow/dataset/<a class="el" href="arrow_2dataset_2filter_8h_source.html">filter.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107500873-1');
</script>
</body>
</html>
