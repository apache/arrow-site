


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Extending pyarrow &mdash; Apache Arrow v0.17.0</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Using pyarrow from C++ and Cython Code" href="extending.html" />
    <link rel="prev" title="CUDA Integration" href="cuda.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Apache Arrow
          

          
          </a>

          
            
            
              <div class="version">
                0.17.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Arrow Specifications and Protocols</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../format/Versioning.html">Format Versioning and Stability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../format/Columnar.html">Arrow Columnar Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../format/Flight.html">Arrow Flight RPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../format/Integration.html">Integration Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../format/CDataInterface.html">The Arrow C data interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../format/Other.html">Other Data Structures</a></li>
</ul>
<p class="caption"><span class="caption-text">Arrow Libraries</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../cpp/index.html">C++ Implementation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Python bindings</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="install.html">Installing PyArrow</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory.html">Memory and IO Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html">Data Types and In-Memory Data Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipc.html">Streaming, Serialization, and IPC</a></li>
<li class="toctree-l2"><a class="reference internal" href="filesystems.html">Filesystem Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="filesystems_deprecated.html">Filesystem Interface (legacy)</a></li>
<li class="toctree-l2"><a class="reference internal" href="plasma.html">The Plasma In-Memory Object Store</a></li>
<li class="toctree-l2"><a class="reference internal" href="numpy.html">NumPy Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="pandas.html">Pandas Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="timestamps.html">Timestamps</a></li>
<li class="toctree-l2"><a class="reference internal" href="csv.html">Reading CSV files</a></li>
<li class="toctree-l2"><a class="reference internal" href="feather.html">Feather File Format</a></li>
<li class="toctree-l2"><a class="reference internal" href="json.html">Reading JSON files</a></li>
<li class="toctree-l2"><a class="reference internal" href="parquet.html">Reading and Writing the Apache Parquet Format</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataset.html">Tabular Datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="cuda.html">CUDA Integration</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Extending pyarrow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#controlling-conversion-to-pyarrow-array-with-the-arrow-array-protocol">Controlling conversion to pyarrow.Array with the <code class="docutils literal notranslate"><span class="pre">__arrow_array__</span></code> protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-extension-types-user-defined-types">Defining extension types (“user-defined types”)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parametrized-extension-type">Parametrized extension type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#custom-extension-array-class">Custom extension array class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conversion-to-pandas">Conversion to pandas</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="extending.html">Using pyarrow from C++ and Cython Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html">API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting_involved.html">Getting Involved</a></li>
<li class="toctree-l2"><a class="reference internal" href="benchmarks.html">Benchmarks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/java/">Java</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/c_glib/">C GLib</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/js/">JavaScript</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/r/">R</a></li>
</ul>
<p class="caption"><span class="caption-text">Development and Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developers/contributing.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developers/cpp/index.html">C++ Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developers/python.html">Python Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developers/integration.html">Integration Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developers/crossbow.html">Packaging and Testing with Crossbow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developers/benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developers/documentation.html">Building the Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Apache Arrow</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Python bindings</a> &raquo;</li>
        
      <li>Extending pyarrow</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/python/extending_types.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="extending-pyarrow">
<span id="extending-types"></span><h1>Extending pyarrow<a class="headerlink" href="#extending-pyarrow" title="Permalink to this headline">¶</a></h1>
<div class="section" id="controlling-conversion-to-pyarrow-array-with-the-arrow-array-protocol">
<h2>Controlling conversion to pyarrow.Array with the <code class="docutils literal notranslate"><span class="pre">__arrow_array__</span></code> protocol<a class="headerlink" href="#controlling-conversion-to-pyarrow-array-with-the-arrow-array-protocol" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/pyarrow.Array.html#pyarrow.array" title="pyarrow.array"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyarrow.array()</span></code></a> function has built-in support for Python sequences,
numpy arrays and pandas 1D objects (Series, Index, Categorical, ..) to convert
those to Arrow arrays. This can be extended for other array-like objects
by implementing the <code class="docutils literal notranslate"><span class="pre">__arrow_array__</span></code> method (similar to numpy’s <code class="docutils literal notranslate"><span class="pre">__array__</span></code>
protocol).</p>
<p>For example, to support conversion of your duck array class to an Arrow array,
define the <code class="docutils literal notranslate"><span class="pre">__arrow_array__</span></code> method to return an Arrow array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyDuckArray</span><span class="p">:</span>

    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__arrow_array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># convert the underlying array values to a pyarrow Array</span>
        <span class="kn">import</span> <span class="nn">pyarrow</span>
        <span class="k">return</span> <span class="n">pyarrow</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__arrow_array__</span></code> method takes an optional <cite>type</cite> keyword which is passed
through from <a class="reference internal" href="generated/pyarrow.Array.html#pyarrow.array" title="pyarrow.array"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyarrow.array()</span></code></a>. The method is allowed to return either
a <code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code> or a <a class="reference internal" href="generated/pyarrow.ChunkedArray.html#pyarrow.ChunkedArray" title="pyarrow.ChunkedArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ChunkedArray</span></code></a>.</p>
</div>
<div class="section" id="defining-extension-types-user-defined-types">
<h2>Defining extension types (“user-defined types”)<a class="headerlink" href="#defining-extension-types-user-defined-types" title="Permalink to this headline">¶</a></h2>
<p>Arrow has the notion of extension types in the metadata specification as a
possibility to extend the built-in types. This is done by annotating any of the
built-in Arrow logical types (the “storage type”) with a custom type name and
optional serialized representation (“ARROW:extension:name” and
“ARROW:extension:metadata” keys in the Field’s custom_metadata of an IPC
message).
See the <a class="reference internal" href="../format/Columnar.html#format-metadata-extension-types"><span class="std std-ref">Extension Types</span></a> section of the metadata
specification for more details.</p>
<p>Pyarrow allows you to define such extension types from Python.</p>
<p>There are currently two ways:</p>
<ul class="simple">
<li><p>Subclassing <a class="reference internal" href="generated/pyarrow.PyExtensionType.html#pyarrow.PyExtensionType" title="pyarrow.PyExtensionType"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyExtensionType</span></code></a>: the (de)serialization is based on pickle.
This is a good option for an extension type that is only used from Python.</p></li>
<li><p>Subclassing <a class="reference internal" href="generated/pyarrow.ExtensionType.html#pyarrow.ExtensionType" title="pyarrow.ExtensionType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionType</span></code></a>: this allows to give a custom
Python-independent name and serialized metadata, that can potentially be
recognized by other (non-Python) Arrow implementations such as PySpark.</p></li>
</ul>
<p>For example, we could define a custom UUID type for 128-bit numbers which can
be represented as <code class="docutils literal notranslate"><span class="pre">FixedSizeBinary</span></code> type with 16 bytes.
Using the first approach, we create a <code class="docutils literal notranslate"><span class="pre">UuidType</span></code> subclass, and implement the
<code class="docutils literal notranslate"><span class="pre">__reduce__</span></code> method to ensure the class can be properly pickled:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UuidType</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">PyExtensionType</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pa</span><span class="o">.</span><span class="n">PyExtensionType</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">binary</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">UuidType</span><span class="p">,</span> <span class="p">()</span>
</pre></div>
</div>
<p>This can now be used to create arrays and tables holding the extension type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">uuid_type</span> <span class="o">=</span> <span class="n">UuidType</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid_type</span><span class="o">.</span><span class="n">extension_name</span>
<span class="go">&#39;arrow.py_extension_type&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid_type</span><span class="o">.</span><span class="n">storage_type</span>
<span class="go">FixedSizeBinaryType(fixed_size_binary[16])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">uuid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">storage_array</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">bytes</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)],</span> <span class="n">pa</span><span class="o">.</span><span class="n">binary</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">ExtensionArray</span><span class="o">.</span><span class="n">from_storage</span><span class="p">(</span><span class="n">uuid_type</span><span class="p">,</span> <span class="n">storage_array</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">&lt;pyarrow.lib.ExtensionArray object at 0x7f75c2f300a0&gt;</span>
<span class="go">[</span>
<span class="go">  A6861959108644B797664AEEE686B682,</span>
<span class="go">  718747F48E5F4058A7261E2B6B228BE8,</span>
<span class="go">  7FE201227D624D96A5CD8639DEF2A68B,</span>
<span class="go">  C6CA8C7F95744BFD9462A40B3F57A86C</span>
<span class="go">]</span>
</pre></div>
</div>
<p>This array can be included in RecordBatches, sent over IPC and received in
another Python process. The custom UUID type will be preserved there, as long
as the definition of the class is available (the type can be unpickled).</p>
<p>For example, creating a RecordBatch and writing it to a stream using the
IPC protocol:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">batch</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatch</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">([</span><span class="n">arr</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;ext&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sink</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">BufferOutputStream</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">writer</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatchStreamWriter</span><span class="p">(</span><span class="n">sink</span><span class="p">,</span> <span class="n">batch</span><span class="o">.</span><span class="n">schema</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">writer</span><span class="o">.</span><span class="n">write_batch</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">sink</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
</pre></div>
</div>
<p>and then reading it back yields the proper type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">ipc</span><span class="o">.</span><span class="n">open_stream</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="s1">&#39;ext&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
<span class="go">UuidType(extension&lt;arrow.py_extension_type&gt;)</span>
</pre></div>
</div>
<p>We can define the same type using the other option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UuidType</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">ExtensionType</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pa</span><span class="o">.</span><span class="n">ExtensionType</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">binary</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;my_package.uuid&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__arrow_ext_serialize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># since we don&#39;t have a parametrized type, we don&#39;t need extra</span>
        <span class="c1"># metadata to be deserialized</span>
        <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__arrow_ext_deserialize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">storage_type</span><span class="p">,</span> <span class="n">serialized</span><span class="p">):</span>
        <span class="c1"># return an instance of this subclass given the serialized</span>
        <span class="c1"># metadata.</span>
        <span class="k">return</span> <span class="n">UuidType</span><span class="p">()</span>
</pre></div>
</div>
<p>This is a slightly longer implementation (you need to implement the special
methods <code class="docutils literal notranslate"><span class="pre">__arrow_ext_serialize__</span></code> and <code class="docutils literal notranslate"><span class="pre">__arrow_ext_deserialize__</span></code>), and the
extension type needs to be registered to be received through IPC (using
<a class="reference internal" href="generated/pyarrow.register_extension_type.html#pyarrow.register_extension_type" title="pyarrow.register_extension_type"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_extension_type()</span></code></a>), but it has
now a unique name:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">uuid_type</span> <span class="o">=</span> <span class="n">UuidType</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid_type</span><span class="o">.</span><span class="n">extension_name</span>
<span class="go">&#39;my_package.uuid&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pa</span><span class="o">.</span><span class="n">register_extension_type</span><span class="p">(</span><span class="n">uuid_type</span><span class="p">)</span>
</pre></div>
</div>
<p>The receiving application doesn’t need to be Python but can still recognize
the extension type as a “uuid” type, if it has implemented its own extension
type to receive it.
If the type is not registered in the receiving application, it will fall back
to the storage type.</p>
<div class="section" id="parametrized-extension-type">
<h3>Parametrized extension type<a class="headerlink" href="#parametrized-extension-type" title="Permalink to this headline">¶</a></h3>
<p>The above example used a fixed storage type with no further metadata. But
more flexible, parametrized extension types are also possible.</p>
<p>The example given here implements an extension type for the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#time-span-representation">pandas “period”
data type</a>,
represententing time spans (e.g., a frequency of a day, a month, a quarter, etc).
It is stored as an int64 array which is interpreted as the number of time spans
of the given frequency since 1970.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PeriodType</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">ExtensionType</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
        <span class="c1"># attributes need to be set first before calling</span>
        <span class="c1"># super init (as that calls serialize)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="n">pa</span><span class="o">.</span><span class="n">ExtensionType</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">int64</span><span class="p">(),</span> <span class="s1">&#39;my_package.period&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

    <span class="k">def</span> <span class="nf">__arrow_ext_serialize__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;freq=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__arrow_ext_deserialize__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">storage_type</span><span class="p">,</span> <span class="n">serialized</span><span class="p">):</span>
        <span class="c1"># return an instance of this subclass given the serialized</span>
        <span class="c1"># metadata.</span>
        <span class="n">serialized</span> <span class="o">=</span> <span class="n">serialized</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">serialized</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;freq=&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">serialized</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">PeriodType</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we ensure to store all information in the serialized metadata that is
needed to reconstruct the instance (in the <code class="docutils literal notranslate"><span class="pre">__arrow_ext_deserialize__</span></code> class
method), in this case the frequency string.</p>
<p>Note that, once created, the data type instance is considered immutable. If,
in the example above, the <code class="docutils literal notranslate"><span class="pre">freq</span></code> parameter would change after instantiation,
the reconstruction of the type instance after IPC will be incorrect.
In the example above, the <code class="docutils literal notranslate"><span class="pre">freq</span></code> parameter is therefore stored in a private
attribute with a public read-only property to access it.</p>
<p>Parametrized extension types are also possible using the pickle-based type
subclassing <a class="reference internal" href="generated/pyarrow.PyExtensionType.html#pyarrow.PyExtensionType" title="pyarrow.PyExtensionType"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyExtensionType</span></code></a>. The equivalent example for the period
data type from above would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PeriodType</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">PyExtensionType</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="n">pa</span><span class="o">.</span><span class="n">PyExtensionType</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">int64</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PeriodType</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,)</span>
</pre></div>
</div>
<p>Also the storage type does not need to be fixed but can be parametrized.</p>
</div>
<div class="section" id="custom-extension-array-class">
<h3>Custom extension array class<a class="headerlink" href="#custom-extension-array-class" title="Permalink to this headline">¶</a></h3>
<p>By default, all arrays with an extension type are constructed or deserialized into
a built-in <a class="reference internal" href="generated/pyarrow.ExtensionArray.html#pyarrow.ExtensionArray" title="pyarrow.ExtensionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionArray</span></code></a> object. Nevertheless, one could want to subclass
<a class="reference internal" href="generated/pyarrow.ExtensionArray.html#pyarrow.ExtensionArray" title="pyarrow.ExtensionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionArray</span></code></a> in order to add some custom logic specific to the extension
type. Arrow allows to do so by adding a special method <code class="docutils literal notranslate"><span class="pre">__arrow_ext_class__</span></code> to the
definition of the extension type.</p>
<p>For instance, let us consider the example from the <a class="reference external" href="https://docs.scipy.org/doc/numpy-1.13.0/user/quickstart.html">Numpy Quickstart</a> of points in 3D space.
We can store these as a fixed-size list, where we wish to be able to extract
the data as a 2-D Numpy array <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">3)</span></code> without any copy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point3DArray</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">ExtensionArray</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">to_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Point3DType</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">PyExtensionType</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pa</span><span class="o">.</span><span class="n">PyExtensionType</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pa</span><span class="o">.</span><span class="n">list_</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">float32</span><span class="p">(),</span> <span class="mi">3</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Point3DType</span><span class="p">,</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__arrow_ext_class__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Point3DArray</span>
</pre></div>
</div>
<p>Arrays built using this extension type now have the expected custom array class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">storage</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="n">pa</span><span class="o">.</span><span class="n">list_</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">float32</span><span class="p">(),</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">ExtensionArray</span><span class="o">.</span><span class="n">from_storage</span><span class="p">(</span><span class="n">Point3DType</span><span class="p">(),</span> <span class="n">storage</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">&lt;__main__.Point3DArray object at 0x7f40dea80670&gt;</span>
<span class="go">[</span>
<span class="go">    [</span>
<span class="go">        1,</span>
<span class="go">        2,</span>
<span class="go">        3</span>
<span class="go">    ],</span>
<span class="go">    [</span>
<span class="go">        4,</span>
<span class="go">        5,</span>
<span class="go">        6</span>
<span class="go">    ]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>The additional methods in the extension class are then available to the user:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">()</span>
<span class="go">array([[1., 2., 3.],</span>
<span class="go">   [4., 5., 6.]], dtype=float32)</span>
</pre></div>
</div>
<p>This array can be sent over IPC, received in another Python process, and the custom
extension array class will be preserved (as long as the definitions of the classes above
are available).</p>
<p>The same <code class="docutils literal notranslate"><span class="pre">__arrow_ext_class__</span></code> specialization can be used with custom types defined
by subclassing <a class="reference internal" href="generated/pyarrow.ExtensionType.html#pyarrow.ExtensionType" title="pyarrow.ExtensionType"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionType</span></code></a>.</p>
</div>
<div class="section" id="conversion-to-pandas">
<h3>Conversion to pandas<a class="headerlink" href="#conversion-to-pandas" title="Permalink to this headline">¶</a></h3>
<p>The conversion to pandas (in <code class="xref py py-meth docutils literal notranslate"><span class="pre">Table.to_pandas()</span></code>) of columns with an
extension type can controlled in case there is a corresponding
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/development/extending.html#extension-types">pandas extension array</a>
for your extension type.</p>
<p>For this, the <a class="reference internal" href="generated/pyarrow.ExtensionType.html#pyarrow.ExtensionType.to_pandas_dtype" title="pyarrow.ExtensionType.to_pandas_dtype"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExtensionType.to_pandas_dtype()</span></code></a> method needs to be
implemented, and should return a <code class="docutils literal notranslate"><span class="pre">pandas.api.extensions.ExtensionDtype</span></code>
subclass instance.</p>
<p>Using the pandas period type from above as example, this would look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PeriodType</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">ExtensionType</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">to_pandas_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">PeriodDtype</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
</pre></div>
</div>
<p>Secondly, the pandas <code class="docutils literal notranslate"><span class="pre">ExtensionDtype</span></code> on its turn needs to have the
<code class="docutils literal notranslate"><span class="pre">__from_arrow__</span></code> method implemented: a method that given a pyarrow Array
or ChunkedArray of the extension type can construct the corresponding
pandas <code class="docutils literal notranslate"><span class="pre">ExtensionArray</span></code>. This method should have the following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyExtensionDtype</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">extensions</span><span class="o">.</span><span class="n">ExtensionDtype</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__from_arrow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="n">pyarrow</span><span class="o">.</span><span class="n">Array</span><span class="o">/</span><span class="n">ChunkedArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pandas</span><span class="o">.</span><span class="n">ExtensionArray</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>This way, you can control the conversion of a pyarrow <code class="docutils literal notranslate"><span class="pre">Array</span></code> of your pyarrow
extension type to a pandas <code class="docutils literal notranslate"><span class="pre">ExtensionArray</span></code> that can be stored in a DataFrame.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="extending.html" class="btn btn-neutral float-right" title="Using pyarrow from C++ and Cython Code" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cuda.html" class="btn btn-neutral float-left" title="CUDA Integration" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2019 Apache Software Foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-107500873-1');
</script>


</body>
</html>