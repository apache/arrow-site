<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1_result" kind="class" language="C++" prot="public">
    <compoundname>arrow::Result</compoundname>
    <basecompoundref refid="classarrow_1_1util_1_1_equality_comparable" prot="public" virt="non-virtual">arrow::util::EqualityComparable&lt; Result&lt; T &gt; &gt;</basecompoundref>
    <includes refid="arrow_2python_2common_8h" local="no">arrow/python/common.h</includes>
    <templateparamlist>
      <param>
        <type>class</type>
        <declname>T</declname>
        <defname>T</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classarrow_1_1_result_1ad8d5bfa294f21e8aa5a5a5d8c0cd5e92" prot="public" static="no">
        <type>T</type>
        <definition>using arrow::Result&lt; T &gt;::ValueType =  T</definition>
        <argsstring></argsstring>
        <name>ValueType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="109" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="109" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classarrow_1_1_result_1ad45d529e81f21b12958357efc1796af4" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>friend class</type>
        <definition>friend class Result</definition>
        <argsstring></argsstring>
        <name>Result</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="103" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="103" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classarrow_1_1_result_1a2865a39f6476f763b55ca7d3ba5033ec" prot="private" static="no" mutable="no">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Result&lt; T &gt;::status_</definition>
        <argsstring></argsstring>
        <name>status_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="412" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="412" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1_result_1aaf2e2f7b861a61cdc9b33188408d31dd" prot="private" static="no" mutable="no">
        <type>std::aligned_storage&lt; sizeof(T), alignof(T)&gt;::type</type>
        <definition>std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type arrow::Result&lt; T &gt;::data_</definition>
        <argsstring></argsstring>
        <name>data_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="413" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="413" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1_result_1afc67b86669f44cf44a1e326665408a02" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Result&lt; T &gt;::Result</definition>
        <argsstring>()</argsstring>
        <name>Result</name>
        <briefdescription>
<para>Constructs a <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object that contains a non-OK status. </para>        </briefdescription>
        <detaileddescription>
<para>This constructor is marked <computeroutput>explicit</computeroutput> to prevent attempts to <computeroutput>return {}</computeroutput> from a function with a return type of, for example, <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;std::vector&lt;int&gt;&gt;</computeroutput>. While <computeroutput>return {}</computeroutput> seems like it would return an empty vector, it will actually invoke the default constructor of <ref refid="classarrow_1_1_result" kindref="compound">Result</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="118" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="118" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a85d43353cb1a58e5aeb305b82d8127eb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Result&lt; T &gt;::~Result</definition>
        <argsstring>() noexcept</argsstring>
        <name>~Result</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="121" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="121" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a60d1d677ca61ef1e30f8491e74de33d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Result&lt; T &gt;::Result</definition>
        <argsstring>(const Status &amp;status)</argsstring>
        <name>Result</name>
        <param>
          <type>const <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> &amp;</type>
          <declname>status</declname>
        </param>
        <briefdescription>
<para>Constructs a <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object with the given non-OK <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> object. </para>        </briefdescription>
        <detaileddescription>
<para>All calls to <ref refid="classarrow_1_1_result_1a03d0aee5e9074bf75b98f7d35dbc7fd3" kindref="member">ValueOrDie()</ref> on this object will abort. The given <computeroutput>status</computeroutput> must not be an OK status, otherwise this constructor will abort.</para><para>This constructor is not declared explicit so that a function with a return type of <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;T&gt;</computeroutput> can return a <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> object, and the status will be implicitly converted to the appropriate return type as a matter of convenience.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>status</parametername>
</parameternamelist>
<parameterdescription>
<para>The non-OK <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> object to initialize to. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="133" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="133" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1af99acb73441cc6ef82bfcd4d45609331" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename U</type>
          </param>
          <param>
            <type>typename E</type>
            <defval>typename std::enable_if&lt;                std::is_constructible&lt;T, U&gt;::value &amp;&amp; std::is_convertible&lt;U, T&gt;::value &amp;&amp;                !std::is_same&lt;typename std::remove_reference&lt;                                  typename std::remove_cv&lt;U&gt;::type&gt;::type,                              <ref refid="classarrow_1_1_status" kindref="compound">Status</ref>&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type></type>
        <definition>arrow::Result&lt; T &gt;::Result</definition>
        <argsstring>(U &amp;&amp;value) noexcept</argsstring>
        <name>Result</name>
        <param>
          <type>U &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Constructs a <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object that contains <computeroutput>value</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The resulting object is considered to have an OK status. The wrapped element can be accessed with <ref refid="classarrow_1_1_result_1a03d0aee5e9074bf75b98f7d35dbc7fd3" kindref="member">ValueOrDie()</ref>.</para><para>This constructor is made implicit so that a function with a return type of <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;T&gt;</computeroutput> can return an object of type <computeroutput>U &amp;&amp;</computeroutput>, implicitly converting it to a <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;T&gt;</computeroutput> object.</para><para>Note that <computeroutput>T</computeroutput> must be implicitly constructible from <computeroutput>U</computeroutput>, and <computeroutput>U</computeroutput> must not be a (cv-qualified) <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> or Status-reference type. Due to C++ reference-collapsing rules and perfect-forwarding semantics, this constructor matches invocations that pass <computeroutput>value</computeroutput> either as a const reference or as an rvalue reference. Since <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> needs to work for both reference and rvalue-reference types, the constructor uses perfect forwarding to avoid invalidating arguments that were passed by reference. See <ulink url="http://thbecker.net/articles/rvalue_references/section_08.html">http://thbecker.net/articles/rvalue_references/section_08.html</ulink> for additional details.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to initialize to. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="166" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="166" bodyend="168"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1aa2db3792c16bf783a1c00b7601c35799" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Result&lt; T &gt;::Result</definition>
        <argsstring>(T &amp;&amp;value) noexcept</argsstring>
        <name>Result</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Constructs a <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object that contains <computeroutput>value</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para>The resulting object is considered to have an OK status. The wrapped element can be accessed with <ref refid="classarrow_1_1_result_1a03d0aee5e9074bf75b98f7d35dbc7fd3" kindref="member">ValueOrDie()</ref>.</para><para>This constructor is made implicit so that a function with a return type of <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;T&gt;</computeroutput> can return an object of type <computeroutput>T</computeroutput>, implicitly converting it to a <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;T&gt;</computeroutput> object.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to initialize to. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="181" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="181" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a9bcbb1f9b195c373c4aab239960493ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Result&lt; T &gt;::Result</definition>
        <argsstring>(const Result &amp;other)</argsstring>
        <name>Result</name>
        <param>
          <type>const <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Copy constructor. </para>        </briefdescription>
        <detaileddescription>
<para>This constructor needs to be explicitly defined because the presence of the move-assignment operator deletes the default copy constructor. In such a scenario, since the deleted copy constructor has stricter binding rules than the templated copy constructor, the templated constructor cannot act as a copy constructor, and any attempt to copy-construct a <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref></computeroutput> object results in a compilation error.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to copy from. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="195" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="195" bodyend="199"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1af71726e519c053eef6faf7192484eae7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename U</type>
          </param>
          <param>
            <type>typename E</type>
            <defval>typename std::enable_if&lt;                            std::is_constructible&lt;T, const U&amp;&gt;::value &amp;&amp;                            std::is_convertible&lt;U, T&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type></type>
        <definition>arrow::Result&lt; T &gt;::Result</definition>
        <argsstring>(const Result&lt; U &gt; &amp;other)</argsstring>
        <name>Result</name>
        <param>
          <type>const <ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; U &gt; &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Templatized constructor that constructs a <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;T&gt;</computeroutput> from a const reference to a <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;U&gt;</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><computeroutput>T</computeroutput> must be implicitly constructible from <computeroutput>const U &amp;</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to copy from. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="210" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="210" bodyend="214"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a7020bc6122c8b88816de0ab02c22559f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref> &amp;</type>
        <definition>Result&amp; arrow::Result&lt; T &gt;::operator=</definition>
        <argsstring>(const Result &amp;other)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Copy-assignment operator. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object to copy. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="219" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="219" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a336d8e48cd7f713e4f82b26869f715c6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename U</type>
          </param>
          <param>
            <type>typename E</type>
            <defval>typename std::enable_if&lt;std::is_constructible&lt;T, U&amp;&amp;&gt;::value &amp;&amp;                                                 std::is_convertible&lt;U, T&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type></type>
        <definition>arrow::Result&lt; T &gt;::Result</definition>
        <argsstring>(Result&lt; U &gt; &amp;&amp;other) noexcept</argsstring>
        <name>Result</name>
        <param>
          <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; U &gt; &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Templatized constructor which constructs a <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;T&gt;</computeroutput> by moving the contents of a <computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;U&gt;</computeroutput>. </para>        </briefdescription>
        <detaileddescription>
<para><computeroutput>T</computeroutput> must be implicitly constructible from <computeroutput>U &amp;&amp;</computeroutput>.</para><para>Sets <computeroutput>other</computeroutput> to contain a non-OK status with a<computeroutput><ref refid="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa4bbb8f967da6d1a610596d7257179c2b" kindref="member">StatusError::Invalid</ref></computeroutput> error code.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object to move from and set to a non-OK status. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="243" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="243" bodyend="252"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a96d8f265891a8a7d3fba447c94ccde75" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref> &amp;</type>
        <definition>Result&amp; arrow::Result&lt; T &gt;::operator=</definition>
        <argsstring>(Result &amp;&amp;other) noexcept</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Move-assignment operator. </para>        </briefdescription>
        <detaileddescription>
<para>Sets <computeroutput>other</computeroutput> to an invalid state..</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object to assign from and set to a non-OK status. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="260" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="260" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a179348089c1f091b6e20d3b576b6593d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::Result&lt; T &gt;::Equals</definition>
        <argsstring>(const Result &amp;other) const</argsstring>
        <name>Equals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Compare to another <ref refid="classarrow_1_1_result" kindref="compound">Result</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="278" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="278" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::Result&lt; T &gt;::ok</definition>
        <argsstring>() const</argsstring>
        <name>ok</name>
        <briefdescription>
<para>Indicates whether the object contains a <computeroutput>T</computeroutput> value. </para>        </briefdescription>
        <detaileddescription>
<para>Generally instead of accessing this directly you will want to use ASSIGN_OR_RAISE defined below.</para><para><simplesect kind="return"><para>True if this <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object&apos;s status is OK (i.e. a call to <ref refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" kindref="member">ok()</ref> returns true). If this function returns true, then it is safe to access the wrapped element through a call to <ref refid="classarrow_1_1_result_1a03d0aee5e9074bf75b98f7d35dbc7fd3" kindref="member">ValueOrDie()</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="292" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="292" bodyend="292"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a7f9be249188ee2c9516ac69ec06b0235" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Result&lt; T &gt;::status</definition>
        <argsstring>() const</argsstring>
        <name>status</name>
        <briefdescription>
<para>Equivalent to <ref refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" kindref="member">ok()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Gets the stored status object, or an OK status if a <computeroutput>T</computeroutput> value is stored.</para><para><simplesect kind="return"><para>The stored non-OK status object, or an OK status if this object has a value. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="301" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="301" bodyend="301"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a03d0aee5e9074bf75b98f7d35dbc7fd3" prot="public" static="no" const="yes" explicit="no" inline="yes" refqual="lvalue" virt="non-virtual">
        <type>const T &amp;</type>
        <definition>const T&amp; arrow::Result&lt; T &gt;::ValueOrDie</definition>
        <argsstring>() const &amp;</argsstring>
        <name>ValueOrDie</name>
        <briefdescription>
<para>Gets the stored <computeroutput>T</computeroutput> value. </para>        </briefdescription>
        <detaileddescription>
<para>This method should only be called if this <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object&apos;s status is OK (i.e. a call to <ref refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" kindref="member">ok()</ref> returns true), otherwise this call will abort.</para><para><simplesect kind="return"><para>The stored <computeroutput>T</computeroutput> value. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="309" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="309" bodyend="314"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1ab99dcf6a54a09c94940b5e14b4fc8210" prot="public" static="no" const="yes" explicit="no" inline="yes" refqual="lvalue" virt="non-virtual">
        <type>const T &amp;</type>
        <definition>const T&amp; arrow::Result&lt; T &gt;::operator*</definition>
        <argsstring>() const &amp;</argsstring>
        <name>operator*</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="315" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="315" bodyend="315"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1af06a0a8c358b090595586e91fe85ca42" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="lvalue" virt="non-virtual">
        <type>T &amp;</type>
        <definition>T&amp; arrow::Result&lt; T &gt;::ValueOrDie</definition>
        <argsstring>() &amp;</argsstring>
        <name>ValueOrDie</name>
        <briefdescription>
<para>Gets a mutable reference to the stored <computeroutput>T</computeroutput> value. </para>        </briefdescription>
        <detaileddescription>
<para>This method should only be called if this <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object&apos;s status is OK (i.e. a call to <ref refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" kindref="member">ok()</ref> returns true), otherwise this call will abort.</para><para><simplesect kind="return"><para>The stored <computeroutput>T</computeroutput> value. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="323" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="323" bodyend="328"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a159e8d9468aa493c5e46354767506d75" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="lvalue" virt="non-virtual">
        <type>T &amp;</type>
        <definition>T&amp; arrow::Result&lt; T &gt;::operator*</definition>
        <argsstring>() &amp;</argsstring>
        <name>operator*</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="329" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="329" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1aeddcd41d61cb41b2fdca0cc814ff03c9" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="rvalue" virt="non-virtual">
        <type>T</type>
        <definition>T arrow::Result&lt; T &gt;::ValueOrDie</definition>
        <argsstring>() &amp;&amp;</argsstring>
        <name>ValueOrDie</name>
        <briefdescription>
<para>Moves and returns the internally-stored <computeroutput>T</computeroutput> value. </para>        </briefdescription>
        <detaileddescription>
<para>This method should only be called if this <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object&apos;s status is OK (i.e. a call to <ref refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" kindref="member">ok()</ref> returns true), otherwise this call will abort. The <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object is invalidated after this call and will be updated to contain a non-OK status.</para><para><simplesect kind="return"><para>The stored <computeroutput>T</computeroutput> value. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="339" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="339" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1ad5b6d3fb1d6b148bc82f97d267a22e38" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="rvalue" virt="non-virtual">
        <type>T</type>
        <definition>T arrow::Result&lt; T &gt;::operator*</definition>
        <argsstring>() &amp;&amp;</argsstring>
        <name>operator*</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="345" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="345" bodyend="345"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a4ba6599a83fc659b24e4336eb06b9ae4" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="rvalue" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename U</type>
          </param>
          <param>
            <type>typename E</type>
            <defval>typename std::enable_if&lt;                            std::is_constructible&lt;U, T&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Result&lt; T &gt;::Value</definition>
        <argsstring>(U *out) &amp;&amp;</argsstring>
        <name>Value</name>
        <param>
          <type>U *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Helper method for implementing <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> returning functions in terms of semantically equivalent <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> returning functions. </para>        </briefdescription>
        <detaileddescription>
<para>For example:</para><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> GetInt(int *out) { return GetInt().Value(out); } </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="353" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="353" bodyend="359"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a00ecc57de8813a5e587060f42e036462" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="rvalue" virt="non-virtual">
        <type>T</type>
        <definition>T arrow::Result&lt; T &gt;::ValueOr</definition>
        <argsstring>(T alternative) &amp;&amp;</argsstring>
        <name>ValueOr</name>
        <param>
          <type>T</type>
          <declname>alternative</declname>
        </param>
        <briefdescription>
<para>Move and return the internally stored value or alternative if an error is stored. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="362" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="362" bodyend="367"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a159c85d9159b5e0a3e7f79a00a3f5314" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="rvalue" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename G</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T arrow::Result&lt; T &gt;::ValueOrElse</definition>
        <argsstring>(G &amp;&amp;generate_alternative) &amp;&amp;</argsstring>
        <name>ValueOrElse</name>
        <param>
          <type>G &amp;&amp;</type>
          <declname>generate_alternative</declname>
        </param>
        <briefdescription>
<para>Retrieve the value if <ref refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" kindref="member">ok()</ref>, falling back to an alternative generated by the provided factory. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="372" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="372" bodyend="377"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a6abc595bbb640cac339fa215245e257a" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="rvalue" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename M</type>
          </param>
        </templateparamlist>
        <type>std::result_of&lt; M &amp;&amp;(T)&gt;::type</type>
        <definition>std::result_of&lt;M &amp;&amp; (T)&gt;::type arrow::Result&lt; T &gt;::Map</definition>
        <argsstring>(M &amp;&amp;m) &amp;&amp;</argsstring>
        <name>Map</name>
        <param>
          <type>M &amp;&amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Apply a function to the internally stored value to produce a new result or propagate the stored error. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="382" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="382" bodyend="387"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a36e8298c563a27944e99c517e3e1a797" prot="public" static="no" const="yes" explicit="no" inline="yes" refqual="lvalue" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename M</type>
          </param>
        </templateparamlist>
        <type>std::result_of&lt; M &amp;&amp;(const T &amp;)&gt;::type</type>
        <definition>std::result_of&lt;M &amp;&amp; (const T&amp;)&gt;::type arrow::Result&lt; T &gt;::Map</definition>
        <argsstring>(M &amp;&amp;m) const &amp;</argsstring>
        <name>Map</name>
        <param>
          <type>M &amp;&amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
<para>Apply a function to the internally stored value to produce a new result or propagate the stored error. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="392" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="392" bodyend="397"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1aaa9cf7eafd8aeaae574a8dfa6cef4547" prot="public" static="no" const="yes" explicit="no" inline="yes" refqual="lvalue" virt="non-virtual">
        <type>const T &amp;</type>
        <definition>const T&amp; arrow::Result&lt; T &gt;::ValueUnsafe</definition>
        <argsstring>() const &amp;</argsstring>
        <name>ValueUnsafe</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="399" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="399" bodyend="401"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1ab28efec8c757de4d6695b3521288c09e" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="lvalue" virt="non-virtual">
        <type>T &amp;</type>
        <definition>T&amp; arrow::Result&lt; T &gt;::ValueUnsafe</definition>
        <argsstring>() &amp;</argsstring>
        <name>ValueUnsafe</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="403" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="403" bodyend="403"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1ada79a00016d19f9f8af442bf2b020467" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="rvalue" virt="non-virtual">
        <type>T</type>
        <definition>T arrow::Result&lt; T &gt;::ValueUnsafe</definition>
        <argsstring>() &amp;&amp;</argsstring>
        <name>ValueUnsafe</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="405" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="405" bodyend="405"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1a2562206bd7bdc22c3531d29f448ee6ed" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T arrow::Result&lt; T &gt;::MoveValueUnsafe</definition>
        <argsstring>()</argsstring>
        <name>MoveValueUnsafe</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="407" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="407" bodyend="409"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classarrow_1_1_result_1a7563349ca58e1179d338a9c5866869b0" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void arrow::Result&lt; T &gt;::ConstructValue</definition>
        <argsstring>(U &amp;&amp;u)</argsstring>
        <name>ConstructValue</name>
        <param>
          <type>U &amp;&amp;</type>
          <declname>u</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="416" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="416" bodyend="418"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_result_1afcdc367951c345a580827bf2af7672a2" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::Result&lt; T &gt;::Destroy</definition>
        <argsstring>()</argsstring>
        <name>Destroy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/result.h" line="420" column="1" bodyfile="/arrow/cpp/src/arrow/result.h" bodystart="420" bodyend="424"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A class for representing either a usable value, or an error. </para>    </briefdescription>
    <detaileddescription>
<para>A <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object either contains a value of type <computeroutput>T</computeroutput> or a <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> object explaining why such a value is not present. The type <computeroutput>T</computeroutput> must be copy-constructible and/or move-constructible.</para><para>The state of a <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object may be determined by calling <ref refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" kindref="member">ok()</ref> or <ref refid="classarrow_1_1_result_1a7f9be249188ee2c9516ac69ec06b0235" kindref="member">status()</ref>. The <ref refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" kindref="member">ok()</ref> method returns true if the object contains a valid value. The <ref refid="classarrow_1_1_result_1a7f9be249188ee2c9516ac69ec06b0235" kindref="member">status()</ref> method returns the internal <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> object. A <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object that contains a valid value will return an OK <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> for a call to <ref refid="classarrow_1_1_result_1a7f9be249188ee2c9516ac69ec06b0235" kindref="member">status()</ref>.</para><para>A value of type <computeroutput>T</computeroutput> may be extracted from a <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object through a call to <ref refid="classarrow_1_1_result_1a03d0aee5e9074bf75b98f7d35dbc7fd3" kindref="member">ValueOrDie()</ref>. This function should only be called if a call to <ref refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" kindref="member">ok()</ref> returns true. Sample usage:</para><para><programlisting><codeline><highlight class="normal"><sp/>arrow::Result&lt;Foo&gt;<sp/>result<sp/>=<sp/>CalculateFoo();</highlight></codeline>
<codeline><highlight class="normal"><sp/>if<sp/>(result.ok())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>Foo<sp/>foo<sp/>=<sp/>result.ValueOrDie();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>foo.DoSomethingCool();</highlight></codeline>
<codeline><highlight class="normal"><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>ARROW_LOG(ERROR)<sp/>&lt;&lt;<sp/>result.status();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>If <computeroutput>T</computeroutput> is a move-only type, like <computeroutput>std::unique_ptr&lt;&gt;</computeroutput>, then the value should only be extracted after invoking <computeroutput>std::move()</computeroutput> on the <ref refid="classarrow_1_1_result" kindref="compound">Result</ref> object. Sample usage:</para><para><programlisting><codeline><highlight class="normal">arrow::Result&lt;std::unique_ptr&lt;Foo&gt;&gt;<sp/>result<sp/>=<sp/>CalculateFoo();</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(result.ok())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::unique_ptr&lt;Foo&gt;<sp/>foo<sp/>=<sp/>std::move(result).ValueOrDie();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>foo-&gt;DoSomethingCool();</highlight></codeline>
<codeline><highlight class="normal">}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ARROW_LOG(ERROR)<sp/>&lt;&lt;<sp/>result.status();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><ref refid="classarrow_1_1_result" kindref="compound">Result</ref> is provided for the convenience of implementing functions that return some value but may fail during execution. For instance, consider a function with the following signature:</para><para><programlisting><codeline><highlight class="normal">arrow::Status<sp/>CalculateFoo(int<sp/>*output);</highlight></codeline>
</programlisting></para><para>This function may instead be written as:</para><para><programlisting><codeline><highlight class="normal">arrow::Result&lt;int&gt;<sp/>CalculateFoo();</highlight></codeline>
</programlisting> </para>    </detaileddescription>
    <inheritancegraph>
      <node id="3916">
        <label>arrow::util::EqualityComparable&lt; Result&lt; T &gt; &gt;</label>
        <link refid="classarrow_1_1util_1_1_equality_comparable"/>
      </node>
      <node id="3915">
        <label>arrow::Result&lt; T &gt;</label>
        <link refid="classarrow_1_1_result"/>
        <childnode refid="3916" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="3918">
        <label>arrow::util::EqualityComparable&lt; Result&lt; T &gt; &gt;</label>
        <link refid="classarrow_1_1util_1_1_equality_comparable"/>
      </node>
      <node id="3917">
        <label>arrow::Result&lt; T &gt;</label>
        <link refid="classarrow_1_1_result"/>
        <childnode refid="3918" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/arrow/cpp/src/arrow/python/common.h" line="34" column="1" bodyfile="/arrow/cpp/src/arrow/python/common.h" bodystart="34" bodyend="-1"/>
    <listofallmembers>
      <member refid="classarrow_1_1_result_1a7563349ca58e1179d338a9c5866869b0" prot="private" virt="non-virtual"><scope>arrow::Result</scope><name>ConstructValue</name></member>
      <member refid="classarrow_1_1_result_1aaf2e2f7b861a61cdc9b33188408d31dd" prot="private" virt="non-virtual"><scope>arrow::Result</scope><name>data_</name></member>
      <member refid="classarrow_1_1_result_1afcdc367951c345a580827bf2af7672a2" prot="private" virt="non-virtual"><scope>arrow::Result</scope><name>Destroy</name></member>
      <member refid="classarrow_1_1_result_1a179348089c1f091b6e20d3b576b6593d" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Equals</name></member>
      <member refid="classarrow_1_1util_1_1_equality_comparable_1a140cfdea92ae17331d8db8f69aad082f" prot="public" virt="non-virtual" ambiguityscope="EqualityComparable&lt; Result&lt; T &gt; &gt;::"><scope>arrow::Result</scope><name>Equals</name></member>
      <member refid="classarrow_1_1_result_1a6abc595bbb640cac339fa215245e257a" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Map</name></member>
      <member refid="classarrow_1_1_result_1a36e8298c563a27944e99c517e3e1a797" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Map</name></member>
      <member refid="classarrow_1_1_result_1a2562206bd7bdc22c3531d29f448ee6ed" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>MoveValueUnsafe</name></member>
      <member refid="classarrow_1_1_result_1a6d1f64c394afe8ba05938053be5939bf" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ok</name></member>
      <member refid="classarrow_1_1util_1_1_equality_comparable_1a1a7ff2c6f720209bc960524c47ad0535" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>operator!=</name></member>
      <member refid="classarrow_1_1_result_1ab99dcf6a54a09c94940b5e14b4fc8210" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>operator*</name></member>
      <member refid="classarrow_1_1_result_1a159e8d9468aa493c5e46354767506d75" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>operator*</name></member>
      <member refid="classarrow_1_1_result_1ad5b6d3fb1d6b148bc82f97d267a22e38" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>operator*</name></member>
      <member refid="classarrow_1_1_result_1a7020bc6122c8b88816de0ab02c22559f" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>operator=</name></member>
      <member refid="classarrow_1_1_result_1a96d8f265891a8a7d3fba447c94ccde75" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>operator=</name></member>
      <member refid="classarrow_1_1util_1_1_equality_comparable_1ac0e8ec25e77ece923689ee31c389200e" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>operator==</name></member>
      <member refid="classarrow_1_1_result_1afc67b86669f44cf44a1e326665408a02" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Result</name></member>
      <member refid="classarrow_1_1_result_1a60d1d677ca61ef1e30f8491e74de33d5" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Result</name></member>
      <member refid="classarrow_1_1_result_1af99acb73441cc6ef82bfcd4d45609331" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Result</name></member>
      <member refid="classarrow_1_1_result_1aa2db3792c16bf783a1c00b7601c35799" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Result</name></member>
      <member refid="classarrow_1_1_result_1a9bcbb1f9b195c373c4aab239960493ef" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Result</name></member>
      <member refid="classarrow_1_1_result_1af71726e519c053eef6faf7192484eae7" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Result</name></member>
      <member refid="classarrow_1_1_result_1a336d8e48cd7f713e4f82b26869f715c6" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Result</name></member>
      <member refid="classarrow_1_1_result_1a7f9be249188ee2c9516ac69ec06b0235" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>status</name></member>
      <member refid="classarrow_1_1_result_1a2865a39f6476f763b55ca7d3ba5033ec" prot="private" virt="non-virtual"><scope>arrow::Result</scope><name>status_</name></member>
      <member refid="classarrow_1_1_result_1a4ba6599a83fc659b24e4336eb06b9ae4" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>Value</name></member>
      <member refid="classarrow_1_1_result_1a00ecc57de8813a5e587060f42e036462" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ValueOr</name></member>
      <member refid="classarrow_1_1_result_1a03d0aee5e9074bf75b98f7d35dbc7fd3" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ValueOrDie</name></member>
      <member refid="classarrow_1_1_result_1af06a0a8c358b090595586e91fe85ca42" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ValueOrDie</name></member>
      <member refid="classarrow_1_1_result_1aeddcd41d61cb41b2fdca0cc814ff03c9" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ValueOrDie</name></member>
      <member refid="classarrow_1_1_result_1a159c85d9159b5e0a3e7f79a00a3f5314" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ValueOrElse</name></member>
      <member refid="classarrow_1_1_result_1ad8d5bfa294f21e8aa5a5a5d8c0cd5e92" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ValueType</name></member>
      <member refid="classarrow_1_1_result_1aaa9cf7eafd8aeaae574a8dfa6cef4547" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ValueUnsafe</name></member>
      <member refid="classarrow_1_1_result_1ab28efec8c757de4d6695b3521288c09e" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ValueUnsafe</name></member>
      <member refid="classarrow_1_1_result_1ada79a00016d19f9f8af442bf2b020467" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>ValueUnsafe</name></member>
      <member refid="classarrow_1_1util_1_1_equality_comparable_1a14c5ed61e030855eef29edebc6355806" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>~EqualityComparable</name></member>
      <member refid="classarrow_1_1_result_1a85d43353cb1a58e5aeb305b82d8127eb" prot="public" virt="non-virtual"><scope>arrow::Result</scope><name>~Result</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
