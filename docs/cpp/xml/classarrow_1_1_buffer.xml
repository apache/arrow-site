<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1_buffer" kind="class" language="C++" prot="public">
    <compoundname>arrow::Buffer</compoundname>
    <derivedcompoundref refid="classarrow_1_1cuda_1_1_cuda_buffer" prot="public" virt="non-virtual">arrow::cuda::CudaBuffer</derivedcompoundref>
    <derivedcompoundref refid="classarrow_1_1_mutable_buffer" prot="public" virt="non-virtual">arrow::MutableBuffer</derivedcompoundref>
    <derivedcompoundref refid="classarrow_1_1py_1_1_num_py_buffer" prot="public" virt="non-virtual">arrow::py::NumPyBuffer</derivedcompoundref>
    <derivedcompoundref refid="classarrow_1_1py_1_1_py_buffer" prot="public" virt="non-virtual">arrow::py::PyBuffer</derivedcompoundref>
    <derivedcompoundref refid="classarrow_1_1py_1_1_py_foreign_buffer" prot="public" virt="non-virtual">arrow::py::PyForeignBuffer</derivedcompoundref>
    <includes refid="buffer_8h" local="no">arrow/buffer.h</includes>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classarrow_1_1_buffer_1acfefa777b4d7d6a2f7a8ea23549dac46" prot="protected" static="no" mutable="no">
        <type>bool</type>
        <definition>bool arrow::Buffer::is_mutable_</definition>
        <argsstring></argsstring>
        <name>is_mutable_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="306" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="306" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1_buffer_1a5abed4a6cddccc03be462e84034800e9" prot="protected" static="no" mutable="no">
        <type>bool</type>
        <definition>bool arrow::Buffer::is_cpu_</definition>
        <argsstring></argsstring>
        <name>is_cpu_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="307" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="307" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1_buffer_1af468a7a1f346f9a6a29738bf585a3548" prot="protected" static="no" mutable="no">
        <type>const uint8_t *</type>
        <definition>const uint8_t* arrow::Buffer::data_</definition>
        <argsstring></argsstring>
        <name>data_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="308" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="308" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1_buffer_1ad36e306b99bc8427865bcac9b2d4f7e5" prot="protected" static="no" mutable="no">
        <type>uint8_t *</type>
        <definition>uint8_t* arrow::Buffer::mutable_data_</definition>
        <argsstring></argsstring>
        <name>mutable_data_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="309" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="309" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1_buffer_1a3500e42217635843b3b34bfe92b2f73a" prot="protected" static="no" mutable="no">
        <type>int64_t</type>
        <definition>int64_t arrow::Buffer::size_</definition>
        <argsstring></argsstring>
        <name>size_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="310" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="310" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1_buffer_1a45ee7f1e21f9f3f4cb8233be8d64731e" prot="protected" static="no" mutable="no">
        <type>int64_t</type>
        <definition>int64_t arrow::Buffer::capacity_</definition>
        <argsstring></argsstring>
        <name>capacity_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="311" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="311" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1_buffer_1a3feb5a490cbd9699837067931476c65b" prot="protected" static="no" mutable="no">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Buffer&gt; arrow::Buffer::parent_</definition>
        <argsstring></argsstring>
        <name>parent_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="314" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="314" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classarrow_1_1_buffer_1ab00bfb3fc1876f207457f9d69e8ecd31" prot="private" static="no" mutable="no">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt;</type>
        <definition>std::shared_ptr&lt;MemoryManager&gt; arrow::Buffer::memory_manager_</definition>
        <argsstring></argsstring>
        <name>memory_manager_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="318" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="318" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1_buffer_1a801078c559b0c351f1ca5a6b6a04488f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Buffer::Buffer</definition>
        <argsstring>(const uint8_t *data, int64_t size)</argsstring>
        <name>Buffer</name>
        <param>
          <type>const uint8_t *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Construct from buffer and size without copying memory. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>a memory buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer size</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The passed memory must be kept alive through some other means </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="60" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="60" bodyend="68"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1aeedf5002e6f26bb2d9ca815889462619" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Buffer::Buffer</definition>
        <argsstring>(const uint8_t *data, int64_t size, std::shared_ptr&lt; MemoryManager &gt; mm, std::shared_ptr&lt; Buffer &gt; parent=NULLPTR)</argsstring>
        <name>Buffer</name>
        <param>
          <type>const uint8_t *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt;</type>
          <declname>mm</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>parent</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="70" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="70" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1aa65c1dfabef4c7a6ae3bf9b9adaa6bb4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Buffer::Buffer</definition>
        <argsstring>(uintptr_t address, int64_t size, std::shared_ptr&lt; MemoryManager &gt; mm, std::shared_ptr&lt; Buffer &gt; parent=NULLPTR)</argsstring>
        <name>Buffer</name>
        <param>
          <type>uintptr_t</type>
          <declname>address</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt;</type>
          <declname>mm</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>parent</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="81" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="81" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a5a918801b40b57a959dd9405f87948f2" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Buffer::Buffer</definition>
        <argsstring>(util::string_view data)</argsstring>
        <name>Buffer</name>
        <param>
          <type>util::string_view</type>
          <declname>data</declname>
        </param>
        <briefdescription>
<para>Construct from string_view without copying memory. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>a string_view object</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The memory viewed by data must not be deallocated in the lifetime of the <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref>; temporary rvalue strings must be stored in an lvalue somewhere </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="92" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="92" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1ae6e34f304922c3416a58688bf0cd4471" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual arrow::Buffer::~Buffer</definition>
        <argsstring>()=default</argsstring>
        <name>~Buffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="96" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1af694696afedb9313cf5dc874ffa9a453" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Buffer::Buffer</definition>
        <argsstring>(const std::shared_ptr&lt; Buffer &gt; &amp;parent, const int64_t offset, const int64_t size)</argsstring>
        <name>Buffer</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &amp;</type>
          <declname>parent</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>An offset into data that is owned by another buffer, but we want to be able to retain a valid pointer to it even after other shared_ptr&apos;s to the parent buffer have been destroyed. </para>        </briefdescription>
        <detaileddescription>
<para>This method makes no assertions about alignment or padding of the buffer but in general we expected buffers to be aligned and padded to 64 bytes. In the future we might add utility methods to help determine if a buffer satisfies this contract. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="105" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="105" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a90752e80fe0d4252d73da6e8c3658bd1" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t arrow::Buffer::operator[]</definition>
        <argsstring>(std::size_t i) const</argsstring>
        <name>operator[]</name>
        <param>
          <type>std::size_t</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="111" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="111" bodyend="111"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1adf6316bf6733c0f308dfa8f6db540b19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string arrow::Buffer::ToHexString</definition>
        <argsstring>()</argsstring>
        <name>ToHexString</name>
        <briefdescription>
<para>Construct a new std::string with a hexadecimal representation of the buffer. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>std::string </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="115" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a94918db73183b750716a07133dd8384d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::Buffer::Equals</definition>
        <argsstring>(const Buffer &amp;other, int64_t nbytes) const</argsstring>
        <name>Equals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>nbytes</declname>
        </param>
        <briefdescription>
<para>Return true if both buffers are the same size and contain the same bytes up to the number of compared bytes. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="119" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a0d3d3bd95a3297046a6ab24f5e957bfd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::Buffer::Equals</definition>
        <argsstring>(const Buffer &amp;other) const</argsstring>
        <name>Equals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Return true if both buffers are the same size and contain the same bytes. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="122" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a8e6500a2eb6667f2e7ebf0277627d435" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::Buffer::CopySlice</definition>
        <argsstring>(const int64_t start, const int64_t nbytes, MemoryPool *pool=default_memory_pool()) const</argsstring>
        <name>CopySlice</name>
        <param>
          <type>const int64_t</type>
          <declname>start</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>nbytes</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820" kindref="member">default_memory_pool</ref>()</defval>
        </param>
        <briefdescription>
<para>Copy a section of the buffer into a new <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="125" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a7081913a08b88c2ca674c36354d5e171" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Buffer::Copy</definition>
        <argsstring>(const int64_t start, const int64_t nbytes, MemoryPool *pool, std::shared_ptr&lt; Buffer &gt; *out) const</argsstring>
        <name>Copy</name>
        <param>
          <type>const int64_t</type>
          <declname>start</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>nbytes</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="130" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1adcf891e5c72d591f1c293027dbf7f22a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Buffer::Copy</definition>
        <argsstring>(const int64_t start, const int64_t nbytes, std::shared_ptr&lt; Buffer &gt; *out) const</argsstring>
        <name>Copy</name>
        <param>
          <type>const int64_t</type>
          <declname>start</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>nbytes</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="134" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a885f7b3329f3adb43a826e9403732a15" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::Buffer::ZeroPadding</definition>
        <argsstring>()</argsstring>
        <name>ZeroPadding</name>
        <briefdescription>
<para>Zero bytes in padding, i.e. bytes between size_ and capacity_. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="138" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="138" bodyend="146"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a90034bddee753d83af07e97cdd252b8f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string arrow::Buffer::ToString</definition>
        <argsstring>() const</argsstring>
        <name>ToString</name>
        <briefdescription>
<para>Copy buffer contents into a new std::string. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>std::string </para></simplesect>
<simplesect kind="note"><para>Can throw std::bad_alloc if buffer is large </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="187" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a3553bee276a12793c601d92789388052" prot="public" static="no" const="yes" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Buffer::operator util::string_view</definition>
        <argsstring>() const</argsstring>
        <name>operator util::string_view</name>
        <briefdescription>
<para>View buffer contents as a util::string_view. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>util::string_view </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="191" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="191" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a63f0eb8387cb5a9717c11e9d5e720cbb" prot="public" static="no" const="yes" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Buffer::operator util::bytes_view</definition>
        <argsstring>() const</argsstring>
        <name>operator util::bytes_view</name>
        <briefdescription>
<para>View buffer contents as a <ref refid="namespacearrow_1_1util_1a550cadd9d8d2f10f4b3c968065b9287b" kindref="member">util::bytes_view</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="namespacearrow_1_1util_1a550cadd9d8d2f10f4b3c968065b9287b" kindref="member">util::bytes_view</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="197" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="197" bodyend="197"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a81c3dd8c11dd804be2ada6df5ce8fad2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const uint8_t *</type>
        <definition>const uint8_t* arrow::Buffer::data</definition>
        <argsstring>() const</argsstring>
        <name>data</name>
        <briefdescription>
<para>Return a pointer to the buffer&apos;s data. </para>        </briefdescription>
        <detaileddescription>
<para>The buffer has to be a CPU buffer (<computeroutput><ref refid="classarrow_1_1_buffer_1ad349be0b3ddf33c20e96501ad64e1ff6" kindref="member">is_cpu()</ref></computeroutput> is true). Otherwise, an assertion may be thrown or a null pointer may be returned.</para><para>To get the buffer&apos;s data address regardless of its device, call <computeroutput><ref refid="classarrow_1_1_buffer_1a48683d9fd81454ba10ea0046775f38f3" kindref="member">address()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="205" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="205" bodyend="210"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a5a9cb9324d3f7e323eb070b553c925aa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>uint8_t *</type>
        <definition>uint8_t* arrow::Buffer::mutable_data</definition>
        <argsstring>()</argsstring>
        <name>mutable_data</name>
        <briefdescription>
<para>Return a writable pointer to the buffer&apos;s data. </para>        </briefdescription>
        <detaileddescription>
<para>The buffer has to be a mutable CPU buffer (<computeroutput><ref refid="classarrow_1_1_buffer_1ad349be0b3ddf33c20e96501ad64e1ff6" kindref="member">is_cpu()</ref></computeroutput> and <computeroutput><ref refid="classarrow_1_1_buffer_1a8244f9c354364788161f11bedc6f2ab9" kindref="member">is_mutable()</ref></computeroutput> are true). Otherwise, an assertion may be thrown or a null pointer may be returned.</para><para>To get the buffer&apos;s mutable data address regardless of its device, call <computeroutput><ref refid="classarrow_1_1_buffer_1ab7a69ac4d88bd02c39fbe57225ff387a" kindref="member">mutable_address()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="220" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="220" bodyend="226"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a48683d9fd81454ba10ea0046775f38f3" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>uintptr_t</type>
        <definition>uintptr_t arrow::Buffer::address</definition>
        <argsstring>() const</argsstring>
        <name>address</name>
        <briefdescription>
<para>Return the device address of the buffer&apos;s data. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="229" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="229" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1ab7a69ac4d88bd02c39fbe57225ff387a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>uintptr_t</type>
        <definition>uintptr_t arrow::Buffer::mutable_address</definition>
        <argsstring>() const</argsstring>
        <name>mutable_address</name>
        <briefdescription>
<para>Return a writable device address to the buffer&apos;s data. </para>        </briefdescription>
        <detaileddescription>
<para>The buffer has to be a mutable buffer (<computeroutput><ref refid="classarrow_1_1_buffer_1a8244f9c354364788161f11bedc6f2ab9" kindref="member">is_mutable()</ref></computeroutput> is true). Otherwise, an assertion may be thrown or 0 may be returned. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="235" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="235" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a2a49871341c300996a39145d22aa8054" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t arrow::Buffer::size</definition>
        <argsstring>() const</argsstring>
        <name>size</name>
        <briefdescription>
<para>Return the buffer&apos;s size in bytes. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="243" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="243" bodyend="243"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a4c75902129b5f2fb471fd166907361dc" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t arrow::Buffer::capacity</definition>
        <argsstring>() const</argsstring>
        <name>capacity</name>
        <briefdescription>
<para>Return the buffer&apos;s capacity (number of allocated bytes) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="246" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="246" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1ad349be0b3ddf33c20e96501ad64e1ff6" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::Buffer::is_cpu</definition>
        <argsstring>() const</argsstring>
        <name>is_cpu</name>
        <briefdescription>
<para>Whether the buffer is directly CPU-accessible. </para>        </briefdescription>
        <detaileddescription>
<para>If this function returns true, you can read directly from the buffer&apos;s <computeroutput><ref refid="classarrow_1_1_buffer_1a81c3dd8c11dd804be2ada6df5ce8fad2" kindref="member">data()</ref></computeroutput> pointer. Otherwise, you&apos;ll have to <computeroutput><ref refid="classarrow_1_1_buffer_1ac4b959d7080e383ab0a9ff54d8dd9fa3" kindref="member">View()</ref></computeroutput> or <computeroutput><ref refid="classarrow_1_1_buffer_1a7081913a08b88c2ca674c36354d5e171" kindref="member">Copy()</ref></computeroutput> it. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="252" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="252" bodyend="252"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a8244f9c354364788161f11bedc6f2ab9" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::Buffer::is_mutable</definition>
        <argsstring>() const</argsstring>
        <name>is_mutable</name>
        <briefdescription>
<para>Whether the buffer is mutable. </para>        </briefdescription>
        <detaileddescription>
<para>If this function returns true, you are allowed to modify buffer contents using the pointer returned by <computeroutput><ref refid="classarrow_1_1_buffer_1a5a9cb9324d3f7e323eb070b553c925aa" kindref="member">mutable_data()</ref></computeroutput> or <computeroutput><ref refid="classarrow_1_1_buffer_1ab7a69ac4d88bd02c39fbe57225ff387a" kindref="member">mutable_address()</ref></computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="258" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="258" bodyend="258"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1aee84b1a0d5a0ff5e0f80f9bfcb05ffa2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_device" kindref="compound">Device</ref> &gt; &amp;</type>
        <definition>const std::shared_ptr&lt;Device&gt;&amp; arrow::Buffer::device</definition>
        <argsstring>() const</argsstring>
        <name>device</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="260" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="260" bodyend="260"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a41cea4c92d66087126036c81221ce7ea" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt; &amp;</type>
        <definition>const std::shared_ptr&lt;MemoryManager&gt;&amp; arrow::Buffer::memory_manager</definition>
        <argsstring>() const</argsstring>
        <name>memory_manager</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="262" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="262" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1ac58d818fa0d8a5db215ca858c5e6aece" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Buffer&gt; arrow::Buffer::parent</definition>
        <argsstring>() const</argsstring>
        <name>parent</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="264" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="264" bodyend="264"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classarrow_1_1_buffer_1aa88d832230101259ad4f06cbb4c27582" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        <definition>static std::shared_ptr&lt;Buffer&gt; arrow::Buffer::FromString</definition>
        <argsstring>(std::string data)</argsstring>
        <name>FromString</name>
        <param>
          <type>std::string</type>
          <declname>data</declname>
        </param>
        <briefdescription>
<para>Construct an immutable buffer that takes ownership of the contents of an std::string (without copying it). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>a string to own </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a new <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> instance </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="153" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1adeea70eb65ff53f3ec94d3a7b754c7c0" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>static Status arrow::Buffer::FromString</definition>
        <argsstring>(const std::string &amp;data, MemoryPool *pool, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>FromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="156" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a65e1ae0e908b997d371fc80ff1cb8f43" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>static Status arrow::Buffer::FromString</definition>
        <argsstring>(const std::string &amp;data, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>FromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="160" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1abd877e4c900427798762d0abaa92b679" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename SizeType</type>
            <defval>int64_t</defval>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        <definition>static std::shared_ptr&lt;Buffer&gt; arrow::Buffer::Wrap</definition>
        <argsstring>(const T *data, SizeType length)</argsstring>
        <name>Wrap</name>
        <param>
          <type>const T *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>SizeType</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Create buffer referencing typed memory with some length without copying. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>the typed memory as C array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">length</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of values in the array </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a new shared_ptr&lt;Buffer&gt; </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="168" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="168" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a62d1926a69dd12ce6821dd8c96eafea2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        <definition>static std::shared_ptr&lt;Buffer&gt; arrow::Buffer::Wrap</definition>
        <argsstring>(const std::vector&lt; T &gt; &amp;data)</argsstring>
        <name>Wrap</name>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>data</declname>
        </param>
        <briefdescription>
<para>Create buffer referencing std::vector with some length without copying. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to be referenced. If this vector is changed, the buffer may become invalid </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a new shared_ptr&lt;Buffer&gt; </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="179" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="179" bodyend="182"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1ae2eded44b1379542966cd441a49fe953" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1io_1_1_random_access_file" kindref="compound">io::RandomAccessFile</ref> &gt; &gt;</type>
        <definition>static Result&lt;std::shared_ptr&lt;io::RandomAccessFile&gt; &gt; arrow::Buffer::GetReader</definition>
        <argsstring>(std::shared_ptr&lt; Buffer &gt;)</argsstring>
        <name>GetReader</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        </param>
        <briefdescription>
<para>Get a RandomAccessFile for reading a buffer. </para>        </briefdescription>
        <detaileddescription>
<para>The returned file object reads from this buffer&apos;s underlying memory. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="269" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a3131f10cde81c53e4d6615eb5e4850ec" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> &gt; &gt;</type>
        <definition>static Result&lt;std::shared_ptr&lt;io::OutputStream&gt; &gt; arrow::Buffer::GetWriter</definition>
        <argsstring>(std::shared_ptr&lt; Buffer &gt;)</argsstring>
        <name>GetWriter</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        </param>
        <briefdescription>
<para>Get a OutputStream for writing to a buffer. </para>        </briefdescription>
        <detaileddescription>
<para>The buffer must be mutable. The returned stream object writes into the buffer&apos;s underlying memory (but it won&apos;t resize it). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="275" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a9dcc66ada966d56a9294531e72a0e1d9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>static Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::Buffer::Copy</definition>
        <argsstring>(std::shared_ptr&lt; Buffer &gt; source, const std::shared_ptr&lt; MemoryManager &gt; &amp;to)</argsstring>
        <name>Copy</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>source</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt; &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
<para>Copy buffer. </para>        </briefdescription>
        <detaileddescription>
<para>The buffer contents will be copied into a new buffer allocated by the given <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref>. This function supports cross-device copies. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="281" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1ac4b959d7080e383ab0a9ff54d8dd9fa3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>static Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::Buffer::View</definition>
        <argsstring>(std::shared_ptr&lt; Buffer &gt; source, const std::shared_ptr&lt; MemoryManager &gt; &amp;to)</argsstring>
        <name>View</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>source</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt; &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
<para>View buffer. </para>        </briefdescription>
        <detaileddescription>
<para>Return a <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> that reflects this buffer, seen potentially from another device, without making an explicit copy of the contents. The underlying mechanism is typically implemented by the kernel or device driver, and may involve lazy caching of parts of the buffer contents on the destination device&apos;s memory.</para><para>If a non-copy view is unsupported for the buffer on the given device, nullptr is returned. An error can be returned if some low-level operation fails (such as an out-of-memory condition). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="295" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1ac54ad71b05ab0d1847bc6b8921399752" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>static Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::Buffer::ViewOrCopy</definition>
        <argsstring>(std::shared_ptr&lt; Buffer &gt; source, const std::shared_ptr&lt; MemoryManager &gt; &amp;to)</argsstring>
        <name>ViewOrCopy</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>source</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt; &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
<para>View or copy buffer. </para>        </briefdescription>
        <detaileddescription>
<para>Try to view buffer contents on the given <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref>&apos;s device, but fall back to copying if a no-copy view isn&apos;t supported. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="302" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classarrow_1_1_buffer_1a1f0df2ff745996a85ab586e150630b53" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::Buffer::CheckMutable</definition>
        <argsstring>() const</argsstring>
        <name>CheckMutable</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="321" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a2d2adec9988968f89311058ebc65e734" prot="protected" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::Buffer::CheckCPU</definition>
        <argsstring>() const</argsstring>
        <name>CheckCPU</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="322" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a515a9dde11cae1363d61f9e42a6ad8f5" prot="protected" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::Buffer::SetMemoryManager</definition>
        <argsstring>(std::shared_ptr&lt; MemoryManager &gt; mm)</argsstring>
        <name>SetMemoryManager</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt;</type>
          <declname>mm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="324" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="324" bodyend="327"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classarrow_1_1_buffer_1a8fc0550453ee766e715318cdff030dd1" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>arrow::Buffer::Buffer</definition>
        <argsstring>()=delete</argsstring>
        <name>Buffer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="330" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_buffer_1a51a3a1becb49e950f2591cef2ef0fb55" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>arrow::Buffer::ARROW_DISALLOW_COPY_AND_ASSIGN</definition>
        <argsstring>(Buffer)</argsstring>
        <name>ARROW_DISALLOW_COPY_AND_ASSIGN</name>
        <param>
          <type><ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="331" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Object containing a pointer to a piece of contiguous memory with a particular size. </para>    </briefdescription>
    <detaileddescription>
<para>Buffers have two related notions of length: size and capacity. Size is the number of bytes that might have valid data. Capacity is the number of bytes that were allocated for the buffer in total.</para><para>The <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> base class does not own its memory, but subclasses often do.</para><para>The following invariant is always true: Size &lt;= Capacity </para>    </detaileddescription>
    <inheritancegraph>
      <node id="451">
        <label>arrow::py::NumPyBuffer</label>
        <link refid="classarrow_1_1py_1_1_num_py_buffer"/>
        <childnode refid="446" relation="public-inheritance">
        </childnode>
      </node>
      <node id="447">
        <label>arrow::cuda::CudaBuffer</label>
        <link refid="classarrow_1_1cuda_1_1_cuda_buffer"/>
        <childnode refid="446" relation="public-inheritance">
        </childnode>
      </node>
      <node id="446">
        <label>arrow::Buffer</label>
        <link refid="classarrow_1_1_buffer"/>
      </node>
      <node id="449">
        <label>arrow::cuda::CudaHostBuffer</label>
        <link refid="classarrow_1_1cuda_1_1_cuda_host_buffer"/>
        <childnode refid="448" relation="public-inheritance">
        </childnode>
      </node>
      <node id="453">
        <label>arrow::py::PyForeignBuffer</label>
        <link refid="classarrow_1_1py_1_1_py_foreign_buffer"/>
        <childnode refid="446" relation="public-inheritance">
        </childnode>
      </node>
      <node id="448">
        <label>arrow::MutableBuffer</label>
        <link refid="classarrow_1_1_mutable_buffer"/>
        <childnode refid="446" relation="public-inheritance">
        </childnode>
      </node>
      <node id="450">
        <label>arrow::ResizableBuffer</label>
        <link refid="classarrow_1_1_resizable_buffer"/>
        <childnode refid="448" relation="public-inheritance">
        </childnode>
      </node>
      <node id="452">
        <label>arrow::py::PyBuffer</label>
        <link refid="classarrow_1_1py_1_1_py_buffer"/>
        <childnode refid="446" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="/arrow/cpp/src/arrow/buffer.h" line="52" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="52" bodyend="332"/>
    <listofallmembers>
      <member refid="classarrow_1_1_buffer_1a48683d9fd81454ba10ea0046775f38f3" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>address</name></member>
      <member refid="classarrow_1_1_buffer_1a51a3a1becb49e950f2591cef2ef0fb55" prot="private" virt="non-virtual"><scope>arrow::Buffer</scope><name>ARROW_DISALLOW_COPY_AND_ASSIGN</name></member>
      <member refid="classarrow_1_1_buffer_1a801078c559b0c351f1ca5a6b6a04488f" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Buffer</name></member>
      <member refid="classarrow_1_1_buffer_1aeedf5002e6f26bb2d9ca815889462619" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Buffer</name></member>
      <member refid="classarrow_1_1_buffer_1aa65c1dfabef4c7a6ae3bf9b9adaa6bb4" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Buffer</name></member>
      <member refid="classarrow_1_1_buffer_1a5a918801b40b57a959dd9405f87948f2" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Buffer</name></member>
      <member refid="classarrow_1_1_buffer_1af694696afedb9313cf5dc874ffa9a453" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Buffer</name></member>
      <member refid="classarrow_1_1_buffer_1a8fc0550453ee766e715318cdff030dd1" prot="private" virt="non-virtual"><scope>arrow::Buffer</scope><name>Buffer</name></member>
      <member refid="classarrow_1_1_buffer_1a4c75902129b5f2fb471fd166907361dc" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>capacity</name></member>
      <member refid="classarrow_1_1_buffer_1a45ee7f1e21f9f3f4cb8233be8d64731e" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>capacity_</name></member>
      <member refid="classarrow_1_1_buffer_1a2d2adec9988968f89311058ebc65e734" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>CheckCPU</name></member>
      <member refid="classarrow_1_1_buffer_1a1f0df2ff745996a85ab586e150630b53" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>CheckMutable</name></member>
      <member refid="classarrow_1_1_buffer_1a7081913a08b88c2ca674c36354d5e171" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Copy</name></member>
      <member refid="classarrow_1_1_buffer_1adcf891e5c72d591f1c293027dbf7f22a" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Copy</name></member>
      <member refid="classarrow_1_1_buffer_1a9dcc66ada966d56a9294531e72a0e1d9" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Copy</name></member>
      <member refid="classarrow_1_1_buffer_1a8e6500a2eb6667f2e7ebf0277627d435" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>CopySlice</name></member>
      <member refid="classarrow_1_1_buffer_1a81c3dd8c11dd804be2ada6df5ce8fad2" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>data</name></member>
      <member refid="classarrow_1_1_buffer_1af468a7a1f346f9a6a29738bf585a3548" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>data_</name></member>
      <member refid="classarrow_1_1_buffer_1aee84b1a0d5a0ff5e0f80f9bfcb05ffa2" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>device</name></member>
      <member refid="classarrow_1_1_buffer_1a94918db73183b750716a07133dd8384d" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Equals</name></member>
      <member refid="classarrow_1_1_buffer_1a0d3d3bd95a3297046a6ab24f5e957bfd" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Equals</name></member>
      <member refid="classarrow_1_1_buffer_1aa88d832230101259ad4f06cbb4c27582" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>FromString</name></member>
      <member refid="classarrow_1_1_buffer_1adeea70eb65ff53f3ec94d3a7b754c7c0" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>FromString</name></member>
      <member refid="classarrow_1_1_buffer_1a65e1ae0e908b997d371fc80ff1cb8f43" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>FromString</name></member>
      <member refid="classarrow_1_1_buffer_1ae2eded44b1379542966cd441a49fe953" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>GetReader</name></member>
      <member refid="classarrow_1_1_buffer_1a3131f10cde81c53e4d6615eb5e4850ec" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>GetWriter</name></member>
      <member refid="classarrow_1_1_buffer_1ad349be0b3ddf33c20e96501ad64e1ff6" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>is_cpu</name></member>
      <member refid="classarrow_1_1_buffer_1a5abed4a6cddccc03be462e84034800e9" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>is_cpu_</name></member>
      <member refid="classarrow_1_1_buffer_1a8244f9c354364788161f11bedc6f2ab9" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>is_mutable</name></member>
      <member refid="classarrow_1_1_buffer_1acfefa777b4d7d6a2f7a8ea23549dac46" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>is_mutable_</name></member>
      <member refid="classarrow_1_1_buffer_1a41cea4c92d66087126036c81221ce7ea" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>memory_manager</name></member>
      <member refid="classarrow_1_1_buffer_1ab00bfb3fc1876f207457f9d69e8ecd31" prot="private" virt="non-virtual"><scope>arrow::Buffer</scope><name>memory_manager_</name></member>
      <member refid="classarrow_1_1_buffer_1ab7a69ac4d88bd02c39fbe57225ff387a" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>mutable_address</name></member>
      <member refid="classarrow_1_1_buffer_1a5a9cb9324d3f7e323eb070b553c925aa" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>mutable_data</name></member>
      <member refid="classarrow_1_1_buffer_1ad36e306b99bc8427865bcac9b2d4f7e5" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>mutable_data_</name></member>
      <member refid="classarrow_1_1_buffer_1a63f0eb8387cb5a9717c11e9d5e720cbb" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>operator util::bytes_view</name></member>
      <member refid="classarrow_1_1_buffer_1a3553bee276a12793c601d92789388052" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>operator util::string_view</name></member>
      <member refid="classarrow_1_1_buffer_1a90752e80fe0d4252d73da6e8c3658bd1" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>operator[]</name></member>
      <member refid="classarrow_1_1_buffer_1ac58d818fa0d8a5db215ca858c5e6aece" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>parent</name></member>
      <member refid="classarrow_1_1_buffer_1a3feb5a490cbd9699837067931476c65b" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>parent_</name></member>
      <member refid="classarrow_1_1_buffer_1a515a9dde11cae1363d61f9e42a6ad8f5" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>SetMemoryManager</name></member>
      <member refid="classarrow_1_1_buffer_1a2a49871341c300996a39145d22aa8054" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>size</name></member>
      <member refid="classarrow_1_1_buffer_1a3500e42217635843b3b34bfe92b2f73a" prot="protected" virt="non-virtual"><scope>arrow::Buffer</scope><name>size_</name></member>
      <member refid="classarrow_1_1_buffer_1adf6316bf6733c0f308dfa8f6db540b19" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>ToHexString</name></member>
      <member refid="classarrow_1_1_buffer_1a90034bddee753d83af07e97cdd252b8f" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>ToString</name></member>
      <member refid="classarrow_1_1_buffer_1ac4b959d7080e383ab0a9ff54d8dd9fa3" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>View</name></member>
      <member refid="classarrow_1_1_buffer_1ac54ad71b05ab0d1847bc6b8921399752" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>ViewOrCopy</name></member>
      <member refid="classarrow_1_1_buffer_1abd877e4c900427798762d0abaa92b679" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Wrap</name></member>
      <member refid="classarrow_1_1_buffer_1a62d1926a69dd12ce6821dd8c96eafea2" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>Wrap</name></member>
      <member refid="classarrow_1_1_buffer_1a885f7b3329f3adb43a826e9403732a15" prot="public" virt="non-virtual"><scope>arrow::Buffer</scope><name>ZeroPadding</name></member>
      <member refid="classarrow_1_1_buffer_1ae6e34f304922c3416a58688bf0cd4471" prot="public" virt="virtual"><scope>arrow::Buffer</scope><name>~Buffer</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
