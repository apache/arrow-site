<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacearrow" kind="namespace" language="C++">
    <compoundname>arrow</compoundname>
    <innerclass refid="classarrow_1_1_adaptive_int_builder" prot="public">arrow::AdaptiveIntBuilder</innerclass>
    <innerclass refid="classarrow_1_1_adaptive_u_int_builder" prot="public">arrow::AdaptiveUIntBuilder</innerclass>
    <innerclass refid="classarrow_1_1_array" prot="public">arrow::Array</innerclass>
    <innerclass refid="classarrow_1_1_array_builder" prot="public">arrow::ArrayBuilder</innerclass>
    <innerclass refid="structarrow_1_1_array_data" prot="public">arrow::ArrayData</innerclass>
    <innerclass refid="structarrow_1_1_array_data_visitor" prot="public">arrow::ArrayDataVisitor</innerclass>
    <innerclass refid="classarrow_1_1_array_visitor" prot="public">arrow::ArrayVisitor</innerclass>
    <innerclass refid="classarrow_1_1_as_completed_iterator" prot="public">arrow::AsCompletedIterator</innerclass>
    <innerclass refid="classarrow_1_1_base_binary_array" prot="public">arrow::BaseBinaryArray</innerclass>
    <innerclass refid="classarrow_1_1_base_binary_builder" prot="public">arrow::BaseBinaryBuilder</innerclass>
    <innerclass refid="structarrow_1_1_base_binary_scalar" prot="public">arrow::BaseBinaryScalar</innerclass>
    <innerclass refid="classarrow_1_1_base_binary_type" prot="public">arrow::BaseBinaryType</innerclass>
    <innerclass refid="classarrow_1_1_base_list_array" prot="public">arrow::BaseListArray</innerclass>
    <innerclass refid="classarrow_1_1_base_list_builder" prot="public">arrow::BaseListBuilder</innerclass>
    <innerclass refid="structarrow_1_1_base_list_scalar" prot="public">arrow::BaseListScalar</innerclass>
    <innerclass refid="classarrow_1_1_base_list_type" prot="public">arrow::BaseListType</innerclass>
    <innerclass refid="classarrow_1_1_basic_decimal128" prot="public">arrow::BasicDecimal128</innerclass>
    <innerclass refid="classarrow_1_1_basic_union_builder" prot="public">arrow::BasicUnionBuilder</innerclass>
    <innerclass refid="classarrow_1_1_binary_array" prot="public">arrow::BinaryArray</innerclass>
    <innerclass refid="classarrow_1_1_binary_builder" prot="public">arrow::BinaryBuilder</innerclass>
    <innerclass refid="structarrow_1_1_binary_scalar" prot="public">arrow::BinaryScalar</innerclass>
    <innerclass refid="classarrow_1_1_binary_type" prot="public">arrow::BinaryType</innerclass>
    <innerclass refid="classarrow_1_1_boolean_array" prot="public">arrow::BooleanArray</innerclass>
    <innerclass refid="classarrow_1_1_boolean_builder" prot="public">arrow::BooleanBuilder</innerclass>
    <innerclass refid="structarrow_1_1_boolean_scalar" prot="public">arrow::BooleanScalar</innerclass>
    <innerclass refid="classarrow_1_1_boolean_type" prot="public">arrow::BooleanType</innerclass>
    <innerclass refid="classarrow_1_1_boundary_finder" prot="public">arrow::BoundaryFinder</innerclass>
    <innerclass refid="classarrow_1_1_buffer" prot="public">arrow::Buffer</innerclass>
    <innerclass refid="classarrow_1_1_buffer_builder" prot="public">arrow::BufferBuilder</innerclass>
    <innerclass refid="classarrow_1_1_chunked_array" prot="public">arrow::ChunkedArray</innerclass>
    <innerclass refid="classarrow_1_1_chunker" prot="public">arrow::Chunker</innerclass>
    <innerclass refid="structarrow_1_1_compression" prot="public">arrow::Compression</innerclass>
    <innerclass refid="structarrow_1_1_concatenate_tables_options" prot="public">arrow::ConcatenateTablesOptions</innerclass>
    <innerclass refid="classarrow_1_1_c_p_u_device" prot="public">arrow::CPUDevice</innerclass>
    <innerclass refid="classarrow_1_1_c_p_u_memory_manager" prot="public">arrow::CPUMemoryManager</innerclass>
    <innerclass refid="structarrow_1_1_c_type_traits" prot="public">arrow::CTypeTraits</innerclass>
    <innerclass refid="structarrow_1_1_c_type_traits_3_01bool_01_4" prot="public">arrow::CTypeTraits&lt; bool &gt;</innerclass>
    <innerclass refid="structarrow_1_1_c_type_traits_3_01const_01char_01_5_01_4" prot="public">arrow::CTypeTraits&lt; const char * &gt;</innerclass>
    <innerclass refid="structarrow_1_1_c_type_traits_3_01const_01char_07_6_08[_n]_4" prot="public">arrow::CTypeTraits&lt; const char(&amp;)[N]&gt;</innerclass>
    <innerclass refid="structarrow_1_1_c_type_traits_3_01_day_time_interval_type_1_1_day_milliseconds_01_4" prot="public">arrow::CTypeTraits&lt; DayTimeIntervalType::DayMilliseconds &gt;</innerclass>
    <innerclass refid="structarrow_1_1_c_type_traits_3_01std_1_1string_01_4" prot="public">arrow::CTypeTraits&lt; std::string &gt;</innerclass>
    <innerclass refid="structarrow_1_1_c_type_traits_3_01std_1_1vector_3_01_c_type_01_4_01_4" prot="public">arrow::CTypeTraits&lt; std::vector&lt; CType &gt; &gt;</innerclass>
    <innerclass refid="classarrow_1_1_data_type" prot="public">arrow::DataType</innerclass>
    <innerclass refid="structarrow_1_1_data_type_layout" prot="public">arrow::DataTypeLayout</innerclass>
    <innerclass refid="structarrow_1_1_date32_scalar" prot="public">arrow::Date32Scalar</innerclass>
    <innerclass refid="classarrow_1_1_date32_type" prot="public">arrow::Date32Type</innerclass>
    <innerclass refid="structarrow_1_1_date64_scalar" prot="public">arrow::Date64Scalar</innerclass>
    <innerclass refid="classarrow_1_1_date64_type" prot="public">arrow::Date64Type</innerclass>
    <innerclass refid="structarrow_1_1_date_scalar" prot="public">arrow::DateScalar</innerclass>
    <innerclass refid="classarrow_1_1_date_type" prot="public">arrow::DateType</innerclass>
    <innerclass refid="classarrow_1_1_day_time_interval_array" prot="public">arrow::DayTimeIntervalArray</innerclass>
    <innerclass refid="classarrow_1_1_day_time_interval_builder" prot="public">arrow::DayTimeIntervalBuilder</innerclass>
    <innerclass refid="structarrow_1_1_day_time_interval_scalar" prot="public">arrow::DayTimeIntervalScalar</innerclass>
    <innerclass refid="classarrow_1_1_day_time_interval_type" prot="public">arrow::DayTimeIntervalType</innerclass>
    <innerclass refid="classarrow_1_1_decimal128" prot="public">arrow::Decimal128</innerclass>
    <innerclass refid="classarrow_1_1_decimal128_array" prot="public">arrow::Decimal128Array</innerclass>
    <innerclass refid="classarrow_1_1_decimal128_builder" prot="public">arrow::Decimal128Builder</innerclass>
    <innerclass refid="structarrow_1_1_decimal128_scalar" prot="public">arrow::Decimal128Scalar</innerclass>
    <innerclass refid="classarrow_1_1_decimal128_type" prot="public">arrow::Decimal128Type</innerclass>
    <innerclass refid="classarrow_1_1_decimal_type" prot="public">arrow::DecimalType</innerclass>
    <innerclass refid="classarrow_1_1_dense_union_builder" prot="public">arrow::DenseUnionBuilder</innerclass>
    <innerclass refid="classarrow_1_1_device" prot="public">arrow::Device</innerclass>
    <innerclass refid="classarrow_1_1_dictionary32_builder" prot="public">arrow::Dictionary32Builder</innerclass>
    <innerclass refid="classarrow_1_1_dictionary_array" prot="public">arrow::DictionaryArray</innerclass>
    <innerclass refid="classarrow_1_1_dictionary_builder" prot="public">arrow::DictionaryBuilder</innerclass>
    <innerclass refid="structarrow_1_1_dictionary_scalar" prot="public">arrow::DictionaryScalar</innerclass>
    <innerclass refid="classarrow_1_1_dictionary_type" prot="public">arrow::DictionaryType</innerclass>
    <innerclass refid="classarrow_1_1_dictionary_unifier" prot="public">arrow::DictionaryUnifier</innerclass>
    <innerclass refid="structarrow_1_1_double_scalar" prot="public">arrow::DoubleScalar</innerclass>
    <innerclass refid="classarrow_1_1_double_type" prot="public">arrow::DoubleType</innerclass>
    <innerclass refid="structarrow_1_1_duration_scalar" prot="public">arrow::DurationScalar</innerclass>
    <innerclass refid="classarrow_1_1_duration_type" prot="public">arrow::DurationType</innerclass>
    <innerclass refid="classarrow_1_1_equal_options" prot="public">arrow::EqualOptions</innerclass>
    <innerclass refid="classarrow_1_1_extension_array" prot="public">arrow::ExtensionArray</innerclass>
    <innerclass refid="structarrow_1_1_extension_scalar" prot="public">arrow::ExtensionScalar</innerclass>
    <innerclass refid="classarrow_1_1_extension_type" prot="public">arrow::ExtensionType</innerclass>
    <innerclass refid="classarrow_1_1_extension_type_registry" prot="public">arrow::ExtensionTypeRegistry</innerclass>
    <innerclass refid="classarrow_1_1_field" prot="public">arrow::Field</innerclass>
    <innerclass refid="classarrow_1_1_field_path" prot="public">arrow::FieldPath</innerclass>
    <innerclass refid="classarrow_1_1_field_ref" prot="public">arrow::FieldRef</innerclass>
    <innerclass refid="structarrow_1_1_filter_iterator" prot="public">arrow::FilterIterator</innerclass>
    <innerclass refid="classarrow_1_1_fixed_size_binary_array" prot="public">arrow::FixedSizeBinaryArray</innerclass>
    <innerclass refid="classarrow_1_1_fixed_size_binary_builder" prot="public">arrow::FixedSizeBinaryBuilder</innerclass>
    <innerclass refid="structarrow_1_1_fixed_size_binary_scalar" prot="public">arrow::FixedSizeBinaryScalar</innerclass>
    <innerclass refid="classarrow_1_1_fixed_size_binary_type" prot="public">arrow::FixedSizeBinaryType</innerclass>
    <innerclass refid="classarrow_1_1_fixed_size_list_array" prot="public">arrow::FixedSizeListArray</innerclass>
    <innerclass refid="classarrow_1_1_fixed_size_list_builder" prot="public">arrow::FixedSizeListBuilder</innerclass>
    <innerclass refid="structarrow_1_1_fixed_size_list_scalar" prot="public">arrow::FixedSizeListScalar</innerclass>
    <innerclass refid="classarrow_1_1_fixed_size_list_type" prot="public">arrow::FixedSizeListType</innerclass>
    <innerclass refid="classarrow_1_1_fixed_width_type" prot="public">arrow::FixedWidthType</innerclass>
    <innerclass refid="classarrow_1_1_flat_array" prot="public">arrow::FlatArray</innerclass>
    <innerclass refid="classarrow_1_1_flatten_iterator" prot="public">arrow::FlattenIterator</innerclass>
    <innerclass refid="classarrow_1_1_floating_point_type" prot="public">arrow::FloatingPointType</innerclass>
    <innerclass refid="structarrow_1_1_float_scalar" prot="public">arrow::FloatScalar</innerclass>
    <innerclass refid="classarrow_1_1_float_type" prot="public">arrow::FloatType</innerclass>
    <innerclass refid="classarrow_1_1_function_iterator" prot="public">arrow::FunctionIterator</innerclass>
    <innerclass refid="classarrow_1_1_future" prot="public">arrow::Future</innerclass>
    <innerclass refid="classarrow_1_1_future_impl" prot="public">arrow::FutureImpl</innerclass>
    <innerclass refid="classarrow_1_1_future_storage" prot="public">arrow::FutureStorage</innerclass>
    <innerclass refid="classarrow_1_1_future_storage_3_01_status_01_4" prot="public">arrow::FutureStorage&lt; Status &gt;</innerclass>
    <innerclass refid="classarrow_1_1_future_storage_3_01void_01_4" prot="public">arrow::FutureStorage&lt; void &gt;</innerclass>
    <innerclass refid="classarrow_1_1_future_storage_base" prot="public">arrow::FutureStorageBase</innerclass>
    <innerclass refid="classarrow_1_1_future_waiter" prot="public">arrow::FutureWaiter</innerclass>
    <innerclass refid="structarrow_1_1_half_float_scalar" prot="public">arrow::HalfFloatScalar</innerclass>
    <innerclass refid="classarrow_1_1_half_float_type" prot="public">arrow::HalfFloatType</innerclass>
    <innerclass refid="classarrow_1_1_hash_util" prot="public">arrow::HashUtil</innerclass>
    <innerclass refid="structarrow_1_1_int16_scalar" prot="public">arrow::Int16Scalar</innerclass>
    <innerclass refid="classarrow_1_1_int16_type" prot="public">arrow::Int16Type</innerclass>
    <innerclass refid="structarrow_1_1_int32_scalar" prot="public">arrow::Int32Scalar</innerclass>
    <innerclass refid="classarrow_1_1_int32_type" prot="public">arrow::Int32Type</innerclass>
    <innerclass refid="structarrow_1_1_int64_scalar" prot="public">arrow::Int64Scalar</innerclass>
    <innerclass refid="classarrow_1_1_int64_type" prot="public">arrow::Int64Type</innerclass>
    <innerclass refid="structarrow_1_1_int8_scalar" prot="public">arrow::Int8Scalar</innerclass>
    <innerclass refid="classarrow_1_1_int8_type" prot="public">arrow::Int8Type</innerclass>
    <innerclass refid="classarrow_1_1_integer_type" prot="public">arrow::IntegerType</innerclass>
    <innerclass refid="structarrow_1_1_interval_scalar" prot="public">arrow::IntervalScalar</innerclass>
    <innerclass refid="classarrow_1_1_interval_type" prot="public">arrow::IntervalType</innerclass>
    <innerclass refid="structarrow_1_1_iteration_traits" prot="public">arrow::IterationTraits</innerclass>
    <innerclass refid="structarrow_1_1_iteration_traits_3_01_iterator_3_01_t_01_4_01_4" prot="public">arrow::IterationTraits&lt; Iterator&lt; T &gt; &gt;</innerclass>
    <innerclass refid="structarrow_1_1_iteration_traits_3_01util_1_1optional_3_01_t_01_4_01_4" prot="public">arrow::IterationTraits&lt; util::optional&lt; T &gt; &gt;</innerclass>
    <innerclass refid="classarrow_1_1_iterator" prot="public">arrow::Iterator</innerclass>
    <innerclass refid="classarrow_1_1_key_value_metadata" prot="public">arrow::KeyValueMetadata</innerclass>
    <innerclass refid="classarrow_1_1_large_binary_array" prot="public">arrow::LargeBinaryArray</innerclass>
    <innerclass refid="classarrow_1_1_large_binary_builder" prot="public">arrow::LargeBinaryBuilder</innerclass>
    <innerclass refid="structarrow_1_1_large_binary_scalar" prot="public">arrow::LargeBinaryScalar</innerclass>
    <innerclass refid="classarrow_1_1_large_binary_type" prot="public">arrow::LargeBinaryType</innerclass>
    <innerclass refid="classarrow_1_1_large_list_array" prot="public">arrow::LargeListArray</innerclass>
    <innerclass refid="classarrow_1_1_large_list_builder" prot="public">arrow::LargeListBuilder</innerclass>
    <innerclass refid="structarrow_1_1_large_list_scalar" prot="public">arrow::LargeListScalar</innerclass>
    <innerclass refid="classarrow_1_1_large_list_type" prot="public">arrow::LargeListType</innerclass>
    <innerclass refid="classarrow_1_1_large_string_array" prot="public">arrow::LargeStringArray</innerclass>
    <innerclass refid="classarrow_1_1_large_string_builder" prot="public">arrow::LargeStringBuilder</innerclass>
    <innerclass refid="structarrow_1_1_large_string_scalar" prot="public">arrow::LargeStringScalar</innerclass>
    <innerclass refid="classarrow_1_1_large_string_type" prot="public">arrow::LargeStringType</innerclass>
    <innerclass refid="classarrow_1_1_list_array" prot="public">arrow::ListArray</innerclass>
    <innerclass refid="classarrow_1_1_list_builder" prot="public">arrow::ListBuilder</innerclass>
    <innerclass refid="structarrow_1_1_list_scalar" prot="public">arrow::ListScalar</innerclass>
    <innerclass refid="classarrow_1_1_list_type" prot="public">arrow::ListType</innerclass>
    <innerclass refid="classarrow_1_1_logging_memory_pool" prot="public">arrow::LoggingMemoryPool</innerclass>
    <innerclass refid="structarrow_1_1_make_scalar_impl" prot="public">arrow::MakeScalarImpl</innerclass>
    <innerclass refid="classarrow_1_1_map_array" prot="public">arrow::MapArray</innerclass>
    <innerclass refid="classarrow_1_1_map_builder" prot="public">arrow::MapBuilder</innerclass>
    <innerclass refid="classarrow_1_1_map_iterator" prot="public">arrow::MapIterator</innerclass>
    <innerclass refid="structarrow_1_1_map_scalar" prot="public">arrow::MapScalar</innerclass>
    <innerclass refid="classarrow_1_1_map_type" prot="public">arrow::MapType</innerclass>
    <innerclass refid="classarrow_1_1_memory_manager" prot="public">arrow::MemoryManager</innerclass>
    <innerclass refid="classarrow_1_1_memory_pool" prot="public">arrow::MemoryPool</innerclass>
    <innerclass refid="structarrow_1_1_month_interval_scalar" prot="public">arrow::MonthIntervalScalar</innerclass>
    <innerclass refid="classarrow_1_1_month_interval_type" prot="public">arrow::MonthIntervalType</innerclass>
    <innerclass refid="classarrow_1_1_mutable_buffer" prot="public">arrow::MutableBuffer</innerclass>
    <innerclass refid="classarrow_1_1_nested_type" prot="public">arrow::NestedType</innerclass>
    <innerclass refid="classarrow_1_1_null_array" prot="public">arrow::NullArray</innerclass>
    <innerclass refid="classarrow_1_1_null_builder" prot="public">arrow::NullBuilder</innerclass>
    <innerclass refid="structarrow_1_1_null_scalar" prot="public">arrow::NullScalar</innerclass>
    <innerclass refid="classarrow_1_1_null_type" prot="public">arrow::NullType</innerclass>
    <innerclass refid="classarrow_1_1_number_type" prot="public">arrow::NumberType</innerclass>
    <innerclass refid="classarrow_1_1_numeric_array" prot="public">arrow::NumericArray</innerclass>
    <innerclass refid="classarrow_1_1_numeric_builder" prot="public">arrow::NumericBuilder</innerclass>
    <innerclass refid="structarrow_1_1_numeric_scalar" prot="public">arrow::NumericScalar</innerclass>
    <innerclass refid="classarrow_1_1_numeric_tensor" prot="public">arrow::NumericTensor</innerclass>
    <innerclass refid="classarrow_1_1_parametric_type" prot="public">arrow::ParametricType</innerclass>
    <innerclass refid="structarrow_1_1_pretty_print_options" prot="public">arrow::PrettyPrintOptions</innerclass>
    <innerclass refid="classarrow_1_1_primitive_array" prot="public">arrow::PrimitiveArray</innerclass>
    <innerclass refid="classarrow_1_1_primitive_c_type" prot="public">arrow::PrimitiveCType</innerclass>
    <innerclass refid="classarrow_1_1_proxy_memory_pool" prot="public">arrow::ProxyMemoryPool</innerclass>
    <innerclass refid="classarrow_1_1_readahead_iterator" prot="public">arrow::ReadaheadIterator</innerclass>
    <innerclass refid="classarrow_1_1_record_batch" prot="public">arrow::RecordBatch</innerclass>
    <innerclass refid="classarrow_1_1_record_batch_builder" prot="public">arrow::RecordBatchBuilder</innerclass>
    <innerclass refid="classarrow_1_1_record_batch_reader" prot="public">arrow::RecordBatchReader</innerclass>
    <innerclass refid="classarrow_1_1_resizable_buffer" prot="public">arrow::ResizableBuffer</innerclass>
    <innerclass refid="classarrow_1_1_result" prot="public">arrow::Result</innerclass>
    <innerclass refid="structarrow_1_1_scalar" prot="public">arrow::Scalar</innerclass>
    <innerclass refid="classarrow_1_1_scalar_visitor" prot="public">arrow::ScalarVisitor</innerclass>
    <innerclass refid="classarrow_1_1_schema" prot="public">arrow::Schema</innerclass>
    <innerclass refid="classarrow_1_1_schema_builder" prot="public">arrow::SchemaBuilder</innerclass>
    <innerclass refid="classarrow_1_1_sparse_c_o_o_index" prot="public">arrow::SparseCOOIndex</innerclass>
    <innerclass refid="classarrow_1_1_sparse_c_s_c_index" prot="public">arrow::SparseCSCIndex</innerclass>
    <innerclass refid="classarrow_1_1_sparse_c_s_f_index" prot="public">arrow::SparseCSFIndex</innerclass>
    <innerclass refid="classarrow_1_1_sparse_c_s_r_index" prot="public">arrow::SparseCSRIndex</innerclass>
    <innerclass refid="classarrow_1_1_sparse_index" prot="public">arrow::SparseIndex</innerclass>
    <innerclass refid="classarrow_1_1_sparse_tensor" prot="public">arrow::SparseTensor</innerclass>
    <innerclass refid="structarrow_1_1_sparse_tensor_format" prot="public">arrow::SparseTensorFormat</innerclass>
    <innerclass refid="classarrow_1_1_sparse_tensor_impl" prot="public">arrow::SparseTensorImpl</innerclass>
    <innerclass refid="classarrow_1_1_sparse_union_builder" prot="public">arrow::SparseUnionBuilder</innerclass>
    <innerclass refid="classarrow_1_1_status" prot="public">arrow::Status</innerclass>
    <innerclass refid="classarrow_1_1_status_detail" prot="public">arrow::StatusDetail</innerclass>
    <innerclass refid="classarrow_1_1_string_array" prot="public">arrow::StringArray</innerclass>
    <innerclass refid="classarrow_1_1_string_builder" prot="public">arrow::StringBuilder</innerclass>
    <innerclass refid="structarrow_1_1_string_scalar" prot="public">arrow::StringScalar</innerclass>
    <innerclass refid="classarrow_1_1_string_type" prot="public">arrow::StringType</innerclass>
    <innerclass refid="classarrow_1_1_struct_array" prot="public">arrow::StructArray</innerclass>
    <innerclass refid="classarrow_1_1_struct_builder" prot="public">arrow::StructBuilder</innerclass>
    <innerclass refid="structarrow_1_1_struct_scalar" prot="public">arrow::StructScalar</innerclass>
    <innerclass refid="classarrow_1_1_struct_type" prot="public">arrow::StructType</innerclass>
    <innerclass refid="classarrow_1_1_table" prot="public">arrow::Table</innerclass>
    <innerclass refid="classarrow_1_1_table_batch_reader" prot="public">arrow::TableBatchReader</innerclass>
    <innerclass refid="structarrow_1_1_temporal_scalar" prot="public">arrow::TemporalScalar</innerclass>
    <innerclass refid="classarrow_1_1_temporal_type" prot="public">arrow::TemporalType</innerclass>
    <innerclass refid="classarrow_1_1_tensor" prot="public">arrow::Tensor</innerclass>
    <innerclass refid="structarrow_1_1_time32_scalar" prot="public">arrow::Time32Scalar</innerclass>
    <innerclass refid="classarrow_1_1_time32_type" prot="public">arrow::Time32Type</innerclass>
    <innerclass refid="structarrow_1_1_time64_scalar" prot="public">arrow::Time64Scalar</innerclass>
    <innerclass refid="classarrow_1_1_time64_type" prot="public">arrow::Time64Type</innerclass>
    <innerclass refid="structarrow_1_1_time_scalar" prot="public">arrow::TimeScalar</innerclass>
    <innerclass refid="structarrow_1_1_timestamp_scalar" prot="public">arrow::TimestampScalar</innerclass>
    <innerclass refid="classarrow_1_1_timestamp_type" prot="public">arrow::TimestampType</innerclass>
    <innerclass refid="classarrow_1_1_time_type" prot="public">arrow::TimeType</innerclass>
    <innerclass refid="structarrow_1_1_time_unit" prot="public">arrow::TimeUnit</innerclass>
    <innerclass refid="structarrow_1_1_type" prot="public">arrow::Type</innerclass>
    <innerclass refid="classarrow_1_1_typed_buffer_builder" prot="public">arrow::TypedBufferBuilder</innerclass>
    <innerclass refid="classarrow_1_1_typed_buffer_builder_3_01bool_01_4" prot="public">arrow::TypedBufferBuilder&lt; bool &gt;</innerclass>
    <innerclass refid="classarrow_1_1_typed_buffer_builder_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__aritec42b86b747ba8f9be42ca702c779c07" prot="public">arrow::TypedBufferBuilder&lt; T, typename std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value||std::is_standard_layout&lt; T &gt;::value &gt;::type &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits" prot="public">arrow::TypeTraits</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_binary_type_01_4" prot="public">arrow::TypeTraits&lt; BinaryType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_boolean_type_01_4" prot="public">arrow::TypeTraits&lt; BooleanType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_date32_type_01_4" prot="public">arrow::TypeTraits&lt; Date32Type &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_date64_type_01_4" prot="public">arrow::TypeTraits&lt; Date64Type &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_day_time_interval_type_01_4" prot="public">arrow::TypeTraits&lt; DayTimeIntervalType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_decimal128_type_01_4" prot="public">arrow::TypeTraits&lt; Decimal128Type &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_dictionary_type_01_4" prot="public">arrow::TypeTraits&lt; DictionaryType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_duration_type_01_4" prot="public">arrow::TypeTraits&lt; DurationType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_extension_type_01_4" prot="public">arrow::TypeTraits&lt; ExtensionType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_fixed_size_binary_type_01_4" prot="public">arrow::TypeTraits&lt; FixedSizeBinaryType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_fixed_size_list_type_01_4" prot="public">arrow::TypeTraits&lt; FixedSizeListType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_half_float_type_01_4" prot="public">arrow::TypeTraits&lt; HalfFloatType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_large_binary_type_01_4" prot="public">arrow::TypeTraits&lt; LargeBinaryType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_large_list_type_01_4" prot="public">arrow::TypeTraits&lt; LargeListType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_large_string_type_01_4" prot="public">arrow::TypeTraits&lt; LargeStringType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_list_type_01_4" prot="public">arrow::TypeTraits&lt; ListType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_map_type_01_4" prot="public">arrow::TypeTraits&lt; MapType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_month_interval_type_01_4" prot="public">arrow::TypeTraits&lt; MonthIntervalType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_null_type_01_4" prot="public">arrow::TypeTraits&lt; NullType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_string_type_01_4" prot="public">arrow::TypeTraits&lt; StringType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_struct_type_01_4" prot="public">arrow::TypeTraits&lt; StructType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_time32_type_01_4" prot="public">arrow::TypeTraits&lt; Time32Type &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_time64_type_01_4" prot="public">arrow::TypeTraits&lt; Time64Type &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_timestamp_type_01_4" prot="public">arrow::TypeTraits&lt; TimestampType &gt;</innerclass>
    <innerclass refid="structarrow_1_1_type_traits_3_01_union_type_01_4" prot="public">arrow::TypeTraits&lt; UnionType &gt;</innerclass>
    <innerclass refid="classarrow_1_1_type_visitor" prot="public">arrow::TypeVisitor</innerclass>
    <innerclass refid="structarrow_1_1_u_int16_scalar" prot="public">arrow::UInt16Scalar</innerclass>
    <innerclass refid="classarrow_1_1_u_int16_type" prot="public">arrow::UInt16Type</innerclass>
    <innerclass refid="structarrow_1_1_u_int32_scalar" prot="public">arrow::UInt32Scalar</innerclass>
    <innerclass refid="classarrow_1_1_u_int32_type" prot="public">arrow::UInt32Type</innerclass>
    <innerclass refid="structarrow_1_1_u_int64_scalar" prot="public">arrow::UInt64Scalar</innerclass>
    <innerclass refid="classarrow_1_1_u_int64_type" prot="public">arrow::UInt64Type</innerclass>
    <innerclass refid="structarrow_1_1_u_int8_scalar" prot="public">arrow::UInt8Scalar</innerclass>
    <innerclass refid="classarrow_1_1_u_int8_type" prot="public">arrow::UInt8Type</innerclass>
    <innerclass refid="classarrow_1_1_union_array" prot="public">arrow::UnionArray</innerclass>
    <innerclass refid="structarrow_1_1_union_mode" prot="public">arrow::UnionMode</innerclass>
    <innerclass refid="structarrow_1_1_union_scalar" prot="public">arrow::UnionScalar</innerclass>
    <innerclass refid="classarrow_1_1_union_type" prot="public">arrow::UnionType</innerclass>
    <innerclass refid="classarrow_1_1_vector_iterator" prot="public">arrow::VectorIterator</innerclass>
    <innerclass refid="classarrow_1_1_vector_optional_iterator" prot="public">arrow::VectorOptionalIterator</innerclass>
    <innernamespace refid="namespacearrow_1_1adapters">arrow::adapters</innernamespace>
    <innernamespace refid="namespacearrow_1_1compute">arrow::compute</innernamespace>
    <innernamespace refid="namespacearrow_1_1csv">arrow::csv</innernamespace>
    <innernamespace refid="namespacearrow_1_1cuda">arrow::cuda</innernamespace>
    <innernamespace refid="namespacearrow_1_1dataset">arrow::dataset</innernamespace>
    <innernamespace refid="namespacearrow_1_1flight">arrow::flight</innernamespace>
    <innernamespace refid="namespacearrow_1_1fs">arrow::fs</innernamespace>
    <innernamespace refid="namespacearrow_1_1hiveserver2">arrow::hiveserver2</innernamespace>
    <innernamespace refid="namespacearrow_1_1io">arrow::io</innernamespace>
    <innernamespace refid="namespacearrow_1_1ipc">arrow::ipc</innernamespace>
    <innernamespace refid="namespacearrow_1_1jni">arrow::jni</innernamespace>
    <innernamespace refid="namespacearrow_1_1json">arrow::json</innernamespace>
    <innernamespace refid="namespacearrow_1_1py">arrow::py</innernamespace>
    <innernamespace refid="namespacearrow_1_1stl">arrow::stl</innernamespace>
    <innernamespace refid="namespacearrow_1_1util">arrow::util</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188f" prot="public" static="no">
        <name>StatusCode</name>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fae0aa021e21dddbd6d8cecec71e9cf564" prot="public">
          <name>OK</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fab498327feeb51430af73e07deac268fd" prot="public">
          <name>OutOfMemory</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fac84999914a408f8c02b4122a49df6e00" prot="public">
          <name>KeyError</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa137bf8cff2d59f0883c600f9524b3eed" prot="public">
          <name>TypeError</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa4bbb8f967da6d1a610596d7257179c2b" prot="public">
          <name>Invalid</name>
          <initializer>= 4</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa5206bd7472156351d2d9a99633ac9580" prot="public">
          <name>IOError</name>
          <initializer>= 5</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa65f55acee27ef038c04505e05dbf6c35" prot="public">
          <name>CapacityError</name>
          <initializer>= 6</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188faeb6ff05a2e9b0485ea84cbe3809e36ed" prot="public">
          <name>IndexError</name>
          <initializer>= 7</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fabfaef30f1c8011c5cefa38ae470fb7aa" prot="public">
          <name>UnknownError</name>
          <initializer>= 9</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa997ca4ce119685f40f03a9a8a6c5346e" prot="public">
          <name>NotImplemented</name>
          <initializer>= 10</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa64353c9071b50ec2fe6b90ed122471a8" prot="public">
          <name>SerializationError</name>
          <initializer>= 11</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa92f049e5e1d59cc2f960d1974c50e072" prot="public">
          <name>RError</name>
          <initializer>= 13</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa8a938435e76704025c8ab2b7f7a7ca52" prot="public">
          <name>CodeGenError</name>
          <initializer>= 40</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa70b5374da923fd3b982ac38c1fd20bc3" prot="public">
          <name>ExpressionValidationError</name>
          <initializer>= 41</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa6e129f00c2572c6d267cf433bc9ad99e" prot="public">
          <name>ExecutionError</name>
          <initializer>= 42</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a331ad1dbd1c157c8be168cb6548d188fa89b69484680b18e9179e826c6e023805" prot="public">
          <name>AlreadyExists</name>
          <initializer>= 45</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/status.h" line="77" column="1" bodyfile="/arrow/cpp/src/arrow/status.h" bodystart="77" bodyend="96"/>
      </memberdef>
      <memberdef kind="enum" id="namespacearrow_1a04410292f01b108a8a8af3c7077afcda" prot="public" static="no">
        <name>DateUnit</name>
        <enumvalue id="namespacearrow_1a04410292f01b108a8a8af3c7077afcdaa5b1d59b5451c06afb65ab1bc2713cfb4" prot="public">
          <name>DAY</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a04410292f01b108a8a8af3c7077afcdaa8f06f9f0a1efa42a2ad3ec880b0a1f70" prot="public">
          <name>MILLI</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1041" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1041" bodyend="1041"/>
      </memberdef>
      <memberdef kind="enum" id="namespacearrow_1a57a966e51cab768580c6f9a9427f34d2" prot="public" static="no">
        <name>DecimalStatus</name>
        <enumvalue id="namespacearrow_1a57a966e51cab768580c6f9a9427f34d2a8c632159fa131f09d04f94e3cbcd8782" prot="public">
          <name>kSuccess</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a57a966e51cab768580c6f9a9427f34d2a41ef173591458a0b06e7f793fb7ed46c" prot="public">
          <name>kDivideByZero</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a57a966e51cab768580c6f9a9427f34d2aae5484a6f25ec42ff2fc33b0fc8bc2d5" prot="public">
          <name>kOverflow</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a57a966e51cab768580c6f9a9427f34d2ac1d48c17e57675d19e1fdb51b625e8c3" prot="public">
          <name>kRescaleDataLoss</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="32" column="1" bodyfile="/arrow/cpp/src/arrow/util/basic_decimal.h" bodystart="32" bodyend="37"/>
      </memberdef>
      <memberdef kind="enum" id="namespacearrow_1a235876e04ae6167cfde18ad69cf2821a" prot="public" static="no">
        <name>FutureState</name>
        <enumvalue id="namespacearrow_1a235876e04ae6167cfde18ad69cf2821aac69f06e1a9b016d133907b4e5f5864d2" prot="public">
          <name>PENDING</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a235876e04ae6167cfde18ad69cf2821aad0749aaba8b833466dfcbb0428e4f89c" prot="public">
          <name>SUCCESS</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1a235876e04ae6167cfde18ad69cf2821aa36fc6065a3e970bc3e6b2e59da52bf2a" prot="public">
          <name>FAILURE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>A <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&apos;s execution or completion status. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="35" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="35" bodyend="35"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacearrow_1a59bcac644b0f2cd8e7034643d09e23bb" prot="public" static="no">
        <type><ref refid="classarrow_1_1_decimal128_builder" kindref="compound">Decimal128Builder</ref></type>
        <definition>using arrow::DecimalBuilder = typedef Decimal128Builder</definition>
        <argsstring></argsstring>
        <name>DecimalBuilder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_decimal.h" line="58" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_decimal.h" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a5f8131cc0c59201919057baede1e1915" prot="public" static="no">
        <type><ref refid="classarrow_1_1_dictionary_builder" kindref="compound">DictionaryBuilder</ref>&lt; <ref refid="classarrow_1_1_binary_type" kindref="compound">BinaryType</ref> &gt;</type>
        <definition>using arrow::BinaryDictionaryBuilder = typedef DictionaryBuilder&lt;BinaryType&gt;</definition>
        <argsstring></argsstring>
        <name>BinaryDictionaryBuilder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_dict.h" line="447" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_dict.h" bodystart="447" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1abaee05f9db0635d18089f51fedb2ea18" prot="public" static="no">
        <type><ref refid="classarrow_1_1_dictionary_builder" kindref="compound">DictionaryBuilder</ref>&lt; <ref refid="classarrow_1_1_string_type" kindref="compound">StringType</ref> &gt;</type>
        <definition>using arrow::StringDictionaryBuilder = typedef DictionaryBuilder&lt;StringType&gt;</definition>
        <argsstring></argsstring>
        <name>StringDictionaryBuilder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_dict.h" line="448" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_dict.h" bodystart="448" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1adcb8bc3a11dc7a68ca1eee6f9235ae47" prot="public" static="no">
        <type><ref refid="classarrow_1_1_dictionary32_builder" kindref="compound">Dictionary32Builder</ref>&lt; <ref refid="classarrow_1_1_binary_type" kindref="compound">BinaryType</ref> &gt;</type>
        <definition>using arrow::BinaryDictionary32Builder = typedef Dictionary32Builder&lt;BinaryType&gt;</definition>
        <argsstring></argsstring>
        <name>BinaryDictionary32Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_dict.h" line="449" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_dict.h" bodystart="449" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aaa212e571198e5d0102195c2202d462a" prot="public" static="no">
        <type><ref refid="classarrow_1_1_dictionary32_builder" kindref="compound">Dictionary32Builder</ref>&lt; <ref refid="classarrow_1_1_string_type" kindref="compound">StringType</ref> &gt;</type>
        <definition>using arrow::StringDictionary32Builder = typedef Dictionary32Builder&lt;StringType&gt;</definition>
        <argsstring></argsstring>
        <name>StringDictionary32Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_dict.h" line="450" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_dict.h" bodystart="450" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1adab028f188008a82d790cd69ac351a3b" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_u_int8_type" kindref="compound">UInt8Type</ref> &gt;</type>
        <definition>using arrow::UInt8Builder = typedef NumericBuilder&lt;UInt8Type&gt;</definition>
        <argsstring></argsstring>
        <name>UInt8Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="258" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="258" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a6f7720234c751cfa79a0d6d4e2014485" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_u_int16_type" kindref="compound">UInt16Type</ref> &gt;</type>
        <definition>using arrow::UInt16Builder = typedef NumericBuilder&lt;UInt16Type&gt;</definition>
        <argsstring></argsstring>
        <name>UInt16Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="259" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="259" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a54e6101656a21b97a88179c8d1c453b9" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_u_int32_type" kindref="compound">UInt32Type</ref> &gt;</type>
        <definition>using arrow::UInt32Builder = typedef NumericBuilder&lt;UInt32Type&gt;</definition>
        <argsstring></argsstring>
        <name>UInt32Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="260" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="260" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a1777cb0f7c98036ad6f078fa0f1a6829" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_u_int64_type" kindref="compound">UInt64Type</ref> &gt;</type>
        <definition>using arrow::UInt64Builder = typedef NumericBuilder&lt;UInt64Type&gt;</definition>
        <argsstring></argsstring>
        <name>UInt64Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="261" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="261" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a9675d2aecdd6ad622ee1358c358ba278" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_int8_type" kindref="compound">Int8Type</ref> &gt;</type>
        <definition>using arrow::Int8Builder = typedef NumericBuilder&lt;Int8Type&gt;</definition>
        <argsstring></argsstring>
        <name>Int8Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="263" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="263" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ab5ad5330bb34a045c6e87ecee875057e" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_int16_type" kindref="compound">Int16Type</ref> &gt;</type>
        <definition>using arrow::Int16Builder = typedef NumericBuilder&lt;Int16Type&gt;</definition>
        <argsstring></argsstring>
        <name>Int16Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="264" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="264" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a031c893d8d592c7a099bb9bea3a25f86" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_int32_type" kindref="compound">Int32Type</ref> &gt;</type>
        <definition>using arrow::Int32Builder = typedef NumericBuilder&lt;Int32Type&gt;</definition>
        <argsstring></argsstring>
        <name>Int32Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="265" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="265" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a08fa80026c56e0f1ff24b43c4dc33e61" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_int64_type" kindref="compound">Int64Type</ref> &gt;</type>
        <definition>using arrow::Int64Builder = typedef NumericBuilder&lt;Int64Type&gt;</definition>
        <argsstring></argsstring>
        <name>Int64Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="266" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="266" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ae87957f6c01fb918bb573f04c5188ca4" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_half_float_type" kindref="compound">HalfFloatType</ref> &gt;</type>
        <definition>using arrow::HalfFloatBuilder = typedef NumericBuilder&lt;HalfFloatType&gt;</definition>
        <argsstring></argsstring>
        <name>HalfFloatBuilder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="268" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="268" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1afc7f8a9698e4a5b6e8c3884c2cf3aedb" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_float_type" kindref="compound">FloatType</ref> &gt;</type>
        <definition>using arrow::FloatBuilder = typedef NumericBuilder&lt;FloatType&gt;</definition>
        <argsstring></argsstring>
        <name>FloatBuilder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="269" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="269" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ab98cad76b29efffe92c6c88af8947873" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_double_type" kindref="compound">DoubleType</ref> &gt;</type>
        <definition>using arrow::DoubleBuilder = typedef NumericBuilder&lt;DoubleType&gt;</definition>
        <argsstring></argsstring>
        <name>DoubleBuilder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_primitive.h" line="270" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_primitive.h" bodystart="270" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a2d707f9cf680a2e01f48cc972e7aa7dd" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; !std::is_same&lt; typename internal::DictionaryTraits&lt; T &gt;::MemoTableType, void &gt;::value, Out &gt;</type>
        <definition>using arrow::enable_if_memoize = typedef enable_if_t&lt; !std::is_same&lt;typename internal::DictionaryTraits&lt;T&gt;::MemoTableType, void&gt;::value, Out&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_memoize</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/dict_internal.h" line="51" column="1" bodyfile="/arrow/cpp/src/arrow/array/dict_internal.h" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a4b94ab6f22b2b71f032a996091499b7b" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; std::is_same&lt; typename internal::DictionaryTraits&lt; T &gt;::MemoTableType, void &gt;::value, Out &gt;</type>
        <definition>using arrow::enable_if_no_memoize = typedef enable_if_t&lt; std::is_same&lt;typename internal::DictionaryTraits&lt;T&gt;::MemoTableType, void&gt;::value, Out&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_no_memoize</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/dict_internal.h" line="56" column="1" bodyfile="/arrow/cpp/src/arrow/array/dict_internal.h" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aa9162b62a545f10bb02754571cd7ec80" prot="public" static="no">
        <type><ref refid="classarrow_1_1_decimal128_array" kindref="compound">Decimal128Array</ref></type>
        <definition>using arrow::DecimalArray = typedef Decimal128Array</definition>
        <argsstring></argsstring>
        <name>DecimalArray</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="1039" column="1" bodyfile="/arrow/cpp/src/arrow/array.h" bodystart="1039" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ac9b05a1d2db4d6cce70e2adc6ae983f9" prot="public" static="no">
        <type><ref refid="classarrow_1_1_sparse_tensor_impl" kindref="compound">SparseTensorImpl</ref>&lt; <ref refid="classarrow_1_1_sparse_c_o_o_index" kindref="compound">SparseCOOIndex</ref> &gt;</type>
        <definition>using arrow::SparseCOOTensor = typedef SparseTensorImpl&lt;SparseCOOIndex&gt;</definition>
        <argsstring></argsstring>
        <name>SparseCOOTensor</name>
        <briefdescription>
<para>EXPERIMENTAL: <ref refid="structarrow_1_1_type" kindref="compound">Type</ref> alias for COO sparse tensor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/sparse_tensor.h" line="566" column="1" bodyfile="/arrow/cpp/src/arrow/sparse_tensor.h" bodystart="566" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a30853e74abee092db4aa50440dab9ce8" prot="public" static="no">
        <type><ref refid="classarrow_1_1_sparse_tensor_impl" kindref="compound">SparseTensorImpl</ref>&lt; <ref refid="classarrow_1_1_sparse_c_s_r_index" kindref="compound">SparseCSRIndex</ref> &gt;</type>
        <definition>using arrow::SparseCSRMatrix = typedef SparseTensorImpl&lt;SparseCSRIndex&gt;</definition>
        <argsstring></argsstring>
        <name>SparseCSRMatrix</name>
        <briefdescription>
<para>EXPERIMENTAL: <ref refid="structarrow_1_1_type" kindref="compound">Type</ref> alias for CSR sparse matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/sparse_tensor.h" line="569" column="1" bodyfile="/arrow/cpp/src/arrow/sparse_tensor.h" bodystart="569" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a365a8eacbf769f8ce28bac334b84690c" prot="public" static="no">
        <type><ref refid="classarrow_1_1_sparse_tensor_impl" kindref="compound">SparseTensorImpl</ref>&lt; <ref refid="classarrow_1_1_sparse_c_s_c_index" kindref="compound">SparseCSCIndex</ref> &gt;</type>
        <definition>using arrow::SparseCSCMatrix = typedef SparseTensorImpl&lt;SparseCSCIndex&gt;</definition>
        <argsstring></argsstring>
        <name>SparseCSCMatrix</name>
        <briefdescription>
<para>EXPERIMENTAL: <ref refid="structarrow_1_1_type" kindref="compound">Type</ref> alias for CSC sparse matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/sparse_tensor.h" line="572" column="1" bodyfile="/arrow/cpp/src/arrow/sparse_tensor.h" bodystart="572" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a425323660be318b4ad32315190d83371" prot="public" static="no">
        <type><ref refid="classarrow_1_1_sparse_tensor_impl" kindref="compound">SparseTensorImpl</ref>&lt; <ref refid="classarrow_1_1_sparse_c_s_f_index" kindref="compound">SparseCSFIndex</ref> &gt;</type>
        <definition>using arrow::SparseCSFTensor = typedef SparseTensorImpl&lt;SparseCSFIndex&gt;</definition>
        <argsstring></argsstring>
        <name>SparseCSFTensor</name>
        <briefdescription>
<para>EXPERIMENTAL: <ref refid="structarrow_1_1_type" kindref="compound">Type</ref> alias for CSF sparse matrix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/sparse_tensor.h" line="575" column="1" bodyfile="/arrow/cpp/src/arrow/sparse_tensor.h" bodystart="575" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a26e0360de3fc4b7120b6b50f14a22786" prot="public" static="no">
        <type>std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>using arrow::BufferVector = typedef std::vector&lt;std::shared_ptr&lt;Buffer&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>BufferVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="44" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="44" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a4599536b489227968fbdf37c1f9585cf" prot="public" static="no">
        <type>std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt; &gt;</type>
        <definition>using arrow::FieldVector = typedef std::vector&lt;std::shared_ptr&lt;Field&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>FieldVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="52" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="52" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a673a462c4839a467a29173c4f9625cfc" prot="public" static="no">
        <type>std::vector&lt; std::shared_ptr&lt; <ref refid="structarrow_1_1_array_data" kindref="compound">ArrayData</ref> &gt; &gt;</type>
        <definition>using arrow::ArrayDataVector = typedef std::vector&lt;std::shared_ptr&lt;ArrayData&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>ArrayDataVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="60" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="60" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ad77c54b51dac02d857f3a26d11ed58b3" prot="public" static="no">
        <type>std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; &gt;</type>
        <definition>using arrow::ArrayVector = typedef std::vector&lt;std::shared_ptr&lt;Array&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>ArrayVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="61" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="61" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a83d3f46b57e3f7f20eb0dbd1bd3c0238" prot="public" static="no">
        <type>std::vector&lt; std::shared_ptr&lt; <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &gt; &gt;</type>
        <definition>using arrow::ScalarVector = typedef std::vector&lt;std::shared_ptr&lt;Scalar&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>ScalarVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="62" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="62" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ad1db2275abafb67decaeca75014e41a0" prot="public" static="no">
        <type>std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &gt; &gt;</type>
        <definition>using arrow::ChunkedArrayVector = typedef std::vector&lt;std::shared_ptr&lt;ChunkedArray&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>ChunkedArrayVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="68" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="68" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aac5dbb97116a1738dc75b2baa2a67a7f" prot="public" static="no">
        <type>std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; &gt;</type>
        <definition>using arrow::RecordBatchVector = typedef std::vector&lt;std::shared_ptr&lt;RecordBatch&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>RecordBatchVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="69" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="69" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a98532acfa6b99a8c35c14d2484cd65bb" prot="public" static="no">
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; &gt;</type>
        <definition>using arrow::RecordBatchIterator = typedef Iterator&lt;std::shared_ptr&lt;RecordBatch&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>RecordBatchIterator</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="70" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="70" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a3ea89658181e81c18b237da93d8294f7" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_array" kindref="compound">NumericArray</ref>&lt; <ref refid="classarrow_1_1_date32_type" kindref="compound">Date32Type</ref> &gt;</type>
        <definition>using arrow::Date32Array = typedef NumericArray&lt;Date32Type&gt;</definition>
        <argsstring></argsstring>
        <name>Date32Array</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="180" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="180" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aa210dc2cd0cab7513343548d42c00000" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_date32_type" kindref="compound">Date32Type</ref> &gt;</type>
        <definition>using arrow::Date32Builder = typedef NumericBuilder&lt;Date32Type&gt;</definition>
        <argsstring></argsstring>
        <name>Date32Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="181" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="181" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aa9a45b66d455778ec8168f937379f22e" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_array" kindref="compound">NumericArray</ref>&lt; <ref refid="classarrow_1_1_date64_type" kindref="compound">Date64Type</ref> &gt;</type>
        <definition>using arrow::Date64Array = typedef NumericArray&lt;Date64Type&gt;</definition>
        <argsstring></argsstring>
        <name>Date64Array</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="185" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="185" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1afd7b5640cf95de8799d75b12f901b62a" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_date64_type" kindref="compound">Date64Type</ref> &gt;</type>
        <definition>using arrow::Date64Builder = typedef NumericBuilder&lt;Date64Type&gt;</definition>
        <argsstring></argsstring>
        <name>Date64Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="186" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="186" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a97345da72ba3bedb03d2b93e8c039b19" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_array" kindref="compound">NumericArray</ref>&lt; <ref refid="classarrow_1_1_time32_type" kindref="compound">Time32Type</ref> &gt;</type>
        <definition>using arrow::Time32Array = typedef NumericArray&lt;Time32Type&gt;</definition>
        <argsstring></argsstring>
        <name>Time32Array</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="195" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="195" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a8d407b259c6792c8b8bbb86959259721" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_time32_type" kindref="compound">Time32Type</ref> &gt;</type>
        <definition>using arrow::Time32Builder = typedef NumericBuilder&lt;Time32Type&gt;</definition>
        <argsstring></argsstring>
        <name>Time32Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="196" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="196" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a093e1d42b3a49745a128a04736b56fad" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_array" kindref="compound">NumericArray</ref>&lt; <ref refid="classarrow_1_1_time64_type" kindref="compound">Time64Type</ref> &gt;</type>
        <definition>using arrow::Time64Array = typedef NumericArray&lt;Time64Type&gt;</definition>
        <argsstring></argsstring>
        <name>Time64Array</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="200" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="200" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a682d18a383e3cc604c5add634bde4980" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_time64_type" kindref="compound">Time64Type</ref> &gt;</type>
        <definition>using arrow::Time64Builder = typedef NumericBuilder&lt;Time64Type&gt;</definition>
        <argsstring></argsstring>
        <name>Time64Builder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="201" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="201" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a8da84bd82ad0d204965fe95d134a6c08" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_array" kindref="compound">NumericArray</ref>&lt; <ref refid="classarrow_1_1_timestamp_type" kindref="compound">TimestampType</ref> &gt;</type>
        <definition>using arrow::TimestampArray = typedef NumericArray&lt;TimestampType&gt;</definition>
        <argsstring></argsstring>
        <name>TimestampArray</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="205" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="205" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a7c24ba298ea48738e160ebcf6133aa2f" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_timestamp_type" kindref="compound">TimestampType</ref> &gt;</type>
        <definition>using arrow::TimestampBuilder = typedef NumericBuilder&lt;TimestampType&gt;</definition>
        <argsstring></argsstring>
        <name>TimestampBuilder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="206" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="206" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a182e773860b508e71ad82e8aa2b9556c" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_array" kindref="compound">NumericArray</ref>&lt; <ref refid="classarrow_1_1_month_interval_type" kindref="compound">MonthIntervalType</ref> &gt;</type>
        <definition>using arrow::MonthIntervalArray = typedef NumericArray&lt;MonthIntervalType&gt;</definition>
        <argsstring></argsstring>
        <name>MonthIntervalArray</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="210" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="210" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a8f513441e20a820ba699fb943d527e03" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_month_interval_type" kindref="compound">MonthIntervalType</ref> &gt;</type>
        <definition>using arrow::MonthIntervalBuilder = typedef NumericBuilder&lt;MonthIntervalType&gt;</definition>
        <argsstring></argsstring>
        <name>MonthIntervalBuilder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="211" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="211" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a44cfa546dbecd78fdb541518d7867fe0" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_array" kindref="compound">NumericArray</ref>&lt; <ref refid="classarrow_1_1_duration_type" kindref="compound">DurationType</ref> &gt;</type>
        <definition>using arrow::DurationArray = typedef NumericArray&lt;DurationType&gt;</definition>
        <argsstring></argsstring>
        <name>DurationArray</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="220" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="220" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aefd4592209b60fc1aa1d6fc1f2d0f7bf" prot="public" static="no">
        <type><ref refid="classarrow_1_1_numeric_builder" kindref="compound">NumericBuilder</ref>&lt; <ref refid="classarrow_1_1_duration_type" kindref="compound">DurationType</ref> &gt;</type>
        <definition>using arrow::DurationBuilder = typedef NumericBuilder&lt;DurationType&gt;</definition>
        <argsstring></argsstring>
        <name>DurationBuilder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="221" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="221" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" prot="public" static="no">
        <type>typename std::enable_if&lt; B, T &gt;::type</type>
        <definition>using arrow::enable_if_t = typedef typename std::enable_if&lt;B, T&gt;::type</definition>
        <argsstring></argsstring>
        <name>enable_if_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="397" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="397" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ae823a76b8a9209b0553bd12b92f7628e" prot="public" static="no">
        <type>std::is_same&lt; <ref refid="classarrow_1_1_null_type" kindref="compound">NullType</ref>, T &gt;</type>
        <definition>using arrow::is_null_type = typedef std::is_same&lt;NullType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_null_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="400" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="400" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aefffb639efbe0f7bd75e2a302b7f772e" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1ae823a76b8a9209b0553bd12b92f7628e" kindref="member">is_null_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_null = typedef enable_if_t&lt;is_null_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_null</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="403" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="403" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a1505b20d54161f765534e652d0c20118" prot="public" static="no">
        <type>std::is_same&lt; <ref refid="classarrow_1_1_boolean_type" kindref="compound">BooleanType</ref>, T &gt;</type>
        <definition>using arrow::is_boolean_type = typedef std::is_same&lt;BooleanType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_boolean_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="406" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="406" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1acafae5fb16a0ba015d3d5dc0ba94c059" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a1505b20d54161f765534e652d0c20118" kindref="member">is_boolean_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_boolean = typedef enable_if_t&lt;is_boolean_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_boolean</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="409" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="409" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a17762801d38e85bb19ba347db78c9e38" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_number_type" kindref="compound">NumberType</ref>, T &gt;</type>
        <definition>using arrow::is_number_type = typedef std::is_base_of&lt;NumberType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_number_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="412" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="412" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a7630f411a876624d7d347e59dea8ef70" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a17762801d38e85bb19ba347db78c9e38" kindref="member">is_number_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_number = typedef enable_if_t&lt;is_number_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_number</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="415" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="415" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a3858c2a0029df0a836908cd00da27a73" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_integer_type" kindref="compound">IntegerType</ref>, T &gt;</type>
        <definition>using arrow::is_integer_type = typedef std::is_base_of&lt;IntegerType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_integer_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="418" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="418" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a231590a53c16996c8c7b698333f1ed82" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a3858c2a0029df0a836908cd00da27a73" kindref="member">is_integer_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_integer = typedef enable_if_t&lt;is_integer_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_integer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="421" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="421" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a20dd2b914ad4a61e400eb59894d23a70" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="namespacearrow_1a3858c2a0029df0a836908cd00da27a73" kindref="member">is_integer_type</ref>&lt; T &gt;::value &amp;&amp;std::is_signed&lt; typename T::c_type &gt;::value &gt;</type>
        <definition>using arrow::is_signed_integer_type = typedef std::integral_constant&lt;bool, is_integer_type&lt;T&gt;::value &amp;&amp; std::is_signed&lt;typename T::c_type&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>is_signed_integer_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="424" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="426" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a5f130ef645ae790fb2b596b1123e6d1e" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a20dd2b914ad4a61e400eb59894d23a70" kindref="member">is_signed_integer_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_signed_integer = typedef enable_if_t&lt;is_signed_integer_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_signed_integer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="429" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="429" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1afbff722ac55605b6945c47d8a99feb53" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="namespacearrow_1a3858c2a0029df0a836908cd00da27a73" kindref="member">is_integer_type</ref>&lt; T &gt;::value &amp;&amp;std::is_unsigned&lt; typename T::c_type &gt;::value &gt;</type>
        <definition>using arrow::is_unsigned_integer_type = typedef std::integral_constant&lt;bool, is_integer_type&lt;T&gt;::value &amp;&amp; std::is_unsigned&lt;typename T::c_type&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>is_unsigned_integer_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="432" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="434" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a9b2160429e178313ac15141e7277e763" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1afbff722ac55605b6945c47d8a99feb53" kindref="member">is_unsigned_integer_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_unsigned_integer = typedef enable_if_t&lt;is_unsigned_integer_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_unsigned_integer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="437" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="437" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ab39920d433ba89ea20da9e9ff52ba0de" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_floating_point_type" kindref="compound">FloatingPointType</ref>, T &gt;</type>
        <definition>using arrow::is_floating_type = typedef std::is_base_of&lt;FloatingPointType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_floating_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="442" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="442" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a9dddaa868c5f1b0f2b0642192f16f29b" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1ab39920d433ba89ea20da9e9ff52ba0de" kindref="member">is_floating_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_floating_point = typedef enable_if_t&lt;is_floating_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_floating_point</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="445" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="445" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1af8b7471bd6e7d3ae3f2a996cca113ac5" prot="public" static="no">
        <type>std::is_same&lt; <ref refid="classarrow_1_1_half_float_type" kindref="compound">HalfFloatType</ref>, T &gt;</type>
        <definition>using arrow::is_half_float_type = typedef std::is_same&lt;HalfFloatType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_half_float_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="450" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="450" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ad60fed4e396b94591b87566731a74a7a" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1af8b7471bd6e7d3ae3f2a996cca113ac5" kindref="member">is_half_float_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_half_float = typedef enable_if_t&lt;is_half_float_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_half_float</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="453" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="453" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a7b18703d712bea4f0e5565ebaf84ed74" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_base_binary_type" kindref="compound">BaseBinaryType</ref>, T &gt;</type>
        <definition>using arrow::is_base_binary_type = typedef std::is_base_of&lt;BaseBinaryType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_base_binary_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="459" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="459" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a5adfa6f41eb212d569e8c644b9815bd8" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a7b18703d712bea4f0e5565ebaf84ed74" kindref="member">is_base_binary_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_base_binary = typedef enable_if_t&lt;is_base_binary_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_base_binary</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="462" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="462" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a57b69802ef6353c58cbbf30df4457bf7" prot="public" static="no">
        <type>std::integral_constant&lt; bool, std::is_same&lt; <ref refid="classarrow_1_1_binary_type" kindref="compound">BinaryType</ref>, T &gt;::value||std::is_same&lt; <ref refid="classarrow_1_1_large_binary_type" kindref="compound">LargeBinaryType</ref>, T &gt;::value &gt;</type>
        <definition>using arrow::is_any_binary_type = typedef std::integral_constant&lt;bool, std::is_same&lt;BinaryType, T&gt;::value || std::is_same&lt;LargeBinaryType, T&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>is_any_binary_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="466" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="468" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aa40d4db05ea1b3772a900c4a0dc1d6df" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a57b69802ef6353c58cbbf30df4457bf7" kindref="member">is_any_binary_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_any_binary = typedef enable_if_t&lt;is_any_binary_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_any_binary</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="471" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="471" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a45709f39fa2d7508b0068c6e493acc5b" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="namespacearrow_1a7b18703d712bea4f0e5565ebaf84ed74" kindref="member">is_base_binary_type</ref>&lt; T &gt;::value &amp;&amp;T::is_utf8 &gt;</type>
        <definition>using arrow::is_string_like_type = typedef std::integral_constant&lt;bool, is_base_binary_type&lt;T&gt;::value &amp;&amp; T::is_utf8&gt;</definition>
        <argsstring></argsstring>
        <name>is_string_like_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="474" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="475" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a4eb96642403fdce64b1f1f1189a859e4" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a45709f39fa2d7508b0068c6e493acc5b" kindref="member">is_string_like_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_string_like = typedef enable_if_t&lt;is_string_like_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_string_like</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="478" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="478" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a0f1f61cca333813d5652f9cf7bc54c00" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_fixed_size_binary_type" kindref="compound">FixedSizeBinaryType</ref>, T &gt;</type>
        <definition>using arrow::is_fixed_size_binary_type = typedef std::is_base_of&lt;FixedSizeBinaryType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_fixed_size_binary_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="482" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="482" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aaaf9cd29f578b7221cbd8cf4183d0d80" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a0f1f61cca333813d5652f9cf7bc54c00" kindref="member">is_fixed_size_binary_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_fixed_size_binary = typedef enable_if_t&lt;is_fixed_size_binary_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_fixed_size_binary</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="485" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="485" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a31da5300521aeadb8c39244e672aad20" prot="public" static="no">
        <type>std::integral_constant&lt; bool,(<ref refid="namespacearrow_1a7b18703d712bea4f0e5565ebaf84ed74" kindref="member">is_base_binary_type</ref>&lt; T &gt;::value &amp;&amp;!<ref refid="namespacearrow_1a45709f39fa2d7508b0068c6e493acc5b" kindref="member">is_string_like_type</ref>&lt; T &gt;::value)||<ref refid="namespacearrow_1a0f1f61cca333813d5652f9cf7bc54c00" kindref="member">is_fixed_size_binary_type</ref>&lt; T &gt;::value &gt;</type>
        <definition>using arrow::is_binary_like_type = typedef std::integral_constant&lt;bool, (is_base_binary_type&lt;T&gt;::value &amp;&amp; !is_string_like_type&lt;T&gt;::value) || is_fixed_size_binary_type&lt;T&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>is_binary_like_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="488" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="491" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a07e76ad2a1ac1cc895d9ef4429596e89" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a31da5300521aeadb8c39244e672aad20" kindref="member">is_binary_like_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_binary_like = typedef enable_if_t&lt;is_binary_like_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_binary_like</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="494" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="494" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a104b6b0fbbfcaf5420f1e4efbe06e6a0" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_decimal_type" kindref="compound">DecimalType</ref>, T &gt;</type>
        <definition>using arrow::is_decimal_type = typedef std::is_base_of&lt;DecimalType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_decimal_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="497" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="497" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a1111b82ec23da8d84da2b9aaca4bc936" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a104b6b0fbbfcaf5420f1e4efbe06e6a0" kindref="member">is_decimal_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_decimal = typedef enable_if_t&lt;is_decimal_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_decimal</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="500" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="500" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a29f27de2e50e048565bb9606bb7603d6" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_nested_type" kindref="compound">NestedType</ref>, T &gt;</type>
        <definition>using arrow::is_nested_type = typedef std::is_base_of&lt;NestedType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_nested_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="505" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="505" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a5afc66a9dd979542bb7691353facc725" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a29f27de2e50e048565bb9606bb7603d6" kindref="member">is_nested_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_nested = typedef enable_if_t&lt;is_nested_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_nested</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="508" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="508" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ac8355f70ffdffa130e9ca72d01cfdc0c" prot="public" static="no">
        <type>std::integral_constant&lt; bool, std::is_base_of&lt; <ref refid="classarrow_1_1_large_list_type" kindref="compound">LargeListType</ref>, T &gt;::value||std::is_base_of&lt; <ref refid="classarrow_1_1_list_type" kindref="compound">ListType</ref>, T &gt;::value &gt;</type>
        <definition>using arrow::is_var_length_list_type = typedef std::integral_constant&lt;bool, std::is_base_of&lt;LargeListType, T&gt;::value || std::is_base_of&lt;ListType, T&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>is_var_length_list_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="511" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="513" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a10348582fba4b40efc0cdacc1e8a3469" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1ac8355f70ffdffa130e9ca72d01cfdc0c" kindref="member">is_var_length_list_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_var_size_list = typedef enable_if_t&lt;is_var_length_list_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_var_size_list</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="516" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="516" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a94978108f2e82a2b903f12d180f12bb8" prot="public" static="no">
        <type><ref refid="namespacearrow_1ac8355f70ffdffa130e9ca72d01cfdc0c" kindref="member">is_var_length_list_type</ref>&lt; T &gt;</type>
        <definition>using arrow::is_base_list_type = typedef is_var_length_list_type&lt;T&gt;</definition>
        <argsstring></argsstring>
        <name>is_base_list_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="520" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="520" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1af8d4e2943d8e55e8a58247140746161a" prot="public" static="no">
        <type><ref refid="namespacearrow_1a10348582fba4b40efc0cdacc1e8a3469" kindref="member">enable_if_var_size_list</ref>&lt; T, R &gt;</type>
        <definition>using arrow::enable_if_base_list = typedef enable_if_var_size_list&lt;T, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_base_list</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="524" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="524" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a2d0fa3fa76eca92942333e08afbf5e2c" prot="public" static="no">
        <type>std::is_same&lt; <ref refid="classarrow_1_1_fixed_size_list_type" kindref="compound">FixedSizeListType</ref>, T &gt;</type>
        <definition>using arrow::is_fixed_size_list_type = typedef std::is_same&lt;FixedSizeListType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_fixed_size_list_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="527" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="527" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a5d5fd9fcbc47d7a271bc3e8acffb7419" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a2d0fa3fa76eca92942333e08afbf5e2c" kindref="member">is_fixed_size_list_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_fixed_size_list = typedef enable_if_t&lt;is_fixed_size_list_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_fixed_size_list</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="530" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="530" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a2b6af17dcffa6518fe03a0e26d084814" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="namespacearrow_1a94978108f2e82a2b903f12d180f12bb8" kindref="member">is_base_list_type</ref>&lt; T &gt;::value||<ref refid="namespacearrow_1a2d0fa3fa76eca92942333e08afbf5e2c" kindref="member">is_fixed_size_list_type</ref>&lt; T &gt;::value &gt;</type>
        <definition>using arrow::is_list_like_type = typedef std::integral_constant&lt;bool, is_base_list_type&lt;T&gt;::value || is_fixed_size_list_type&lt;T&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>is_list_like_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="533" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="535" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a391a75a25d56b15b309a520d42b7696d" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a2b6af17dcffa6518fe03a0e26d084814" kindref="member">is_list_like_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_list_like = typedef enable_if_t&lt;is_list_like_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_list_like</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="538" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="538" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a7cc4639f9805d2ff49d79770577683bb" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_struct_type" kindref="compound">StructType</ref>, T &gt;</type>
        <definition>using arrow::is_struct_type = typedef std::is_base_of&lt;StructType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_struct_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="541" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="541" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a524c1cd0f2b105e5ad18a1410aafcba0" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a7cc4639f9805d2ff49d79770577683bb" kindref="member">is_struct_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_struct = typedef enable_if_t&lt;is_struct_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_struct</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="544" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="544" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a8a8ba17a03d55c0a45607ce41c506e6b" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_union_type" kindref="compound">UnionType</ref>, T &gt;</type>
        <definition>using arrow::is_union_type = typedef std::is_base_of&lt;UnionType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_union_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="547" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="547" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ada6364f401be8babca103e18af1154c6" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a8a8ba17a03d55c0a45607ce41c506e6b" kindref="member">is_union_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_union = typedef enable_if_t&lt;is_union_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_union</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="550" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="550" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ad747b7b43421fb8bcb9e41e2b9ccc5e7" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_temporal_type" kindref="compound">TemporalType</ref>, T &gt;</type>
        <definition>using arrow::is_temporal_type = typedef std::is_base_of&lt;TemporalType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_temporal_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="555" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="555" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aead9c608ea64700fc81a28485d675cce" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1ad747b7b43421fb8bcb9e41e2b9ccc5e7" kindref="member">is_temporal_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_temporal = typedef enable_if_t&lt;is_temporal_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_temporal</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="558" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="558" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a201c518970c17cdce4d402b68510edee" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_date_type" kindref="compound">DateType</ref>, T &gt;</type>
        <definition>using arrow::is_date_type = typedef std::is_base_of&lt;DateType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_date_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="561" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="561" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a95bd19f17d8bafe6e5be8f1b6a293466" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a201c518970c17cdce4d402b68510edee" kindref="member">is_date_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_date = typedef enable_if_t&lt;is_date_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_date</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="564" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="564" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aaa20abe6646670908e927e14fe48f238" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_time_type" kindref="compound">TimeType</ref>, T &gt;</type>
        <definition>using arrow::is_time_type = typedef std::is_base_of&lt;TimeType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_time_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="567" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="567" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a9d121c21d9bf722d5630549f91de2494" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1aaa20abe6646670908e927e14fe48f238" kindref="member">is_time_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_time = typedef enable_if_t&lt;is_time_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_time</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="570" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="570" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1abc4fc09acf6524064a074ffc9c8269ea" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_timestamp_type" kindref="compound">TimestampType</ref>, T &gt;</type>
        <definition>using arrow::is_timestamp_type = typedef std::is_base_of&lt;TimestampType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_timestamp_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="573" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="573" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a34f916e587fb352a2ac375ca35cb3434" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1abc4fc09acf6524064a074ffc9c8269ea" kindref="member">is_timestamp_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_timestamp = typedef enable_if_t&lt;is_timestamp_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_timestamp</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="576" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="576" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a9e8b36624157a2c34db12f20a54a20e4" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_duration_type" kindref="compound">DurationType</ref>, T &gt;</type>
        <definition>using arrow::is_duration_type = typedef std::is_base_of&lt;DurationType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_duration_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="579" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="579" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1af862a54186228d55eedb5e96a177d816" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a9e8b36624157a2c34db12f20a54a20e4" kindref="member">is_duration_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_duration = typedef enable_if_t&lt;is_duration_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_duration</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="582" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="582" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a59ba5d87672cd108fd3b167fd258fb54" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_interval_type" kindref="compound">IntervalType</ref>, T &gt;</type>
        <definition>using arrow::is_interval_type = typedef std::is_base_of&lt;IntervalType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_interval_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="585" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="585" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a119121074b7bfa291143daba4f5cd7f0" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a59ba5d87672cd108fd3b167fd258fb54" kindref="member">is_interval_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_interval = typedef enable_if_t&lt;is_interval_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_interval</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="588" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="588" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1af5f81113b89cbe368312906d2ea05455" prot="public" static="no">
        <type>std::is_base_of&lt; <ref refid="classarrow_1_1_primitive_c_type" kindref="compound">PrimitiveCType</ref>, T &gt;</type>
        <definition>using arrow::is_primitive_ctype = typedef std::is_base_of&lt;PrimitiveCType, T&gt;</definition>
        <argsstring></argsstring>
        <name>is_primitive_ctype</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="593" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="593" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ac8463908634b0318bee5971d05f00386" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1af5f81113b89cbe368312906d2ea05455" kindref="member">is_primitive_ctype</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_primitive_ctype = typedef enable_if_t&lt;is_primitive_ctype&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_primitive_ctype</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="596" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="596" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a1d618f8e1fb33c3f4ecc90094dc9eec9" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="namespacearrow_1af5f81113b89cbe368312906d2ea05455" kindref="member">is_primitive_ctype</ref>&lt; T &gt;::value||<ref refid="namespacearrow_1ad747b7b43421fb8bcb9e41e2b9ccc5e7" kindref="member">is_temporal_type</ref>&lt; T &gt;::value &gt;</type>
        <definition>using arrow::has_c_type = typedef std::integral_constant&lt;bool, is_primitive_ctype&lt;T&gt;::value || is_temporal_type&lt;T&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>has_c_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="599" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="600" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a7e090acba4674b10ca16691401701bd6" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a1d618f8e1fb33c3f4ecc90094dc9eec9" kindref="member">has_c_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_has_c_type = typedef enable_if_t&lt;has_c_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_has_c_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="603" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="603" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a4444a0309da790a63c0856fb90e635b7" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="namespacearrow_1a31da5300521aeadb8c39244e672aad20" kindref="member">is_binary_like_type</ref>&lt; T &gt;::value||<ref refid="namespacearrow_1a45709f39fa2d7508b0068c6e493acc5b" kindref="member">is_string_like_type</ref>&lt; T &gt;::value &gt;</type>
        <definition>using arrow::has_string_view = typedef std::integral_constant&lt;bool, is_binary_like_type&lt;T&gt;::value || is_string_like_type&lt;T&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>has_string_view</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="606" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="607" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a94667b305c94aaad1ed7c2b667a24fad" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a4444a0309da790a63c0856fb90e635b7" kindref="member">has_string_view</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_has_string_view = typedef enable_if_t&lt;has_string_view&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_has_string_view</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="610" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="610" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a775977292719f9e7ace109475c3d497b" prot="public" static="no">
        <type>std::integral_constant&lt; bool, std::is_same&lt; <ref refid="classarrow_1_1_u_int8_type" kindref="compound">UInt8Type</ref>, T &gt;::value||std::is_same&lt; <ref refid="classarrow_1_1_int8_type" kindref="compound">Int8Type</ref>, T &gt;::value &gt;</type>
        <definition>using arrow::is_8bit_int = typedef std::integral_constant&lt;bool, std::is_same&lt;UInt8Type, T&gt;::value || std::is_same&lt;Int8Type, T&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>is_8bit_int</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="613" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="614" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1ac28ec25ca257b62697c39d4bf10cab62" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a775977292719f9e7ace109475c3d497b" kindref="member">is_8bit_int</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_8bit_int = typedef enable_if_t&lt;is_8bit_int&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_8bit_int</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="617" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="617" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a0e3a809d6228febd9b9cd5257de92971" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="structarrow_1_1_type_traits" kindref="compound">TypeTraits</ref>&lt; T &gt;::is_parameter_free &gt;</type>
        <definition>using arrow::is_paramater_free_type = typedef std::integral_constant&lt;bool, TypeTraits&lt;T&gt;::is_parameter_free&gt;</definition>
        <argsstring></argsstring>
        <name>is_paramater_free_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="620" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="621" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a6c7d9fa36c6e17e9653179705ab1f49d" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a0e3a809d6228febd9b9cd5257de92971" kindref="member">is_paramater_free_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_parameter_free = typedef enable_if_t&lt;is_paramater_free_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_parameter_free</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="624" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="624" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a51e9f94af3f7a0c4ed946c23c731e453" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="namespacearrow_1a20dd2b914ad4a61e400eb59894d23a70" kindref="member">is_signed_integer_type</ref>&lt; T &gt;::value||(<ref refid="namespacearrow_1ad747b7b43421fb8bcb9e41e2b9ccc5e7" kindref="member">is_temporal_type</ref>&lt; T &gt;::value &amp;&amp;<ref refid="namespacearrow_1a1d618f8e1fb33c3f4ecc90094dc9eec9" kindref="member">has_c_type</ref>&lt; T &gt;::value)&gt;</type>
        <definition>using arrow::is_physical_signed_integer_type = typedef std::integral_constant&lt;bool, is_signed_integer_type&lt;T&gt;::value || (is_temporal_type&lt;T&gt;::value &amp;&amp; has_c_type&lt;T&gt;::value)&gt;</definition>
        <argsstring></argsstring>
        <name>is_physical_signed_integer_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="629" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="632" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1aec365fc8dcb7c75493dae0eef4871118" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a51e9f94af3f7a0c4ed946c23c731e453" kindref="member">is_physical_signed_integer_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_physical_signed_integer = typedef enable_if_t&lt;is_physical_signed_integer_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_physical_signed_integer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="635" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="636" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a6c99ff90cd175919ff6aabcb854287d0" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="namespacearrow_1afbff722ac55605b6945c47d8a99feb53" kindref="member">is_unsigned_integer_type</ref>&lt; T &gt;::value||<ref refid="namespacearrow_1af8b7471bd6e7d3ae3f2a996cca113ac5" kindref="member">is_half_float_type</ref>&lt; T &gt;::value &gt;</type>
        <definition>using arrow::is_physical_unsigned_integer_type = typedef std::integral_constant&lt;bool, is_unsigned_integer_type&lt;T&gt;::value || is_half_float_type&lt;T&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>is_physical_unsigned_integer_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="639" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="641" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a8e1f2397f5492a98c6a9aaf17c5afe84" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a6c99ff90cd175919ff6aabcb854287d0" kindref="member">is_physical_unsigned_integer_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_physical_unsigned_integer = typedef enable_if_t&lt;is_physical_unsigned_integer_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_physical_unsigned_integer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="644" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="645" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a9bec5260c0be3e093d9bfc1bfc4249cb" prot="public" static="no">
        <type>std::integral_constant&lt; bool, <ref refid="namespacearrow_1ab39920d433ba89ea20da9e9ff52ba0de" kindref="member">is_floating_type</ref>&lt; T &gt;::value &amp;&amp;!<ref refid="namespacearrow_1af8b7471bd6e7d3ae3f2a996cca113ac5" kindref="member">is_half_float_type</ref>&lt; T &gt;::value &gt;</type>
        <definition>using arrow::is_physical_floating_type = typedef std::integral_constant&lt;bool, is_floating_type&lt;T&gt;::value &amp;&amp; !is_half_float_type&lt;T&gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>is_physical_floating_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="650" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="652" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1a6d501b2058862ff8b769dfbf48ba4cd6" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt; <ref refid="namespacearrow_1a9bec5260c0be3e093d9bfc1bfc4249cb" kindref="member">is_physical_floating_type</ref>&lt; T &gt;::value, R &gt;</type>
        <definition>using arrow::enable_if_physical_floating_point = typedef enable_if_t&lt;is_physical_floating_type&lt;T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_physical_floating_point</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="655" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="656" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacearrow_1a4cd38814abf185253aa1c8f68c9ca5ab" prot="public" static="no" mutable="no">
        <type>constexpr int64_t</type>
        <definition>constexpr int64_t arrow::kMinBuilderCapacity</definition>
        <argsstring></argsstring>
        <name>kMinBuilderCapacity</name>
        <initializer>= 1 &lt;&lt; 5</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_base.h" line="43" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_base.h" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1ab64d5a2a0d35fbe0ae87fc18d2a5c0ee" prot="public" static="no" mutable="no">
        <type>constexpr int64_t</type>
        <definition>constexpr int64_t arrow::kListMaximumElements</definition>
        <argsstring></argsstring>
        <name>kListMaximumElements</name>
        <initializer>= std::numeric_limits&lt;int32_t&gt;::max() - 1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_base.h" line="44" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_base.h" bodystart="44" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1a6c4f8bc1a6b7bfa3386005a0bede3640" prot="public" static="no" mutable="no">
        <type>constexpr int64_t</type>
        <definition>constexpr int64_t arrow::kBinaryMemoryLimit</definition>
        <argsstring></argsstring>
        <name>kBinaryMemoryLimit</name>
        <initializer>= std::numeric_limits&lt;int32_t&gt;::max() - 1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/builder_binary.h" line="38" column="1" bodyfile="/arrow/cpp/src/arrow/array/builder_binary.h" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1af7fa6d3c9abcfa1251baa24ff731782e" prot="public" static="no" mutable="no">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::function&lt; <ref refid="classarrow_1_1_status" kindref="compound">Status</ref>(const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;edits, const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;base, const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;target)&gt; &gt;</type>
        <definition>Result&lt; std::function&lt;Status(const Array&amp; edits, const Array&amp; base, const Array&amp; target)&gt; &gt; arrow::MakeUnifiedDiffFormatter(const DataType &amp;type, std::ostream *os)</definition>
        <argsstring>(const DataType &amp;type, std::ostream *os)</argsstring>
        <name>MakeUnifiedDiffFormatter</name>
        <briefdescription>
<para>return a function which will format an edit script in unified diff format to os, given base and target arrays of type </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/diff.h" line="71" column="1" bodyfile="/arrow/cpp/src/arrow/array/diff.h" bodystart="71" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1a2bc89c993234944fd7bdbdfe95812080" prot="public" static="no" mutable="no">
        <type>constexpr int64_t</type>
        <definition>constexpr int64_t arrow::kUnknownNullCount</definition>
        <argsstring></argsstring>
        <name>kUnknownNullCount</name>
        <initializer>= -1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="48" column="1" bodyfile="/arrow/cpp/src/arrow/array.h" bodystart="48" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1a7b6234e4545feef8cf7dcad166ff5990" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double arrow::kDefaultAbsoluteTolerance</definition>
        <argsstring></argsstring>
        <name>kDefaultAbsoluteTolerance</name>
        <initializer>= 1E-5</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compare.h" line="36" column="1" bodyfile="/arrow/cpp/src/arrow/compare.h" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1a0f613bf6f0e5a50bd9a89c767d8004d1" prot="public" static="no" mutable="no">
        <type>const char</type>
        <definition>const char arrow::kExtensionTypeKeyName[]</definition>
        <argsstring>[]</argsstring>
        <name>kExtensionTypeKeyName</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/extension_type.h" line="148" column="1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1ac532e4d8906ecf870014f5a4bbb1382c" prot="public" static="no" mutable="no">
        <type>const char</type>
        <definition>const char arrow::kExtensionMetadataKeyName[]</definition>
        <argsstring>[]</argsstring>
        <name>kExtensionMetadataKeyName</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/extension_type.h" line="149" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacearrow_1a832b1cd8b78ca5af346b5ff1bc0d8df5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Concatenate</definition>
        <argsstring>(const ArrayVector &amp;arrays, MemoryPool *pool, std::shared_ptr&lt; Array &gt; *out)</argsstring>
        <name>Concatenate</name>
        <param>
          <type>const <ref refid="namespacearrow_1ad77c54b51dac02d857f3a26d11ed58b3" kindref="member">ArrayVector</ref> &amp;</type>
          <declname>arrays</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Concatenate arrays. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">arrays</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector of arrays to be concatenated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>memory to store the result will be allocated from this memory pool </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>the resulting concatenated array </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/concatenate.h" line="36" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a0d16f62627582ce40fcb90f88471c67e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_struct_array" kindref="compound">StructArray</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;StructArray&gt; &gt; arrow::Diff</definition>
        <argsstring>(const Array &amp;base, const Array &amp;target, MemoryPool *pool)</argsstring>
        <name>Diff</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>base</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>target</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Compare two arrays, returning an edit script which expresses the difference between them. </para>        </briefdescription>
        <detaileddescription>
<para>An edit script is an array of struct(insert: bool, run_length: int64_t). Each element of &quot;insert&quot; determines whether an element was inserted into (true) or deleted from (false) base. Each insertion or deletion is followed by a run of elements which are unchanged from base to target; the length of this run is stored in &quot;run_length&quot;. (Note that the edit script begins and ends with a run of shared elements but both fields of the struct must have the same length. To accommodate this the first element of &quot;insert&quot; should be ignored.)</para><para>For example for base &quot;hlloo&quot; and target &quot;hello&quot;, the edit script would be [ {&quot;insert&quot;: false, &quot;run_length&quot;: 1}, // leading run of length 1 (&quot;h&quot;) {&quot;insert&quot;: true, &quot;run_length&quot;: 3}, // insert(&quot;e&quot;) then a run of length 3 (&quot;llo&quot;) {&quot;insert&quot;: false, &quot;run_length&quot;: 0} // delete(&quot;o&quot;) then an empty run ]</para><para>Diffing arrays containing nulls is not currently supported.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">base</parametername>
</parameternamelist>
<parameterdescription>
<para>baseline for comparison </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">target</parametername>
</parameternamelist>
<parameterdescription>
<para>an array of identical type to base whose elements differ from base&apos;s </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>memory to store the result will be allocated from this memory pool </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>an edit script array which can be applied to base to produce target </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/diff.h" line="56" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ac00d7d4fc1efa5afee3a1a0b228f7817" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::VisitEditScript</definition>
        <argsstring>(const Array &amp;edits, const std::function&lt; Status(int64_t delete_begin, int64_t delete_end, int64_t insert_begin, int64_t insert_end)&gt; &amp;visitor)</argsstring>
        <name>VisitEditScript</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>edits</declname>
        </param>
        <param>
          <type>const std::function&lt; <ref refid="classarrow_1_1_status" kindref="compound">Status</ref>(int64_t delete_begin, int64_t delete_end, int64_t insert_begin, int64_t insert_end)&gt; &amp;</type>
          <declname>visitor</declname>
        </param>
        <briefdescription>
<para>visitor interface for easy traversal of an edit script </para>        </briefdescription>
        <detaileddescription>
<para>visitor will be called for each hunk of insertions and deletions. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array/diff.h" line="62" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a7edcc7f88dec3ddcfcd8ccf1882cb833" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Array&gt; arrow::MakeArray</definition>
        <argsstring>(const std::shared_ptr&lt; ArrayData &gt; &amp;data)</argsstring>
        <name>MakeArray</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="structarrow_1_1_array_data" kindref="compound">ArrayData</ref> &gt; &amp;</type>
          <declname>data</declname>
        </param>
        <briefdescription>
<para>Create a strongly-typed <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance from generic <ref refid="structarrow_1_1_array_data" kindref="compound">ArrayData</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>the array contents </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the resulting <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="238" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a19b8737ab489d01ffc7d216d2d6aabac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Array&gt; &gt; arrow::MakeArrayOfNull</definition>
        <argsstring>(const std::shared_ptr&lt; DataType &gt; &amp;type, int64_t length, MemoryPool *pool=default_memory_pool())</argsstring>
        <name>MakeArrayOfNull</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820" kindref="member">default_memory_pool</ref>()</defval>
        </param>
        <briefdescription>
<para>Create a strongly-typed <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance with all elements null. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>the array type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">length</parametername>
</parameternamelist>
<parameterdescription>
<para>the array length </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>the memory pool to allocate memory from </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="245" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ad32cba2e36a1a755389ec57810cec516" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Array&gt; &gt; arrow::MakeArrayFromScalar</definition>
        <argsstring>(const Scalar &amp;scalar, int64_t length, MemoryPool *pool=default_memory_pool())</argsstring>
        <name>MakeArrayFromScalar</name>
        <param>
          <type>const <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &amp;</type>
          <declname>scalar</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820" kindref="member">default_memory_pool</ref>()</defval>
        </param>
        <briefdescription>
<para>Create an <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance whose slots are the given scalar. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>the value with which to fill the array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">length</parametername>
</parameternamelist>
<parameterdescription>
<para>the array length </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>the memory pool to allocate memory from </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="254" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a215f8e56eb8f3c0c6ce42f6bd2456f29" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::MakeArrayOfNull</definition>
        <argsstring>(const std::shared_ptr&lt; DataType &gt; &amp;type, int64_t length, std::shared_ptr&lt; Array &gt; *out)</argsstring>
        <name>MakeArrayOfNull</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Create a strongly-typed <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance with all elements null. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>the array type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">length</parametername>
</parameternamelist>
<parameterdescription>
<para>the array length </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="263" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1aca90ffe324b4b915c0bfa4a048f73952" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::MakeArrayOfNull</definition>
        <argsstring>(MemoryPool *pool, const std::shared_ptr&lt; DataType &gt; &amp;type, int64_t length, std::shared_ptr&lt; Array &gt; *out)</argsstring>
        <name>MakeArrayOfNull</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Create a strongly-typed <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance with all elements null. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>the pool from which memory for this array will be allocated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>the array type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">length</parametername>
</parameternamelist>
<parameterdescription>
<para>the array length </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="273" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1af4593951e6af46e335bd41121192e6c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::MakeArrayFromScalar</definition>
        <argsstring>(const Scalar &amp;scalar, int64_t length, std::shared_ptr&lt; Array &gt; *out)</argsstring>
        <name>MakeArrayFromScalar</name>
        <param>
          <type>const <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &amp;</type>
          <declname>scalar</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Create an <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance whose slots are the given scalar. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>the value with which to fill the array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">length</parametername>
</parameternamelist>
<parameterdescription>
<para>the array length </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="282" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ae5bc3e67510177ec60c965a2e59d310a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::MakeArrayFromScalar</definition>
        <argsstring>(MemoryPool *pool, const Scalar &amp;scalar, int64_t length, std::shared_ptr&lt; Array &gt; *out)</argsstring>
        <name>MakeArrayFromScalar</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &amp;</type>
          <declname>scalar</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Create a strongly-typed <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance with all elements null. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>the pool from which memory for this array will be allocated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">scalar</parametername>
</parameternamelist>
<parameterdescription>
<para>the value with which to fill the array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">length</parametername>
</parameternamelist>
<parameterdescription>
<para>the array length </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> instance </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="292" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a7ee685e6074e6b1741c00d7ab095a317" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>static std::ostream&amp; arrow::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Array &amp;x)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/array.h" line="464" column="1" bodyfile="/arrow/cpp/src/arrow/array.h" bodystart="464" bodyend="467"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-slicing-functions_1ga23386d14ecaa97d5c1c93b53676c34e2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        <definition>static std::shared_ptr&lt;Buffer&gt; arrow::SliceBuffer</definition>
        <argsstring>(const std::shared_ptr&lt; Buffer &gt; &amp;buffer, const int64_t offset, const int64_t length)</argsstring>
        <name>SliceBuffer</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &amp;</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Construct a view on a buffer at the given offset and length. </para>        </briefdescription>
        <detaileddescription>
<para>This function cannot fail and does not check for errors (except in debug builds) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="341" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="341" bodyend="345"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-slicing-functions_1gab051c8518e0c9881042fdf8cf1416cbe" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        <definition>static std::shared_ptr&lt;Buffer&gt; arrow::SliceBuffer</definition>
        <argsstring>(const std::shared_ptr&lt; Buffer &gt; &amp;buffer, const int64_t offset)</argsstring>
        <name>SliceBuffer</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &amp;</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>offset</declname>
        </param>
        <briefdescription>
<para>Construct a view on a buffer at the given offset, up to the buffer&apos;s end. </para>        </briefdescription>
        <detaileddescription>
<para>This function cannot fail and does not check for errors (except in debug builds) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="350" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="350" bodyend="354"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-slicing-functions_1ga44c8f98a2874248eb7d5658ccee5718e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Buffer&gt; arrow::SliceMutableBuffer</definition>
        <argsstring>(const std::shared_ptr&lt; Buffer &gt; &amp;buffer, const int64_t offset, const int64_t length)</argsstring>
        <name>SliceMutableBuffer</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &amp;</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Like SliceBuffer, but construct a mutable buffer slice. </para>        </briefdescription>
        <detaileddescription>
<para>If the parent buffer is not mutable, behavior is undefined (it may abort in debug builds). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="361" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-slicing-functions_1ga5eccd6ba6b0902e9eab560b0dc960aae" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
        <definition>static std::shared_ptr&lt;Buffer&gt; arrow::SliceMutableBuffer</definition>
        <argsstring>(const std::shared_ptr&lt; Buffer &gt; &amp;buffer, const int64_t offset)</argsstring>
        <name>SliceMutableBuffer</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &amp;</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>offset</declname>
        </param>
        <briefdescription>
<para>Like SliceBuffer, but construct a mutable buffer slice. </para>        </briefdescription>
        <detaileddescription>
<para>If the parent buffer is not mutable, behavior is undefined (it may abort in debug builds). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="368" column="1" bodyfile="/arrow/cpp/src/arrow/buffer.h" bodystart="368" bodyend="372"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1gab7eeff2b27bb71cb821a1005d1d0a9be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::unique_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>Result&lt;std::unique_ptr&lt;Buffer&gt; &gt; arrow::AllocateBuffer</definition>
        <argsstring>(const int64_t size, MemoryPool *pool=NULLPTR)</argsstring>
        <name>AllocateBuffer</name>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Allocate a fixed size mutable buffer from a memory pool, zero its padding. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>size of buffer to allocate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>a memory pool </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="452" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1gaff11ee23eb038410107ea5246f2fb330" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateBuffer</definition>
        <argsstring>(MemoryPool *pool, const int64_t size, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>AllocateBuffer</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="457" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1gae4d3ff86145cc77724a56967ea8a3f5f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateBuffer</definition>
        <argsstring>(const int64_t size, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>AllocateBuffer</name>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="461" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1gad9698aacbd4ac435cc0cb676e2cb1fe0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateBuffer</definition>
        <argsstring>(MemoryPool *pool, const int64_t size, std::unique_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>AllocateBuffer</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="465" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga06f0e830cd9d1892b243dda5cc66429a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateBuffer</definition>
        <argsstring>(const int64_t size, std::unique_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>AllocateBuffer</name>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="469" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1gaa44d72e6284de08b2171a710a01de2d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::unique_ptr&lt; <ref refid="classarrow_1_1_resizable_buffer" kindref="compound">ResizableBuffer</ref> &gt; &gt;</type>
        <definition>Result&lt;std::unique_ptr&lt;ResizableBuffer&gt; &gt; arrow::AllocateResizableBuffer</definition>
        <argsstring>(const int64_t size, MemoryPool *pool=NULLPTR)</argsstring>
        <name>AllocateResizableBuffer</name>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Allocate a resizeable buffer from a memory pool, zero its padding. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">size</parametername>
</parameternamelist>
<parameterdescription>
<para>size of buffer to allocate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>a memory pool </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="476" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga9c3ce000978a518fad942be4a54e9870" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateResizableBuffer</definition>
        <argsstring>(MemoryPool *pool, const int64_t size, std::shared_ptr&lt; ResizableBuffer &gt; *out)</argsstring>
        <name>AllocateResizableBuffer</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_resizable_buffer" kindref="compound">ResizableBuffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="481" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1gaa80acc74f413afe7f8ed46cde85a5a80" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateResizableBuffer</definition>
        <argsstring>(const int64_t size, std::shared_ptr&lt; ResizableBuffer &gt; *out)</argsstring>
        <name>AllocateResizableBuffer</name>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_resizable_buffer" kindref="compound">ResizableBuffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="486" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga2fdac7fee8638d46c79b8136aa38c956" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateResizableBuffer</definition>
        <argsstring>(MemoryPool *pool, const int64_t size, std::unique_ptr&lt; ResizableBuffer &gt; *out)</argsstring>
        <name>AllocateResizableBuffer</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1_resizable_buffer" kindref="compound">ResizableBuffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="490" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga6eb313aa6e6d83310dcc2a951875b9d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateResizableBuffer</definition>
        <argsstring>(const int64_t size, std::unique_ptr&lt; ResizableBuffer &gt; *out)</argsstring>
        <name>AllocateResizableBuffer</name>
        <param>
          <type>const int64_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1_resizable_buffer" kindref="compound">ResizableBuffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="495" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga4726342b8bd298b7bf05f741076e7527" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::AllocateBitmap</definition>
        <argsstring>(int64_t length, MemoryPool *pool=NULLPTR)</argsstring>
        <name>AllocateBitmap</name>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Allocate a bitmap buffer from a memory pool no guarantee on values is provided. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">length</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bits of bitmap to allocate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>memory pool to allocate memory from </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="503" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga93c20471c43a7a35eaabf2506d5b533e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateBitmap</definition>
        <argsstring>(MemoryPool *pool, int64_t length, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>AllocateBitmap</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="507" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga4bdacf00a6041fa3825f419698c7c40c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::AllocateEmptyBitmap</definition>
        <argsstring>(int64_t length, MemoryPool *pool=NULLPTR)</argsstring>
        <name>AllocateEmptyBitmap</name>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Allocate a zero-initialized bitmap buffer from a memory pool. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">length</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bits of bitmap to allocate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>memory pool to allocate memory from </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="514" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga79907066edd38d36e95c56673aa46a3b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateEmptyBitmap</definition>
        <argsstring>(MemoryPool *pool, int64_t length, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>AllocateEmptyBitmap</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="519" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga2c62ce65a76507d648998fc260e5ead1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::AllocateEmptyBitmap</definition>
        <argsstring>(int64_t length, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>AllocateEmptyBitmap</name>
        <param>
          <type>int64_t</type>
          <declname>length</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="524" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga614382b33dc47fa784c7a4b3be2c0f59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::ConcatenateBuffers</definition>
        <argsstring>(const BufferVector &amp;buffers, MemoryPool *pool=NULLPTR)</argsstring>
        <name>ConcatenateBuffers</name>
        <param>
          <type>const <ref refid="namespacearrow_1a26e0360de3fc4b7120b6b50f14a22786" kindref="member">BufferVector</ref> &amp;</type>
          <declname>buffers</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Concatenate multiple buffers into a single buffer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">buffers</parametername>
</parameternamelist>
<parameterdescription>
<para>to be concatenated </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>memory pool to allocate the new buffer from </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="531" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__buffer-allocation-functions_1ga193a7618d4456e8d4f40d305c8d683f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ConcatenateBuffers</definition>
        <argsstring>(const BufferVector &amp;buffers, MemoryPool *pool, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>ConcatenateBuffers</name>
        <param>
          <type>const <ref refid="namespacearrow_1a26e0360de3fc4b7120b6b50f14a22786" kindref="member">BufferVector</ref> &amp;</type>
          <declname>buffers</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/buffer.h" line="535" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a08900491dab187842698af9cca156b17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::MakeBuilder</definition>
        <argsstring>(MemoryPool *pool, const std::shared_ptr&lt; DataType &gt; &amp;type, std::unique_ptr&lt; ArrayBuilder &gt; *out)</argsstring>
        <name>MakeBuilder</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1_array_builder" kindref="compound">ArrayBuilder</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Construct an empty <ref refid="classarrow_1_1_array_builder" kindref="compound">ArrayBuilder</ref> corresponding to the data type. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> to use for allocations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>an instance of <ref refid="classarrow_1_1_dictionary_type" kindref="compound">DictionaryType</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>the created <ref refid="classarrow_1_1_array_builder" kindref="compound">ArrayBuilder</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/builder.h" line="45" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a5f56be53f725a2959311b30c314f94fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::MakeDictionaryBuilder</definition>
        <argsstring>(MemoryPool *pool, const std::shared_ptr&lt; DataType &gt; &amp;type, const std::shared_ptr&lt; Array &gt; &amp;dictionary, std::unique_ptr&lt; ArrayBuilder &gt; *out)</argsstring>
        <name>MakeDictionaryBuilder</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; &amp;</type>
          <declname>dictionary</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1_array_builder" kindref="compound">ArrayBuilder</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Construct an empty <ref refid="classarrow_1_1_dictionary_builder" kindref="compound">DictionaryBuilder</ref> initialized optionally with a pre-existing dictionary. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> to use for allocations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>an instance of <ref refid="classarrow_1_1_dictionary_type" kindref="compound">DictionaryType</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dictionary</parametername>
</parameternamelist>
<parameterdescription>
<para>the initial dictionary, if any. May be nullptr </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>the created <ref refid="classarrow_1_1_array_builder" kindref="compound">ArrayBuilder</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/builder.h" line="55" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a7da90da6bbc1e4274c5ab69ef548c5cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ExportType</definition>
        <argsstring>(const DataType &amp;type, struct ArrowSchema *out)</argsstring>
        <name>ExportType</name>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Export C++ <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> using the C data interface format. </para>        </briefdescription>
        <detaileddescription>
<para>The root type is considered to have empty name and metadata. If you want the root type to have a name and/or metadata, pass a <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> instead.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> object to export </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>C struct where to export the datatype </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="41" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a59a445f143c92c1b6c2ccd1bbac0dd38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ExportField</definition>
        <argsstring>(const Field &amp;field, struct ArrowSchema *out)</argsstring>
        <name>ExportField</name>
        <param>
          <type>const <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &amp;</type>
          <declname>field</declname>
        </param>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Export C++ <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> using the C data interface format. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">field</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1_field" kindref="compound">Field</ref> object to export </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>C struct where to export the field </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="48" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1af3170f491c928ed457de8b950cb751cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ExportSchema</definition>
        <argsstring>(const Schema &amp;schema, struct ArrowSchema *out)</argsstring>
        <name>ExportSchema</name>
        <param>
          <type>const <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Export C++ <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> using the C data interface format. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> object to export </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>C struct where to export the field </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="55" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a39affd3a4b79ea656cfbdce075e1980d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ExportArray</definition>
        <argsstring>(const Array &amp;array, struct ArrowArray *out, struct ArrowSchema *out_schema=NULLPTR)</argsstring>
        <name>ExportArray</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>array</declname>
        </param>
        <param>
          <type>struct <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> *</type>
          <declname>out</declname>
        </param>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>out_schema</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Export C++ <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> using the C data interface format. </para>        </briefdescription>
        <detaileddescription>
<para>The resulting <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> struct keeps the array data and buffers alive until its release callback is called by the consumer.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">array</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1_array" kindref="compound">Array</ref> object to export </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>C struct where to export the array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out_schema</parametername>
</parameternamelist>
<parameterdescription>
<para>optional C struct where to export the array type </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="66" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a4975ac879aa6563af28fbdaea6809d90" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ExportRecordBatch</definition>
        <argsstring>(const RecordBatch &amp;batch, struct ArrowArray *out, struct ArrowSchema *out_schema=NULLPTR)</argsstring>
        <name>ExportRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>struct <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> *</type>
          <declname>out</declname>
        </param>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>out_schema</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Export C++ <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> using the C data interface format. </para>        </briefdescription>
        <detaileddescription>
<para>The record batch is exported as if it were a struct array. The resulting <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> struct keeps the record batch data and buffers alive until its release callback is called by the consumer.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">batch</parametername>
</parameternamelist>
<parameterdescription>
<para>Record batch to export </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>C struct where to export the record batch </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out_schema</parametername>
</parameternamelist>
<parameterdescription>
<para>optional C struct where to export the record batch schema </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="79" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a93879eda95b4d068637bf9aa3cd4acea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;DataType&gt; &gt; arrow::ImportType</definition>
        <argsstring>(struct ArrowSchema *schema)</argsstring>
        <name>ImportType</name>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>schema</declname>
        </param>
        <briefdescription>
<para>Import C++ <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> from the C data interface. </para>        </briefdescription>
        <detaileddescription>
<para>The given <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> struct is released (as per the C data interface specification), even if this function fails.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>C data interface struct representing the data type </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Imported type object </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="90" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a4aacb5719ecca8b93ddff5dcc0dc3891" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Field&gt; &gt; arrow::ImportField</definition>
        <argsstring>(struct ArrowSchema *schema)</argsstring>
        <name>ImportField</name>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>schema</declname>
        </param>
        <briefdescription>
<para>Import C++ <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> from the C data interface. </para>        </briefdescription>
        <detaileddescription>
<para>The given <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> struct is released (as per the C data interface specification), even if this function fails.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>C data interface struct representing the field </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Imported field object </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="100" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ac24528129a0426eb3f26ed1e15880616" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Schema&gt; &gt; arrow::ImportSchema</definition>
        <argsstring>(struct ArrowSchema *schema)</argsstring>
        <name>ImportSchema</name>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>schema</declname>
        </param>
        <briefdescription>
<para>Import C++ <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> from the C data interface. </para>        </briefdescription>
        <detaileddescription>
<para>The given <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> struct is released (as per the C data interface specification), even if this function fails.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>C data interface struct representing the field </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Imported field object </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="110" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a9933efa71a537134c5d829861537fd0e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Array&gt; &gt; arrow::ImportArray</definition>
        <argsstring>(struct ArrowArray *array, std::shared_ptr&lt; DataType &gt; type)</argsstring>
        <name>ImportArray</name>
        <param>
          <type>struct <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> *</type>
          <declname>array</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>Import C++ array from the C data interface. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> struct has its contents moved (as per the C data interface specification) to a private object held alive by the resulting array.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">array</parametername>
</parameternamelist>
<parameterdescription>
<para>C data interface struct holding the array data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the imported array </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Imported array object </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="121" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1accb0b54d5d9aad0bf4e7881a5e9c8e0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Array&gt; &gt; arrow::ImportArray</definition>
        <argsstring>(struct ArrowArray *array, struct ArrowSchema *type)</argsstring>
        <name>ImportArray</name>
        <param>
          <type>struct <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> *</type>
          <declname>array</declname>
        </param>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>Import C++ array and its type from the C data interface. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> struct has its contents moved (as per the C data interface specification) to a private object held alive by the resulting array. The <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> struct is released, even if this function fails.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">array</parametername>
</parameternamelist>
<parameterdescription>
<para>C data interface struct holding the array data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">type</parametername>
</parameternamelist>
<parameterdescription>
<para>C data interface struct holding the array type </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Imported array object </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="134" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a62dd7e4fbb15ed2d07fb8640412e74ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;RecordBatch&gt; &gt; arrow::ImportRecordBatch</definition>
        <argsstring>(struct ArrowArray *array, std::shared_ptr&lt; Schema &gt; schema)</argsstring>
        <name>ImportRecordBatch</name>
        <param>
          <type>struct <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> *</type>
          <declname>array</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt;</type>
          <declname>schema</declname>
        </param>
        <briefdescription>
<para>Import C++ record batch from the C data interface. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> struct has its contents moved (as per the C data interface specification) to a private object held alive by the resulting record batch.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">array</parametername>
</parameternamelist>
<parameterdescription>
<para>C data interface struct holding the record batch data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>schema of the imported record batch </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Imported record batch object </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="146" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a4b9c523c08a0551164440c3995b74fa4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;RecordBatch&gt; &gt; arrow::ImportRecordBatch</definition>
        <argsstring>(struct ArrowArray *array, struct ArrowSchema *schema)</argsstring>
        <name>ImportRecordBatch</name>
        <param>
          <type>struct <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> *</type>
          <declname>array</declname>
        </param>
        <param>
          <type>struct <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> *</type>
          <declname>schema</declname>
        </param>
        <briefdescription>
<para>Import C++ record batch and its schema from the C data interface. </para>        </briefdescription>
        <detaileddescription>
<para>The type represented by the <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> struct must be a struct type array. The <ref refid="struct_arrow_array" kindref="compound">ArrowArray</ref> struct has its contents moved (as per the C data interface specification) to a private object held alive by the resulting record batch. The <ref refid="struct_arrow_schema" kindref="compound">ArrowSchema</ref> struct is released, even if this function fails.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">array</parametername>
</parameternamelist>
<parameterdescription>
<para>C data interface struct holding the record batch data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>C data interface struct holding the record batch schema </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Imported record batch object </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/c/bridge.h" line="160" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1aa2ecf91f56f47a6d73b95e09d05b4de9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::ArrayEquals</definition>
        <argsstring>(const Array &amp;left, const Array &amp;right, const EqualOptions &amp;=EqualOptions::Defaults())</argsstring>
        <name>ArrayEquals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_equal_options" kindref="compound">EqualOptions</ref> &amp;</type>
          <defval><ref refid="classarrow_1_1_equal_options_1aceb7c9984ead6d5a79ba4a725193d452" kindref="member">EqualOptions::Defaults</ref>()</defval>
        </param>
        <briefdescription>
<para>Returns true if the arrays are exactly equal. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compare.h" line="83" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a0127366929daceea11e1143498477446" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::TensorEquals</definition>
        <argsstring>(const Tensor &amp;left, const Tensor &amp;right, const EqualOptions &amp;=EqualOptions::Defaults())</argsstring>
        <name>TensorEquals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_equal_options" kindref="compound">EqualOptions</ref> &amp;</type>
          <defval><ref refid="classarrow_1_1_equal_options_1aceb7c9984ead6d5a79ba4a725193d452" kindref="member">EqualOptions::Defaults</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compare.h" line="86" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a3f13424f09e4067bbcb4c23f745b48b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::SparseTensorEquals</definition>
        <argsstring>(const SparseTensor &amp;left, const SparseTensor &amp;right, const EqualOptions &amp;=EqualOptions::Defaults())</argsstring>
        <name>SparseTensorEquals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">SparseTensor</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">SparseTensor</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_equal_options" kindref="compound">EqualOptions</ref> &amp;</type>
          <defval><ref refid="classarrow_1_1_equal_options_1aceb7c9984ead6d5a79ba4a725193d452" kindref="member">EqualOptions::Defaults</ref>()</defval>
        </param>
        <briefdescription>
<para>EXPERIMENTAL: Returns true if the given sparse tensors are exactly equal. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compare.h" line="90" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a73d896fc0a4a06fa37f6da05a1a0da44" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::ArrayApproxEquals</definition>
        <argsstring>(const Array &amp;left, const Array &amp;right, const EqualOptions &amp;=EqualOptions::Defaults())</argsstring>
        <name>ArrayApproxEquals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_equal_options" kindref="compound">EqualOptions</ref> &amp;</type>
          <defval><ref refid="classarrow_1_1_equal_options_1aceb7c9984ead6d5a79ba4a725193d452" kindref="member">EqualOptions::Defaults</ref>()</defval>
        </param>
        <briefdescription>
<para>Returns true if the arrays are approximately equal. </para>        </briefdescription>
        <detaileddescription>
<para>For non-floating point types, this is equivalent to ArrayEquals(left, right) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compare.h" line="95" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a1d4576fdd48ce9e8484b30e3b94fd00d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::ArrayRangeEquals</definition>
        <argsstring>(const Array &amp;left, const Array &amp;right, int64_t start_idx, int64_t end_idx, int64_t other_start_idx)</argsstring>
        <name>ArrayRangeEquals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>start_idx</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>end_idx</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>other_start_idx</declname>
        </param>
        <briefdescription>
<para>Returns true if indicated equal-length segment of arrays is exactly equal. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compare.h" line="99" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a234135e3a4408f77e2bbf4719f040ee9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::TypeEquals</definition>
        <argsstring>(const DataType &amp;left, const DataType &amp;right, bool check_metadata=true)</argsstring>
        <name>TypeEquals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>check_metadata</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Returns true if the type metadata are exactly equal. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">left</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">right</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">check_metadata</parametername>
</parameternamelist>
<parameterdescription>
<para>whether to compare <ref refid="classarrow_1_1_key_value_metadata" kindref="compound">KeyValueMetadata</ref> for child fields </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compare.h" line="108" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a17e9a5cf615bc758d9cdbe7e6da611c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::ScalarEquals</definition>
        <argsstring>(const Scalar &amp;left, const Scalar &amp;right)</argsstring>
        <name>ScalarEquals</name>
        <param>
          <type>const <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
<para>Returns true if scalars are equal. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">left</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">right</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compare.h" line="114" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a6945ae85a9bf9faebabefcb308098cc8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt;</type>
        <definition>std::shared_ptr&lt;MemoryManager&gt; arrow::default_cpu_memory_manager</definition>
        <argsstring>()</argsstring>
        <name>default_cpu_memory_manager</name>
        <briefdescription>
<para>Return the default CPU <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> instance. </para>        </briefdescription>
        <detaileddescription>
<para>The returned singleton instance uses the default <ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref>. This function is a faster spelling of <computeroutput><ref refid="classarrow_1_1_c_p_u_device_1a2639c1933007a4c0b553b245c9a59896" kindref="member">CPUDevice::Instance()</ref>-&gt;default_memory_manager()</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/device.h" line="224" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1aac71528443df3a53855482472db00f9d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::RegisterExtensionType</definition>
        <argsstring>(std::shared_ptr&lt; ExtensionType &gt; type)</argsstring>
        <name>RegisterExtensionType</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_extension_type" kindref="compound">ExtensionType</ref> &gt;</type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>Register an extension type globally. </para>        </briefdescription>
        <detaileddescription>
<para>The name returned by the type&apos;s extension_name() method should be unique. This method is thread-safe <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>an instance of the extension type </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/extension_type.h" line="133" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ab162fa7ed427af976c48637d541325be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::UnregisterExtensionType</definition>
        <argsstring>(const std::string &amp;type_name)</argsstring>
        <name>UnregisterExtensionType</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>type_name</declname>
        </param>
        <briefdescription>
<para>Delete an extension type from the global registry. </para>        </briefdescription>
        <detaileddescription>
<para>This method is thread-safe <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">type_name</parametername>
</parameternamelist>
<parameterdescription>
<para>the unique name of a registered extension type </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> error if the type name is unknown </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/extension_type.h" line="140" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a2fb2b23cadfc295fdafbddb144f695ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_extension_type" kindref="compound">ExtensionType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;ExtensionType&gt; arrow::GetExtensionType</definition>
        <argsstring>(const std::string &amp;type_name)</argsstring>
        <name>GetExtensionType</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>type_name</declname>
        </param>
        <briefdescription>
<para>Retrieve an extension type from the global registry. </para>        </briefdescription>
        <detaileddescription>
<para>Returns nullptr if not found. This method is thread-safe <simplesect kind="return"><para>the globally-registered extension type </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/extension_type.h" line="146" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1aab2dcf4f3003c334c3a337d65657e4c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
        <definition>MemoryPool* arrow::system_memory_pool</definition>
        <argsstring>()</argsstring>
        <name>system_memory_pool</name>
        <briefdescription>
<para>Return a process-wide memory pool based on the system allocator. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/memory_pool.h" line="153" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a07e44d557d9f98ba7a42bbcba1fb7698" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::jemalloc_memory_pool</definition>
        <argsstring>(MemoryPool **out)</argsstring>
        <name>jemalloc_memory_pool</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> **</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Return a process-wide memory pool based on jemalloc. </para>        </briefdescription>
        <detaileddescription>
<para>May return NotImplemented if jemalloc is not available. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/memory_pool.h" line="158" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ad0ebc0eb6975ac95276758b9a171c82d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::jemalloc_set_decay_ms</definition>
        <argsstring>(int ms)</argsstring>
        <name>jemalloc_set_decay_ms</name>
        <param>
          <type>int</type>
          <declname>ms</declname>
        </param>
        <briefdescription>
<para>Set jemalloc memory page purging behavior for future-created arenas to the indicated number of milliseconds. </para>        </briefdescription>
        <detaileddescription>
<para>See dirty_decay_ms and muzzy_decay_ms options in jemalloc for a description of what these do. The default is configured to 1000 (1 second) which releases memory more aggressively to the operating system than the jemalloc default of 10 seconds. If you set the value to 0, dirty / muzzy pages will be released immediately rather than with a time decay, but this may reduce application performance. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/memory_pool.h" line="169" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1af03def88fd1ab05b0df699df9c3b9754" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::mimalloc_memory_pool</definition>
        <argsstring>(MemoryPool **out)</argsstring>
        <name>mimalloc_memory_pool</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> **</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Return a process-wide memory pool based on mimalloc. </para>        </briefdescription>
        <detaileddescription>
<para>May return NotImplemented if mimalloc is not available. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/memory_pool.h" line="174" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a737bc52e404537e2dbb14e110e78daaa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const RecordBatch &amp;batch, int indent, std::ostream *sink)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>indent</declname>
        </param>
        <param>
          <type>std::ostream *</type>
          <declname>sink</declname>
        </param>
        <briefdescription>
<para>Print human-readable representation of <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="77" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a1797b746b75cf6af1b6809b5932b1fe8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const RecordBatch &amp;batch, const PrettyPrintOptions &amp;options, std::ostream *sink)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_pretty_print_options" kindref="compound">PrettyPrintOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::ostream *</type>
          <declname>sink</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="80" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a051589b1255ab558754828c44e2dd04b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const Table &amp;table, const PrettyPrintOptions &amp;options, std::ostream *sink)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &amp;</type>
          <declname>table</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_pretty_print_options" kindref="compound">PrettyPrintOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::ostream *</type>
          <declname>sink</declname>
        </param>
        <briefdescription>
<para>Print human-readable representation of <ref refid="classarrow_1_1_table" kindref="compound">Table</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="85" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a5e646aac1cf6c89685b5d161377a236b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const Array &amp;arr, int indent, std::ostream *sink)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>indent</declname>
        </param>
        <param>
          <type>std::ostream *</type>
          <declname>sink</declname>
        </param>
        <briefdescription>
<para>Print human-readable representation of <ref refid="classarrow_1_1_array" kindref="compound">Array</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="90" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1aa1e25f267b13e3a61947a9dfd93b92f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const Array &amp;arr, const PrettyPrintOptions &amp;options, std::ostream *sink)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_pretty_print_options" kindref="compound">PrettyPrintOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::ostream *</type>
          <declname>sink</declname>
        </param>
        <briefdescription>
<para>Print human-readable representation of <ref refid="classarrow_1_1_array" kindref="compound">Array</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="94" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ac6b7f013ed791d08a9e4e3b9ec8a3f54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const Array &amp;arr, const PrettyPrintOptions &amp;options, std::string *result)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_pretty_print_options" kindref="compound">PrettyPrintOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::string *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
<para>Print human-readable representation of <ref refid="classarrow_1_1_array" kindref="compound">Array</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="99" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1aed1396ab6f5f1e481bcaf595dd7a6427" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const ChunkedArray &amp;chunked_arr, const PrettyPrintOptions &amp;options, std::ostream *sink)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &amp;</type>
          <declname>chunked_arr</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_pretty_print_options" kindref="compound">PrettyPrintOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::ostream *</type>
          <declname>sink</declname>
        </param>
        <briefdescription>
<para>Print human-readable representation of <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="104" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a1ac5ddf6d8603e6d0230a2768b42be4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const ChunkedArray &amp;chunked_arr, const PrettyPrintOptions &amp;options, std::string *result)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &amp;</type>
          <declname>chunked_arr</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_pretty_print_options" kindref="compound">PrettyPrintOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::string *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
<para>Print human-readable representation of <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="109" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a9706f4e03928551a9e24db5c205e5521" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const Schema &amp;schema, const PrettyPrintOptions &amp;options, std::ostream *sink)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_pretty_print_options" kindref="compound">PrettyPrintOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::ostream *</type>
          <declname>sink</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="113" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a4dc6b3a8c2c471161f3b4c6c61e86aad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::PrettyPrint</definition>
        <argsstring>(const Schema &amp;schema, const PrettyPrintOptions &amp;options, std::string *result)</argsstring>
        <name>PrettyPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1_pretty_print_options" kindref="compound">PrettyPrintOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::string *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="117" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1acc529837f8c4825ef5ae3ecee7e614d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::DebugPrint</definition>
        <argsstring>(const Array &amp;arr, int indent)</argsstring>
        <name>DebugPrint</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>indent</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/pretty_print.h" line="121" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a5995edd01ce9b02e0a4244fb35cb6746" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch_reader" kindref="compound">RecordBatchReader</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;RecordBatchReader&gt; &gt; arrow::MakeRecordBatchReader</definition>
        <argsstring>(std::vector&lt; std::shared_ptr&lt; RecordBatch &gt;&gt; batches, std::shared_ptr&lt; Schema &gt; schema=NULLPTR)</argsstring>
        <name>MakeRecordBatchReader</name>
        <param>
          <type>std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt;&gt;</type>
          <declname>batches</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt;</type>
          <declname>schema</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_record_batch_reader" kindref="compound">RecordBatchReader</ref> from a vector of <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">batches</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector of <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> to read from </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>schema to conform to. Will be inferred from the first element if not provided. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/record_batch.h" line="243" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a72eb98f2ac861fb4ea1420eef62fcb50" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::MakeRecordBatchReader</definition>
        <argsstring>(std::vector&lt; std::shared_ptr&lt; RecordBatch &gt;&gt; batches, std::shared_ptr&lt; Schema &gt; schema, std::shared_ptr&lt; RecordBatchReader &gt; *out)</argsstring>
        <name>MakeRecordBatchReader</name>
        <param>
          <type>std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt;&gt;</type>
          <declname>batches</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch_reader" kindref="compound">RecordBatchReader</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/record_batch.h" line="248" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a99890873e6dbba7461d3d8bc9b4a03e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Scalar&gt; arrow::MakeNullScalar</definition>
        <argsstring>(std::shared_ptr&lt; DataType &gt; type)</argsstring>
        <name>MakeNullScalar</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/scalar.h" line="388" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a5902391d987b8f930a8d3898813d91d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Scalar&gt; &gt; arrow::MakeScalar</definition>
        <argsstring>(std::shared_ptr&lt; DataType &gt; type, Value &amp;&amp;value)</argsstring>
        <name>MakeScalar</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>Value &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/scalar.h" line="429" column="1" bodyfile="/arrow/cpp/src/arrow/scalar.h" bodystart="429" bodyend="432"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a6d94a22489c2d88b5ece3464f6757b5c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Value</type>
          </param>
          <param>
            <type>typename Traits</type>
            <defval>CTypeTraits&lt;typename std::decay&lt;Value&gt;::type&gt;</defval>
          </param>
          <param>
            <type>typename ScalarType</type>
            <defval>typename Traits::ScalarType</defval>
          </param>
          <param>
            <type>typename Enable</type>
            <defval>decltype(ScalarType(std::declval&lt;Value&gt;(),                                                Traits::type_singleton()))</defval>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Scalar&gt; arrow::MakeScalar</definition>
        <argsstring>(Value value)</argsstring>
        <name>MakeScalar</name>
        <param>
          <type>Value</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>type inferring scalar factory </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/scalar.h" line="439" column="1" bodyfile="/arrow/cpp/src/arrow/scalar.h" bodystart="439" bodyend="441"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ade3bae9d69b7544f4bfe67f6c60ceb1e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Scalar&gt; arrow::MakeScalar</definition>
        <argsstring>(std::string value)</argsstring>
        <name>MakeScalar</name>
        <param>
          <type>std::string</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/scalar.h" line="443" column="1" bodyfile="/arrow/cpp/src/arrow/scalar.h" bodystart="443" bodyend="445"/>
      </memberdef>
      <memberdef kind="function" id="group__concat-tables_1ga6272e4a6555d62afc43b2845d8616eb7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Table&gt; &gt; arrow::ConcatenateTables</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; Table &gt;&gt; &amp;tables, ConcatenateTablesOptions options=ConcatenateTablesOptions::Defaults(), MemoryPool *memory_pool=default_memory_pool())</argsstring>
        <name>ConcatenateTables</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &gt;&gt; &amp;</type>
          <declname>tables</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_concatenate_tables_options" kindref="compound">ConcatenateTablesOptions</ref></type>
          <declname>options</declname>
          <defval><ref refid="group__concat-tables_1ga1f99414177f1507f6efa3471cb650bbb" kindref="member">ConcatenateTablesOptions::Defaults</ref>()</defval>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>memory_pool</declname>
          <defval><ref refid="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820" kindref="member">default_memory_pool</ref>()</defval>
        </param>
        <briefdescription>
<para>Construct table from multiple input tables. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/table.h" line="476" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__concat-tables_1ga4b46a73d9d5aba02b66257039342c5a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Table&gt; &gt; arrow::PromoteTableToSchema</definition>
        <argsstring>(const std::shared_ptr&lt; Table &gt; &amp;table, const std::shared_ptr&lt; Schema &gt; &amp;schema, MemoryPool *pool=default_memory_pool())</argsstring>
        <name>PromoteTableToSchema</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &gt; &amp;</type>
          <declname>table</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820" kindref="member">default_memory_pool</ref>()</defval>
        </param>
        <briefdescription>
<para>Promotes a table to conform to the given schema. </para>        </briefdescription>
        <detaileddescription>
<para>If a field in the schema does not have a corresponding column in the table, a column of nulls will be added to the resulting table. If the corresponding column is of type Null, it will be promoted to the type specified by schema, with null values filled. Returns an error:<itemizedlist>
<listitem><para>if the corresponding column&apos;s type is not compatible with the schema.</para></listitem><listitem><para>if there is a column in the table that does not exist in the schema.</para></listitem></itemizedlist>
</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">table</parametername>
</parameternamelist>
<parameterdescription>
<para>the input <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>the target schema to promote to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>The memory pool to be used if null-filled arrays need to be created. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/table.h" line="497" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1aa2adb29bf5a69435b01a1926ea3a9016" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_tensor_supported</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_tensor_supported</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/tensor.h" line="34" column="1" bodyfile="/arrow/cpp/src/arrow/tensor.h" bodystart="34" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a5709505547e744fa9cf7ddb09b1c2984" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; arrow::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const DataType &amp;type)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="289" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a0877817f90cecf7a3b19a199b7195e2d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; arrow::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, TimeUnit::type unit)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_time_unit_1a561ef51c3755bd873f8f86f5bc4ec1ff" kindref="member">TimeUnit::type</ref></type>
          <declname>unit</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1108" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1abc8d7384b0a61a9a15cfdca6c39c4ded" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Schema&gt; &gt; arrow::UnifySchemas</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; Schema &gt;&gt; &amp;schemas, Field::MergeOptions field_merge_options=Field::MergeOptions::Defaults())</argsstring>
        <name>UnifySchemas</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt;&gt; &amp;</type>
          <declname>schemas</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_field_1_1_merge_options" kindref="compound">Field::MergeOptions</ref></type>
          <declname>field_merge_options</declname>
          <defval><ref refid="structarrow_1_1_field_1_1_merge_options_1aad6ec10fe86793101bf688bbf9c9ad96" kindref="member">Field::MergeOptions::Defaults</ref>()</defval>
        </param>
        <briefdescription>
<para>Unifies schemas by merging fields by name. </para>        </briefdescription>
        <detaileddescription>
<para>The behavior of field merging can be controlled via <computeroutput><ref refid="structarrow_1_1_field_1_1_merge_options" kindref="compound">Field::MergeOptions</ref></computeroutput>.</para><para>The resulting schema will contain the union of fields from all schemas. Fields with the same name will be merged. See <computeroutput><ref refid="structarrow_1_1_field_1_1_merge_options" kindref="compound">Field::MergeOptions</ref></computeroutput>.<itemizedlist>
<listitem><para>They are expected to be mergeable under provided <computeroutput>field_merge_options</computeroutput>.</para></listitem><listitem><para>The unified field will inherit the metadata from the schema where that field is first defined.</para></listitem><listitem><para>The first N fields in the schema will be ordered the same as the N fields in the first schema. The resulting schema will inherit its metadata from the first input schema. Returns an error if:</para></listitem><listitem><para>Any input schema contains fields with duplicate names.</para></listitem><listitem><para>Fields of the same name are not mergeable. </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1851" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gaf642d53dac1a6b6b686fb5984d33bc9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::null</definition>
        <argsstring>()</argsstring>
        <name>null</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_null_type" kindref="compound">NullType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="236" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga1e585e8f1c25a9751ac9381a274df057" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::boolean</definition>
        <argsstring>()</argsstring>
        <name>boolean</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_boolean_type" kindref="compound">BooleanType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="238" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga9c09bf26bc03f0fb0c84a0277215dd67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::int8</definition>
        <argsstring>()</argsstring>
        <name>int8</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_int8_type" kindref="compound">Int8Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="240" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga034c5c703e15039fe76af412d349734d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::int16</definition>
        <argsstring>()</argsstring>
        <name>int16</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_int16_type" kindref="compound">Int16Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="242" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga86f6bfe394347f77befa2143297ad541" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::int32</definition>
        <argsstring>()</argsstring>
        <name>int32</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_int32_type" kindref="compound">Int32Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="244" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga733b16be653069b8d926529662e34e79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::int64</definition>
        <argsstring>()</argsstring>
        <name>int64</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_int64_type" kindref="compound">Int64Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="246" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga4891a423be213550cc24e8ebe830673f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::uint8</definition>
        <argsstring>()</argsstring>
        <name>uint8</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_u_int8_type" kindref="compound">UInt8Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="248" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga9f1e44bc2ab9b465b6e7b601eb48f0a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::uint16</definition>
        <argsstring>()</argsstring>
        <name>uint16</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_u_int16_type" kindref="compound">UInt16Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="250" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gae80e510cfb2931ac18c73cba0be6d894" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::uint32</definition>
        <argsstring>()</argsstring>
        <name>uint32</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_u_int32_type" kindref="compound">UInt32Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="252" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gae548d03275f4afaa97a269774ce6930c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::uint64</definition>
        <argsstring>()</argsstring>
        <name>uint64</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_u_int64_type" kindref="compound">UInt64Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="254" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga4fac9b6739876df09be8b82d70b26734" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::float16</definition>
        <argsstring>()</argsstring>
        <name>float16</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_half_float_type" kindref="compound">HalfFloatType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="256" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga48fca9d26feda61c8255ec3c44a2078c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::float32</definition>
        <argsstring>()</argsstring>
        <name>float32</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_float_type" kindref="compound">FloatType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="258" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gab6f514320a9b037ab161fa97db73b970" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::float64</definition>
        <argsstring>()</argsstring>
        <name>float64</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_double_type" kindref="compound">DoubleType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="260" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga63178820a26f6ecb894ad35963ca981a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::utf8</definition>
        <argsstring>()</argsstring>
        <name>utf8</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_string_type" kindref="compound">StringType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="262" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gacc42ef32dc897b3bee1dea124cefab86" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::large_utf8</definition>
        <argsstring>()</argsstring>
        <name>large_utf8</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_large_string_type" kindref="compound">LargeStringType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="264" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga66c3979f26a439e78d048bbac84a9232" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::binary</definition>
        <argsstring>()</argsstring>
        <name>binary</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_binary_type" kindref="compound">BinaryType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="266" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gad41a46c979c848fee62212f2e49a8d8c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::large_binary</definition>
        <argsstring>()</argsstring>
        <name>large_binary</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_large_binary_type" kindref="compound">LargeBinaryType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="268" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gac15fddc26c629cd5a2cb67f432739e8e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::date32</definition>
        <argsstring>()</argsstring>
        <name>date32</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_date32_type" kindref="compound">Date32Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="270" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga540dd093466c265aa411a65f29e950b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::date64</definition>
        <argsstring>()</argsstring>
        <name>date64</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_date64_type" kindref="compound">Date64Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="272" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gacaf5c20d8caef81e01621a3cad7cc9c2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::fixed_size_binary</definition>
        <argsstring>(int32_t byte_width)</argsstring>
        <name>fixed_size_binary</name>
        <param>
          <type>int32_t</type>
          <declname>byte_width</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_fixed_size_binary_type" kindref="compound">FixedSizeBinaryType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="276" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga3390964f23814ab08c9604158f727883" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::decimal</definition>
        <argsstring>(int32_t precision, int32_t scale)</argsstring>
        <name>decimal</name>
        <param>
          <type>int32_t</type>
          <declname>precision</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>scale</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_decimal128_type" kindref="compound">Decimal128Type</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="280" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga20e7157554937088556275ed4b6485d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::list</definition>
        <argsstring>(const std::shared_ptr&lt; Field &gt; &amp;value_type)</argsstring>
        <name>list</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt; &amp;</type>
          <declname>value_type</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_list_type" kindref="compound">ListType</ref> instance from its child <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="284" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga1bf7acea41aa557cf249bc91b50c8044" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::list</definition>
        <argsstring>(const std::shared_ptr&lt; DataType &gt; &amp;value_type)</argsstring>
        <name>list</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>value_type</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_list_type" kindref="compound">ListType</ref> instance from its child <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="288" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga14066c45deb0167842e3e7bd7c545ec0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::large_list</definition>
        <argsstring>(const std::shared_ptr&lt; Field &gt; &amp;value_type)</argsstring>
        <name>large_list</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt; &amp;</type>
          <declname>value_type</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_large_list_type" kindref="compound">LargeListType</ref> instance from its child <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="292" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga37378b9cb539ee9284c44e2efaafff8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::large_list</definition>
        <argsstring>(const std::shared_ptr&lt; DataType &gt; &amp;value_type)</argsstring>
        <name>large_list</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>value_type</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_large_list_type" kindref="compound">LargeListType</ref> instance from its child <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="296" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga18349773a5006d18cc0071b89715cb7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::map</definition>
        <argsstring>(const std::shared_ptr&lt; DataType &gt; &amp;key_type, const std::shared_ptr&lt; DataType &gt; &amp;item_type, bool keys_sorted=false)</argsstring>
        <name>map</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>key_type</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>item_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>keys_sorted</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_map_type" kindref="compound">MapType</ref> instance from its key and value DataTypes. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="300" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga52cb3decb340491e8947cb74b2d95b85" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::map</definition>
        <argsstring>(const std::shared_ptr&lt; DataType &gt; &amp;key_type, const std::shared_ptr&lt; Field &gt; &amp;item_field, bool keys_sorted=false)</argsstring>
        <name>map</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>key_type</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt; &amp;</type>
          <declname>item_field</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>keys_sorted</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_map_type" kindref="compound">MapType</ref> instance from its key <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> and value field. </para>        </briefdescription>
        <detaileddescription>
<para>The field override is provided to communicate nullability of the value. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="308" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gad5bb35da3242368660a754a0d47e518b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::fixed_size_list</definition>
        <argsstring>(const std::shared_ptr&lt; Field &gt; &amp;value_type, int32_t list_size)</argsstring>
        <name>fixed_size_list</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt; &amp;</type>
          <declname>value_type</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>list_size</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_fixed_size_list_type" kindref="compound">FixedSizeListType</ref> instance from its child <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="314" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga09fb55b2d07e324f1560a8eeb142e2ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::fixed_size_list</definition>
        <argsstring>(const std::shared_ptr&lt; DataType &gt; &amp;value_type, int32_t list_size)</argsstring>
        <name>fixed_size_list</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>value_type</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>list_size</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_fixed_size_list_type" kindref="compound">FixedSizeListType</ref> instance from its child <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="319" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga4a09df951503764895e56db3fe5d053c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::duration</definition>
        <argsstring>(TimeUnit::type unit)</argsstring>
        <name>duration</name>
        <param>
          <type><ref refid="structarrow_1_1_time_unit_1a561ef51c3755bd873f8f86f5bc4ec1ff" kindref="member">TimeUnit::type</ref></type>
          <declname>unit</declname>
        </param>
        <briefdescription>
<para>Return a Duration instance (naming use _type to avoid namespace conflict with built in time clases). </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="323" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga81643b6c32e9c11375084c074567cba0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::day_time_interval</definition>
        <argsstring>()</argsstring>
        <name>day_time_interval</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_day_time_interval_type" kindref="compound">DayTimeIntervalType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="326" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gaf3c6cebcb8e66ada1ea7bbfe5d4c8978" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::month_interval</definition>
        <argsstring>()</argsstring>
        <name>month_interval</name>
        <briefdescription>
<para>Return a <ref refid="classarrow_1_1_month_interval_type" kindref="compound">MonthIntervalType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="329" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga862528838ca7d12e13c09edc02bb6151" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::timestamp</definition>
        <argsstring>(TimeUnit::type unit)</argsstring>
        <name>timestamp</name>
        <param>
          <type><ref refid="structarrow_1_1_time_unit_1a561ef51c3755bd873f8f86f5bc4ec1ff" kindref="member">TimeUnit::type</ref></type>
          <declname>unit</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_timestamp_type" kindref="compound">TimestampType</ref> instance from its unit. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="333" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga58fe6ad4ca179979515028f11d8abbca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::timestamp</definition>
        <argsstring>(TimeUnit::type unit, const std::string &amp;timezone)</argsstring>
        <name>timestamp</name>
        <param>
          <type><ref refid="structarrow_1_1_time_unit_1a561ef51c3755bd873f8f86f5bc4ec1ff" kindref="member">TimeUnit::type</ref></type>
          <declname>unit</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>timezone</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_timestamp_type" kindref="compound">TimestampType</ref> instance from its unit and timezone. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="337" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gae2e76c6504af1c30799b5b4d7e737305" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::time32</definition>
        <argsstring>(TimeUnit::type unit)</argsstring>
        <name>time32</name>
        <param>
          <type><ref refid="structarrow_1_1_time_unit_1a561ef51c3755bd873f8f86f5bc4ec1ff" kindref="member">TimeUnit::type</ref></type>
          <declname>unit</declname>
        </param>
        <briefdescription>
<para>Create a 32-bit time type instance. </para>        </briefdescription>
        <detaileddescription>
<para>Unit can be either SECOND or MILLI </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="342" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga7f6f30b7153111da33e446965b5531e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::time64</definition>
        <argsstring>(TimeUnit::type unit)</argsstring>
        <name>time64</name>
        <param>
          <type><ref refid="structarrow_1_1_time_unit_1a561ef51c3755bd873f8f86f5bc4ec1ff" kindref="member">TimeUnit::type</ref></type>
          <declname>unit</declname>
        </param>
        <briefdescription>
<para>Create a 64-bit time type instance. </para>        </briefdescription>
        <detaileddescription>
<para>Unit can be either MICRO or NANO </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="347" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gafa9f64b1f9435636482c7cc65ec47ecd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::struct_</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; Field &gt;&gt; &amp;fields)</argsstring>
        <name>struct_</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt;&gt; &amp;</type>
          <declname>fields</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_struct_type" kindref="compound">StructType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="351" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga476046674d06cb75a111694064beae36" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::union_</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; Field &gt;&gt; &amp;child_fields, const std::vector&lt; int8_t &gt; &amp;type_codes, UnionMode::type mode=UnionMode::SPARSE)</argsstring>
        <name>union_</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt;&gt; &amp;</type>
          <declname>child_fields</declname>
        </param>
        <param>
          <type>const std::vector&lt; int8_t &gt; &amp;</type>
          <declname>type_codes</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dac" kindref="member">UnionMode::type</ref></type>
          <declname>mode</declname>
          <defval><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60" kindref="member">UnionMode::SPARSE</ref></defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_union_type" kindref="compound">UnionType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="355" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga3781bbe8baac73138ad864fa53735490" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::union_</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; Field &gt;&gt; &amp;child_fields, UnionMode::type mode=UnionMode::SPARSE)</argsstring>
        <name>union_</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt;&gt; &amp;</type>
          <declname>child_fields</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dac" kindref="member">UnionMode::type</ref></type>
          <declname>mode</declname>
          <defval><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60" kindref="member">UnionMode::SPARSE</ref></defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_union_type" kindref="compound">UnionType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="360" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga16c955b465c8bfe339b624fd605fb3a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::union_</definition>
        <argsstring>(UnionMode::type mode=UnionMode::SPARSE)</argsstring>
        <name>union_</name>
        <param>
          <type><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dac" kindref="member">UnionMode::type</ref></type>
          <declname>mode</declname>
          <defval><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60" kindref="member">UnionMode::SPARSE</ref></defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_union_type" kindref="compound">UnionType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="364" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gaae8cac474f002c3be857a88bf9497972" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::union_</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; Array &gt;&gt; &amp;children, const std::vector&lt; std::string &gt; &amp;field_names, const std::vector&lt; int8_t &gt; &amp;type_codes, UnionMode::type mode=UnionMode::SPARSE)</argsstring>
        <name>union_</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt;&gt; &amp;</type>
          <declname>children</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>field_names</declname>
        </param>
        <param>
          <type>const std::vector&lt; int8_t &gt; &amp;</type>
          <declname>type_codes</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dac" kindref="member">UnionMode::type</ref></type>
          <declname>mode</declname>
          <defval><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60" kindref="member">UnionMode::SPARSE</ref></defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_union_type" kindref="compound">UnionType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="368" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga009d36e7c16f62a9e192394da9a94c7c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::union_</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; Array &gt;&gt; &amp;children, const std::vector&lt; std::string &gt; &amp;field_names, UnionMode::type mode=UnionMode::SPARSE)</argsstring>
        <name>union_</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt;&gt; &amp;</type>
          <declname>children</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>field_names</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dac" kindref="member">UnionMode::type</ref></type>
          <declname>mode</declname>
          <defval><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60" kindref="member">UnionMode::SPARSE</ref></defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_union_type" kindref="compound">UnionType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="374" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="374" bodyend="378"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1gabe1ec5ec1af98b0dc19aee59fdaa442a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::union_</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; Array &gt;&gt; &amp;children, UnionMode::type mode=UnionMode::SPARSE)</argsstring>
        <name>union_</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt;&gt; &amp;</type>
          <declname>children</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dac" kindref="member">UnionMode::type</ref></type>
          <declname>mode</declname>
          <defval><ref refid="structarrow_1_1_union_mode_1a98f368f8fb8a5553a17abc2fb1e76dacaf747592e2e0c52a802406811b95b3a60" kindref="member">UnionMode::SPARSE</ref></defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_union_type" kindref="compound">UnionType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="382" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="382" bodyend="385"/>
      </memberdef>
      <memberdef kind="function" id="group__type-factories_1ga36f61c68b2a04a9d179cb56ff1186c59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
        <definition>std::shared_ptr&lt;DataType&gt; arrow::dictionary</definition>
        <argsstring>(const std::shared_ptr&lt; DataType &gt; &amp;index_type, const std::shared_ptr&lt; DataType &gt; &amp;dict_type, bool ordered=false)</argsstring>
        <name>dictionary</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>index_type</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &amp;</type>
          <declname>dict_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>ordered</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_dictionary_type" kindref="compound">DictionaryType</ref> instance. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">index_type</parametername>
</parameternamelist>
<parameterdescription>
<para>the type of the dictionary indices (must be a signed integer) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dict_type</parametername>
</parameternamelist>
<parameterdescription>
<para>the type of the values in the variable dictionary </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ordered</parametername>
</parameternamelist>
<parameterdescription>
<para>true if the order of the dictionary values has semantic meaning and should be preserved where possible </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="394" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__schema-factories_1gaf9f57798b5abe44d560a52887f28894c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Field&gt; arrow::field</definition>
        <argsstring>(std::string name, std::shared_ptr&lt; DataType &gt; type, bool nullable=true, std::shared_ptr&lt; const KeyValueMetadata &gt; metadata=NULLPTR)</argsstring>
        <name>field</name>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>nullable</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>std::shared_ptr&lt; const <ref refid="classarrow_1_1_key_value_metadata" kindref="compound">KeyValueMetadata</ref> &gt;</type>
          <declname>metadata</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> instance. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>the field name </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>the field value type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nullable</parametername>
</parameternamelist>
<parameterdescription>
<para>whether the values are nullable, default true </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>metadata</parametername>
</parameternamelist>
<parameterdescription>
<para>any custom key-value metadata, default null </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="412" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__schema-factories_1gab03f1059d8776b1e85ee93c7cd03a078" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Schema&gt; arrow::schema</definition>
        <argsstring>(std::vector&lt; std::shared_ptr&lt; Field &gt;&gt; fields, std::shared_ptr&lt; const KeyValueMetadata &gt; metadata=NULLPTR)</argsstring>
        <name>schema</name>
        <param>
          <type>std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &gt;&gt;</type>
          <declname>fields</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; const <ref refid="classarrow_1_1_key_value_metadata" kindref="compound">KeyValueMetadata</ref> &gt;</type>
          <declname>metadata</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> instance. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fields</parametername>
</parameternamelist>
<parameterdescription>
<para>the schema&apos;s fields </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>metadata</parametername>
</parameternamelist>
<parameterdescription>
<para>any custom key-value metadata, default null </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>schema shared_ptr to <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="421" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
        <definition>MemoryPool* arrow::default_memory_pool</definition>
        <argsstring>()</argsstring>
        <name>default_memory_pool</name>
        <briefdescription>
<para>Return the process-wide default memory pool. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_fwd.h" line="428" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a1fe1b39f8d7a021ed54130343aa20441" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_integer</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_integer</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="658" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="658" bodyend="673"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a5ecc3d4fc571c3dad675bf1540f32222" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_floating</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_floating</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="675" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="675" bodyend="685"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a40d4759f1284bd9dc7b716d82cd5d190" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_primitive</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_primitive</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="687" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="687" bodyend="714"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ac0024dc1ae519c2a150c1c3a6d177bc8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_base_binary_like</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_base_binary_like</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="716" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="716" bodyend="727"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a6b2920876a17bc922d4c6feee7c243d7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_binary_like</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_binary_like</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="729" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="729" bodyend="738"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a4f9e09027751067276667f21cbe00e8a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_large_binary_like</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_large_binary_like</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="740" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="740" bodyend="749"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a290e17f5e11d8247f3d760e369ce9d7c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_dictionary</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_dictionary</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="751" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="751" bodyend="753"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a04d52b785d537096cde26ea0aa0793a1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_fixed_size_binary</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_fixed_size_binary</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="755" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="755" bodyend="764"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a6af3d4f147168dcad4b6e582a618fc64" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::is_fixed_width</definition>
        <argsstring>(Type::type type_id)</argsstring>
        <name>is_fixed_width</name>
        <param>
          <type><ref refid="structarrow_1_1_type_1a00a041cb19a3be373da8eec7d4bf1f44" kindref="member">Type::type</ref></type>
          <declname>type_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type_traits.h" line="766" column="1" bodyfile="/arrow/cpp/src/arrow/type_traits.h" bodystart="766" bodyend="768"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1acbf9e156c4a8a01745d20c33a22f1f28" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::operator==</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="155" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ae7e5d5239907d98d4d80c80616f8bee7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::operator!=</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="156" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a193e2bb54c6f5de5e388b2edd534a57c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::operator&lt;</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="157" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1acb54a5f01d82053eb4779c29aabd9a89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::operator&lt;=</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="158" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a80697b084df40ebe8094fee62e8e5192" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::operator&gt;</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="159" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a92b97ff62146c0a0e2aeb702b9fddb77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::operator&gt;=</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator&gt;=</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="160" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a4ae9b9602fea3bcd4bf6d9a45c011f4d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref></type>
        <definition>BasicDecimal128 arrow::operator-</definition>
        <argsstring>(const BasicDecimal128 &amp;operand)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="162" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a7cf501b98a8ee4d346febfa3e96bc8e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref></type>
        <definition>BasicDecimal128 arrow::operator~</definition>
        <argsstring>(const BasicDecimal128 &amp;operand)</argsstring>
        <name>operator~</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>operand</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="163" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ae8e15d3146feab799b2bac1848f2df94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref></type>
        <definition>BasicDecimal128 arrow::operator+</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="164" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ab9f136f8caf36352437cc51b126ad2ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref></type>
        <definition>BasicDecimal128 arrow::operator-</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="166" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ab6773885c4f560a78057a4455d422a7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref></type>
        <definition>BasicDecimal128 arrow::operator*</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="168" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a79a236ea3b1930a4f78adcbdf0832ba8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref></type>
        <definition>BasicDecimal128 arrow::operator/</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator/</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="170" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a52f812806d0a240278b246de398438bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref></type>
        <definition>BasicDecimal128 arrow::operator%</definition>
        <argsstring>(const BasicDecimal128 &amp;left, const BasicDecimal128 &amp;right)</argsstring>
        <name>operator%</name>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_basic_decimal128" kindref="compound">BasicDecimal128</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/basic_decimal.h" line="172" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1acbc24abeb218eea1d217a52c7ed0a4a0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_boundary_finder" kindref="compound">BoundaryFinder</ref> &gt;</type>
        <definition>std::shared_ptr&lt;BoundaryFinder&gt; arrow::MakeNewlineBoundaryFinder</definition>
        <argsstring>()</argsstring>
        <name>MakeNewlineBoundaryFinder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/delimiting.h" line="62" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a1f52379e463af0bd762c960323ba6f2b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::IsFutureFinished</definition>
        <argsstring>(FutureState state)</argsstring>
        <name>IsFutureFinished</name>
        <param>
          <type><ref refid="namespacearrow_1a235876e04ae6167cfde18ad69cf2821a" kindref="member">FutureState</ref></type>
          <declname>state</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="37" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="37" bodyend="37"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a00640e225ff259f4982520b907f8ca6a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool arrow::WaitForAll</definition>
        <argsstring>(const std::vector&lt; Future&lt; T &gt;&gt; &amp;futures, double seconds=FutureWaiter::kInfinity)</argsstring>
        <name>WaitForAll</name>
        <param>
          <type>const std::vector&lt; <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&lt; T &gt;&gt; &amp;</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>double</type>
          <declname>seconds</declname>
          <defval><ref refid="classarrow_1_1_future_waiter_1ae9bf616b6751ab4f0cb84ec0d0894458" kindref="member">FutureWaiter::kInfinity</ref></defval>
        </param>
        <briefdescription>
<para>Wait for all the futures to end, or for the given timeout to expire. </para>        </briefdescription>
        <detaileddescription>
<para><computeroutput>true</computeroutput> is returned if all the futures completed before the timeout was reached, <computeroutput>false</computeroutput> otherwise. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="381" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="381" bodyend="385"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a63fe3a20ec0285cbffe038e142ab3451" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool arrow::WaitForAll</definition>
        <argsstring>(const std::vector&lt; Future&lt; T &gt; *&gt; &amp;futures, double seconds=FutureWaiter::kInfinity)</argsstring>
        <name>WaitForAll</name>
        <param>
          <type>const std::vector&lt; <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&lt; T &gt; *&gt; &amp;</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>double</type>
          <declname>seconds</declname>
          <defval><ref refid="classarrow_1_1_future_waiter_1ae9bf616b6751ab4f0cb84ec0d0894458" kindref="member">FutureWaiter::kInfinity</ref></defval>
        </param>
        <briefdescription>
<para>Wait for all the futures to end, or for the given timeout to expire. </para>        </briefdescription>
        <detaileddescription>
<para><computeroutput>true</computeroutput> is returned if all the futures completed before the timeout was reached, <computeroutput>false</computeroutput> otherwise. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="392" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="392" bodyend="396"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a51d296f6420eb66d3f734f7afceaa563" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; int &gt;</type>
        <definition>std::vector&lt;int&gt; arrow::WaitForAny</definition>
        <argsstring>(const std::vector&lt; Future&lt; T &gt;&gt; &amp;futures, double seconds=FutureWaiter::kInfinity)</argsstring>
        <name>WaitForAny</name>
        <param>
          <type>const std::vector&lt; <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&lt; T &gt;&gt; &amp;</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>double</type>
          <declname>seconds</declname>
          <defval><ref refid="classarrow_1_1_future_waiter_1ae9bf616b6751ab4f0cb84ec0d0894458" kindref="member">FutureWaiter::kInfinity</ref></defval>
        </param>
        <briefdescription>
<para>Wait for one of the futures to end, or for the given timeout to expire. </para>        </briefdescription>
        <detaileddescription>
<para>The indices of all completed futures are returned. Note that some futures may not be in the returned set, but still complete concurrently. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="403" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="403" bodyend="408"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a8a7cfda6170118560ee19e8d6bbdd599" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; int &gt;</type>
        <definition>std::vector&lt;int&gt; arrow::WaitForAny</definition>
        <argsstring>(const std::vector&lt; Future&lt; T &gt; *&gt; &amp;futures, double seconds=FutureWaiter::kInfinity)</argsstring>
        <name>WaitForAny</name>
        <param>
          <type>const std::vector&lt; <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&lt; T &gt; *&gt; &amp;</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>double</type>
          <declname>seconds</declname>
          <defval><ref refid="classarrow_1_1_future_waiter_1ae9bf616b6751ab4f0cb84ec0d0894458" kindref="member">FutureWaiter::kInfinity</ref></defval>
        </param>
        <briefdescription>
<para>Wait for one of the futures to end, or for the given timeout to expire. </para>        </briefdescription>
        <detaileddescription>
<para>The indices of all completed futures are returned. Note that some futures may not be in the returned set, but still complete concurrently. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="415" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="415" bodyend="420"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a39ab99e5d4ce3d698c2bea62593423b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; T &gt;</type>
        <definition>Iterator&lt;T&gt; arrow::MakeAsCompletedIterator</definition>
        <argsstring>(std::vector&lt; Future&lt; T &gt;&gt; futures)</argsstring>
        <name>MakeAsCompletedIterator</name>
        <param>
          <type>std::vector&lt; <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&lt; T &gt;&gt;</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future_iterator.h" line="71" column="1" bodyfile="/arrow/cpp/src/arrow/util/future_iterator.h" bodystart="71" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1afbe9311bc4b5b80d1cc42102bb1542ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Fn</type>
          </param>
          <param>
            <type>typename Ret</type>
            <defval>typename internal::call_traits::return_type&lt;Fn&gt;::ValueType</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; Ret &gt;</type>
        <definition>Iterator&lt;Ret&gt; arrow::MakeFunctionIterator</definition>
        <argsstring>(Fn fn)</argsstring>
        <name>MakeFunctionIterator</name>
        <param>
          <type>Fn</type>
          <declname>fn</declname>
        </param>
        <briefdescription>
<para>Construct an <ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref> which invokes a callable on Next() </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="209" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="209" bodyend="211"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ac88b501daab08dda0e148de95dd68d94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; T &gt;</type>
        <definition>Iterator&lt;T&gt; arrow::MakeEmptyIterator</definition>
        <argsstring>()</argsstring>
        <name>MakeEmptyIterator</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="214" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="214" bodyend="216"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ab926f5eb39c55824dd5a7cf146ca867e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; T &gt;</type>
        <definition>Iterator&lt;T&gt; arrow::MakeErrorIterator</definition>
        <argsstring>(Status s)</argsstring>
        <name>MakeErrorIterator</name>
        <param>
          <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="219" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="219" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a260d67d2d8f74d6bef570dc730982fee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; T &gt;</type>
        <definition>Iterator&lt;T&gt; arrow::MakeVectorIterator</definition>
        <argsstring>(std::vector&lt; T &gt; v)</argsstring>
        <name>MakeVectorIterator</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="245" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="245" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a34c8b32dbbc2e7415d1e286ca132c006" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; <ref refid="namespacearrow_1_1util_1a37597d23d580458d4547f817e2943744" kindref="member">util::optional</ref>&lt; T &gt; &gt;</type>
        <definition>Iterator&lt;util::optional&lt;T&gt; &gt; arrow::MakeVectorOptionalIterator</definition>
        <argsstring>(std::vector&lt; T &gt; v)</argsstring>
        <name>MakeVectorOptionalIterator</name>
        <param>
          <type>std::vector&lt; T &gt;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="269" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="269" bodyend="271"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a0739021d27a4ce9b060cd1d0fb537821" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Fn</type>
          </param>
          <param>
            <type>typename From</type>
            <defval>internal::call_traits::argument_type&lt;0, Fn&gt;</defval>
          </param>
          <param>
            <type>typename To</type>
            <defval>internal::call_traits::return_type&lt;Fn&gt;</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; To &gt;</type>
        <definition>Iterator&lt;To&gt; arrow::MakeMapIterator</definition>
        <argsstring>(Fn map, Iterator&lt; From &gt; it)</argsstring>
        <name>MakeMapIterator</name>
        <param>
          <type>Fn</type>
          <declname>map</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; From &gt;</type>
          <declname>it</declname>
        </param>
        <briefdescription>
<para><ref refid="classarrow_1_1_map_iterator" kindref="compound">MapIterator</ref> takes ownership of an iterator and a function to apply on every element. </para>        </briefdescription>
        <detaileddescription>
<para>The mapped function is not allowed to fail. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="300" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="300" bodyend="302"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a91b921bf603b379a7e9a25236ec3fe79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Fn</type>
          </param>
          <param>
            <type>typename From</type>
            <defval>internal::call_traits::argument_type&lt;0, Fn&gt;</defval>
          </param>
          <param>
            <type>typename To</type>
            <defval>typename internal::call_traits::return_type&lt;Fn&gt;::ValueType</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; To &gt;</type>
        <definition>Iterator&lt;To&gt; arrow::MakeMaybeMapIterator</definition>
        <argsstring>(Fn map, Iterator&lt; From &gt; it)</argsstring>
        <name>MakeMaybeMapIterator</name>
        <param>
          <type>Fn</type>
          <declname>map</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; From &gt;</type>
          <declname>it</declname>
        </param>
        <briefdescription>
<para>Like <ref refid="classarrow_1_1_map_iterator" kindref="compound">MapIterator</ref>, but where the function can fail. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="307" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="307" bodyend="309"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a62c38fa56ca1c43c4b0a2acd98de9624" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Fn</type>
          </param>
          <param>
            <type>typename From</type>
            <defval>typename internal::call_traits::argument_type&lt;0, Fn&gt;</defval>
          </param>
          <param>
            <type>typename Ret</type>
            <defval>typename internal::call_traits::return_type&lt;Fn&gt;::ValueType</defval>
          </param>
          <param>
            <type>typename To</type>
            <defval>typename std::tuple_element&lt;0, Ret&gt;::type</defval>
          </param>
          <param>
            <type>typename Enable</type>
            <defval>typename std::enable_if&lt;std::is_same&lt;        typename std::tuple_element&lt;1, Ret&gt;::type, FilterIterator::Action&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; To &gt;</type>
        <definition>Iterator&lt;To&gt; arrow::MakeFilterIterator</definition>
        <argsstring>(Fn filter, Iterator&lt; From &gt; it)</argsstring>
        <name>MakeFilterIterator</name>
        <param>
          <type>Fn</type>
          <declname>filter</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; From &gt;</type>
          <declname>it</declname>
        </param>
        <briefdescription>
<para>Like <ref refid="classarrow_1_1_map_iterator" kindref="compound">MapIterator</ref>, but where the function can fail or reject elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="369" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="369" bodyend="372"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a6975d6cac55ba9bd6b286030381b862c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; T &gt;</type>
        <definition>Iterator&lt;T&gt; arrow::MakeFlattenIterator</definition>
        <argsstring>(Iterator&lt; Iterator&lt; T &gt;&gt; it)</argsstring>
        <name>MakeFlattenIterator</name>
        <param>
          <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; <ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; T &gt;&gt;</type>
          <declname>it</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="412" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="412" bodyend="414"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a664b7dc6954a6f27fc0e3b1ea4db551d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; <ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; T &gt; &gt;</type>
        <definition>Result&lt;Iterator&lt;T&gt; &gt; arrow::MakeReadaheadIterator</definition>
        <argsstring>(Iterator&lt; T &gt; it, int readahead_queue_size)</argsstring>
        <name>MakeReadaheadIterator</name>
        <param>
          <type><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref>&lt; T &gt;</type>
          <declname>it</declname>
        </param>
        <param>
          <type>int</type>
          <declname>readahead_queue_size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="525" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="525" bodyend="527"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ae2b06732381cac7996882e17c245290a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_key_value_metadata" kindref="compound">KeyValueMetadata</ref> &gt;</type>
        <definition>std::shared_ptr&lt;KeyValueMetadata&gt; arrow::key_value_metadata</definition>
        <argsstring>(const std::unordered_map&lt; std::string, std::string &gt; &amp;pairs)</argsstring>
        <name>key_value_metadata</name>
        <param>
          <type>const std::unordered_map&lt; std::string, std::string &gt; &amp;</type>
          <declname>pairs</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_key_value_metadata" kindref="compound">KeyValueMetadata</ref> instance. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pairs</parametername>
</parameternamelist>
<parameterdescription>
<para>key-value mapping </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/key_value_metadata.h" line="81" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ac2f2336c1ffb0cbf4476ef35df473ea2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_key_value_metadata" kindref="compound">KeyValueMetadata</ref> &gt;</type>
        <definition>std::shared_ptr&lt;KeyValueMetadata&gt; arrow::key_value_metadata</definition>
        <argsstring>(std::vector&lt; std::string &gt; keys, std::vector&lt; std::string &gt; values)</argsstring>
        <name>key_value_metadata</name>
        <param>
          <type>std::vector&lt; std::string &gt;</type>
          <declname>keys</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
<para>Create a <ref refid="classarrow_1_1_key_value_metadata" kindref="compound">KeyValueMetadata</ref> instance. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>keys</parametername>
</parameternamelist>
<parameterdescription>
<para>sequence of metadata keys </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>values</parametername>
</parameternamelist>
<parameterdescription>
<para>sequence of corresponding metadata values </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/key_value_metadata.h" line="88" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a2cc96e2a2b4dca763befd1d172134ac2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string arrow::HexEncode</definition>
        <argsstring>(const uint8_t *data, size_t length)</argsstring>
        <name>HexEncode</name>
        <param>
          <type>const uint8_t *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/string.h" line="30" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1af0898d30c6a1068bbfc1ccf9064aa8ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string arrow::Escape</definition>
        <argsstring>(const char *data, size_t length)</argsstring>
        <name>Escape</name>
        <param>
          <type>const char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/string.h" line="32" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a98ac42e0d52b7800aafbbbcf2587b5d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string arrow::HexEncode</definition>
        <argsstring>(const char *data, size_t length)</argsstring>
        <name>HexEncode</name>
        <param>
          <type>const char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/string.h" line="34" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ad3c7f8cdc8482addd98d3066653080d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string arrow::HexEncode</definition>
        <argsstring>(util::string_view str)</argsstring>
        <name>HexEncode</name>
        <param>
          <type>util::string_view</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/string.h" line="36" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ad438db68959b2071de6b71a919316da0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string arrow::Escape</definition>
        <argsstring>(util::string_view str)</argsstring>
        <name>Escape</name>
        <param>
          <type>util::string_view</type>
          <declname>str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/string.h" line="38" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a5b66debdce0800121a0b573cb4f51344" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ParseHexValue</definition>
        <argsstring>(const char *data, uint8_t *out)</argsstring>
        <name>ParseHexValue</name>
        <param>
          <type>const char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>uint8_t *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/string.h" line="40" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a187c243ea680906ebe9d2c20ab311940" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int arrow::GetCpuThreadPoolCapacity</definition>
        <argsstring>()</argsstring>
        <name>GetCpuThreadPoolCapacity</name>
        <briefdescription>
<para>Get the capacity of the global thread pool. </para>        </briefdescription>
        <detaileddescription>
<para>Return the number of worker threads in the thread pool to which Arrow dispatches various CPU-bound tasks. This is an ideal number, not necessarily the exact number of threads at a given point in time.</para><para>You can change this number using <ref refid="namespacearrow_1aa103995039a823ac5ce376994562f06d" kindref="member">SetCpuThreadPoolCapacity()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/thread_pool.h" line="51" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1aa103995039a823ac5ce376994562f06d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::SetCpuThreadPoolCapacity</definition>
        <argsstring>(int threads)</argsstring>
        <name>SetCpuThreadPoolCapacity</name>
        <param>
          <type>int</type>
          <declname>threads</declname>
        </param>
        <briefdescription>
<para>Set the capacity of the global thread pool. </para>        </briefdescription>
        <detaileddescription>
<para>Set the number of worker threads int the thread pool to which Arrow dispatches various CPU-bound tasks.</para><para>The current number is returned by <ref refid="namespacearrow_1a187c243ea680906ebe9d2c20ab311940" kindref="member">GetCpuThreadPoolCapacity()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/thread_pool.h" line="59" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a431bd46d978673b1b00afc3049776c49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VISITOR</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::VisitTypeInline</definition>
        <argsstring>(const DataType &amp;type, VISITOR *visitor)</argsstring>
        <name>VisitTypeInline</name>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>VISITOR *</type>
          <declname>visitor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/visitor_inline.h" line="83" column="1" bodyfile="/arrow/cpp/src/arrow/visitor_inline.h" bodystart="83" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a2f912387c238cd2feef3c242c0647d2b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VISITOR</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::VisitArrayInline</definition>
        <argsstring>(const Array &amp;array, VISITOR *visitor)</argsstring>
        <name>VisitArrayInline</name>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>array</declname>
        </param>
        <param>
          <type>VISITOR *</type>
          <declname>visitor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/visitor_inline.h" line="111" column="1" bodyfile="/arrow/cpp/src/arrow/visitor_inline.h" bodystart="111" bodyend="129"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ab4b3c91dfc7add7c20e0dcfbb8fe25db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename VisitFunc</type>
          </param>
        </templateparamlist>
        <type>internal::call_traits::enable_if_return&lt; VisitFunc, <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> &gt;::type</type>
        <definition>internal::call_traits::enable_if_return&lt;VisitFunc, Status&gt;::type arrow::VisitArrayDataInline</definition>
        <argsstring>(const ArrayData &amp;arr, VisitFunc &amp;&amp;func)</argsstring>
        <name>VisitArrayDataInline</name>
        <param>
          <type>const <ref refid="structarrow_1_1_array_data" kindref="compound">ArrayData</ref> &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>VisitFunc &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/visitor_inline.h" line="408" column="1" bodyfile="/arrow/cpp/src/arrow/visitor_inline.h" bodystart="408" bodyend="411"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a66beb93f9f98c00347447ad37eaae535" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename VisitFunc</type>
          </param>
        </templateparamlist>
        <type>internal::call_traits::enable_if_return&lt; VisitFunc, void &gt;::type</type>
        <definition>internal::call_traits::enable_if_return&lt;VisitFunc, void&gt;::type arrow::VisitArrayDataInline</definition>
        <argsstring>(const ArrayData &amp;arr, VisitFunc &amp;&amp;func)</argsstring>
        <name>VisitArrayDataInline</name>
        <param>
          <type>const <ref refid="structarrow_1_1_array_data" kindref="compound">ArrayData</ref> &amp;</type>
          <declname>arr</declname>
        </param>
        <param>
          <type>VisitFunc &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/visitor_inline.h" line="415" column="1" bodyfile="/arrow/cpp/src/arrow/visitor_inline.h" bodystart="415" bodyend="418"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a511650783e127b8c2acb1326b9b94e7a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VISITOR</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::VisitScalarInline</definition>
        <argsstring>(const Scalar &amp;scalar, VISITOR *visitor)</argsstring>
        <name>VisitScalarInline</name>
        <param>
          <type>const <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &amp;</type>
          <declname>scalar</declname>
        </param>
        <param>
          <type>VISITOR *</type>
          <declname>visitor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/visitor_inline.h" line="454" column="1" bodyfile="/arrow/cpp/src/arrow/visitor_inline.h" bodystart="454" bodyend="473"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1a584027e59cc605219695aaadf50ed2df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VisitFunc</type>
          </param>
        </templateparamlist>
        <type>internal::call_traits::enable_if_return&lt; VisitFunc, <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> &gt;::type</type>
        <definition>internal::call_traits::enable_if_return&lt;VisitFunc, Status&gt;::type arrow::VisitNullBitmapInline</definition>
        <argsstring>(const uint8_t *valid_bits, int64_t valid_bits_offset, int64_t num_values, int64_t null_count, VisitFunc &amp;&amp;func)</argsstring>
        <name>VisitNullBitmapInline</name>
        <param>
          <type>const uint8_t *</type>
          <declname>valid_bits</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>valid_bits_offset</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>num_values</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>null_count</declname>
        </param>
        <param>
          <type>VisitFunc &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/visitor_inline.h" line="485" column="1" bodyfile="/arrow/cpp/src/arrow/visitor_inline.h" bodystart="485" bodyend="499"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1ad71c7a67f4fdbcc165276f04d955e5ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VisitFunc</type>
          </param>
        </templateparamlist>
        <type>internal::call_traits::enable_if_return&lt; VisitFunc, void &gt;::type</type>
        <definition>internal::call_traits::enable_if_return&lt;VisitFunc, void&gt;::type arrow::VisitNullBitmapInline</definition>
        <argsstring>(const uint8_t *valid_bits, int64_t valid_bits_offset, int64_t num_values, int64_t null_count, VisitFunc &amp;&amp;func)</argsstring>
        <name>VisitNullBitmapInline</name>
        <param>
          <type>const uint8_t *</type>
          <declname>valid_bits</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>valid_bits_offset</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>num_values</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>null_count</declname>
        </param>
        <param>
          <type>VisitFunc &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/visitor_inline.h" line="503" column="1" bodyfile="/arrow/cpp/src/arrow/visitor_inline.h" bodystart="503" bodyend="516"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Top-level namespace for Apache Arrow C++ API. </para>    </briefdescription>
    <detaileddescription>
<para>Server-side APIs to implement authentication for Flight.</para><para>Implementation of Flight RPC client using gRPC. API should be.</para><para>User-defined extension types.</para><para>Logic for automatically determining the structure of multi-file dataset with possible partitioning according to available partitioning.</para><para>EXPERIMENTAL in 0.13.0 <simplesect kind="since"><para>0.13.0 </para></simplesect>
</para>    </detaileddescription>
    <location file="/arrow/cpp/src/arrow/adapters/orc/adapter.h" line="31" column="1"/>
  </compounddef>
</doxygen>
