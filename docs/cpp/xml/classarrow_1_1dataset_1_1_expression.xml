<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1dataset_1_1_expression" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>arrow::dataset::Expression</compoundname>
    <derivedcompoundref refid="classarrow_1_1dataset_1_1_binary_expression" prot="public" virt="non-virtual">arrow::dataset::BinaryExpression</derivedcompoundref>
    <derivedcompoundref refid="classarrow_1_1dataset_1_1_custom_expression" prot="public" virt="non-virtual">arrow::dataset::CustomExpression</derivedcompoundref>
    <derivedcompoundref refid="classarrow_1_1dataset_1_1_field_expression" prot="public" virt="non-virtual">arrow::dataset::FieldExpression</derivedcompoundref>
    <derivedcompoundref refid="classarrow_1_1dataset_1_1_scalar_expression" prot="public" virt="non-virtual">arrow::dataset::ScalarExpression</derivedcompoundref>
    <derivedcompoundref refid="classarrow_1_1dataset_1_1_unary_expression" prot="public" virt="non-virtual">arrow::dataset::UnaryExpression</derivedcompoundref>
    <includes refid="arrow_2dataset_2filter_8h" local="no">arrow/dataset/filter.h</includes>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classarrow_1_1dataset_1_1_expression_1a4f70ea37a6b7d7e542b1d806e65305f4" prot="protected" static="no" mutable="no">
        <type><ref refid="structarrow_1_1dataset_1_1_expression_type_1aa055f8b51338c1fa7f7dda520053b4d5" kindref="member">ExpressionType::type</ref></type>
        <definition>ExpressionType::type arrow::dataset::Expression::type_</definition>
        <argsstring></argsstring>
        <name>type_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="209" column="1" bodyfile="/arrow/cpp/src/arrow/dataset/filter.h" bodystart="209" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1ace247255d88029192703e49bcb468c7a" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::dataset::Expression::Expression</definition>
        <argsstring>(ExpressionType::type type)</argsstring>
        <name>Expression</name>
        <param>
          <type><ref refid="structarrow_1_1dataset_1_1_expression_type_1aa055f8b51338c1fa7f7dda520053b4d5" kindref="member">ExpressionType::type</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="85" column="1" bodyfile="/arrow/cpp/src/arrow/dataset/filter.h" bodystart="85" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1aeadfb3da0cb488e984d342be1ed9ae36" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual arrow::dataset::Expression::~Expression</definition>
        <argsstring>()=default</argsstring>
        <name>~Expression</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="87" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1a8c952a05b1090e1ec15adbe7ed712ea6" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>bool</type>
        <definition>virtual bool arrow::dataset::Expression::Equals</definition>
        <argsstring>(const Expression &amp;other) const =0</argsstring>
        <name>Equals</name>
        <reimplementedby refid="classarrow_1_1dataset_1_1_unary_expression_1a5781cb87864a15770ba7fd4b23c7bf5b">Equals</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_binary_expression_1a502e2a91f6c0e6aa61f450fd0e914117">Equals</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_comparison_expression_1ad8705821278fadf57533d601970bb710">Equals</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_scalar_expression_1a9fa18fb3f05a4fa28c3a29db1e20514c">Equals</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_field_expression_1ad6071bd8d7747d7d33f2a135d403fc70">Equals</reimplementedby>
        <param>
          <type>const <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Returns true iff the expressions are identical; does not check for equivalence. </para>        </briefdescription>
        <detaileddescription>
<para>For example, (A and B) is not equal to (B and A) nor is (A and not A) equal to (false). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="92" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1a2080b195e1999f973c7ceb7e0978a13e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::dataset::Expression::Equals</definition>
        <argsstring>(const std::shared_ptr&lt; Expression &gt; &amp;other) const</argsstring>
        <name>Equals</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &gt; &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="94" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1a55f49c9a8081e757c4d399073785f171" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Enable</type>
            <defval>decltype(<ref refid="namespacearrow_1a5902391d987b8f930a8d3898813d91d9" kindref="member">MakeScalar</ref>(std::declval&lt;T&gt;()))</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool arrow::dataset::Expression::Equals</definition>
        <argsstring>(T &amp;&amp;t) const</argsstring>
        <name>Equals</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Overload for the common case of checking for equality to a specific scalar. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="98" column="1" bodyfile="/arrow/cpp/src/arrow/dataset/filter.h" bodystart="505" bodyend="511"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1a8e5d308f61bdb2ec2074b662ea33f760" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::dataset::Expression::IsNull</definition>
        <argsstring>() const</argsstring>
        <name>IsNull</name>
        <briefdescription>
<para>If true, this <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> is a <ref refid="classarrow_1_1dataset_1_1_scalar_expression" kindref="compound">ScalarExpression</ref> wrapping a null scalar. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="101" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1a1073c67366c820875c3825e867419050" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &gt;</type>
        <definition>virtual Result&lt;std::shared_ptr&lt;DataType&gt; &gt; arrow::dataset::Expression::Validate</definition>
        <argsstring>(const Schema &amp;schema) const =0</argsstring>
        <name>Validate</name>
        <reimplementedby refid="classarrow_1_1dataset_1_1_comparison_expression_1a1e11d7629bf57719dbd3ec26fc97c6e9">Validate</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_and_expression_1a47e66fb78bd4e72211cf628bc272c333">Validate</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_or_expression_1a359f4524a454a1191986c54165e9438d">Validate</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_not_expression_1a522f9f8abdc0393ce60803e70117d6a5">Validate</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_is_valid_expression_1aab5fbdcac2dcfd41a1aab46625bccebf">Validate</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_in_expression_1a817e1de48eab774117aef2a3c8fab693">Validate</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_cast_expression_1a9e12a6b26c33b2d8e560e8ecd2ec1ec9">Validate</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_scalar_expression_1a7303c16da3123ee96085fc29a12e1244">Validate</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_field_expression_1ae3c0c467490c9a5428b52279cab501fd">Validate</reimplementedby>
        <param>
          <type>const <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>schema</declname>
        </param>
        <briefdescription>
<para>Validate this expression for execution against a schema. </para>        </briefdescription>
        <detaileddescription>
<para>This will check that all reference fields are present (fields not in the schema will be replaced with null) and all subexpressions are executable. Returns the type to which this expression will evaluate. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="107" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1a5cf8311867209fd28af7f0fdf6b26b33" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &gt;</type>
        <definition>virtual std::shared_ptr&lt;Expression&gt; arrow::dataset::Expression::Assume</definition>
        <argsstring>(const Expression &amp;given) const</argsstring>
        <name>Assume</name>
        <reimplementedby refid="classarrow_1_1dataset_1_1_comparison_expression_1a3414ab1b56fbb8c25bd79bc22e4a7ae6">Assume</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_and_expression_1a207f428a3d8b05161469e30daa2c4750">Assume</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_or_expression_1a571fd457bca2d81b302427d5a641c13d">Assume</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_not_expression_1a7a6fc4ee6b7d09b59a5e9bd37bccb7b7">Assume</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_is_valid_expression_1a68cc36296e26491ae9b4cdde347a2794">Assume</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_in_expression_1accf3ab14e766a02bb4de69fc16bfb78f">Assume</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_cast_expression_1a4b831d793a60be2707d5f3c336c45f76">Assume</reimplementedby>
        <param>
          <type>const <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &amp;</type>
          <declname>given</declname>
        </param>
        <briefdescription>
<para>Simplify to an equivalent <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> given assumed constraints on input. </para>        </briefdescription>
        <detaileddescription>
<para>This can be used to do less filtering work using predicate push down.</para><para>Both expressions must pass validation against a schema before Assume may be used.</para><para>Two expressions can be considered equivalent for a given subset of possible inputs if they yield identical results. Formally, if given.Evaluate(input).Equals(input) then Assume guarantees that: expr.Assume(given).Evaluate(input).Equals(expr.Evaluate(input))</para><para>For example if we are given that all inputs will satisfy (&quot;a&quot;_ == 1) then the expression (&quot;a&quot;_ &gt; 0 and &quot;b&quot;_ &gt; 0) is equivalent to (&quot;b&quot;_ &gt; 0). It is impossible that the comparison (&quot;a&quot;_ &gt; 0) will evaluate false given (&quot;a&quot;_ == 1), so both expressions will yield identical results. Thus we can write: (&quot;a&quot;_ &gt; 0 and &quot;b&quot;_ &gt; 0).Assume(&quot;a&quot;_ == 1).Equals(&quot;b&quot;_ &gt; 0)</para><para>filter.Assume(partition) is trivial if filter and partition are disjoint or if partition is a subset of filter. FIXME(bkietz) write this better<itemizedlist>
<listitem><para>If the two are disjoint, then (false) may be substituted for filter.</para></listitem><listitem><para>If partition is a subset of filter then (true) may be substituted for filter.</para></listitem></itemizedlist>
</para><para>filter.Assume(partition) is straightforward if both filter and partition are simple comparisons.<itemizedlist>
<listitem><para>filter may be a superset of partition, in which case the filter is satisfied by all inputs: (&quot;a&quot;_ &gt; 0).Assume(&quot;a&quot;_ == 1).Equals(true)</para></listitem><listitem><para>filter may be disjoint with partition, in which case there are no inputs which satisfy filter: (&quot;a&quot;_ &lt; 0).Assume(&quot;a&quot;_ == 1).Equals(false)</para></listitem><listitem><para>If neither of these is the case, partition provides no information which can simplify filter: (&quot;a&quot;_ == 1).Assume(&quot;a&quot;_ &gt; 0).Equals(&quot;a&quot;_ == 1) (&quot;a&quot;_ == 1).Assume(&quot;b&quot;_ == 1).Equals(&quot;a&quot;_ == 1)</para></listitem></itemizedlist>
</para><para>If filter is compound, Assume can be distributed across the boolean operator. To prove this is valid, we again demonstrate that the simplified expression will yield identical results. For conjunction of filters lhs and rhs: (lhs.Assume(p) and rhs.Assume(p)).Evaluate(input) == Intersection(lhs.Assume(p).Evaluate(input), rhs.Assume(p).Evaluate(input)) == Intersection(lhs.Evaluate(input), rhs.Evaluate(input)) == (lhs and rhs).Evaluate(input)<itemizedlist>
<listitem><para>The proof for disjunction is symmetric; just replace Intersection with Union. Thus we can write: (lhs and rhs).Assume(p).Equals(lhs.Assume(p) and rhs.Assume(p)) (lhs or rhs).Assume(p).Equals(lhs.Assume(p) or rhs.Assume(p))</para></listitem><listitem><para>For negation: (not e.Assume(p)).Evaluate(input) == Difference(input, e.Assume(p).Evaluate(input)) == Difference(input, e.Evaluate(input)) == (not e).Evaluate(input)</para></listitem><listitem><para>Thus we can write: (not e).Assume(p).Equals(not e.Assume(p))</para></listitem></itemizedlist>
</para><para>If the partition expression is a conjunction then each of its subexpressions is true for all input and can be used independently: filter.Assume(lhs).Assume(rhs).Evaluate(input) == filter.Assume(lhs).Evaluate(input) == filter.Evaluate(input)<itemizedlist>
<listitem><para>Thus we can write: filter.Assume(lhs and rhs).Equals(filter.Assume(lhs).Assume(rhs))</para></listitem></itemizedlist>
</para><para>FIXME(bkietz) disjunction proof filter.Assume(lhs or rhs).Equals(filter.Assume(lhs) and filter.Assume(rhs))<itemizedlist>
<listitem><para>This may not result in a simpler expression so it is only used when filter.Assume(lhs).Equals(filter.Assume(rhs))</para></listitem></itemizedlist>
</para><para>If the partition expression is a negation then we can use the above relations by replacing comparisons with their complements and using the properties: (not (a and b)).Equals(not a or not b) (not (a or b)).Equals(not a and not b) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="180" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1aa94bb5128873b3955ef1079dbfa59a05" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Expression&gt; arrow::dataset::Expression::Assume</definition>
        <argsstring>(const std::shared_ptr&lt; Expression &gt; &amp;given) const</argsstring>
        <name>Assume</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &gt; &amp;</type>
          <declname>given</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="182" column="1" bodyfile="/arrow/cpp/src/arrow/dataset/filter.h" bodystart="182" bodyend="184"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1acd37d50f9235db97d98299dedde5deb8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>std::string</type>
        <definition>virtual std::string arrow::dataset::Expression::ToString</definition>
        <argsstring>() const =0</argsstring>
        <name>ToString</name>
        <reimplementedby refid="classarrow_1_1dataset_1_1_comparison_expression_1afb54c43e6ed0005e345651eac188fbd7">ToString</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_and_expression_1aa42e76ceec3797cc26cc791d94f04414">ToString</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_or_expression_1a563d79e10c50d6028c3e661d3eb1b0db">ToString</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_not_expression_1a745c7fec120d79fce049d42270c1b60a">ToString</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_is_valid_expression_1ae9268702c95414fba541ab57f0f8cc07">ToString</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_in_expression_1a1c314782ec9e4682e7b2f710e50078fe">ToString</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_cast_expression_1a8f17eb2e0e2fee7a734503097dbc0475">ToString</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_scalar_expression_1ab720167a80c6244bfa84e1cf30f213d8">ToString</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_field_expression_1afb489412780876ed217cf6a81ff256cb">ToString</reimplementedby>
        <briefdescription>
<para>returns a debug string representing this expression </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="187" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1a26c748fc0b8eb3ffa800bd957a019d39" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structarrow_1_1dataset_1_1_expression_type_1aa055f8b51338c1fa7f7dda520053b4d5" kindref="member">ExpressionType::type</ref></type>
        <definition>ExpressionType::type arrow::dataset::Expression::type</definition>
        <argsstring>() const</argsstring>
        <name>type</name>
        <briefdescription>
<para>Return the expression&apos;s type identifier. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="190" column="1" bodyfile="/arrow/cpp/src/arrow/dataset/filter.h" bodystart="190" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1ab4baacac016afb9b00f41113dd05f602" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &gt;</type>
        <definition>virtual std::shared_ptr&lt;Expression&gt; arrow::dataset::Expression::Copy</definition>
        <argsstring>() const =0</argsstring>
        <name>Copy</name>
        <reimplementedby refid="classarrow_1_1dataset_1_1_expression_impl_1a6efe2a97203c4253061884774b261fa7">Copy</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_expression_impl_1a6efe2a97203c4253061884774b261fa7">Copy</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_expression_impl_1a6efe2a97203c4253061884774b261fa7">Copy</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_expression_impl_1a6efe2a97203c4253061884774b261fa7">Copy</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_expression_impl_1a6efe2a97203c4253061884774b261fa7">Copy</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_expression_impl_1a6efe2a97203c4253061884774b261fa7">Copy</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_expression_impl_1a6efe2a97203c4253061884774b261fa7">Copy</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_scalar_expression_1aac62a4bc3d38d8082b4aa8f61b216664">Copy</reimplementedby>
        <reimplementedby refid="classarrow_1_1dataset_1_1_field_expression_1a8f1b716f7818cbd3220c439a2e79c29a">Copy</reimplementedby>
        <briefdescription>
<para>Copy this expression into a shared pointer. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="193" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1a5ce811a47927451199574abff5bab72a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1dataset_1_1_in_expression" kindref="compound">InExpression</ref></type>
        <definition>InExpression arrow::dataset::Expression::In</definition>
        <argsstring>(std::shared_ptr&lt; Array &gt; set) const</argsstring>
        <name>In</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt;</type>
          <declname>set</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="195" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1ac665b2a07ec4247f0af1ada25340a294" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1dataset_1_1_is_valid_expression" kindref="compound">IsValidExpression</ref></type>
        <definition>IsValidExpression arrow::dataset::Expression::IsValid</definition>
        <argsstring>() const</argsstring>
        <name>IsValid</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="197" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1a67c73de7e4be70d94decb62d73d9679f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1dataset_1_1_cast_expression" kindref="compound">CastExpression</ref></type>
        <definition>CastExpression arrow::dataset::Expression::CastTo</definition>
        <argsstring>(std::shared_ptr&lt; DataType &gt; type, compute::CastOptions options=compute::CastOptions()) const</argsstring>
        <name>CastTo</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
          <declname>type</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">compute::CastOptions</ref></type>
          <declname>options</declname>
          <defval><ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">compute::CastOptions</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="199" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1aa3b8f7274bf46ffb4c9d63c54182eed3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1dataset_1_1_cast_expression" kindref="compound">CastExpression</ref></type>
        <definition>CastExpression arrow::dataset::Expression::CastLike</definition>
        <argsstring>(const Expression &amp;expr, compute::CastOptions options=compute::CastOptions()) const</argsstring>
        <name>CastLike</name>
        <param>
          <type>const <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &amp;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">compute::CastOptions</ref></type>
          <declname>options</declname>
          <defval><ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">compute::CastOptions</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="202" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_expression_1ab93e79be7899dc8a3aa063d92748d6d1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1dataset_1_1_cast_expression" kindref="compound">CastExpression</ref></type>
        <definition>CastExpression arrow::dataset::Expression::CastLike</definition>
        <argsstring>(std::shared_ptr&lt; Expression &gt; expr, compute::CastOptions options=compute::CastOptions()) const</argsstring>
        <name>CastLike</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &gt;</type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">compute::CastOptions</ref></type>
          <declname>options</declname>
          <defval><ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">compute::CastOptions</ref>()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="205" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Represents an expression tree. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="1465">
        <label>arrow::dataset::BinaryExpression</label>
        <link refid="classarrow_1_1dataset_1_1_binary_expression"/>
        <childnode refid="1464" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1479">
        <label>arrow::dataset::InExpression</label>
        <link refid="classarrow_1_1dataset_1_1_in_expression"/>
        <childnode refid="1478" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1470">
        <label>arrow::dataset::ExpressionImpl&lt; BinaryExpression, OrExpression, ExpressionType::OR &gt;</label>
        <link refid="classarrow_1_1dataset_1_1_expression_impl"/>
        <childnode refid="1465" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1468">
        <label>arrow::dataset::ExpressionImpl&lt; BinaryExpression, ComparisonExpression, ExpressionType::COMPARISON &gt;</label>
        <link refid="classarrow_1_1dataset_1_1_expression_impl"/>
        <childnode refid="1465" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1466">
        <label>arrow::dataset::ExpressionImpl&lt; BinaryExpression, AndExpression, ExpressionType::AND &gt;</label>
        <link refid="classarrow_1_1dataset_1_1_expression_impl"/>
        <childnode refid="1465" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1471">
        <label>arrow::dataset::OrExpression</label>
        <link refid="classarrow_1_1dataset_1_1_or_expression"/>
        <childnode refid="1470" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1475">
        <label>arrow::dataset::UnaryExpression</label>
        <link refid="classarrow_1_1dataset_1_1_unary_expression"/>
        <childnode refid="1464" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1474">
        <label>arrow::dataset::ScalarExpression</label>
        <link refid="classarrow_1_1dataset_1_1_scalar_expression"/>
        <childnode refid="1464" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1481">
        <label>arrow::dataset::IsValidExpression</label>
        <link refid="classarrow_1_1dataset_1_1_is_valid_expression"/>
        <childnode refid="1480" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1472">
        <label>arrow::dataset::CustomExpression</label>
        <link refid="classarrow_1_1dataset_1_1_custom_expression"/>
        <childnode refid="1464" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1480">
        <label>arrow::dataset::ExpressionImpl&lt; UnaryExpression, IsValidExpression, ExpressionType::IS_VALID &gt;</label>
        <link refid="classarrow_1_1dataset_1_1_expression_impl"/>
        <childnode refid="1475" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1477">
        <label>arrow::dataset::CastExpression</label>
        <link refid="classarrow_1_1dataset_1_1_cast_expression"/>
        <childnode refid="1476" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1473">
        <label>arrow::dataset::FieldExpression</label>
        <link refid="classarrow_1_1dataset_1_1_field_expression"/>
        <childnode refid="1464" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1464">
        <label>arrow::dataset::Expression</label>
        <link refid="classarrow_1_1dataset_1_1_expression"/>
      </node>
      <node id="1478">
        <label>arrow::dataset::ExpressionImpl&lt; UnaryExpression, InExpression, ExpressionType::IN &gt;</label>
        <link refid="classarrow_1_1dataset_1_1_expression_impl"/>
        <childnode refid="1475" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1469">
        <label>arrow::dataset::ComparisonExpression</label>
        <link refid="classarrow_1_1dataset_1_1_comparison_expression"/>
        <childnode refid="1468" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1482">
        <label>arrow::dataset::ExpressionImpl&lt; UnaryExpression, NotExpression, ExpressionType::NOT &gt;</label>
        <link refid="classarrow_1_1dataset_1_1_expression_impl"/>
        <childnode refid="1475" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1476">
        <label>arrow::dataset::ExpressionImpl&lt; UnaryExpression, CastExpression, ExpressionType::CAST &gt;</label>
        <link refid="classarrow_1_1dataset_1_1_expression_impl"/>
        <childnode refid="1475" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1467">
        <label>arrow::dataset::AndExpression</label>
        <link refid="classarrow_1_1dataset_1_1_and_expression"/>
        <childnode refid="1466" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1483">
        <label>arrow::dataset::NotExpression</label>
        <link refid="classarrow_1_1dataset_1_1_not_expression"/>
        <childnode refid="1482" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="83" column="1" bodyfile="/arrow/cpp/src/arrow/dataset/filter.h" bodystart="83" bodyend="210"/>
    <listofallmembers>
      <member refid="classarrow_1_1dataset_1_1_expression_1a5cf8311867209fd28af7f0fdf6b26b33" prot="public" virt="virtual"><scope>arrow::dataset::Expression</scope><name>Assume</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1aa94bb5128873b3955ef1079dbfa59a05" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>Assume</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1aa3b8f7274bf46ffb4c9d63c54182eed3" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>CastLike</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1ab93e79be7899dc8a3aa063d92748d6d1" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>CastLike</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a67c73de7e4be70d94decb62d73d9679f" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>CastTo</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1ab4baacac016afb9b00f41113dd05f602" prot="public" virt="pure-virtual"><scope>arrow::dataset::Expression</scope><name>Copy</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a8c952a05b1090e1ec15adbe7ed712ea6" prot="public" virt="pure-virtual"><scope>arrow::dataset::Expression</scope><name>Equals</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a2080b195e1999f973c7ceb7e0978a13e" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>Equals</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a55f49c9a8081e757c4d399073785f171" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>Equals</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1ace247255d88029192703e49bcb468c7a" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>Expression</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a5ce811a47927451199574abff5bab72a" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>In</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a8e5d308f61bdb2ec2074b662ea33f760" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>IsNull</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1ac665b2a07ec4247f0af1ada25340a294" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>IsValid</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1acd37d50f9235db97d98299dedde5deb8" prot="public" virt="pure-virtual"><scope>arrow::dataset::Expression</scope><name>ToString</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a26c748fc0b8eb3ffa800bd957a019d39" prot="public" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>type</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a4f70ea37a6b7d7e542b1d806e65305f4" prot="protected" virt="non-virtual"><scope>arrow::dataset::Expression</scope><name>type_</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a1073c67366c820875c3825e867419050" prot="public" virt="pure-virtual"><scope>arrow::dataset::Expression</scope><name>Validate</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1aeadfb3da0cb488e984d342be1ed9ae36" prot="public" virt="virtual"><scope>arrow::dataset::Expression</scope><name>~Expression</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
