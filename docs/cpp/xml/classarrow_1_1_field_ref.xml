<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1_field_ref" kind="class" language="C++" prot="public">
    <compoundname>arrow::FieldRef</compoundname>
    <includes refid="type_8h" local="no">arrow/type.h</includes>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classarrow_1_1_field_ref_1a45ff0400d878f4a4b928860973bf7c89" prot="public" static="no">
        <type>decltype(std::declval&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> &gt;().Get(std::declval&lt; T &gt;()).ValueOrDie())</type>
        <definition>using arrow::FieldRef::GetType =  decltype(std::declval&lt;FieldPath&gt;().Get(std::declval&lt;T&gt;()).ValueOrDie())</definition>
        <argsstring></argsstring>
        <name>GetType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1592" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1592" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classarrow_1_1_field_ref_1aedd28189e197fff5d8fc9e2874efd25b" prot="private" static="no" mutable="no">
        <type>util::variant&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref>, std::string, std::vector&lt; <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> &gt; &gt;</type>
        <definition>util::variant&lt;FieldPath, std::string, std::vector&lt;FieldRef&gt; &gt; arrow::FieldRef::impl_</definition>
        <argsstring></argsstring>
        <name>impl_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1626" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1626" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a13e0b853fc6b3dcf9bd6179bf9664efe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>arrow::FieldRef::FieldRef</definition>
        <argsstring>()=default</argsstring>
        <name>FieldRef</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1484" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1ac4eb88bec1e2e92c0904014630a703da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>arrow::FieldRef::FieldRef</definition>
        <argsstring>(FieldPath indices)</argsstring>
        <name>FieldRef</name>
        <param>
          <type><ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref></type>
          <declname>indices</declname>
        </param>
        <briefdescription>
<para>Construct a <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> using a string of indices. </para>        </briefdescription>
        <detaileddescription>
<para>The reference will be retrieved as: schema.fields[self.indices[0]].type.fields[self.indices[1]] ...</para><para>Empty indices are not valid. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1490" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a184489f63e9ea5656c1978b135bcfb33" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::FieldRef::FieldRef</definition>
        <argsstring>(std::string name)</argsstring>
        <name>FieldRef</name>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Construct a by-name <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Multiple fields may match a by-name <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>: [f for f in schema.fields where f.name == self.name] </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1494" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1494" bodyend="1494"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1ada3081176aebf294d36e69761c395fd0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::FieldRef::FieldRef</definition>
        <argsstring>(int index)</argsstring>
        <name>FieldRef</name>
        <param>
          <type>int</type>
          <declname>index</declname>
        </param>
        <briefdescription>
<para>Equivalent to a single index string of indices. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1497" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1497" bodyend="1497"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a34007097362d31fba751b9b7a4516b63" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename A0</type>
          </param>
          <param>
            <type>typename A1</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>A</declname>
            <defname>A</defname>
          </param>
        </templateparamlist>
        <type></type>
        <definition>arrow::FieldRef::FieldRef</definition>
        <argsstring>(A0 &amp;&amp;a0, A1 &amp;&amp;a1, A &amp;&amp;... a)</argsstring>
        <name>FieldRef</name>
        <param>
          <type>A0 &amp;&amp;</type>
          <declname>a0</declname>
        </param>
        <param>
          <type>A1 &amp;&amp;</type>
          <declname>a1</declname>
        </param>
        <param>
          <type>A &amp;&amp;...</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Convenience constructor for nested FieldRefs: each argument will be used to construct a <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1502" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1502" bodyend="1507"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1ad1d196aa0da401d87faebc252b725150" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::FieldRef::Equals</definition>
        <argsstring>(const FieldRef &amp;other) const</argsstring>
        <name>Equals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1528" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1528" bodyend="1528"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1aa3ec4f70e37c0f65e269a2f7f10c99ce" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::FieldRef::operator==</definition>
        <argsstring>(const FieldRef &amp;other) const</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1529" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1529" bodyend="1529"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a89794f5ce7772774c3b1829f42bc1c47" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string arrow::FieldRef::ToString</definition>
        <argsstring>() const</argsstring>
        <name>ToString</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1531" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1acad550fcf1de6ce2828f9b9f10941540" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t arrow::FieldRef::hash</definition>
        <argsstring>() const</argsstring>
        <name>hash</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1533" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1ae33cf0296994a6fb6284c4e11027d95a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::FieldRef::IsFieldPath</definition>
        <argsstring>() const</argsstring>
        <name>IsFieldPath</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1535" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1535" bodyend="1535"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a56d1b8aeab2722bca9800b27be338b52" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::FieldRef::IsName</definition>
        <argsstring>() const</argsstring>
        <name>IsName</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1536" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1536" bodyend="1536"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1aad7e05c92cb4a2a520335b477f1af51e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::FieldRef::IsNested</definition>
        <argsstring>() const</argsstring>
        <name>IsNested</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1537" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1537" bodyend="1541"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1aaff5736dd030e307d798190eedd76b70" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> &gt;</type>
        <definition>std::vector&lt;FieldPath&gt; arrow::FieldRef::FindAll</definition>
        <argsstring>(const Schema &amp;schema) const</argsstring>
        <name>FindAll</name>
        <param>
          <type>const <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>schema</declname>
        </param>
        <briefdescription>
<para>Retrieve <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> of every child field which matches this <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1544" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1ae2b81ca3a38027267fb657f3fb14d8b8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> &gt;</type>
        <definition>std::vector&lt;FieldPath&gt; arrow::FieldRef::FindAll</definition>
        <argsstring>(const Field &amp;field) const</argsstring>
        <name>FindAll</name>
        <param>
          <type>const <ref refid="classarrow_1_1_field" kindref="compound">Field</ref> &amp;</type>
          <declname>field</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1545" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1acebfd1f84e99cf29ba26953b0f70b17a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> &gt;</type>
        <definition>std::vector&lt;FieldPath&gt; arrow::FieldRef::FindAll</definition>
        <argsstring>(const DataType &amp;type) const</argsstring>
        <name>FindAll</name>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1546" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1aa6cfe0e3d06bf54b8b72cd5658e84a3b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> &gt;</type>
        <definition>std::vector&lt;FieldPath&gt; arrow::FieldRef::FindAll</definition>
        <argsstring>(const FieldVector &amp;fields) const</argsstring>
        <name>FindAll</name>
        <param>
          <type>const <ref refid="namespacearrow_1a4599536b489227968fbdf37c1f9585cf" kindref="member">FieldVector</ref> &amp;</type>
          <declname>fields</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1547" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a1905a993f22a735911a7903e746f05e9" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::FieldRef::CheckNonEmpty</definition>
        <argsstring>(const std::vector&lt; FieldPath &gt; &amp;matches, const T &amp;root) const</argsstring>
        <name>CheckNonEmpty</name>
        <param>
          <type>const std::vector&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> &gt; &amp;</type>
          <declname>matches</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>root</declname>
        </param>
        <briefdescription>
<para>Convenience function: raise an error if matches is empty. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1551" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1551" bodyend="1556"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a993d0872b2c308ed541d943fc785129d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::FieldRef::CheckNonMultiple</definition>
        <argsstring>(const std::vector&lt; FieldPath &gt; &amp;matches, const T &amp;root) const</argsstring>
        <name>CheckNonMultiple</name>
        <param>
          <type>const std::vector&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> &gt; &amp;</type>
          <declname>matches</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>root</declname>
        </param>
        <briefdescription>
<para>Convenience function: raise an error if matches contains multiple FieldPaths. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1560" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1560" bodyend="1566"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a3a46e4e8f9041e4ffa5bb34e50ad93b4" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> &gt;</type>
        <definition>Result&lt;FieldPath&gt; arrow::FieldRef::FindOne</definition>
        <argsstring>(const T &amp;root) const</argsstring>
        <name>FindOne</name>
        <param>
          <type>const T &amp;</type>
          <declname>root</declname>
        </param>
        <briefdescription>
<para>Retrieve <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> of a single child field which matches this <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Emit an error if none or multiple match. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1571" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1571" bodyend="1576"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a7663e6dcd2b692877ca071f126ac22c1" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> &gt;</type>
        <definition>Result&lt;FieldPath&gt; arrow::FieldRef::FindOneOrNone</definition>
        <argsstring>(const T &amp;root) const</argsstring>
        <name>FindOneOrNone</name>
        <param>
          <type>const T &amp;</type>
          <declname>root</declname>
        </param>
        <briefdescription>
<para>Retrieve <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> of a single child field which matches this <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Emit an error if multiple match. An empty (invalid) <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> will be returned if none match. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1582" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1582" bodyend="1589"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a658301f688f2cbeb9fad49c7560ad618" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="classarrow_1_1_field_ref_1a45ff0400d878f4a4b928860973bf7c89" kindref="member">GetType</ref>&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;GetType&lt;T&gt; &gt; arrow::FieldRef::GetAll</definition>
        <argsstring>(const T &amp;root) const</argsstring>
        <name>GetAll</name>
        <param>
          <type>const T &amp;</type>
          <declname>root</declname>
        </param>
        <briefdescription>
<para>Get all children matching this <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1596" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1596" bodyend="1602"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a59b98c599b14aca11a32e2cb3082f583" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; <ref refid="classarrow_1_1_field_ref_1a45ff0400d878f4a4b928860973bf7c89" kindref="member">GetType</ref>&lt; T &gt; &gt;</type>
        <definition>Result&lt;GetType&lt;T&gt; &gt; arrow::FieldRef::GetOne</definition>
        <argsstring>(const T &amp;root) const</argsstring>
        <name>GetOne</name>
        <param>
          <type>const T &amp;</type>
          <declname>root</declname>
        </param>
        <briefdescription>
<para>Get the single child matching this <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Emit an error if none or multiple match. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1607" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1607" bodyend="1610"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a6687be25f7b918d83439f33f2969fdc3" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; <ref refid="classarrow_1_1_field_ref_1a45ff0400d878f4a4b928860973bf7c89" kindref="member">GetType</ref>&lt; T &gt; &gt;</type>
        <definition>Result&lt;GetType&lt;T&gt; &gt; arrow::FieldRef::GetOneOrNone</definition>
        <argsstring>(const T &amp;root) const</argsstring>
        <name>GetOneOrNone</name>
        <param>
          <type>const T &amp;</type>
          <declname>root</declname>
        </param>
        <briefdescription>
<para>Get the single child matching this <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Return nullptr if none match, emit an error if multiple match. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1615" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1615" bodyend="1621"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classarrow_1_1_field_ref_1abea828b46abe54db47c3af1b5faa49b2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> &gt;</type>
        <definition>static Result&lt;FieldRef&gt; arrow::FieldRef::FromDotPath</definition>
        <argsstring>(const std::string &amp;dot_path)</argsstring>
        <name>FromDotPath</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>dot_path</declname>
        </param>
        <briefdescription>
<para>Parse a dot path into a <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>dot_path = &apos;.&apos; name | &apos;[&apos; digit+ &apos;]&apos; | dot_path+</para><para>Examples: &quot;.alpha&quot; =&gt; <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>(&quot;alpha&quot;) &quot;[2]&quot; =&gt; FieldRef(2) &quot;.beta[3]&quot; =&gt; <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>(&quot;beta&quot;, 3) &quot;[5].gamma.delta[7]&quot; =&gt; <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>(5, &quot;gamma&quot;, &quot;delta&quot;, 7) &quot;.hello world&quot; =&gt; <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>(&quot;hello world&quot;) R&quot;(.\[y\]\\tho\.\)&quot; =&gt; <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>(R&quot;([y]\tho.\)&quot;)</para><para>Note: When parsing a name, a &apos;\&apos; preceding any other character will be dropped from the resulting name. Therefore if a name must contain the characters &apos;.&apos;, &apos;\&apos;, or &apos;[&apos; those must be escaped with a preceding &apos;\&apos;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1526" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classarrow_1_1_field_ref_1a28b2c5de246793df39a65b44cf7a929b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::FieldRef::Flatten</definition>
        <argsstring>(std::vector&lt; FieldRef &gt; children)</argsstring>
        <name>Flatten</name>
        <param>
          <type>std::vector&lt; <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> &gt;</type>
          <declname>children</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1624" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classarrow_1_1_field_ref_1ab4d55bcb24a8a6e710f12240369224c9" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend void</type>
        <definition>void PrintTo</definition>
        <argsstring>(const FieldRef &amp;ref, std::ostream *os)</argsstring>
        <name>PrintTo</name>
        <param>
          <type>const <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> &amp;</type>
          <declname>ref</declname>
        </param>
        <param>
          <type>std::ostream *</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/type.h" line="1628" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Descriptor of a (potentially nested) field within a schema. </para>    </briefdescription>
    <detaileddescription>
<para>Unlike <ref refid="classarrow_1_1_field_path" kindref="compound">FieldPath</ref> (which exclusively uses indices of child fields), <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> may reference a field by name. It is intended to replace parameters like <computeroutput>int field_index</computeroutput> and <computeroutput>const std::string&amp; field_name</computeroutput>; it can be implicitly constructed from either a field index or a name.</para><para>Nested fields can be referenced as well. Given schema({field(&quot;a&quot;, struct_({field(&quot;n&quot;, <ref refid="group__type-factories_1gaf642d53dac1a6b6b686fb5984d33bc9a" kindref="member">null()</ref>)})), field(&quot;b&quot;, <ref refid="group__type-factories_1ga86f6bfe394347f77befa2143297ad541" kindref="member">int32()</ref>)})</para><para>the following all indicate the nested field named &quot;n&quot;: <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> ref1(0, 0); <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> ref2(&quot;a&quot;, 0); <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> ref3(&quot;a&quot;, &quot;n&quot;); <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> ref4(0, &quot;n&quot;); ARROW_ASSIGN_OR_RAISE(<ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> ref5, <ref refid="classarrow_1_1_field_ref_1abea828b46abe54db47c3af1b5faa49b2" kindref="member">FieldRef::FromDotPath</ref>(&quot;.a[0]&quot;));</para><para>FieldPaths matching a <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref> are retrieved using the member function FindAll. Multiple matches are possible because field names may be duplicated within a schema. For example: <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> a_is_ambiguous({field(&quot;a&quot;, <ref refid="group__type-factories_1ga86f6bfe394347f77befa2143297ad541" kindref="member">int32()</ref>), field(&quot;a&quot;, <ref refid="group__type-factories_1ga48fca9d26feda61c8255ec3c44a2078c" kindref="member">float32()</ref>)}); auto matches = <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>(&quot;a&quot;).FindAll(a_is_ambiguous); assert(matches.size() == 2); assert(matches[0].Get(a_is_ambiguous)-&gt;Equals(a_is_ambiguous.field(0))); assert(matches[1].Get(a_is_ambiguous)-&gt;Equals(a_is_ambiguous.field(1)));</para><para>Convenience accessors are available which raise a helpful error if the field is not found or ambiguous, and for immediately calling <ref refid="classarrow_1_1_field_path_1a165fd942d59b8b8a6f45f1f939cb7a1b" kindref="member">FieldPath::Get</ref> to retrieve any matching children: auto maybe_match = <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>(&quot;struct&quot;, &quot;field_i32&quot;).FindOneOrNone(schema); auto maybe_column = <ref refid="classarrow_1_1_field_ref" kindref="compound">FieldRef</ref>(&quot;struct&quot;, &quot;field_i32&quot;).GetOne(some_table); </para>    </detaileddescription>
    <location file="/arrow/cpp/src/arrow/type.h" line="1482" column="1" bodyfile="/arrow/cpp/src/arrow/type.h" bodystart="1482" bodyend="1629"/>
    <listofallmembers>
      <member refid="classarrow_1_1_field_ref_1a1905a993f22a735911a7903e746f05e9" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>CheckNonEmpty</name></member>
      <member refid="classarrow_1_1_field_ref_1a993d0872b2c308ed541d943fc785129d" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>CheckNonMultiple</name></member>
      <member refid="classarrow_1_1_field_ref_1ad1d196aa0da401d87faebc252b725150" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>Equals</name></member>
      <member refid="classarrow_1_1_field_ref_1a13e0b853fc6b3dcf9bd6179bf9664efe" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FieldRef</name></member>
      <member refid="classarrow_1_1_field_ref_1ac4eb88bec1e2e92c0904014630a703da" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FieldRef</name></member>
      <member refid="classarrow_1_1_field_ref_1a184489f63e9ea5656c1978b135bcfb33" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FieldRef</name></member>
      <member refid="classarrow_1_1_field_ref_1ada3081176aebf294d36e69761c395fd0" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FieldRef</name></member>
      <member refid="classarrow_1_1_field_ref_1a34007097362d31fba751b9b7a4516b63" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FieldRef</name></member>
      <member refid="classarrow_1_1_field_ref_1aaff5736dd030e307d798190eedd76b70" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FindAll</name></member>
      <member refid="classarrow_1_1_field_ref_1ae2b81ca3a38027267fb657f3fb14d8b8" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FindAll</name></member>
      <member refid="classarrow_1_1_field_ref_1acebfd1f84e99cf29ba26953b0f70b17a" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FindAll</name></member>
      <member refid="classarrow_1_1_field_ref_1aa6cfe0e3d06bf54b8b72cd5658e84a3b" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FindAll</name></member>
      <member refid="classarrow_1_1_field_ref_1a3a46e4e8f9041e4ffa5bb34e50ad93b4" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FindOne</name></member>
      <member refid="classarrow_1_1_field_ref_1a7663e6dcd2b692877ca071f126ac22c1" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FindOneOrNone</name></member>
      <member refid="classarrow_1_1_field_ref_1a28b2c5de246793df39a65b44cf7a929b" prot="private" virt="non-virtual"><scope>arrow::FieldRef</scope><name>Flatten</name></member>
      <member refid="classarrow_1_1_field_ref_1abea828b46abe54db47c3af1b5faa49b2" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>FromDotPath</name></member>
      <member refid="classarrow_1_1_field_ref_1a658301f688f2cbeb9fad49c7560ad618" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>GetAll</name></member>
      <member refid="classarrow_1_1_field_ref_1a59b98c599b14aca11a32e2cb3082f583" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>GetOne</name></member>
      <member refid="classarrow_1_1_field_ref_1a6687be25f7b918d83439f33f2969fdc3" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>GetOneOrNone</name></member>
      <member refid="classarrow_1_1_field_ref_1a45ff0400d878f4a4b928860973bf7c89" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>GetType</name></member>
      <member refid="classarrow_1_1_field_ref_1acad550fcf1de6ce2828f9b9f10941540" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>hash</name></member>
      <member refid="classarrow_1_1_field_ref_1aedd28189e197fff5d8fc9e2874efd25b" prot="private" virt="non-virtual"><scope>arrow::FieldRef</scope><name>impl_</name></member>
      <member refid="classarrow_1_1_field_ref_1ae33cf0296994a6fb6284c4e11027d95a" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>IsFieldPath</name></member>
      <member refid="classarrow_1_1_field_ref_1a56d1b8aeab2722bca9800b27be338b52" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>IsName</name></member>
      <member refid="classarrow_1_1_field_ref_1aad7e05c92cb4a2a520335b477f1af51e" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>IsNested</name></member>
      <member refid="classarrow_1_1_field_ref_1aa3ec4f70e37c0f65e269a2f7f10c99ce" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>operator==</name></member>
      <member refid="classarrow_1_1_field_ref_1ab4d55bcb24a8a6e710f12240369224c9" prot="private" virt="non-virtual"><scope>arrow::FieldRef</scope><name>PrintTo</name></member>
      <member refid="classarrow_1_1_field_ref_1a89794f5ce7772774c3b1829f42bc1c47" prot="public" virt="non-virtual"><scope>arrow::FieldRef</scope><name>ToString</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
