<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacearrow_1_1stl" kind="namespace" language="C++">
    <compoundname>arrow::stl</compoundname>
    <innerclass refid="classarrow_1_1stl_1_1allocator" prot="public">arrow::stl::allocator</innerclass>
    <innerclass refid="structarrow_1_1stl_1_1_conversion_traits" prot="public">arrow::stl::ConversionTraits</innerclass>
    <innerclass refid="structarrow_1_1stl_1_1_conversion_traits_3_01_optional_00_01enable__if__optional__like_3_01_optional_01_4_01_4" prot="public">arrow::stl::ConversionTraits&lt; Optional, enable_if_optional_like&lt; Optional &gt; &gt;</innerclass>
    <innerclass refid="structarrow_1_1stl_1_1_conversion_traits_3_01std_1_1string_01_4" prot="public">arrow::stl::ConversionTraits&lt; std::string &gt;</innerclass>
    <innerclass refid="structarrow_1_1stl_1_1_conversion_traits_3_01std_1_1vector_3_01_value_c_type_01_4_01_4" prot="public">arrow::stl::ConversionTraits&lt; std::vector&lt; ValueCType &gt; &gt;</innerclass>
    <innerclass refid="structarrow_1_1stl_1_1_schema_from_tuple" prot="public">arrow::stl::SchemaFromTuple</innerclass>
    <innerclass refid="structarrow_1_1stl_1_1_schema_from_tuple_3_01_tuple_00_010_01_4" prot="public">arrow::stl::SchemaFromTuple&lt; Tuple, 0 &gt;</innerclass>
    <innerclass refid="classarrow_1_1stl_1_1_s_t_l_memory_pool" prot="public">arrow::stl::STLMemoryPool</innerclass>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacearrow_1_1stl_1aa869f1ad4f123dc12504ad7bcfd21d40" prot="public" static="no">
        <type>typename std::enable_if&lt; internal::is_optional_like&lt; T &gt;::value, R &gt;::type</type>
        <definition>using arrow::stl::enable_if_optional_like = typedef typename std::enable_if&lt;internal::is_optional_like&lt;T&gt;::value, R&gt;::type</definition>
        <argsstring></argsstring>
        <name>enable_if_optional_like</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/stl.h" line="72" column="1" bodyfile="/arrow/cpp/src/arrow/stl.h" bodystart="73" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1_1stl_1a6df2295eb333588d6a494478a590b90f" prot="public" static="no">
        <type>typename <ref refid="structarrow_1_1_type_traits" kindref="compound">TypeTraits</ref>&lt; typename <ref refid="structarrow_1_1stl_1_1_conversion_traits" kindref="compound">ConversionTraits</ref>&lt; CType &gt;::ArrowType &gt;::BuilderType</type>
        <definition>using arrow::stl::CBuilderType = typedef typename TypeTraits&lt;typename ConversionTraits&lt;CType&gt;::ArrowType&gt;::BuilderType</definition>
        <argsstring></argsstring>
        <name>CBuilderType</name>
        <briefdescription>
<para>Returns builder type for given standard C/C++ type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/stl.h" line="81" column="1" bodyfile="/arrow/cpp/src/arrow/stl.h" bodystart="82" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacearrow_1_1stl_1adbef871ae921a475398dbe61c557db38" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueCType</type>
          </param>
          <param>
            <type>typename Range</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::stl::AppendListValues</definition>
        <argsstring>(CBuilderType&lt; ValueCType &gt; &amp;value_builder, Range &amp;&amp;cell_range)</argsstring>
        <name>AppendListValues</name>
        <param>
          <type><ref refid="namespacearrow_1_1stl_1a6df2295eb333588d6a494478a590b90f" kindref="member">CBuilderType</ref>&lt; ValueCType &gt; &amp;</type>
          <declname>value_builder</declname>
        </param>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>cell_range</declname>
        </param>
        <briefdescription>
<para>Default implementation of AppendListValues. </para>        </briefdescription>
        <detaileddescription>
<para>This function can be specialized by user to take advantage of appending contiguous ranges while appending. This default implementation will call ConversionTraits&lt;ValueCType&gt;::AppendRow() for each value in the range. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/stl.h" line="90" column="1" bodyfile="/arrow/cpp/src/arrow/stl.h" bodystart="90" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1stl_1ac2316b3c7ddb9ab2ac10735d5b86baab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueCType</type>
          </param>
          <param>
            <type>typename ListBuilderType</type>
          </param>
          <param>
            <type>typename Range</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::stl::AppendCellRange</definition>
        <argsstring>(ListBuilderType &amp;builder, Range &amp;&amp;cell_range)</argsstring>
        <name>AppendCellRange</name>
        <param>
          <type>ListBuilderType &amp;</type>
          <declname>builder</declname>
        </param>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>cell_range</declname>
        </param>
        <briefdescription>
<para>Append cell range elements as a single value to the list builder. </para>        </briefdescription>
        <detaileddescription>
<para>Cell range will be added to child builder using <ref refid="namespacearrow_1_1stl_1adbef871ae921a475398dbe61c557db38" kindref="member">AppendListValues&lt;ValueCType&gt;()</ref> if provided. <ref refid="namespacearrow_1_1stl_1adbef871ae921a475398dbe61c557db38" kindref="member">AppendListValues&lt;ValueCType&gt;()</ref> has a default implementation, but it can be specialized by users. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/stl.h" line="146" column="1" bodyfile="/arrow/cpp/src/arrow/stl.h" bodystart="146" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1stl_1abc15ebf9867f11c0cf2daa3711f480da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Range</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::stl::TableFromTupleRange</definition>
        <argsstring>(MemoryPool *pool, Range &amp;&amp;rows, const std::vector&lt; std::string &gt; &amp;names, std::shared_ptr&lt; Table &gt; *table)</argsstring>
        <name>TableFromTupleRange</name>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>rows</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>names</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &gt; *</type>
          <declname>table</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/stl.h" line="403" column="1" bodyfile="/arrow/cpp/src/arrow/stl.h" bodystart="403" bodyend="428"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1stl_1affacdee6d66a98c58c349de975ce5a3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Range</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::stl::TupleRangeFromTable</definition>
        <argsstring>(const Table &amp;table, const compute::CastOptions &amp;cast_options, compute::FunctionContext *ctx, Range *rows)</argsstring>
        <name>TupleRangeFromTable</name>
        <param>
          <type>const <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &amp;</type>
          <declname>table</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">compute::CastOptions</ref> &amp;</type>
          <declname>cast_options</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">compute::FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>Range *</type>
          <declname>rows</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/stl.h" line="431" column="1" bodyfile="/arrow/cpp/src/arrow/stl.h" bodystart="431" bodyend="461"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1stl_1a232ce3f7139c816ba00d677ac277c4b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T1</type>
          </param>
          <param>
            <type>class T2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool arrow::stl::operator==</definition>
        <argsstring>(const allocator&lt; T1 &gt; &amp;lhs, const allocator&lt; T2 &gt; &amp;rhs) noexcept</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classarrow_1_1stl_1_1allocator" kindref="compound">allocator</ref>&lt; T1 &gt; &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1stl_1_1allocator" kindref="compound">allocator</ref>&lt; T2 &gt; &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/stl_allocator.h" line="143" column="1" bodyfile="/arrow/cpp/src/arrow/stl_allocator.h" bodystart="143" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1stl_1a29bc23b481099b0c508b4fd0b2e36f49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T1</type>
          </param>
          <param>
            <type>class T2</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool arrow::stl::operator!=</definition>
        <argsstring>(const allocator&lt; T1 &gt; &amp;lhs, const allocator&lt; T2 &gt; &amp;rhs) noexcept</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classarrow_1_1stl_1_1allocator" kindref="compound">allocator</ref>&lt; T1 &gt; &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1stl_1_1allocator" kindref="compound">allocator</ref>&lt; T2 &gt; &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/stl_allocator.h" line="148" column="1" bodyfile="/arrow/cpp/src/arrow/stl_allocator.h" bodystart="148" bodyend="150"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/arrow/cpp/src/arrow/stl.h" line="44" column="1"/>
  </compounddef>
</doxygen>
