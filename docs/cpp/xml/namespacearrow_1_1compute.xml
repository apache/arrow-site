<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacearrow_1_1compute" kind="namespace" language="C++">
    <compoundname>arrow::compute</compoundname>
    <innerclass refid="classarrow_1_1compute_1_1_add_kernel" prot="public">arrow::compute::AddKernel</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_aggregate_function" prot="public">arrow::compute::AggregateFunction</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_aggregate_function_static_state" prot="public">arrow::compute::AggregateFunctionStaticState</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_aggregate_unary_kernel" prot="public">arrow::compute::AggregateUnaryKernel</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_array_expr" prot="public">arrow::compute::ArrayExpr</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_array_index_sequence" prot="public">arrow::compute::ArrayIndexSequence</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_benchmark_args_type" prot="public">arrow::compute::BenchmarkArgsType</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_binary_kernel" prot="public">arrow::compute::BinaryKernel</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_cast_options" prot="public">arrow::compute::CastOptions</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_compare_options" prot="public">arrow::compute::CompareOptions</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_count_options" prot="public">arrow::compute::CountOptions</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_datum" prot="public">arrow::compute::Datum</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_expr" prot="public">arrow::compute::Expr</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_filter_kernel" prot="public">arrow::compute::FilterKernel</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_filter_options" prot="public">arrow::compute::FilterOptions</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_find_accumulator_type" prot="public">arrow::compute::FindAccumulatorType</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_find_accumulator_type_3_01_i_00_01enable__if__floating__point_3_01_i_01_4_01_4" prot="public">arrow::compute::FindAccumulatorType&lt; I, enable_if_floating_point&lt; I &gt; &gt;</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_find_accumulator_type_3_01_i_00_01enable__if__signed__integer_3_01_i_01_4_01_4" prot="public">arrow::compute::FindAccumulatorType&lt; I, enable_if_signed_integer&lt; I &gt; &gt;</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_find_accumulator_type_3_01_i_00_01enable__if__unsigned__integer_3_01_i_01_4_01_4" prot="public">arrow::compute::FindAccumulatorType&lt; I, enable_if_unsigned_integer&lt; I &gt; &gt;</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_function_context" prot="public">arrow::compute::FunctionContext</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_list_taker_impl" prot="public">arrow::compute::ListTakerImpl</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_logical_type" prot="public">arrow::compute::LogicalType</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_min_max_options" prot="public">arrow::compute::MinMaxOptions</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_operation" prot="public">arrow::compute::Operation</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_op_kernel" prot="public">arrow::compute::OpKernel</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_range_index_sequence" prot="public">arrow::compute::RangeIndexSequence</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_regression_args" prot="public">arrow::compute::RegressionArgs</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_scalar_expr" prot="public">arrow::compute::ScalarExpr</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_sum_aggregate_function" prot="public">arrow::compute::SumAggregateFunction</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_take_kernel" prot="public">arrow::compute::TakeKernel</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_take_options" prot="public">arrow::compute::TakeOptions</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker" prot="public">arrow::compute::Taker</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl" prot="public">arrow::compute::TakerImpl</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_dictionary_type_01_4" prot="public">arrow::compute::TakerImpl&lt; IndexSequence, DictionaryType &gt;</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_extension_type_01_4" prot="public">arrow::compute::TakerImpl&lt; IndexSequence, ExtensionType &gt;</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_fixed_size_list_type_01_4" prot="public">arrow::compute::TakerImpl&lt; IndexSequence, FixedSizeListType &gt;</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_large_list_type_01_4" prot="public">arrow::compute::TakerImpl&lt; IndexSequence, LargeListType &gt;</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_list_type_01_4" prot="public">arrow::compute::TakerImpl&lt; IndexSequence, ListType &gt;</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_map_type_01_4" prot="public">arrow::compute::TakerImpl&lt; IndexSequence, MapType &gt;</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_null_type_01_4" prot="public">arrow::compute::TakerImpl&lt; IndexSequence, NullType &gt;</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_struct_type_01_4" prot="public">arrow::compute::TakerImpl&lt; IndexSequence, StructType &gt;</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_taker_impl_3_01_index_sequence_00_01_union_type_01_4" prot="public">arrow::compute::TakerImpl&lt; IndexSequence, UnionType &gt;</innerclass>
    <innerclass refid="structarrow_1_1compute_1_1_taker_make_impl" prot="public">arrow::compute::TakerMakeImpl</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_unary_kernel" prot="public">arrow::compute::UnaryKernel</innerclass>
    <innerclass refid="classarrow_1_1compute_1_1_value_expr" prot="public">arrow::compute::ValueExpr</innerclass>
    <innernamespace refid="namespacearrow_1_1compute_1_1array">arrow::compute::array</innernamespace>
    <innernamespace refid="namespacearrow_1_1compute_1_1ops">arrow::compute::ops</innernamespace>
    <innernamespace refid="namespacearrow_1_1compute_1_1scalar">arrow::compute::scalar</innernamespace>
    <innernamespace refid="namespacearrow_1_1compute_1_1type">arrow::compute::type</innernamespace>
    <innernamespace refid="namespacearrow_1_1compute_1_1value">arrow::compute::value</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacearrow_1_1compute_1a8c7314c2838c3f4df31d9027983e7b0b" prot="public" static="no">
        <name>ValueRank</name>
        <enumvalue id="namespacearrow_1_1compute_1a8c7314c2838c3f4df31d9027983e7b0ba8f3d9a4b6a7b7f2c7afa61ca113d0db9" prot="public">
          <name>SCALAR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1_1compute_1a8c7314c2838c3f4df31d9027983e7b0bacb4fb1757fb37c43cded35d3eb857c43" prot="public">
          <name>ARRAY</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>The value cardinality: one or many. </para>        </briefdescription>
        <detaileddescription>
<para>These correspond to the <ref refid="structarrow_1_1_scalar" kindref="compound">arrow::Scalar</ref> and <ref refid="classarrow_1_1_array" kindref="compound">arrow::Array</ref> types </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/expression.h" line="61" column="1" bodyfile="/arrow/cpp/src/arrow/compute/expression.h" bodystart="61" bodyend="61"/>
      </memberdef>
      <memberdef kind="enum" id="namespacearrow_1_1compute_1a722101516c22b89bdf3f54ff6f90cd2e" prot="public" static="no">
        <name>CompareOperator</name>
        <enumvalue id="namespacearrow_1_1compute_1a722101516c22b89bdf3f54ff6f90cd2ea602792ae96607227306b00b948a49642" prot="public">
          <name>EQUAL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1_1compute_1a722101516c22b89bdf3f54ff6f90cd2ea4bcbbc099f2f532f402c86415099f446" prot="public">
          <name>NOT_EQUAL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1_1compute_1a722101516c22b89bdf3f54ff6f90cd2ea3da583275ccef5bb978f7c0caf0c93e8" prot="public">
          <name>GREATER</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1_1compute_1a722101516c22b89bdf3f54ff6f90cd2eaafce6452f6406693fc0b4736f343c19a" prot="public">
          <name>GREATER_EQUAL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1_1compute_1a722101516c22b89bdf3f54ff6f90cd2eaece4bea22705948d598457047b45a713" prot="public">
          <name>LESS</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1_1compute_1a722101516c22b89bdf3f54ff6f90cd2eab8cba2f6e6f1cb0afed2d02ee7ed5afa" prot="public">
          <name>LESS_EQUAL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/compare.h" line="34" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernels/compare.h" bodystart="34" bodyend="41"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacearrow_1_1compute_1abcdcabf38ba21c6ca54c9c2630045926" prot="public" static="no">
        <type>typename <ref refid="structarrow_1_1compute_1_1_benchmark_args_type" kindref="compound">BenchmarkArgsType</ref>&lt; decltype(&amp;benchmark::internal::Benchmark::Args)&gt;::type</type>
        <definition>using arrow::compute::ArgsType = typedef typename BenchmarkArgsType&lt;decltype(&amp;benchmark::internal::Benchmark::Args)&gt;::type</definition>
        <argsstring></argsstring>
        <name>ArgsType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="51" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="52" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1_1compute_1ade436c20161be56a69cde0c8e044bd0e" prot="public" static="no">
        <type><ref refid="namespacearrow_1a6ffa941ae85f4dd1545a9fad796324c6" kindref="member">enable_if_t</ref>&lt;!std::is_base_of&lt; <ref refid="classarrow_1_1_base_binary_type" kindref="compound">BaseBinaryType</ref>, T &gt;::value, R &gt;</type>
        <definition>using arrow::compute::enable_if_not_base_binary = typedef enable_if_t&lt;!std::is_base_of&lt;BaseBinaryType, T&gt;::value, R&gt;</definition>
        <argsstring></argsstring>
        <name>enable_if_not_base_binary</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" line="42" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1_1compute_1ad92a8b9428e7982c9a32ff706b516744" prot="public" static="no">
        <type>std::shared_ptr&lt;::<ref refid="classarrow_1_1_data_type" kindref="compound">arrow::DataType</ref> &gt;</type>
        <definition>using arrow::compute::ArrowTypePtr = typedef std::shared_ptr&lt;::arrow::DataType&gt;</definition>
        <argsstring></argsstring>
        <name>ArrowTypePtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/type_fwd.h" line="31" column="1" bodyfile="/arrow/cpp/src/arrow/compute/type_fwd.h" bodystart="31" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1_1compute_1a3d7741dfdaf5c06817fdbdaa539534a2" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1compute_1_1_expr" kindref="compound">Expr</ref> &gt;</type>
        <definition>using arrow::compute::ExprPtr = typedef std::shared_ptr&lt;Expr&gt;</definition>
        <argsstring></argsstring>
        <name>ExprPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/type_fwd.h" line="32" column="1" bodyfile="/arrow/cpp/src/arrow/compute/type_fwd.h" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1_1compute_1af255a47e73df4040c1239b137018bb89" prot="public" static="no">
        <type>std::shared_ptr&lt; const <ref refid="classarrow_1_1compute_1_1_operation" kindref="compound">Operation</ref> &gt;</type>
        <definition>using arrow::compute::ConstOpPtr = typedef std::shared_ptr&lt;const Operation&gt;</definition>
        <argsstring></argsstring>
        <name>ConstOpPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/type_fwd.h" line="33" column="1" bodyfile="/arrow/cpp/src/arrow/compute/type_fwd.h" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1_1compute_1ac33a552016037f2813983a80b5fcaf50" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1compute_1_1_operation" kindref="compound">Operation</ref> &gt;</type>
        <definition>using arrow::compute::OpPtr = typedef std::shared_ptr&lt;Operation&gt;</definition>
        <argsstring></argsstring>
        <name>OpPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/type_fwd.h" line="34" column="1" bodyfile="/arrow/cpp/src/arrow/compute/type_fwd.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1_1compute_1a21de3825cdde68e67cd591917584b21b" prot="public" static="no">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1compute_1_1_logical_type" kindref="compound">LogicalType</ref> &gt;</type>
        <definition>using arrow::compute::LogicalTypePtr = typedef std::shared_ptr&lt;LogicalType&gt;</definition>
        <argsstring></argsstring>
        <name>LogicalTypePtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/type_fwd.h" line="35" column="1" bodyfile="/arrow/cpp/src/arrow/compute/type_fwd.h" bodystart="35" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacearrow_1_1compute_1ad34e7d4fb82b58ec02b776b0ba7bb30c" prot="public" static="yes" mutable="no">
        <type>CpuInfo *</type>
        <definition>CpuInfo* arrow::compute::cpu_info</definition>
        <argsstring></argsstring>
        <name>cpu_info</name>
        <initializer>= CpuInfo::GetInstance()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="29" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="29" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1a95036735ef4aed21c017c3b37e53a450" prot="public" static="yes" mutable="no">
        <type>const int64_t</type>
        <definition>const int64_t arrow::compute::kL1Size</definition>
        <argsstring></argsstring>
        <name>kL1Size</name>
        <initializer>= cpu_info-&gt;CacheSize(CpuInfo::L1_CACHE)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="31" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="31" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1a84d66d6c7f9789453300d3576b76202a" prot="public" static="yes" mutable="no">
        <type>const int64_t</type>
        <definition>const int64_t arrow::compute::kL2Size</definition>
        <argsstring></argsstring>
        <name>kL2Size</name>
        <initializer>= cpu_info-&gt;CacheSize(CpuInfo::L2_CACHE)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="32" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1a4e8b1ba29ccc0df04973fb9cb2f92d5e" prot="public" static="yes" mutable="no">
        <type>const int64_t</type>
        <definition>const int64_t arrow::compute::kL3Size</definition>
        <argsstring></argsstring>
        <name>kL3Size</name>
        <initializer>= cpu_info-&gt;CacheSize(CpuInfo::L3_CACHE)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="33" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1a98ed624b3d21aff7c18627d4e82ae49a" prot="public" static="yes" mutable="no">
        <type>const int64_t</type>
        <definition>const int64_t arrow::compute::kCantFitInL3Size</definition>
        <argsstring></argsstring>
        <name>kCantFitInL3Size</name>
        <initializer>= kL3Size * 4</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="34" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1a291fdf9e3eb27e8588e8c67fadaea883" prot="public" static="yes" mutable="no">
        <type>const std::vector&lt; int64_t &gt;</type>
        <definition>const std::vector&lt;int64_t&gt; arrow::compute::kMemorySizes</definition>
        <argsstring></argsstring>
        <name>kMemorySizes</name>
        <initializer>= {kL1Size, kL2Size, kL3Size,
                                                  kCantFitInL3Size}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="35" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1a6836fc8750a44e1d54c5950a3dc2f1ca" prot="public" static="no" mutable="no">
        <type>constexpr int64_t</type>
        <definition>constexpr int64_t arrow::compute::kUnknownLength</definition>
        <argsstring></argsstring>
        <name>kUnknownLength</name>
        <initializer>= -1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernel.h" line="68" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernel.h" bodystart="68" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1afb50c66aab2b6d66f9ec4b4a9ac7a9a7" prot="public" static="no" mutable="no">
        <type>const char</type>
        <definition>const char arrow::compute::kValuesFieldName[]</definition>
        <argsstring>[]</argsstring>
        <name>kValuesFieldName</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/hash.h" line="50" column="1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1af37632587e0949231b9b7e2d320c2f83" prot="public" static="no" mutable="no">
        <type>const char</type>
        <definition>const char arrow::compute::kCountsFieldName[]</definition>
        <argsstring>[]</argsstring>
        <name>kCountsFieldName</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/hash.h" line="51" column="1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1ac0ee75b1f2835d78a3a66142b19491aa" prot="public" static="no" mutable="no">
        <type>const int32_t</type>
        <definition>const int32_t arrow::compute::kValuesFieldIndex</definition>
        <argsstring></argsstring>
        <name>kValuesFieldIndex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/hash.h" line="52" column="1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1compute_1a236c42d5a172823c7268ba5b4a86063e" prot="public" static="no" mutable="no">
        <type>const int32_t</type>
        <definition>const int32_t arrow::compute::kCountsFieldIndex</definition>
        <argsstring></argsstring>
        <name>kCountsFieldIndex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/hash.h" line="53" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacearrow_1_1compute_1a471b198ae0c536b6f694f9ca76800cc9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::compute::BenchmarkSetArgsWithSizes</definition>
        <argsstring>(benchmark::internal::Benchmark *bench, const std::vector&lt; int64_t &gt; &amp;sizes=kMemorySizes)</argsstring>
        <name>BenchmarkSetArgsWithSizes</name>
        <param>
          <type>benchmark::internal::Benchmark *</type>
          <declname>bench</declname>
        </param>
        <param>
          <type>const std::vector&lt; int64_t &gt; &amp;</type>
          <declname>sizes</declname>
          <defval>kMemorySizes</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="54" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="54" bodyend="61"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a3e989a6765f48fe18e0febfa4c4e2006" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::compute::BenchmarkSetArgs</definition>
        <argsstring>(benchmark::internal::Benchmark *bench)</argsstring>
        <name>BenchmarkSetArgs</name>
        <param>
          <type>benchmark::internal::Benchmark *</type>
          <declname>bench</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="63" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="63" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a5200d700dfe799b541a272c3c05892c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::compute::RegressionSetArgs</definition>
        <argsstring>(benchmark::internal::Benchmark *bench)</argsstring>
        <name>RegressionSetArgs</name>
        <param>
          <type>benchmark::internal::Benchmark *</type>
          <declname>bench</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="67" column="1" bodyfile="/arrow/cpp/src/arrow/compute/benchmark_util.h" bodystart="67" bodyend="71"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1acb07c5f8cc6b295a7b39681058a1af39" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ObjectType</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool arrow::compute::InheritsFrom</definition>
        <argsstring>(const ObjectType *obj)</argsstring>
        <name>InheritsFrom</name>
        <param>
          <type>const ObjectType *</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/expression.h" line="243" column="1" bodyfile="/arrow/cpp/src/arrow/compute/expression.h" bodystart="243" bodyend="245"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a137884557c4ada6b6c4b9f381fd7165b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename ObjectType</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool arrow::compute::InheritsFrom</definition>
        <argsstring>(const ObjectType &amp;obj)</argsstring>
        <name>InheritsFrom</name>
        <param>
          <type>const ObjectType &amp;</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/expression.h" line="248" column="1" bodyfile="/arrow/cpp/src/arrow/compute/expression.h" bodystart="248" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1abc53dddd8a483d5a242c37aa655c5ddc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::GetScalarExpr</definition>
        <argsstring>(ConstOpPtr op, LogicalTypePtr ty, ExprPtr *out)</argsstring>
        <name>GetScalarExpr</name>
        <param>
          <type><ref refid="namespacearrow_1_1compute_1af255a47e73df4040c1239b137018bb89" kindref="member">ConstOpPtr</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type><ref refid="namespacearrow_1_1compute_1a21de3825cdde68e67cd591917584b21b" kindref="member">LogicalTypePtr</ref></type>
          <declname>ty</declname>
        </param>
        <param>
          <type><ref refid="namespacearrow_1_1compute_1a3d7741dfdaf5c06817fdbdaa539534a2" kindref="member">ExprPtr</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Construct a <ref refid="classarrow_1_1compute_1_1_scalar_expr" kindref="compound">ScalarExpr</ref> containing an <ref refid="classarrow_1_1compute_1_1_operation" kindref="compound">Operation</ref> given a logical type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/expression.h" line="254" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a0444dc9ae8752dfc070c0583106d3193" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::GetArrayExpr</definition>
        <argsstring>(ConstOpPtr op, LogicalTypePtr ty, ExprPtr *out)</argsstring>
        <name>GetArrayExpr</name>
        <param>
          <type><ref refid="namespacearrow_1_1compute_1af255a47e73df4040c1239b137018bb89" kindref="member">ConstOpPtr</ref></type>
          <declname>op</declname>
        </param>
        <param>
          <type><ref refid="namespacearrow_1_1compute_1a21de3825cdde68e67cd591917584b21b" kindref="member">LogicalTypePtr</ref></type>
          <declname>ty</declname>
        </param>
        <param>
          <type><ref refid="namespacearrow_1_1compute_1a3d7741dfdaf5c06817fdbdaa539534a2" kindref="member">ExprPtr</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Construct an <ref refid="classarrow_1_1compute_1_1_array_expr" kindref="compound">ArrayExpr</ref> containing an <ref refid="classarrow_1_1compute_1_1_operation" kindref="compound">Operation</ref> given a logical type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/expression.h" line="258" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a470316e2954130c635ce1858e46d4328" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool arrow::compute::CollectionEquals</definition>
        <argsstring>(const std::vector&lt; Datum &gt; &amp;left, const std::vector&lt; Datum &gt; &amp;right)</argsstring>
        <name>CollectionEquals</name>
        <param>
          <type>const std::vector&lt; <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &gt; &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &gt; &amp;</type>
          <declname>right</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernel.h" line="63" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a24a49ecaa4199b437adbddfe1481f52e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Add</definition>
        <argsstring>(FunctionContext *ctx, const Array &amp;lhs, const Array &amp;rhs, std::shared_ptr&lt; Array &gt; *result)</argsstring>
        <name>Add</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>result</declname>
        </param>
        <briefdescription>
<para>Summarizes two arrays. </para>        </briefdescription>
        <detaileddescription>
<para>Summarizes two arrays with the same length. The output is an array with same length and type as input. Types of both input arrays should be equal</para><para>For example given lhs = [1, null, 3], rhs = [4, 5, 6], the output will be [5, null, 7]</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">lhs</parametername>
</parameternamelist>
<parameterdescription>
<para>the first array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>the second array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">result</parametername>
</parameternamelist>
<parameterdescription>
<para>the sum of first and second arrays </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/add.h" line="49" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a157d9c73ff1d5c9730a3f9fbb2a91286" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Invert</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;value, Datum *out)</argsstring>
        <name>Invert</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Invert the values of a boolean datum. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">value</parametername>
</parameternamelist>
<parameterdescription>
<para>datum to invert </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.11.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/boolean.h" line="37" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a1effccba3cfc4b88a01a9ed5d0338db6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::And</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;left, const Datum &amp;right, Datum *out)</argsstring>
        <name>And</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Element-wise AND of two boolean datums which always propagates nulls (null and false is null). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">left</parametername>
</parameternamelist>
<parameterdescription>
<para>left operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">right</parametername>
</parameternamelist>
<parameterdescription>
<para>right operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.11.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/boolean.h" line="50" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1ad3b66852874f97dedaae34b17a94f2ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::KleeneAnd</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;left, const Datum &amp;right, Datum *out)</argsstring>
        <name>KleeneAnd</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Element-wise AND of two boolean datums with a Kleene truth table (null and false is false). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">left</parametername>
</parameternamelist>
<parameterdescription>
<para>left operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">right</parametername>
</parameternamelist>
<parameterdescription>
<para>right operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>1.0.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/boolean.h" line="63" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a5c42e1e03467da2a48e841a1337be7f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Or</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;left, const Datum &amp;right, Datum *out)</argsstring>
        <name>Or</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Element-wise OR of two boolean datums which always propagates nulls (null and true is null). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">left</parametername>
</parameternamelist>
<parameterdescription>
<para>left operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">right</parametername>
</parameternamelist>
<parameterdescription>
<para>right operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.11.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/boolean.h" line="77" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a5aefdd5a0890cf0824bdbc6f7e7ec561" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::KleeneOr</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;left, const Datum &amp;right, Datum *out)</argsstring>
        <name>KleeneOr</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Element-wise OR of two boolean datums with a Kleene truth table (null or true is true). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">left</parametername>
</parameternamelist>
<parameterdescription>
<para>left operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">right</parametername>
</parameternamelist>
<parameterdescription>
<para>right operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>1.0.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/boolean.h" line="90" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a4af0c55adb14f8e018227e4575e0aa38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Xor</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;left, const Datum &amp;right, Datum *out)</argsstring>
        <name>Xor</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Element-wise XOR of two boolean datums. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">left</parametername>
</parameternamelist>
<parameterdescription>
<para>left operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">right</parametername>
</parameternamelist>
<parameterdescription>
<para>right operand (array) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.11.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/boolean.h" line="102" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a1b785d94aca34a10de4d1218a2b924a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::GetCastFunction</definition>
        <argsstring>(const DataType &amp;in_type, std::shared_ptr&lt; DataType &gt; to_type, const CastOptions &amp;options, std::unique_ptr&lt; UnaryKernel &gt; *kernel)</argsstring>
        <name>GetCastFunction</name>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>in_type</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
          <declname>to_type</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">CastOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1compute_1_1_unary_kernel" kindref="compound">UnaryKernel</ref> &gt; *</type>
          <declname>kernel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="since"><para>0.7.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/cast.h" line="70" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a87994288b6e4b96a52d9fc32e579c9ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Cast</definition>
        <argsstring>(FunctionContext *context, const Array &amp;value, std::shared_ptr&lt; DataType &gt; to_type, const CastOptions &amp;options, std::shared_ptr&lt; Array &gt; *out)</argsstring>
        <name>Cast</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
          <declname>to_type</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">CastOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Cast from one array type to another. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">value</parametername>
</parameternamelist>
<parameterdescription>
<para>array to cast </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to_type</parametername>
</parameternamelist>
<parameterdescription>
<para>type to cast to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>casting options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting array</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.7.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/cast.h" line="83" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1adf6a3d4dda9ae8624603cea6da76dc55" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Cast</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;value, std::shared_ptr&lt; DataType &gt; to_type, const CastOptions &amp;options, Datum *out)</argsstring>
        <name>Cast</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt;</type>
          <declname>to_type</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_cast_options" kindref="compound">CastOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Cast from one value to another. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">value</parametername>
</parameternamelist>
<parameterdescription>
<para>datum to cast </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">to_type</parametername>
</parameternamelist>
<parameterdescription>
<para>type to cast to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>casting options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.8.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/cast.h" line="97" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1ae97e791761922ec76882bdca17c08808" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::MakeCompareKernel</definition>
        <argsstring>(const DataType &amp;type, CompareOptions options, std::shared_ptr&lt; BinaryKernel &gt; *out)</argsstring>
        <name>MakeCompareKernel</name>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_compare_options" kindref="compound">CompareOptions</ref></type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1compute_1_1_binary_kernel" kindref="compound">BinaryKernel</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para><ref refid="classarrow_1_1compute_1_1_binary_kernel" kindref="compound">BinaryKernel</ref> bound implementing comparison. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/compare.h" line="51" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1aaa7e88adfcea48dd0aaec2d14a9d85ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Compare</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;left, const Datum &amp;right, struct CompareOptions options, Datum *out)</argsstring>
        <name>Compare</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type>struct <ref refid="structarrow_1_1compute_1_1_compare_options" kindref="compound">CompareOptions</ref></type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Compare a numeric array with a scalar. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">left</parametername>
</parameternamelist>
<parameterdescription>
<para>datum to compare, must be an <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">right</parametername>
</parameternamelist>
<parameterdescription>
<para>datum to compare, must be a <ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> of the same type than left <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>compare options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
Note on floating point arrays, this uses ieee-754 compare semantics.</para><para><simplesect kind="since"><para>0.14.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/compare.h" line="68" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1ae585e5596b3e5c70eef8a916be23e7cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1compute_1_1_aggregate_function" kindref="compound">AggregateFunction</ref> &gt;</type>
        <definition>std::shared_ptr&lt;AggregateFunction&gt; arrow::compute::MakeCount</definition>
        <argsstring>(FunctionContext *context, const CountOptions &amp;options)</argsstring>
        <name>MakeCount</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_count_options" kindref="compound">CountOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
<para>Return Count function aggregate. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/count.h" line="58" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1aa409c2094425f36d0d41f0c1d3335bac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Count</definition>
        <argsstring>(FunctionContext *context, const CountOptions &amp;options, const Datum &amp;datum, Datum *out)</argsstring>
        <name>Count</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_count_options" kindref="compound">CountOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>datum</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Count non-null (or null) values in an array. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>counting options, see <ref refid="structarrow_1_1compute_1_1_count_options" kindref="compound">CountOptions</ref> for more information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">datum</parametername>
</parameternamelist>
<parameterdescription>
<para>to count </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.13.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/count.h" line="71" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a775549b0138d5cc4f9b1d3380852b771" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Count</definition>
        <argsstring>(FunctionContext *context, const CountOptions &amp;options, const Array &amp;array, Datum *out)</argsstring>
        <name>Count</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_count_options" kindref="compound">CountOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>array</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Count non-null (or null) values in an array. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>counting options, see <ref refid="structarrow_1_1compute_1_1_count_options" kindref="compound">CountOptions</ref> for more information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">array</parametername>
</parameternamelist>
<parameterdescription>
<para>to count </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.13.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/count.h" line="84" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a5197379391d1425601f697bc949d7229" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Filter</definition>
        <argsstring>(FunctionContext *ctx, const Datum &amp;values, const Datum &amp;filter, FilterOptions options, Datum *out)</argsstring>
        <name>Filter</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>filter</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_filter_options" kindref="compound">FilterOptions</ref></type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Filter with a boolean selection filter. </para>        </briefdescription>
        <detaileddescription>
<para>The output will be populated with values from the input at positions where the selection filter is not 0. Nulls in the filter will be handled based on options.null_selection_behavior.</para><para>For example given values = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, null, &quot;e&quot;, &quot;f&quot;] and filter = [0, 1, 1, 0, null, 1], the output will be (null_selection_behavior == DROP) = [&quot;b&quot;, &quot;c&quot;, &quot;f&quot;] (null_selection_behavior == EMIT_NULL) = [&quot;b&quot;, &quot;c&quot;, null, &quot;f&quot;]</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">values</parametername>
</parameternamelist>
<parameterdescription>
<para>array to filter </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">filter</parametername>
</parameternamelist>
<parameterdescription>
<para>indicates which values should be filtered out </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>configures null_selection_behavior </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting array </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/filter.h" line="65" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a9d011093aecc73991bc11f65c4d0acb2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Unique</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;datum, std::shared_ptr&lt; Array &gt; *out)</argsstring>
        <name>Unique</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>datum</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Compute unique elements from an array-like object. </para>        </briefdescription>
        <detaileddescription>
<para>Note if a null occurs in the input it will NOT be included in the output.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">datum</parametername>
</parameternamelist>
<parameterdescription>
<para>array-like input </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>result as <ref refid="classarrow_1_1_array" kindref="compound">Array</ref></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.8.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/hash.h" line="47" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1adca33d8dd6bff7dd79ceec269c86ff53" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::ValueCounts</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;value, std::shared_ptr&lt; Array &gt; *counts)</argsstring>
        <name>ValueCounts</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>counts</declname>
        </param>
        <briefdescription>
<para>Return counts of unique elements from an array-like object. </para>        </briefdescription>
        <detaileddescription>
<para>Note that the counts do not include counts for nulls in the array. These can be obtained separately from metadata.</para><para>For floating point arrays there is no attempt to normalize -0.0, 0.0 and NaN values which can lead to unexpected results if the input <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> has these values.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">value</parametername>
</parameternamelist>
<parameterdescription>
<para>array-like input </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">counts</parametername>
</parameternamelist>
<parameterdescription>
<para>An array of &lt;input type &quot;Values&quot;, int64_t &quot;Counts&quot;&gt; structs.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.13.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/hash.h" line="69" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1abb320b25453cee69ed5c8048bd0e0df4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::DictionaryEncode</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;data, Datum *out)</argsstring>
        <name>DictionaryEncode</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Dictionary-encode values in an array-like object. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>array-like input </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>result with same shape and type as input</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.8.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/hash.h" line="80" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a10a7275ae0354ddfaa7ffe0d139497c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::IsIn</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;left, const Datum &amp;right, Datum *out)</argsstring>
        <name>IsIn</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>left</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>right</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>IsIn returns boolean values if the value is in both left and right arrays. </para>        </briefdescription>
        <detaileddescription>
<para>If null occurs in left, if null count in right is not 0, it returns true, else returns null.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">left</parametername>
</parameternamelist>
<parameterdescription>
<para>array-like input </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">right</parametername>
</parameternamelist>
<parameterdescription>
<para>array-like input </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>1.0.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/isin.h" line="46" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a26d08b4fa6b95a86ea4a0808064c7cb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Match</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;haystack, const Datum &amp;needles, Datum *out)</argsstring>
        <name>Match</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>haystack</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>needles</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Match examines each slot in the haystack against a needles array. </para>        </briefdescription>
        <detaileddescription>
<para>If the value is not found in needles, null will be output. If found, the index of occurrence within needles (ignoring duplicates) will be output.</para><para>For example given haystack = [99, 42, 3, null] and needles = [3, 3, 99], the output will be = [1, null, 0, null]</para><para>Note: Null in the haystack is considered to match a null in the needles array. For example given haystack = [99, 42, 3, null] and needles = [3, 99, null], the output will be = [1, null, 0, 2]</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">haystack</parametername>
</parameternamelist>
<parameterdescription>
<para>array-like input </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">needles</parametername>
</parameternamelist>
<parameterdescription>
<para>array-like input </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>1.0.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/match.h" line="53" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1ae1d9f7d89aaf495af9979791980edb84" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1compute_1_1_aggregate_function" kindref="compound">AggregateFunction</ref> &gt;</type>
        <definition>std::shared_ptr&lt;AggregateFunction&gt; arrow::compute::MakeMeanAggregateFunction</definition>
        <argsstring>(const DataType &amp;type, FunctionContext *context)</argsstring>
        <name>MakeMeanAggregateFunction</name>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/mean.h" line="40" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a51444316ac3eb35a81962e50b17d4967" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Mean</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;value, Datum *mean)</argsstring>
        <name>Mean</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>mean</declname>
        </param>
        <briefdescription>
<para>Compute the mean of a numeric array. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">value</parametername>
</parameternamelist>
<parameterdescription>
<para>datum to compute the mean, expecting <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">mean</parametername>
</parameternamelist>
<parameterdescription>
<para>datum of the computed mean as a <ref refid="structarrow_1_1_double_scalar" kindref="compound">DoubleScalar</ref></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.13.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/mean.h" line="52" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a7087b36a0180f6f86d4aa8a9fac3195b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Mean</definition>
        <argsstring>(FunctionContext *context, const Array &amp;array, Datum *mean)</argsstring>
        <name>Mean</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>array</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>mean</declname>
        </param>
        <briefdescription>
<para>Compute the mean of a numeric array. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">array</parametername>
</parameternamelist>
<parameterdescription>
<para>to compute the mean </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">mean</parametername>
</parameternamelist>
<parameterdescription>
<para>datum of the computed mean as a <ref refid="structarrow_1_1_double_scalar" kindref="compound">DoubleScalar</ref></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.13.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/mean.h" line="63" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1ae64fb43adf02634e081f5ae1a79edaf9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1compute_1_1_aggregate_function" kindref="compound">AggregateFunction</ref> &gt;</type>
        <definition>std::shared_ptr&lt;AggregateFunction&gt; arrow::compute::MakeMinMaxAggregateFunction</definition>
        <argsstring>(const DataType &amp;type, FunctionContext *ctx, const MinMaxOptions &amp;options)</argsstring>
        <name>MakeMinMaxAggregateFunction</name>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_min_max_options" kindref="compound">MinMaxOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
<para>Return a Min/Max Kernel. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>required to specialize the kernel </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>see <ref refid="structarrow_1_1compute_1_1_min_max_options" kindref="compound">MinMaxOptions</ref> for more information</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>1.0.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/minmax.h" line="62" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a4d6120ab7c72a0d165a5877cf989c427" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::MinMax</definition>
        <argsstring>(FunctionContext *ctx, const MinMaxOptions &amp;options, const Datum &amp;value, Datum *out)</argsstring>
        <name>MinMax</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_min_max_options" kindref="compound">MinMaxOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Calculate the min / max of a numeric array. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns both the min and max as a collection. The resulting datum thus consists of two scalar datums: {Datum(min), Datum(max)}</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>see <ref refid="structarrow_1_1compute_1_1_min_max_options" kindref="compound">MinMaxOptions</ref> for more information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">value</parametername>
</parameternamelist>
<parameterdescription>
<para>input datum, expecting <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> or <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum containing a {min, max} collection</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>1.0.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/minmax.h" line="78" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a441ab4f2826ce3134b2ab3ef633e48d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::MinMax</definition>
        <argsstring>(FunctionContext *ctx, const MinMaxOptions &amp;options, const Array &amp;array, Datum *out)</argsstring>
        <name>MinMax</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_min_max_options" kindref="compound">MinMaxOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>array</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Calculate the min / max of a numeric array. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns both the min and max as a collection. The resulting datum thus consists of two scalar datums: {Datum(min), Datum(max)}</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>see <ref refid="structarrow_1_1compute_1_1_min_max_options" kindref="compound">MinMaxOptions</ref> for more information </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">array</parametername>
</parameternamelist>
<parameterdescription>
<para>input array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum containing a {min, max} collection</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>1.0.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/minmax.h" line="94" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a2fd15eaffbeacdd13089d8f62baec745" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::NthToIndices</definition>
        <argsstring>(FunctionContext *ctx, const Array &amp;values, int64_t n, std::shared_ptr&lt; Array &gt; *offsets)</argsstring>
        <name>NthToIndices</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>offsets</declname>
        </param>
        <briefdescription>
<para>Returns indices that partition an array around n-th sorted element. </para>        </briefdescription>
        <detaileddescription>
<para>Find index of n-th(0 based) smallest value and perform indirect partition of an array around that element. Output indices[0 ~ n-1] holds values no greater than n-th element, and indices[n+1 ~ end] holds values no less than n-th element. Elements in each partition is not sorted. Nulls will be partitioned to the end of the output. Output is not guaranteed to be stable.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">values</parametername>
</parameternamelist>
<parameterdescription>
<para>array to be partitioned </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">n</parametername>
</parameternamelist>
<parameterdescription>
<para>pivot array around sorted n-th element </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">offsets</parametername>
</parameternamelist>
<parameterdescription>
<para>indices that would partition an array </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/nth_to_indices.h" line="49" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a0cd113ddac905f26ddbbda6bfde05fce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::SortToIndices</definition>
        <argsstring>(FunctionContext *ctx, const Array &amp;values, std::shared_ptr&lt; Array &gt; *offsets)</argsstring>
        <name>SortToIndices</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>offsets</declname>
        </param>
        <briefdescription>
<para>Returns the indices that would sort an array. </para>        </briefdescription>
        <detaileddescription>
<para>Perform an indirect sort of array. The output array will contain indices that would sort an array, which would be the same length as input. Nulls will be stably partitioned to the end of the output.</para><para>For example given values = [null, 1, 3.3, null, 2, 5.3], the output will be [1, 4, 2, 5, 0, 3]</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">values</parametername>
</parameternamelist>
<parameterdescription>
<para>array to sort </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">offsets</parametername>
</parameternamelist>
<parameterdescription>
<para>indices that would sort an array </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/sort_to_indices.h" line="47" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a2017d598da196b7ae05c13dc28be6176" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1compute_1_1_aggregate_function" kindref="compound">AggregateFunction</ref> &gt;</type>
        <definition>std::shared_ptr&lt;AggregateFunction&gt; arrow::compute::MakeSumAggregateFunction</definition>
        <argsstring>(const DataType &amp;type, FunctionContext *context)</argsstring>
        <name>MakeSumAggregateFunction</name>
        <param>
          <type>const <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <briefdescription>
<para>Return a Sum Kernel. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">type</parametername>
</parameternamelist>
<parameterdescription>
<para>required to specialize the kernel </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref></para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.13.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/sum.h" line="45" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a4a3c165266ec1c0ed5fcbb23aca1d3e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Sum</definition>
        <argsstring>(FunctionContext *context, const Datum &amp;value, Datum *out)</argsstring>
        <name>Sum</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Sum values of a numeric array. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">value</parametername>
</parameternamelist>
<parameterdescription>
<para>datum to sum, expecting <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> or <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.13.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/sum.h" line="57" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1ab2b126c5b3c01992813c7856915255b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Sum</definition>
        <argsstring>(FunctionContext *context, const Array &amp;array, Datum *out)</argsstring>
        <name>Sum</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>context</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>array</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Sum values of a numeric array. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">context</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">array</parametername>
</parameternamelist>
<parameterdescription>
<para>to sum </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="since"><para>0.13.0 </para></simplesect>
<simplesect kind="note"><para>API not yet finalized </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/sum.h" line="68" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a92e2888270afb2c338802c68199f1fc5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Take</definition>
        <argsstring>(FunctionContext *ctx, const Array &amp;values, const Array &amp;indices, const TakeOptions &amp;options, std::shared_ptr&lt; Array &gt; *out)</argsstring>
        <name>Take</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_take_options" kindref="compound">TakeOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Take from an array of values at indices in another array. </para>        </briefdescription>
        <detaileddescription>
<para>The output array will be of the same type as the input values array, with elements taken from the values array at the given indices. If an index is null then the taken element will be null.</para><para>For example given values = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, null, &quot;e&quot;, &quot;f&quot;] and indices = [2, 1, null, 3], the output will be = [values[2], values[1], null, values[3]] = [&quot;c&quot;, &quot;b&quot;, null, null]</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">values</parametername>
</parameternamelist>
<parameterdescription>
<para>array from which to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">indices</parametername>
</parameternamelist>
<parameterdescription>
<para>which values to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting array </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take.h" line="53" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a5086b6a69e6c1df3872312cfd61b282a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Take</definition>
        <argsstring>(FunctionContext *ctx, const ChunkedArray &amp;values, const Array &amp;indices, const TakeOptions &amp;options, std::shared_ptr&lt; ChunkedArray &gt; *out)</argsstring>
        <name>Take</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_take_options" kindref="compound">TakeOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Take from a chunked array of values at indices in another array. </para>        </briefdescription>
        <detaileddescription>
<para>The output chunked array will be of the same type as the input values array, with elements taken from the values array at the given indices. If an index is null then the taken element will be null.</para><para>For example given values = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, null, &quot;e&quot;, &quot;f&quot;] and indices = [2, 1, null, 3], the output will be = [values[2], values[1], null, values[3]] = [&quot;c&quot;, &quot;b&quot;, null, null]</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">values</parametername>
</parameternamelist>
<parameterdescription>
<para>chunked array from which to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">indices</parametername>
</parameternamelist>
<parameterdescription>
<para>which values to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting chunked array NOTE: Experimental API </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take.h" line="74" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1aec8d450c9eba5448bdc64763155f3b8d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Take</definition>
        <argsstring>(FunctionContext *ctx, const ChunkedArray &amp;values, const ChunkedArray &amp;indices, const TakeOptions &amp;options, std::shared_ptr&lt; ChunkedArray &gt; *out)</argsstring>
        <name>Take</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_take_options" kindref="compound">TakeOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Take from a chunked array of values at indices in a chunked array. </para>        </briefdescription>
        <detaileddescription>
<para>The output chunked array will be of the same type as the input values array, with elements taken from the values array at the given indices. If an index is null then the taken element will be null. The chunks in the output array will align with the chunks in the indices.</para><para>For example given values = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, null, &quot;e&quot;, &quot;f&quot;] and indices = [2, 1, null, 3], the output will be = [values[2], values[1], null, values[3]] = [&quot;c&quot;, &quot;b&quot;, null, null]</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">values</parametername>
</parameternamelist>
<parameterdescription>
<para>chunked array from which to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">indices</parametername>
</parameternamelist>
<parameterdescription>
<para>which values to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting chunked array NOTE: Experimental API </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take.h" line="96" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a687b6cdf1dbf2a23a7bea26225fbd0ad" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Take</definition>
        <argsstring>(FunctionContext *ctx, const Array &amp;values, const ChunkedArray &amp;indices, const TakeOptions &amp;options, std::shared_ptr&lt; ChunkedArray &gt; *out)</argsstring>
        <name>Take</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_take_options" kindref="compound">TakeOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Take from an array of values at indices in a chunked array. </para>        </briefdescription>
        <detaileddescription>
<para>The output chunked array will be of the same type as the input values array, with elements taken from the values array at the given indices. If an index is null then the taken element will be null. The chunks in the output array will align with the chunks in the indices.</para><para>For example given values = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, null, &quot;e&quot;, &quot;f&quot;] and indices = [2, 1, null, 3], the output will be = [values[2], values[1], null, values[3]] = [&quot;c&quot;, &quot;b&quot;, null, null]</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">values</parametername>
</parameternamelist>
<parameterdescription>
<para>array from which to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">indices</parametername>
</parameternamelist>
<parameterdescription>
<para>which values to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting chunked array NOTE: Experimental API </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take.h" line="118" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a9d0baa336e53dc8ee574661ea65702cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Take</definition>
        <argsstring>(FunctionContext *ctx, const RecordBatch &amp;batch, const Array &amp;indices, const TakeOptions &amp;options, std::shared_ptr&lt; RecordBatch &gt; *out)</argsstring>
        <name>Take</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_take_options" kindref="compound">TakeOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Take from a record batch at indices in another array. </para>        </briefdescription>
        <detaileddescription>
<para>The output batch will have the same schema as the input batch, with rows taken from the columns in the batch at the given indices. If an index is null then the taken element will be null.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">batch</parametername>
</parameternamelist>
<parameterdescription>
<para>record batch from which to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">indices</parametername>
</parameternamelist>
<parameterdescription>
<para>which values to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting record batch NOTE: Experimental API </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take.h" line="134" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1ac7a653cee8ae18d2320c1c5d09678da7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Take</definition>
        <argsstring>(FunctionContext *ctx, const Table &amp;table, const Array &amp;indices, const TakeOptions &amp;options, std::shared_ptr&lt; Table &gt; *out)</argsstring>
        <name>Take</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &amp;</type>
          <declname>table</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_take_options" kindref="compound">TakeOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Take from a table at indices in an array. </para>        </briefdescription>
        <detaileddescription>
<para>The output table will have the same schema as the input table, with rows taken from the columns in the table at the given indices. If an index is null then the taken element will be null.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">table</parametername>
</parameternamelist>
<parameterdescription>
<para>table from which to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">indices</parametername>
</parameternamelist>
<parameterdescription>
<para>which values to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting table NOTE: Experimental API </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take.h" line="150" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a04f77351bea35215d159e1c03e975171" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Take</definition>
        <argsstring>(FunctionContext *ctx, const Table &amp;table, const ChunkedArray &amp;indices, const TakeOptions &amp;options, std::shared_ptr&lt; Table &gt; *out)</argsstring>
        <name>Take</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &amp;</type>
          <declname>table</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_chunked_array" kindref="compound">ChunkedArray</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_take_options" kindref="compound">TakeOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_table" kindref="compound">Table</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Take from a table at indices in a chunked array. </para>        </briefdescription>
        <detaileddescription>
<para>The output table will have the same schema as the input table, with rows taken from the values array at the given indices. If an index is null then the taken element will be null.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">table</parametername>
</parameternamelist>
<parameterdescription>
<para>table from which to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">indices</parametername>
</parameternamelist>
<parameterdescription>
<para>which values to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting table NOTE: Experimental API </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take.h" line="166" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a0d28ff5bd18aa2eebe0a596db758c3bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::Take</definition>
        <argsstring>(FunctionContext *ctx, const Datum &amp;values, const Datum &amp;indices, const TakeOptions &amp;options, Datum *out)</argsstring>
        <name>Take</name>
        <param>
          <type><ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> &amp;</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1compute_1_1_take_options" kindref="compound">TakeOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1compute_1_1_datum" kindref="compound">Datum</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Take from an array of values at indices in another array. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1compute_1_1_function_context" kindref="compound">FunctionContext</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">values</parametername>
</parameternamelist>
<parameterdescription>
<para>datum from which to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">indices</parametername>
</parameternamelist>
<parameterdescription>
<para>which values to take </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">out</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting datum </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take.h" line="177" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a6b83d87abdd1f9f5db74a153459f082e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Builder</type>
          </param>
          <param>
            <type>typename Scalar</type>
          </param>
        </templateparamlist>
        <type><ref refid="namespacearrow_1_1compute_1ade436c20161be56a69cde0c8e044bd0e" kindref="member">enable_if_not_base_binary</ref>&lt; typename Builder::TypeClass, <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> &gt;</type>
        <definition>static enable_if_not_base_binary&lt;typename Builder::TypeClass, Status&gt; arrow::compute::UnsafeAppend</definition>
        <argsstring>(Builder *builder, Scalar &amp;&amp;value)</argsstring>
        <name>UnsafeAppend</name>
        <param>
          <type>Builder *</type>
          <declname>builder</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_scalar" kindref="compound">Scalar</ref> &amp;&amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" line="47" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" bodystart="47" bodyend="51"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1abe4f5deed6bf93eca2c05326b412b8ca" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Builder</type>
          </param>
        </templateparamlist>
        <type><ref refid="namespacearrow_1a5adfa6f41eb212d569e8c644b9815bd8" kindref="member">enable_if_base_binary</ref>&lt; typename Builder::TypeClass, <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> &gt;</type>
        <definition>static enable_if_base_binary&lt;typename Builder::TypeClass, Status&gt; arrow::compute::UnsafeAppend</definition>
        <argsstring>(Builder *builder, util::string_view value)</argsstring>
        <name>UnsafeAppend</name>
        <param>
          <type>Builder *</type>
          <declname>builder</declname>
        </param>
        <param>
          <type>util::string_view</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" line="55" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" bodystart="55" bodyend="60"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1ac520849fea358849b66f86a378d540dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>SomeIndicesNull</declname>
            <defname>SomeIndicesNull</defname>
          </param>
          <param>
            <type>bool</type>
            <declname>SomeValuesNull</declname>
            <defname>SomeValuesNull</defname>
          </param>
          <param>
            <type>bool</type>
            <declname>NeverOutOfBounds</declname>
            <defname>NeverOutOfBounds</defname>
          </param>
          <param>
            <type>typename IndexSequence</type>
          </param>
          <param>
            <type>typename Visitor</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::VisitIndices</definition>
        <argsstring>(IndexSequence indices, const Array &amp;values, Visitor &amp;&amp;vis)</argsstring>
        <name>VisitIndices</name>
        <param>
          <type>IndexSequence</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>Visitor &amp;&amp;</type>
          <declname>vis</declname>
        </param>
        <briefdescription>
<para>visit indices from an IndexSequence while bounds checking </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">indices</parametername>
</parameternamelist>
<parameterdescription>
<para>IndexSequence to visit </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">values</parametername>
</parameternamelist>
<parameterdescription>
<para>array to bounds check against, if necessary </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vis</parametername>
</parameternamelist>
<parameterdescription>
<para>index visitor, signature must be Status(int64_t index, bool is_valid) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" line="69" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" bodystart="69" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a8cdcf44c088f89cf0c2ea88bcac9f9b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>SomeIndicesNull</declname>
            <defname>SomeIndicesNull</defname>
          </param>
          <param>
            <type>bool</type>
            <declname>SomeValuesNull</declname>
            <defname>SomeValuesNull</defname>
          </param>
          <param>
            <type>typename IndexSequence</type>
          </param>
          <param>
            <type>typename Visitor</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::VisitIndices</definition>
        <argsstring>(IndexSequence indices, const Array &amp;values, Visitor &amp;&amp;vis)</argsstring>
        <name>VisitIndices</name>
        <param>
          <type>IndexSequence</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>Visitor &amp;&amp;</type>
          <declname>vis</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" line="95" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" bodystart="95" bodyend="102"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1abdf5e5f83e0bcd94bec510d8befbfaff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>SomeIndicesNull</declname>
            <defname>SomeIndicesNull</defname>
          </param>
          <param>
            <type>typename IndexSequence</type>
          </param>
          <param>
            <type>typename Visitor</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::VisitIndices</definition>
        <argsstring>(IndexSequence indices, const Array &amp;values, Visitor &amp;&amp;vis)</argsstring>
        <name>VisitIndices</name>
        <param>
          <type>IndexSequence</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>Visitor &amp;&amp;</type>
          <declname>vis</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" line="105" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" bodystart="105" bodyend="111"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a22e30e069b176830d83b3175738735fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename IndexSequence</type>
          </param>
          <param>
            <type>typename Visitor</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::compute::VisitIndices</definition>
        <argsstring>(IndexSequence indices, const Array &amp;values, Visitor &amp;&amp;vis)</argsstring>
        <name>VisitIndices</name>
        <param>
          <type>IndexSequence</type>
          <declname>indices</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &amp;</type>
          <declname>values</declname>
        </param>
        <param>
          <type>Visitor &amp;&amp;</type>
          <declname>vis</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" line="114" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernels/take_internal.h" bodystart="114" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1compute_1a0a080da83ef6ec822887b3e86bd3d0e4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void arrow::compute::ZeroCopyData</definition>
        <argsstring>(const ArrayData &amp;input, ArrayData *output)</argsstring>
        <name>ZeroCopyData</name>
        <param>
          <type>const <ref refid="structarrow_1_1_array_data" kindref="compound">ArrayData</ref> &amp;</type>
          <declname>input</declname>
        </param>
        <param>
          <type><ref refid="structarrow_1_1_array_data" kindref="compound">ArrayData</ref> *</type>
          <declname>output</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/compute/kernels/util_internal.h" line="36" column="1" bodyfile="/arrow/cpp/src/arrow/compute/kernels/util_internal.h" bodystart="36" bodyend="42"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/arrow/cpp/src/arrow/compute/benchmark_util.h" line="26" column="1"/>
  </compounddef>
</doxygen>
