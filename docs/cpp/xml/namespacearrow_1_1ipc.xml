<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacearrow_1_1ipc" kind="namespace" language="C++">
    <compoundname>arrow::ipc</compoundname>
    <innerclass refid="classarrow_1_1ipc_1_1_assign_message_decoder_listener" prot="public">arrow::ipc::AssignMessageDecoderListener</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_collect_listener" prot="public">arrow::ipc::CollectListener</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_dictionary_memo" prot="public">arrow::ipc::DictionaryMemo</innerclass>
    <innerclass refid="structarrow_1_1ipc_1_1_ipc_read_options" prot="public">arrow::ipc::IpcReadOptions</innerclass>
    <innerclass refid="structarrow_1_1ipc_1_1_ipc_write_options" prot="public">arrow::ipc::IpcWriteOptions</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_listener" prot="public">arrow::ipc::Listener</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_message" prot="public">arrow::ipc::Message</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_message_decoder" prot="public">arrow::ipc::MessageDecoder</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_message_decoder_listener" prot="public">arrow::ipc::MessageDecoderListener</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_message_reader" prot="public">arrow::ipc::MessageReader</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_record_batch_file_reader" prot="public">arrow::ipc::RecordBatchFileReader</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_record_batch_file_writer" prot="public">arrow::ipc::RecordBatchFileWriter</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_record_batch_stream_reader" prot="public">arrow::ipc::RecordBatchStreamReader</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_record_batch_stream_writer" prot="public">arrow::ipc::RecordBatchStreamWriter</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_record_batch_writer" prot="public">arrow::ipc::RecordBatchWriter</innerclass>
    <innerclass refid="classarrow_1_1ipc_1_1_stream_decoder" prot="public">arrow::ipc::StreamDecoder</innerclass>
    <innernamespace refid="namespacearrow_1_1ipc_1_1feather">arrow::ipc::feather</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacearrow_1_1ipc_1aa5d7ec68a8c707271bab98af9bc0ac77" prot="public" static="no">
        <name>MetadataVersion</name>
        <enumvalue id="namespacearrow_1_1ipc_1aa5d7ec68a8c707271bab98af9bc0ac77ab4daca084ad9eabfc8de231929477ed6" prot="public">
          <name>V1</name>
          <briefdescription>
<para>0.1.0 </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1_1ipc_1aa5d7ec68a8c707271bab98af9bc0ac77aec765f1adc3b4253f2d3b131a4a8618f" prot="public">
          <name>V2</name>
          <briefdescription>
<para>0.2.0 </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1_1ipc_1aa5d7ec68a8c707271bab98af9bc0ac77ad5b50b8cf96bcc8aba90f306f5e6189c" prot="public">
          <name>V3</name>
          <briefdescription>
<para>0.3.0 to 0.7.1 </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacearrow_1_1ipc_1aa5d7ec68a8c707271bab98af9bc0ac77ab354cab57768c7d4c1106eb4e82c75dc" prot="public">
          <name>V4</name>
          <briefdescription>
<para>&gt;= 0.8.0 </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="48" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/message.h" bodystart="48" bodyend="60"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacearrow_1_1ipc_1ac4462a1d18d35a0a17f3f6333d83cb3f" prot="public" static="no">
        <type>std::unordered_map&lt; int64_t, std::shared_ptr&lt; <ref refid="classarrow_1_1_array" kindref="compound">Array</ref> &gt; &gt;</type>
        <definition>using arrow::ipc::DictionaryMap = typedef std::unordered_map&lt;int64_t, std::shared_ptr&lt;Array&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>DictionaryMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/dictionary.h" line="39" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/dictionary.h" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1_1ipc_1aee79ddda7a0a3d90586d80bb47fa1eed" prot="public" static="no">
        <type><ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref></type>
        <definition>using arrow::ipc::IpcOptions = typedef IpcWriteOptions</definition>
        <argsstring></argsstring>
        <name>IpcOptions</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/options.h" line="72" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/options.h" bodystart="72" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacearrow_1_1ipc_1a6eae3918b2e6c0c4e1f56e083187a339" prot="public" static="no">
        <type>::<ref refid="classarrow_1_1_record_batch_reader" kindref="compound">arrow::RecordBatchReader</ref></type>
        <definition>using arrow::ipc::RecordBatchReader = typedef ::arrow::RecordBatchReader</definition>
        <argsstring></argsstring>
        <name>RecordBatchReader</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="60" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/reader.h" bodystart="60" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacearrow_1_1ipc_1a2dfe6a86ac11df4637223d48d29111a9" prot="public" static="no" mutable="no">
        <type>constexpr int</type>
        <definition>constexpr int arrow::ipc::kMaxNestingDepth</definition>
        <argsstring></argsstring>
        <name>kMaxNestingDepth</name>
        <initializer>= 64</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/options.h" line="36" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/options.h" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1ipc_1a53f1f48da8f5d293e8d3fb1e0bc19800" prot="public" static="yes" mutable="no">
        <type>constexpr int32_t</type>
        <definition>constexpr int32_t arrow::ipc::kArrowAlignment</definition>
        <argsstring></argsstring>
        <name>kArrowAlignment</name>
        <initializer>= 64</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/util.h" line="30" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/util.h" bodystart="30" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1ipc_1aa526c87df755f3a06f0b608926dc3e0a" prot="public" static="yes" mutable="no">
        <type>constexpr int32_t</type>
        <definition>constexpr int32_t arrow::ipc::kTensorAlignment</definition>
        <argsstring></argsstring>
        <name>kTensorAlignment</name>
        <initializer>= 64</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/util.h" line="33" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/util.h" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1ipc_1a0931eb8de5adfb80b1dbc415dde807fe" prot="public" static="yes" mutable="no">
        <type>constexpr int32_t</type>
        <definition>constexpr int32_t arrow::ipc::kArrowIpcAlignment</definition>
        <argsstring></argsstring>
        <name>kArrowIpcAlignment</name>
        <initializer>= 8</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/util.h" line="36" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/util.h" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacearrow_1_1ipc_1a639c6bce97995b7c80e258d537fc6d3f" prot="public" static="yes" mutable="no">
        <type>constexpr uint8_t</type>
        <definition>constexpr uint8_t arrow::ipc::kPaddingBytes[kArrowAlignment]</definition>
        <argsstring>[kArrowAlignment]</argsstring>
        <name>kPaddingBytes</name>
        <initializer>= {0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/util.h" line="38" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/util.h" bodystart="38" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacearrow_1_1ipc_1aed3401152edad9f00d8e0081510c4113" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::CollectDictionaries</definition>
        <argsstring>(const RecordBatch &amp;batch, DictionaryMemo *memo)</argsstring>
        <name>CollectDictionaries</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>memo</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/dictionary.h" line="100" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a145c8c6c849532881aef6580d5b0c7f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string arrow::ipc::FormatMessageType</definition>
        <argsstring>(Message::Type type)</argsstring>
        <name>FormatMessageType</name>
        <param>
          <type><ref refid="classarrow_1_1ipc_1_1_message_1a6d6973b3b03de50d7be9dbab4db910db" kindref="member">Message::Type</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="181" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1af5768b86472bdc970f26657de03542c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::unique_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &gt; &gt;</type>
        <definition>Result&lt;std::unique_ptr&lt;Message&gt; &gt; arrow::ipc::ReadMessage</definition>
        <argsstring>(const int64_t offset, const int32_t metadata_length, io::RandomAccessFile *file)</argsstring>
        <name>ReadMessage</name>
        <param>
          <type>const int64_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>const int32_t</type>
          <declname>metadata_length</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_random_access_file" kindref="compound">io::RandomAccessFile</ref> *</type>
          <declname>file</declname>
        </param>
        <briefdescription>
<para>Read encapsulated RPC message from position in file. </para>        </briefdescription>
        <detaileddescription>
<para>Read a length-prefixed message flatbuffer starting at the indicated file offset. If the message has a body with non-zero length, it will also be read</para><para>The metadata_length includes at least the length prefix and the flatbuffer</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the position in the file where the message starts. The first 4 bytes after the offset are the message length </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">metadata_length</parametername>
</parameternamelist>
<parameterdescription>
<para>the total number of bytes to read from file </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">file</parametername>
</parameternamelist>
<parameterdescription>
<para>the seekable file interface to read from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the message read </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="503" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a851ed59057bf05674925a9081297d7f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::AlignStream</definition>
        <argsstring>(io::InputStream *stream, int32_t alignment=8)</argsstring>
        <name>AlignStream</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>alignment</declname>
          <defval>8</defval>
        </param>
        <briefdescription>
<para>Advance stream to an 8-byte offset if its position is not a multiple of 8 already. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">stream</parametername>
</parameternamelist>
<parameterdescription>
<para>an input stream </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">alignment</parametername>
</parameternamelist>
<parameterdescription>
<para>the byte multiple for the metadata prefix, usually 8 or 64, to ensure the body starts on a multiple of that alignment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="514" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1ad20823257a9d5ff67cd9510c2adf57fd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::AlignStream</definition>
        <argsstring>(io::OutputStream *stream, int32_t alignment=8)</argsstring>
        <name>AlignStream</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>alignment</declname>
          <defval>8</defval>
        </param>
        <briefdescription>
<para>Advance stream to an 8-byte offset if its position is not a multiple of 8 already. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">stream</parametername>
</parameternamelist>
<parameterdescription>
<para>an output stream </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">alignment</parametername>
</parameternamelist>
<parameterdescription>
<para>the byte multiple for the metadata prefix, usually 8 or 64, to ensure the body starts on a multiple of that alignment </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="523" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a88a35d513cfca55bff3228dbed860c17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::CheckAligned</definition>
        <argsstring>(io::FileInterface *stream, int32_t alignment=8)</argsstring>
        <name>CheckAligned</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_file_interface" kindref="compound">io::FileInterface</ref> *</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>alignment</declname>
          <defval>8</defval>
        </param>
        <briefdescription>
<para>Return error <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> if file position is not a multiple of the indicated alignment. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="528" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a8fd1cee0d3543074bcd8cb8bfe57a843" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::unique_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &gt; &gt;</type>
        <definition>Result&lt;std::unique_ptr&lt;Message&gt; &gt; arrow::ipc::ReadMessage</definition>
        <argsstring>(io::InputStream *stream, MemoryPool *pool=default_memory_pool())</argsstring>
        <name>ReadMessage</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>stream</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820" kindref="member">default_memory_pool</ref>()</defval>
        </param>
        <briefdescription>
<para>Read encapsulated IPC message (metadata and body) from InputStream. </para>        </briefdescription>
        <detaileddescription>
<para>Returns null if there are not enough bytes available or the message length is 0 (e.g. EOS in a stream)</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">stream</parametername>
</parameternamelist>
<parameterdescription>
<para>an input stream </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>an optional <ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> to copy metadata on the CPU, if required </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="539" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a8aee21fb6d1922ed95d9efc9c3e4378f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::DecodeMessage</definition>
        <argsstring>(MessageDecoder *decoder, io::InputStream *stream)</argsstring>
        <name>DecodeMessage</name>
        <param>
          <type><ref refid="classarrow_1_1ipc_1_1_message_decoder" kindref="compound">MessageDecoder</ref> *</type>
          <declname>decoder</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>stream</declname>
        </param>
        <briefdescription>
<para>Feed data from InputStream to <ref refid="classarrow_1_1ipc_1_1_message_decoder" kindref="compound">MessageDecoder</ref> to decode an encapsulated IPC message (metadata and body) </para>        </briefdescription>
        <detaileddescription>
<para>This API is EXPERIMENTAL.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">decoder</parametername>
</parameternamelist>
<parameterdescription>
<para>a decoder </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stream</parametername>
</parameternamelist>
<parameterdescription>
<para>an input stream </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></para></simplesect>
<simplesect kind="since"><para>0.17.0 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="553" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a119c0254fe92d2ac087e7aa9200ed525" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::WriteMessage</definition>
        <argsstring>(const Buffer &amp;message, const IpcWriteOptions &amp;options, io::OutputStream *file, int32_t *message_length)</argsstring>
        <name>WriteMessage</name>
        <param>
          <type>const <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &amp;</type>
          <declname>message</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>file</declname>
        </param>
        <param>
          <type>int32_t *</type>
          <declname>message_length</declname>
        </param>
        <briefdescription>
<para>Write encapsulated IPC message Does not make assumptions about whether the stream is aligned already. </para>        </briefdescription>
        <detaileddescription>
<para>Can write legacy (pre version 0.15.0) IPC message if option set</para><para>continuation: 0xFFFFFFFF message_size: int32 message: const void* padding</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">message</parametername>
</parameternamelist>
<parameterdescription>
<para>a buffer containing the metadata to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>IPC writing options, including alignment and legacy message support </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">file</parametername>
</parameternamelist>
<parameterdescription>
<para>the OutputStream to write to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">message_length</parametername>
</parameternamelist>
<parameterdescription>
<para>the total size of the payload written including padding </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="572" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a8a5b0c3b2731ba0e86a3f091765287ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::ReadMessage</definition>
        <argsstring>(const int64_t offset, const int32_t metadata_length, io::RandomAccessFile *file, std::unique_ptr&lt; Message &gt; *message)</argsstring>
        <name>ReadMessage</name>
        <param>
          <type>const int64_t</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>const int32_t</type>
          <declname>metadata_length</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_random_access_file" kindref="compound">io::RandomAccessFile</ref> *</type>
          <declname>file</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &gt; *</type>
          <declname>message</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="580" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a9cb8d4170270e9d596778268686585c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::ReadMessage</definition>
        <argsstring>(io::InputStream *stream, std::unique_ptr&lt; Message &gt; *message)</argsstring>
        <name>ReadMessage</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &gt; *</type>
          <declname>message</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/message.h" line="585" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a8106077c9356a5a653197573cac756d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Schema&gt; &gt; arrow::ipc::ReadSchema</definition>
        <argsstring>(io::InputStream *stream, DictionaryMemo *dictionary_memo)</argsstring>
        <name>ReadSchema</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>stream</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <briefdescription>
<para>Read <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> from stream serialized as a single IPC message and populate any dictionary-encoded fields into a <ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">stream</parametername>
</parameternamelist>
<parameterdescription>
<para>an InputStream </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dictionary_memo</parametername>
</parameternamelist>
<parameterdescription>
<para>for recording dictionary-encoded fields </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the output <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref></para></simplesect>
If record batches follow the schema, it is better to use <ref refid="classarrow_1_1ipc_1_1_record_batch_stream_reader" kindref="compound">RecordBatchStreamReader</ref> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="406" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a6c04a06f87e57b94614b36fe5d7f604c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Schema&gt; &gt; arrow::ipc::ReadSchema</definition>
        <argsstring>(const Message &amp;message, DictionaryMemo *dictionary_memo)</argsstring>
        <name>ReadSchema</name>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &amp;</type>
          <declname>message</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <briefdescription>
<para>Read <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> from encapsulated <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">message</parametername>
</parameternamelist>
<parameterdescription>
<para>the message containing the <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> IPC metadata </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dictionary_memo</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> for recording dictionary-encoded fields. Can be nullptr if you are sure there are no dictionary-encoded fields </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the resulting <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="417" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1ab93f4e08e34a00a3961ff5a5fd6b323d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;RecordBatch&gt; &gt; arrow::ipc::ReadRecordBatch</definition>
        <argsstring>(const std::shared_ptr&lt; Schema &gt; &amp;schema, const DictionaryMemo *dictionary_memo, const IpcReadOptions &amp;options, io::InputStream *stream)</argsstring>
        <name>ReadRecordBatch</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_read_options" kindref="compound">IpcReadOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>stream</declname>
        </param>
        <briefdescription>
<para>Read record batch as encapsulated IPC message with metadata size prefix and header. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>the record batch schema </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dictionary_memo</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> which has any dictionaries. Can be nullptr if you are sure there are no dictionary-encoded fields </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>IPC options for reading </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">stream</parametername>
</parameternamelist>
<parameterdescription>
<para>the file where the batch is located </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the read record batch </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="431" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a09c0dccab523e6e4ad18ae5961d14b9b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;RecordBatch&gt; &gt; arrow::ipc::ReadRecordBatch</definition>
        <argsstring>(const Message &amp;message, const std::shared_ptr&lt; Schema &gt; &amp;schema, const DictionaryMemo *dictionary_memo, const IpcReadOptions &amp;options)</argsstring>
        <name>ReadRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &amp;</type>
          <declname>message</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_read_options" kindref="compound">IpcReadOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
<para>Read record batch from message. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">message</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> containing the record batch metadata </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>the record batch schema </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dictionary_memo</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> which has any dictionaries. Can be nullptr if you are sure there are no dictionary-encoded fields </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>IPC options for reading </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the read record batch </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="445" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a0733056a1820082f770ee961b80489ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;RecordBatch&gt; &gt; arrow::ipc::ReadRecordBatch</definition>
        <argsstring>(const Buffer &amp;metadata, const std::shared_ptr&lt; Schema &gt; &amp;schema, const DictionaryMemo *dictionary_memo, const IpcReadOptions &amp;options, io::RandomAccessFile *file)</argsstring>
        <name>ReadRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &amp;</type>
          <declname>metadata</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_read_options" kindref="compound">IpcReadOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_random_access_file" kindref="compound">io::RandomAccessFile</ref> *</type>
          <declname>file</declname>
        </param>
        <briefdescription>
<para>Read record batch from file given metadata and schema. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">metadata</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> containing the record batch metadata </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>the record batch schema </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dictionary_memo</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> which has any dictionaries. Can be nullptr if you are sure there are no dictionary-encoded fields </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">file</parametername>
</parameternamelist>
<parameterdescription>
<para>a random access file </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options for deserialization </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the read record batch </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="460" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a70fe7b7692bb655c6f79459bf0f3600e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Tensor&gt; &gt; arrow::ipc::ReadTensor</definition>
        <argsstring>(io::InputStream *file)</argsstring>
        <name>ReadTensor</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>file</declname>
        </param>
        <briefdescription>
<para>Read <ref refid="classarrow_1_1_tensor" kindref="compound">arrow::Tensor</ref> as encapsulated IPC message in file. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">file</parametername>
</parameternamelist>
<parameterdescription>
<para>an InputStream pointed at the start of the message </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the read tensor </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="470" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a0d328ac0e839de876b3b16374d7be886" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Tensor&gt; &gt; arrow::ipc::ReadTensor</definition>
        <argsstring>(const Message &amp;message)</argsstring>
        <name>ReadTensor</name>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &amp;</type>
          <declname>message</declname>
        </param>
        <briefdescription>
<para>EXPERIMENTAL: Read <ref refid="classarrow_1_1_tensor" kindref="compound">arrow::Tensor</ref> from IPC message. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">message</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> containing the tensor metadata and body </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the read tensor </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="477" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a6de02b7f92aa1872ce687b298ca08059" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">SparseTensor</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;SparseTensor&gt; &gt; arrow::ipc::ReadSparseTensor</definition>
        <argsstring>(io::InputStream *file)</argsstring>
        <name>ReadSparseTensor</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>file</declname>
        </param>
        <briefdescription>
<para>EXPERIMENTAL: Read <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">arrow::SparseTensor</ref> as encapsulated IPC message in file. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">file</parametername>
</parameternamelist>
<parameterdescription>
<para>an InputStream pointed at the start of the message </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the read sparse tensor </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="484" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a8f8ad38095464c24d00b8bedeaf8fdee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">SparseTensor</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;SparseTensor&gt; &gt; arrow::ipc::ReadSparseTensor</definition>
        <argsstring>(const Message &amp;message)</argsstring>
        <name>ReadSparseTensor</name>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &amp;</type>
          <declname>message</declname>
        </param>
        <briefdescription>
<para>EXPERIMENTAL: Read <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">arrow::SparseTensor</ref> from IPC message. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">message</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> containing the tensor metadata and body </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the read sparse tensor </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="491" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a7a0abb311187514c1b94979b676ed3f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::ReadSchema</definition>
        <argsstring>(io::InputStream *stream, DictionaryMemo *dictionary_memo, std::shared_ptr&lt; Schema &gt; *out)</argsstring>
        <name>ReadSchema</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>stream</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="519" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a3b3376dd66dad30bab358cc6cc96be0d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::ReadSchema</definition>
        <argsstring>(const Message &amp;message, DictionaryMemo *dictionary_memo, std::shared_ptr&lt; Schema &gt; *out)</argsstring>
        <name>ReadSchema</name>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &amp;</type>
          <declname>message</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="524" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1aa964e5ec1d7b7591ae5ef5b9acc4fef8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::ReadRecordBatch</definition>
        <argsstring>(const std::shared_ptr&lt; Schema &gt; &amp;schema, const DictionaryMemo *dictionary_memo, io::InputStream *stream, std::shared_ptr&lt; RecordBatch &gt; *out)</argsstring>
        <name>ReadRecordBatch</name>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_input_stream" kindref="compound">io::InputStream</ref> *</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="529" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1ad239732e63c296d983aeeb6b379af816" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::ReadRecordBatch</definition>
        <argsstring>(const Buffer &amp;metadata, const std::shared_ptr&lt; Schema &gt; &amp;schema, const DictionaryMemo *dictionary_memo, io::RandomAccessFile *file, std::shared_ptr&lt; RecordBatch &gt; *out)</argsstring>
        <name>ReadRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &amp;</type>
          <declname>metadata</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_random_access_file" kindref="compound">io::RandomAccessFile</ref> *</type>
          <declname>file</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="535" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a48b3b243bc9ae0b6ed1cb3e43bfd54a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::ReadRecordBatch</definition>
        <argsstring>(const Message &amp;message, const std::shared_ptr&lt; Schema &gt; &amp;schema, const DictionaryMemo *dictionary_memo, std::shared_ptr&lt; RecordBatch &gt; *out)</argsstring>
        <name>ReadRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &amp;</type>
          <declname>message</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/reader.h" line="541" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a0887842de4ad79fcd645736e7b7e2c86" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int64_t</type>
        <definition>static int64_t arrow::ipc::PaddedLength</definition>
        <argsstring>(int64_t nbytes, int32_t alignment=kArrowAlignment)</argsstring>
        <name>PaddedLength</name>
        <param>
          <type>int64_t</type>
          <declname>nbytes</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>alignment</declname>
          <defval>kArrowAlignment</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/util.h" line="40" column="1" bodyfile="/arrow/cpp/src/arrow/ipc/util.h" bodystart="40" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a5b9ecafbc29584a6ecacaf9298fc0318" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_record_batch_writer" kindref="compound">RecordBatchWriter</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;RecordBatchWriter&gt; &gt; arrow::ipc::NewStreamWriter</definition>
        <argsstring>(io::OutputStream *sink, const std::shared_ptr&lt; Schema &gt; &amp;schema, const IpcWriteOptions &amp;options=IpcWriteOptions::Defaults())</argsstring>
        <name>NewStreamWriter</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>sink</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> &amp;</type>
          <declname>options</declname>
          <defval><ref refid="structarrow_1_1ipc_1_1_ipc_write_options_1ad66a7351569c732ff6c105140204be67" kindref="member">IpcWriteOptions::Defaults</ref>()</defval>
        </param>
        <briefdescription>
<para>Create a new IPC stream writer from stream sink and schema. </para>        </briefdescription>
        <detaileddescription>
<para>User is responsible for closing the actual OutputStream.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sink</parametername>
</parameternamelist>
<parameterdescription>
<para>output stream to write to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>the schema of the record batches to be written </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options for serialization </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;std::shared_ptr&lt;RecordBatchWriter&gt;&gt; </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="94" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a10744130357f3d4fd083a97f2dafe985" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_record_batch_writer" kindref="compound">RecordBatchWriter</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;RecordBatchWriter&gt; &gt; arrow::ipc::NewFileWriter</definition>
        <argsstring>(io::OutputStream *sink, const std::shared_ptr&lt; Schema &gt; &amp;schema, const IpcWriteOptions &amp;options=IpcWriteOptions::Defaults(), const std::shared_ptr&lt; const KeyValueMetadata &gt; &amp;metadata=NULLPTR)</argsstring>
        <name>NewFileWriter</name>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>sink</declname>
        </param>
        <param>
          <type>const std::shared_ptr&lt; <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &gt; &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> &amp;</type>
          <declname>options</declname>
          <defval><ref refid="structarrow_1_1ipc_1_1_ipc_write_options_1ad66a7351569c732ff6c105140204be67" kindref="member">IpcWriteOptions::Defaults</ref>()</defval>
        </param>
        <param>
          <type>const std::shared_ptr&lt; const <ref refid="classarrow_1_1_key_value_metadata" kindref="compound">KeyValueMetadata</ref> &gt; &amp;</type>
          <declname>metadata</declname>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Create a new IPC file writer from stream sink and schema. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sink</parametername>
</parameternamelist>
<parameterdescription>
<para>output stream to write to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>the schema of the record batches to be written </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options for serialization, optional </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">metadata</parametername>
</parameternamelist>
<parameterdescription>
<para>custom metadata for File Footer, optional </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="106" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a92f5eaf2876a5a90a6194729eefa8d89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::WriteRecordBatch</definition>
        <argsstring>(const RecordBatch &amp;batch, int64_t buffer_start_offset, io::OutputStream *dst, int32_t *metadata_length, int64_t *body_length, const IpcWriteOptions &amp;options)</argsstring>
        <name>WriteRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>buffer_start_offset</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>int32_t *</type>
          <declname>metadata_length</declname>
        </param>
        <param>
          <type>int64_t *</type>
          <declname>body_length</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
<para>Low-level API for writing a record batch (without schema) to an OutputStream as encapsulated IPC message. </para>        </briefdescription>
        <detaileddescription>
<para>See Arrow format documentation for more detail.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">batch</parametername>
</parameternamelist>
<parameterdescription>
<para>the record batch to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buffer_start_offset</parametername>
</parameternamelist>
<parameterdescription>
<para>the start offset to use in the buffer metadata, generally should be 0 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dst</parametername>
</parameternamelist>
<parameterdescription>
<para>an OutputStream </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">metadata_length</parametername>
</parameternamelist>
<parameterdescription>
<para>the size of the length-prefixed flatbuffer including padding to a 64-byte boundary </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">body_length</parametername>
</parameternamelist>
<parameterdescription>
<para>the size of the contiguous buffer block plus </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options for serialization </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="125" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a678c0f4c0685a8953e031f9878ec9cf3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::ipc::SerializeRecordBatch</definition>
        <argsstring>(const RecordBatch &amp;batch, const IpcWriteOptions &amp;options)</argsstring>
        <name>SerializeRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
<para>Serialize record batch as encapsulated IPC message in a new buffer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">batch</parametername>
</parameternamelist>
<parameterdescription>
<para>the record batch </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> to use for serialization </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the serialized message </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="135" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1ac195eda0ee03d15a2b317dc5b534974d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::ipc::SerializeRecordBatch</definition>
        <argsstring>(const RecordBatch &amp;batch, std::shared_ptr&lt; MemoryManager &gt; mm)</argsstring>
        <name>SerializeRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> &gt;</type>
          <declname>mm</declname>
        </param>
        <briefdescription>
<para>Serialize record batch as encapsulated IPC message in a new buffer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">batch</parametername>
</parameternamelist>
<parameterdescription>
<para>the record batch </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mm</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classarrow_1_1_memory_manager" kindref="compound">MemoryManager</ref> to allocate memory from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the serialized message </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="144" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a9985695e4f4cbcfcfbf16bf8242e0650" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::SerializeRecordBatch</definition>
        <argsstring>(const RecordBatch &amp;batch, const IpcWriteOptions &amp;options, io::OutputStream *out)</argsstring>
        <name>SerializeRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Write record batch to OutputStream. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">batch</parametername>
</parameternamelist>
<parameterdescription>
<para>the record batch to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> to use for serialization </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">out</parametername>
</parameternamelist>
<parameterdescription>
<para>the OutputStream to write the output to </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></para></simplesect>
If writing to pre-allocated memory, you can use <ref refid="namespacearrow_1_1ipc_1af3e2c42f9315d51ee531d46506790291" kindref="member">arrow::ipc::GetRecordBatchSize</ref> to compute how much space is required </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="157" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a09392c8b73461ce916b7b86935e9c6b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;Buffer&gt; &gt; arrow::ipc::SerializeSchema</definition>
        <argsstring>(const Schema &amp;schema, DictionaryMemo *dictionary_memo, MemoryPool *pool=default_memory_pool())</argsstring>
        <name>SerializeSchema</name>
        <param>
          <type>const <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
          <defval><ref refid="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820" kindref="member">default_memory_pool</ref>()</defval>
        </param>
        <briefdescription>
<para>Serialize schema as encapsulated IPC message. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">schema</parametername>
</parameternamelist>
<parameterdescription>
<para>the schema to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dictionary_memo</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> for recording dictionary ids </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> to allocate memory from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the serialized schema </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="167" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a790aec6945d5738da69d72977065cb1c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::WriteRecordBatchStream</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; RecordBatch &gt;&gt; &amp;batches, const IpcWriteOptions &amp;options, io::OutputStream *dst)</argsstring>
        <name>WriteRecordBatchStream</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &gt;&gt; &amp;</type>
          <declname>batches</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>dst</declname>
        </param>
        <briefdescription>
<para>Write multiple record batches to OutputStream, including schema. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">batches</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector of batches. Must all have same schema </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>options for serialization </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">dst</parametername>
</parameternamelist>
<parameterdescription>
<para>an OutputStream </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="177" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1af3e2c42f9315d51ee531d46506790291" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::GetRecordBatchSize</definition>
        <argsstring>(const RecordBatch &amp;batch, int64_t *size)</argsstring>
        <name>GetRecordBatchSize</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>int64_t *</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Compute the number of bytes needed to write a record batch including metadata. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">batch</parametername>
</parameternamelist>
<parameterdescription>
<para>the record batch to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">size</parametername>
</parameternamelist>
<parameterdescription>
<para>the size of the complete encapsulated message </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="186" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a8358a45c7dd8605f8ad5af4cb3216602" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::GetTensorSize</definition>
        <argsstring>(const Tensor &amp;tensor, int64_t *size)</argsstring>
        <name>GetTensorSize</name>
        <param>
          <type>const <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type>int64_t *</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Compute the number of bytes needed to write a tensor including metadata. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>the tensor to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">size</parametername>
</parameternamelist>
<parameterdescription>
<para>the size of the complete encapsulated message </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="194" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1aa02293515caa45f36fd4bbff0f8729e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::unique_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &gt; &gt;</type>
        <definition>Result&lt;std::unique_ptr&lt;Message&gt; &gt; arrow::ipc::GetTensorMessage</definition>
        <argsstring>(const Tensor &amp;tensor, MemoryPool *pool)</argsstring>
        <name>GetTensorMessage</name>
        <param>
          <type>const <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>EXPERIMENTAL: Convert <ref refid="classarrow_1_1_tensor" kindref="compound">arrow::Tensor</ref> to a <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> with minimal memory allocation. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> to allocate space for metadata </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the resulting <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="203" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1aab7e08532aec7267dac70e923df75e52" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::WriteTensor</definition>
        <argsstring>(const Tensor &amp;tensor, io::OutputStream *dst, int32_t *metadata_length, int64_t *body_length)</argsstring>
        <name>WriteTensor</name>
        <param>
          <type>const <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>int32_t *</type>
          <declname>metadata_length</declname>
        </param>
        <param>
          <type>int64_t *</type>
          <declname>body_length</declname>
        </param>
        <briefdescription>
<para>Write <ref refid="classarrow_1_1_tensor" kindref="compound">arrow::Tensor</ref> as a contiguous message. </para>        </briefdescription>
        <detaileddescription>
<para>The metadata and body are written assuming 64-byte alignment. It is the user&apos;s responsibility to ensure that the OutputStream has been aligned to a 64-byte multiple before writing the message.</para><para>The message is written out as followed: <programlisting><codeline><highlight class="normal">&lt;metadata<sp/>size&gt;<sp/>&lt;metadata&gt;<sp/>&lt;tensor<sp/>data&gt;</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the OutputStream to write to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">metadata_length</parametername>
</parameternamelist>
<parameterdescription>
<para>the actual metadata length, including padding </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">body_length</parametername>
</parameternamelist>
<parameterdescription>
<para>the actual message body length </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="222" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1aa28e240a9ac6dd2d54c95e1003208d55" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::unique_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &gt; &gt;</type>
        <definition>Result&lt;std::unique_ptr&lt;Message&gt; &gt; arrow::ipc::GetSparseTensorMessage</definition>
        <argsstring>(const SparseTensor &amp;sparse_tensor, MemoryPool *pool)</argsstring>
        <name>GetSparseTensorMessage</name>
        <param>
          <type>const <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">SparseTensor</ref> &amp;</type>
          <declname>sparse_tensor</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>EXPERIMENTAL: Convert <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">arrow::SparseTensor</ref> to a <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> with minimal memory allocation. </para>        </briefdescription>
        <detaileddescription>
<para>The message is written out as followed: <programlisting><codeline><highlight class="normal">&lt;metadata<sp/>size&gt;<sp/>&lt;metadata&gt;<sp/>&lt;sparse<sp/>index&gt;<sp/>&lt;sparse<sp/>tensor<sp/>body&gt;</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sparse_tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">SparseTensor</ref> to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">pool</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> to allocate space for metadata </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the resulting <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="237" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a5e747b81260f5e07e25817e7c11b5875" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::WriteSparseTensor</definition>
        <argsstring>(const SparseTensor &amp;sparse_tensor, io::OutputStream *dst, int32_t *metadata_length, int64_t *body_length)</argsstring>
        <name>WriteSparseTensor</name>
        <param>
          <type>const <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">SparseTensor</ref> &amp;</type>
          <declname>sparse_tensor</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>int32_t *</type>
          <declname>metadata_length</declname>
        </param>
        <param>
          <type>int64_t *</type>
          <declname>body_length</declname>
        </param>
        <briefdescription>
<para>EXPERIMENTAL: Write <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">arrow::SparseTensor</ref> as a contiguous message. </para>        </briefdescription>
        <detaileddescription>
<para>The metadata, sparse index, and body are written assuming 64-byte alignment. It is the user&apos;s responsibility to ensure that the OutputStream has been aligned to a 64-byte multiple before writing the message.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sparse_tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">SparseTensor</ref> to write </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dst</parametername>
</parameternamelist>
<parameterdescription>
<para>the OutputStream to write to </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">metadata_length</parametername>
</parameternamelist>
<parameterdescription>
<para>the actual metadata length, including padding </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">body_length</parametername>
</parameternamelist>
<parameterdescription>
<para>the actual message body length </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classarrow_1_1_status" kindref="compound">Status</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="251" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a0e026769be088906122c43edf1ef0853" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::WriteRecordBatch</definition>
        <argsstring>(const RecordBatch &amp;batch, int64_t buffer_start_offset, io::OutputStream *dst, int32_t *metadata_length, int64_t *body_length, const IpcWriteOptions &amp;options, MemoryPool *pool)</argsstring>
        <name>WriteRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>buffer_start_offset</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>int32_t *</type>
          <declname>metadata_length</declname>
        </param>
        <param>
          <type>int64_t *</type>
          <declname>body_length</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="411" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a7367078e68bce6a4ce099e5f891e19c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::SerializeRecordBatch</definition>
        <argsstring>(const RecordBatch &amp;batch, const IpcWriteOptions &amp;options, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>SerializeRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type>const <ref refid="structarrow_1_1ipc_1_1_ipc_write_options" kindref="compound">IpcWriteOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="418" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a1c6195b676cf99ddde5c1e1a6e5abdec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::SerializeRecordBatch</definition>
        <argsstring>(const RecordBatch &amp;batch, MemoryPool *pool, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>SerializeRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="425" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1ab0fe4d9b40565425a1efb0a12c140ee6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::SerializeRecordBatch</definition>
        <argsstring>(const RecordBatch &amp;batch, MemoryPool *pool, io::OutputStream *out)</argsstring>
        <name>SerializeRecordBatch</name>
        <param>
          <type>const <ref refid="classarrow_1_1_record_batch" kindref="compound">RecordBatch</ref> &amp;</type>
          <declname>batch</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1io_1_1_output_stream" kindref="compound">io::OutputStream</ref> *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="432" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a07d51b6fb9cf65b501aa3680e8163bc0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::SerializeSchema</definition>
        <argsstring>(const Schema &amp;schema, DictionaryMemo *dictionary_memo, MemoryPool *pool, std::shared_ptr&lt; Buffer &gt; *out)</argsstring>
        <name>SerializeSchema</name>
        <param>
          <type>const <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>schema</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1ipc_1_1_dictionary_memo" kindref="compound">DictionaryMemo</ref> *</type>
          <declname>dictionary_memo</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="437" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1aefe310d6c4b825ac1bab725c749a194f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::GetTensorMessage</definition>
        <argsstring>(const Tensor &amp;tensor, MemoryPool *pool, std::unique_ptr&lt; Message &gt; *out)</argsstring>
        <name>GetTensorMessage</name>
        <param>
          <type>const <ref refid="classarrow_1_1_tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>tensor</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="442" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacearrow_1_1ipc_1a299c8368eb27b1118c4b290badc10957" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::ipc::GetSparseTensorMessage</definition>
        <argsstring>(const SparseTensor &amp;sparse_tensor, MemoryPool *pool, std::unique_ptr&lt; Message &gt; *out)</argsstring>
        <name>GetSparseTensorMessage</name>
        <param>
          <type>const <ref refid="classarrow_1_1_sparse_tensor" kindref="compound">SparseTensor</ref> &amp;</type>
          <declname>sparse_tensor</declname>
        </param>
        <param>
          <type><ref refid="classarrow_1_1_memory_pool" kindref="compound">MemoryPool</ref> *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>std::unique_ptr&lt; <ref refid="classarrow_1_1ipc_1_1_message" kindref="compound">Message</ref> &gt; *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/ipc/writer.h" line="447" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/arrow/cpp/src/arrow/flight/internal.h" line="40" column="1"/>
  </compounddef>
</doxygen>
