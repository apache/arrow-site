<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1_iterator" kind="class" language="C++" prot="public">
    <compoundname>arrow::Iterator</compoundname>
    <basecompoundref refid="classarrow_1_1util_1_1_equality_comparable" prot="public" virt="non-virtual">arrow::util::EqualityComparable&lt; Iterator&lt; T &gt; &gt;</basecompoundref>
    <includes refid="type__fwd_8h" local="no">arrow/type_fwd.h</includes>
    <innerclass refid="classarrow_1_1_iterator_1_1_range_iterator" prot="public">arrow::Iterator::RangeIterator</innerclass>
    <templateparamlist>
      <param>
        <type>typename</type>
        <declname>T</declname>
        <defname>T</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classarrow_1_1_iterator_1abd939de478cc22f1a45386901b0dccce" prot="private" static="no" mutable="no">
        <type>std::unique_ptr&lt; void, void(*)(void *)&gt;</type>
        <definition>std::unique_ptr&lt;void, void (*)(void*)&gt; arrow::Iterator&lt; T &gt;::ptr_</definition>
        <argsstring></argsstring>
        <name>ptr_</name>
        <briefdescription>
<para>ptr_ is a unique_ptr to void with a custom deleter: a function pointer which first casts from void* to a pointer to the wrapped type then deletes that. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="181" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="181" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1_iterator_1a3747e4c22bdc33a3b96077097ae15808" prot="private" static="no" mutable="no">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; T &gt;(*</type>
        <definition>Result&lt;T&gt;(* arrow::Iterator&lt; T &gt;::next_) (void *)</definition>
        <argsstring>)(void *)</argsstring>
        <name>next_</name>
        <initializer>= <ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></initializer>
        <briefdescription>
<para>next_ is a function pointer which first casts from void* to a pointer to the wrapped type then invokes its Next member function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="181" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="185" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1_iterator_1ae8f407244068440da5baafec1e163423" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Wrapped</type>
          </param>
        </templateparamlist>
        <type></type>
        <definition>arrow::Iterator&lt; T &gt;::Iterator</definition>
        <argsstring>(Wrapped has_next)</argsstring>
        <name>Iterator</name>
        <param>
          <type>Wrapped</type>
          <declname>has_next</declname>
        </param>
        <briefdescription>
<para><ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref> may be constructed from any type which has a member function with signature <ref refid="classarrow_1_1_status" kindref="compound">Status</ref> Next(T*);. </para>        </briefdescription>
        <detaileddescription>
<para>The argument is moved or copied to the heap and kept in a unique_ptr&lt;void&gt;. Only its destructor and its Next method (which are stored in function pointers) are referenced after construction.</para><para>This approach is used to dodge MSVC linkage hell (ARROW-6244, ARROW-6558) when using an abstract template base class: instead of being inlined as usual for a template function the base&apos;s virtual destructor will be exported, leading to multiple definition errors when linking to any other TU where the base is instantiated. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="77" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="77" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_iterator_1a0397f35684cd711325e89ae0cbbaaf5d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Iterator&lt; T &gt;::Iterator</definition>
        <argsstring>()</argsstring>
        <name>Iterator</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="80" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="80" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_iterator_1aa45bdd8baa769270634c8d28ca8b2623" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; T &gt;</type>
        <definition>Result&lt;T&gt; arrow::Iterator&lt; T &gt;::Next</definition>
        <argsstring>()</argsstring>
        <name>Next</name>
        <briefdescription>
<para>Return the next element of the sequence, <ref refid="structarrow_1_1_iteration_traits_1a3ec3a949aefcc0361ae4cc263faf4a8b" kindref="member">IterationTraits&lt;T&gt;::End()</ref> when the iteration is completed. </para>        </briefdescription>
        <detaileddescription>
<para>Calling this on a default constructed <ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref> will result in undefined behavior. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="85" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="85" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_iterator_1ad4ad044d48e8981dd542b1b9f1b97c9e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Visitor</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Iterator&lt; T &gt;::Visit</definition>
        <argsstring>(Visitor &amp;&amp;visitor)</argsstring>
        <name>Visit</name>
        <param>
          <type>Visitor &amp;&amp;</type>
          <declname>visitor</declname>
        </param>
        <briefdescription>
<para>Pass each element of the sequence to a visitor. </para>        </briefdescription>
        <detaileddescription>
<para>Will return any error status returned by the visitor, terminating iteration. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="90" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="90" bodyend="102"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_iterator_1ac1d269d7e0f7751dd7fe859c4e268921" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::Iterator&lt; T &gt;::Equals</definition>
        <argsstring>(const Iterator &amp;other) const</argsstring>
        <name>Equals</name>
        <param>
          <type>const <ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Iterators will only compare equal if they are both null. </para>        </briefdescription>
        <detaileddescription>
<para>Equality comparability is required to make an <ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref> of Iterators (to check for the end condition). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="107" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="107" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_iterator_1a009a47964dc03797996e52eec95d26df" prot="public" static="no" const="yes" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Iterator&lt; T &gt;::operator bool</definition>
        <argsstring>() const</argsstring>
        <name>operator bool</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="109" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="109" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_iterator_1ab28b6a820eab0c2031d6ef3071f207bf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarrow_1_1_iterator_1_1_range_iterator" kindref="compound">RangeIterator</ref></type>
        <definition>RangeIterator arrow::Iterator&lt; T &gt;::begin</definition>
        <argsstring>()</argsstring>
        <name>begin</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="148" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="148" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_iterator_1aa101c174b560017923078215b5a5154e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarrow_1_1_iterator_1_1_range_iterator" kindref="compound">RangeIterator</ref></type>
        <definition>RangeIterator arrow::Iterator&lt; T &gt;::end</definition>
        <argsstring>()</argsstring>
        <name>end</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="150" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="150" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_iterator_1aa82f50ff3b311668856e942633f9cb16" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::vector&lt; T &gt; &gt;</type>
        <definition>Result&lt;std::vector&lt;T&gt; &gt; arrow::Iterator&lt; T &gt;::ToVector</definition>
        <argsstring>()</argsstring>
        <name>ToVector</name>
        <briefdescription>
<para>Move every element of this iterator into a vector. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="153" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="153" bodyend="162"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-static-func">
      <memberdef kind="function" id="classarrow_1_1_iterator_1adc076ce492debd9b10ab4d633217a5ba" prot="private" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename HasNext</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>static void arrow::Iterator&lt; T &gt;::Delete</definition>
        <argsstring>(void *ptr)</argsstring>
        <name>Delete</name>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Implementation of deleter for ptr_: Casts from void* to the wrapped type and deletes that. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="168" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="168" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_iterator_1a87eaf748bad94159363083763bee4618" prot="private" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename HasNext</type>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; T &gt;</type>
        <definition>static Result&lt;T&gt; arrow::Iterator&lt; T &gt;::Next</definition>
        <argsstring>(void *ptr)</argsstring>
        <name>Next</name>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Implementation of Next: Casts from void* to the wrapped type and invokes that type&apos;s Next member function. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/iterator.h" line="175" column="1" bodyfile="/arrow/cpp/src/arrow/util/iterator.h" bodystart="175" bodyend="177"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A generic <ref refid="classarrow_1_1_iterator" kindref="compound">Iterator</ref> that can return errors. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="2645">
        <label>arrow::util::EqualityComparable&lt; Iterator&lt; T &gt; &gt;</label>
        <link refid="classarrow_1_1util_1_1_equality_comparable"/>
      </node>
      <node id="2644">
        <label>arrow::Iterator&lt; T &gt;</label>
        <link refid="classarrow_1_1_iterator"/>
        <childnode refid="2645" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2647">
        <label>arrow::util::EqualityComparable&lt; Iterator&lt; T &gt; &gt;</label>
        <link refid="classarrow_1_1util_1_1_equality_comparable"/>
      </node>
      <node id="2646">
        <label>arrow::Iterator&lt; T &gt;</label>
        <link refid="classarrow_1_1_iterator"/>
        <childnode refid="2647" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/arrow/cpp/src/arrow/type_fwd.h" line="30" column="1" bodyfile="/arrow/cpp/src/arrow/type_fwd.h" bodystart="30" bodyend="-1"/>
    <listofallmembers>
      <member refid="classarrow_1_1_iterator_1ab28b6a820eab0c2031d6ef3071f207bf" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>begin</name></member>
      <member refid="classarrow_1_1_iterator_1adc076ce492debd9b10ab4d633217a5ba" prot="private" virt="non-virtual"><scope>arrow::Iterator</scope><name>Delete</name></member>
      <member refid="classarrow_1_1_iterator_1aa101c174b560017923078215b5a5154e" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>end</name></member>
      <member refid="classarrow_1_1_iterator_1ac1d269d7e0f7751dd7fe859c4e268921" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>Equals</name></member>
      <member refid="classarrow_1_1util_1_1_equality_comparable_1a140cfdea92ae17331d8db8f69aad082f" prot="public" virt="non-virtual" ambiguityscope="EqualityComparable&lt; Iterator&lt; T &gt; &gt;::"><scope>arrow::Iterator</scope><name>Equals</name></member>
      <member refid="classarrow_1_1_iterator_1ae8f407244068440da5baafec1e163423" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>Iterator</name></member>
      <member refid="classarrow_1_1_iterator_1a0397f35684cd711325e89ae0cbbaaf5d" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>Iterator</name></member>
      <member refid="classarrow_1_1_iterator_1aa45bdd8baa769270634c8d28ca8b2623" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>Next</name></member>
      <member refid="classarrow_1_1_iterator_1a87eaf748bad94159363083763bee4618" prot="private" virt="non-virtual"><scope>arrow::Iterator</scope><name>Next</name></member>
      <member refid="classarrow_1_1_iterator_1a3747e4c22bdc33a3b96077097ae15808" prot="private" virt="non-virtual"><scope>arrow::Iterator</scope><name>next_</name></member>
      <member refid="classarrow_1_1_iterator_1a009a47964dc03797996e52eec95d26df" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>operator bool</name></member>
      <member refid="classarrow_1_1util_1_1_equality_comparable_1a1a7ff2c6f720209bc960524c47ad0535" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>operator!=</name></member>
      <member refid="classarrow_1_1util_1_1_equality_comparable_1ac0e8ec25e77ece923689ee31c389200e" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>operator==</name></member>
      <member refid="classarrow_1_1_iterator_1abd939de478cc22f1a45386901b0dccce" prot="private" virt="non-virtual"><scope>arrow::Iterator</scope><name>ptr_</name></member>
      <member refid="classarrow_1_1_iterator_1aa82f50ff3b311668856e942633f9cb16" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>ToVector</name></member>
      <member refid="classarrow_1_1_iterator_1ad4ad044d48e8981dd542b1b9f1b97c9e" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>Visit</name></member>
      <member refid="classarrow_1_1util_1_1_equality_comparable_1a14c5ed61e030855eef29edebc6355806" prot="public" virt="non-virtual"><scope>arrow::Iterator</scope><name>~EqualityComparable</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
