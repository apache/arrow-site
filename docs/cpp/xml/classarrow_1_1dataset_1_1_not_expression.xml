<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1dataset_1_1_not_expression" kind="class" language="C++" prot="public" final="yes">
    <compoundname>arrow::dataset::NotExpression</compoundname>
    <basecompoundref refid="classarrow_1_1dataset_1_1_expression_impl" prot="public" virt="non-virtual">arrow::dataset::ExpressionImpl&lt; UnaryExpression, NotExpression, ExpressionType::NOT &gt;</basecompoundref>
    <includes refid="arrow_2dataset_2filter_8h" local="no">arrow/dataset/filter.h</includes>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_not_expression_1a745c7fec120d79fce049d42270c1b60a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::string</type>
        <definition>std::string arrow::dataset::NotExpression::ToString</definition>
        <argsstring>() const override</argsstring>
        <name>ToString</name>
        <reimplements refid="classarrow_1_1dataset_1_1_expression_1acd37d50f9235db97d98299dedde5deb8">ToString</reimplements>
        <briefdescription>
<para>returns a debug string representing this expression </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="315" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_not_expression_1a7a6fc4ee6b7d09b59a5e9bd37bccb7b7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Expression&gt; arrow::dataset::NotExpression::Assume</definition>
        <argsstring>(const Expression &amp;given) const override</argsstring>
        <name>Assume</name>
        <reimplements refid="classarrow_1_1dataset_1_1_expression_1a5cf8311867209fd28af7f0fdf6b26b33">Assume</reimplements>
        <param>
          <type>const <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> &amp;</type>
          <declname>given</declname>
        </param>
        <briefdescription>
<para>Simplify to an equivalent <ref refid="classarrow_1_1dataset_1_1_expression" kindref="compound">Expression</ref> given assumed constraints on input. </para>        </briefdescription>
        <detaileddescription>
<para>This can be used to do less filtering work using predicate push down.</para><para>Both expressions must pass validation against a schema before Assume may be used.</para><para>Two expressions can be considered equivalent for a given subset of possible inputs if they yield identical results. Formally, if given.Evaluate(input).Equals(input) then Assume guarantees that: expr.Assume(given).Evaluate(input).Equals(expr.Evaluate(input))</para><para>For example if we are given that all inputs will satisfy (&quot;a&quot;_ == 1) then the expression (&quot;a&quot;_ &gt; 0 and &quot;b&quot;_ &gt; 0) is equivalent to (&quot;b&quot;_ &gt; 0). It is impossible that the comparison (&quot;a&quot;_ &gt; 0) will evaluate false given (&quot;a&quot;_ == 1), so both expressions will yield identical results. Thus we can write: (&quot;a&quot;_ &gt; 0 and &quot;b&quot;_ &gt; 0).Assume(&quot;a&quot;_ == 1).Equals(&quot;b&quot;_ &gt; 0)</para><para>filter.Assume(partition) is trivial if filter and partition are disjoint or if partition is a subset of filter. FIXME(bkietz) write this better<itemizedlist>
<listitem><para>If the two are disjoint, then (false) may be substituted for filter.</para></listitem><listitem><para>If partition is a subset of filter then (true) may be substituted for filter.</para></listitem></itemizedlist>
</para><para>filter.Assume(partition) is straightforward if both filter and partition are simple comparisons.<itemizedlist>
<listitem><para>filter may be a superset of partition, in which case the filter is satisfied by all inputs: (&quot;a&quot;_ &gt; 0).Assume(&quot;a&quot;_ == 1).Equals(true)</para></listitem><listitem><para>filter may be disjoint with partition, in which case there are no inputs which satisfy filter: (&quot;a&quot;_ &lt; 0).Assume(&quot;a&quot;_ == 1).Equals(false)</para></listitem><listitem><para>If neither of these is the case, partition provides no information which can simplify filter: (&quot;a&quot;_ == 1).Assume(&quot;a&quot;_ &gt; 0).Equals(&quot;a&quot;_ == 1) (&quot;a&quot;_ == 1).Assume(&quot;b&quot;_ == 1).Equals(&quot;a&quot;_ == 1)</para></listitem></itemizedlist>
</para><para>If filter is compound, Assume can be distributed across the boolean operator. To prove this is valid, we again demonstrate that the simplified expression will yield identical results. For conjunction of filters lhs and rhs: (lhs.Assume(p) and rhs.Assume(p)).Evaluate(input) == Intersection(lhs.Assume(p).Evaluate(input), rhs.Assume(p).Evaluate(input)) == Intersection(lhs.Evaluate(input), rhs.Evaluate(input)) == (lhs and rhs).Evaluate(input)<itemizedlist>
<listitem><para>The proof for disjunction is symmetric; just replace Intersection with Union. Thus we can write: (lhs and rhs).Assume(p).Equals(lhs.Assume(p) and rhs.Assume(p)) (lhs or rhs).Assume(p).Equals(lhs.Assume(p) or rhs.Assume(p))</para></listitem><listitem><para>For negation: (not e.Assume(p)).Evaluate(input) == Difference(input, e.Assume(p).Evaluate(input)) == Difference(input, e.Evaluate(input)) == (not e).Evaluate(input)</para></listitem><listitem><para>Thus we can write: (not e).Assume(p).Equals(not e.Assume(p))</para></listitem></itemizedlist>
</para><para>If the partition expression is a conjunction then each of its subexpressions is true for all input and can be used independently: filter.Assume(lhs).Assume(rhs).Evaluate(input) == filter.Assume(lhs).Evaluate(input) == filter.Evaluate(input)<itemizedlist>
<listitem><para>Thus we can write: filter.Assume(lhs and rhs).Equals(filter.Assume(lhs).Assume(rhs))</para></listitem></itemizedlist>
</para><para>FIXME(bkietz) disjunction proof filter.Assume(lhs or rhs).Equals(filter.Assume(lhs) and filter.Assume(rhs))<itemizedlist>
<listitem><para>This may not result in a simpler expression so it is only used when filter.Assume(lhs).Equals(filter.Assume(rhs))</para></listitem></itemizedlist>
</para><para>If the partition expression is a negation then we can use the above relations by replacing comparisons with their complements and using the properties: (not (a and b)).Equals(not a or not b) (not (a or b)).Equals(not a and not b) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="317" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1dataset_1_1_not_expression_1a522f9f8abdc0393ce60803e70117d6a5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; std::shared_ptr&lt; <ref refid="classarrow_1_1_data_type" kindref="compound">DataType</ref> &gt; &gt;</type>
        <definition>Result&lt;std::shared_ptr&lt;DataType&gt; &gt; arrow::dataset::NotExpression::Validate</definition>
        <argsstring>(const Schema &amp;schema) const override</argsstring>
        <name>Validate</name>
        <reimplements refid="classarrow_1_1dataset_1_1_expression_1a1073c67366c820875c3825e867419050">Validate</reimplements>
        <param>
          <type>const <ref refid="classarrow_1_1_schema" kindref="compound">Schema</ref> &amp;</type>
          <declname>schema</declname>
        </param>
        <briefdescription>
<para>Validate this expression for execution against a schema. </para>        </briefdescription>
        <detaileddescription>
<para>This will check that all reference fields are present (fields not in the schema will be replaced with null) and all subexpressions are executable. Returns the type to which this expression will evaluate. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="319" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="3168">
        <label>arrow::dataset::UnaryExpression</label>
        <link refid="classarrow_1_1dataset_1_1_unary_expression"/>
        <childnode refid="3169" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3169">
        <label>arrow::dataset::Expression</label>
        <link refid="classarrow_1_1dataset_1_1_expression"/>
      </node>
      <node id="3167">
        <label>arrow::dataset::ExpressionImpl&lt; UnaryExpression, NotExpression, ExpressionType::NOT &gt;</label>
        <link refid="classarrow_1_1dataset_1_1_expression_impl"/>
        <childnode refid="3168" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3166">
        <label>arrow::dataset::NotExpression</label>
        <link refid="classarrow_1_1dataset_1_1_not_expression"/>
        <childnode refid="3167" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="3172">
        <label>arrow::dataset::UnaryExpression</label>
        <link refid="classarrow_1_1dataset_1_1_unary_expression"/>
        <childnode refid="3173" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3173">
        <label>arrow::dataset::Expression</label>
        <link refid="classarrow_1_1dataset_1_1_expression"/>
      </node>
      <node id="3171">
        <label>arrow::dataset::ExpressionImpl&lt; UnaryExpression, NotExpression, ExpressionType::NOT &gt;</label>
        <link refid="classarrow_1_1dataset_1_1_expression_impl"/>
        <childnode refid="3172" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3170">
        <label>arrow::dataset::NotExpression</label>
        <link refid="classarrow_1_1dataset_1_1_not_expression"/>
        <childnode refid="3171" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/arrow/cpp/src/arrow/dataset/filter.h" line="311" column="1" bodyfile="/arrow/cpp/src/arrow/dataset/filter.h" bodystart="310" bodyend="320"/>
    <listofallmembers>
      <member refid="classarrow_1_1dataset_1_1_not_expression_1a7a6fc4ee6b7d09b59a5e9bd37bccb7b7" prot="public" virt="virtual"><scope>arrow::dataset::NotExpression</scope><name>Assume</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1aa94bb5128873b3955ef1079dbfa59a05" prot="public" virt="non-virtual" ambiguityscope="ExpressionImpl&lt; UnaryExpression, NotExpression, ExpressionType::NOT &gt;::"><scope>arrow::dataset::NotExpression</scope><name>Assume</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1aa3b8f7274bf46ffb4c9d63c54182eed3" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>CastLike</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1ab93e79be7899dc8a3aa063d92748d6d1" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>CastLike</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a67c73de7e4be70d94decb62d73d9679f" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>CastTo</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_impl_1a6efe2a97203c4253061884774b261fa7" prot="public" virt="virtual"><scope>arrow::dataset::NotExpression</scope><name>Copy</name></member>
      <member refid="classarrow_1_1dataset_1_1_unary_expression_1a5781cb87864a15770ba7fd4b23c7bf5b" prot="public" virt="virtual"><scope>arrow::dataset::NotExpression</scope><name>Equals</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a2080b195e1999f973c7ceb7e0978a13e" prot="public" virt="non-virtual" ambiguityscope="arrow::dataset::Expression::"><scope>arrow::dataset::NotExpression</scope><name>Equals</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a55f49c9a8081e757c4d399073785f171" prot="public" virt="non-virtual" ambiguityscope="arrow::dataset::Expression::"><scope>arrow::dataset::NotExpression</scope><name>Equals</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1ace247255d88029192703e49bcb468c7a" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>Expression</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_impl_1ac0d20822c852c91a7954643d2046ace9" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>expression_type</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_impl_1a42fa4e97b34c43391b6babb001c3634c" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>ExpressionImpl</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a5ce811a47927451199574abff5bab72a" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>In</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a8e5d308f61bdb2ec2074b662ea33f760" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>IsNull</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1ac665b2a07ec4247f0af1ada25340a294" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>IsValid</name></member>
      <member refid="classarrow_1_1dataset_1_1_unary_expression_1a13793184fb3c695ed51d6ef666801e61" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>operand</name></member>
      <member refid="classarrow_1_1dataset_1_1_unary_expression_1abee129bd1e31822aee0a8a2c6213fb44" prot="protected" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>operand_</name></member>
      <member refid="classarrow_1_1dataset_1_1_not_expression_1a745c7fec120d79fce049d42270c1b60a" prot="public" virt="virtual"><scope>arrow::dataset::NotExpression</scope><name>ToString</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a26c748fc0b8eb3ffa800bd957a019d39" prot="public" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>type</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1a4f70ea37a6b7d7e542b1d806e65305f4" prot="protected" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>type_</name></member>
      <member refid="classarrow_1_1dataset_1_1_unary_expression_1a866bb7d6c74e828367b2d22efba0b14e" prot="protected" virt="non-virtual"><scope>arrow::dataset::NotExpression</scope><name>UnaryExpression</name></member>
      <member refid="classarrow_1_1dataset_1_1_not_expression_1a522f9f8abdc0393ce60803e70117d6a5" prot="public" virt="virtual"><scope>arrow::dataset::NotExpression</scope><name>Validate</name></member>
      <member refid="classarrow_1_1dataset_1_1_expression_1aeadfb3da0cb488e984d342be1ed9ae36" prot="public" virt="virtual"><scope>arrow::dataset::NotExpression</scope><name>~Expression</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
