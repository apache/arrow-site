<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1_future" kind="class" language="C++" prot="public">
    <compoundname>arrow::Future</compoundname>
    <includes refid="interfaces_8h" local="no">arrow/io/interfaces.h</includes>
    <templateparamlist>
      <param>
        <type>typename</type>
        <declname>T</declname>
        <defname>T</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="private-type">
      <memberdef kind="typedef" id="classarrow_1_1_future_1ac2f0ba0d2d3c23dae10f10df7618065d" prot="private" static="no">
        <type>typename std::enable_if&lt; HasValue, <ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; U &gt; &gt;::type</type>
        <definition>using arrow::Future&lt; T &gt;::EnableResult =  typename std::enable_if&lt;HasValue, Result&lt;U&gt; &gt;::type</definition>
        <argsstring></argsstring>
        <name>EnableResult</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="245" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="245" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-static-attrib">
      <memberdef kind="variable" id="classarrow_1_1_future_1a2ba01fc6ef9c09d587c287c6e8204010" prot="private" static="yes" mutable="no">
        <type>constexpr bool</type>
        <definition>constexpr bool arrow::Future&lt; T &gt;::HasValue</definition>
        <argsstring></argsstring>
        <name>HasValue</name>
        <initializer>= <ref refid="classarrow_1_1_future_storage" kindref="compound">FutureStorage</ref>&lt;T&gt;::HasValue</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="243" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="243" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="classarrow_1_1_future_1a007dafa635b5f0aac2b4f8a979646095" prot="public" static="yes" mutable="no">
        <type>constexpr double</type>
        <definition>constexpr double arrow::Future&lt; T &gt;::kInfinity</definition>
        <argsstring></argsstring>
        <name>kInfinity</name>
        <initializer>= FutureImpl::kInfinity</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="248" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="248" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classarrow_1_1_future_1aa51be76771324fc42b9d7b168e7f7813" prot="protected" static="no" mutable="no">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_future_storage" kindref="compound">FutureStorage</ref>&lt; T &gt; &gt;</type>
        <definition>std::shared_ptr&lt;FutureStorage&lt;T&gt; &gt; arrow::Future&lt; T &gt;::storage_</definition>
        <argsstring></argsstring>
        <name>storage_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="370" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="370" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1_future_1acadfe2e4dc340be798b940aadf9fd230" prot="protected" static="no" mutable="no">
        <type><ref refid="classarrow_1_1_future_impl" kindref="compound">FutureImpl</ref> *</type>
        <definition>FutureImpl* arrow::Future&lt; T &gt;::impl_</definition>
        <argsstring></argsstring>
        <name>impl_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="371" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="371" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classarrow_1_1_future_1a0392e480c9a553ce4efe5be4ed6db938" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class FutureWaiter</definition>
        <argsstring></argsstring>
        <name>FutureWaiter</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="373" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="373" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1_future_1a3e69c5d668fdfdb3c0bf485228146393" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::Future&lt; T &gt;::Future</definition>
        <argsstring>()</argsstring>
        <name>Future</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="253" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="253" bodyend="253"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1af2ba2618de95a29e50181cfbe4803764" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::Future&lt; T &gt;::is_valid</definition>
        <argsstring>() const</argsstring>
        <name>is_valid</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="257" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="257" bodyend="257"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1af5ed07708946f090bb76f7544f68e483" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="namespacearrow_1a235876e04ae6167cfde18ad69cf2821a" kindref="member">FutureState</ref></type>
        <definition>FutureState arrow::Future&lt; T &gt;::state</definition>
        <argsstring>() const</argsstring>
        <name>state</name>
        <briefdescription>
<para>Return the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&apos;s current state. </para>        </briefdescription>
        <detaileddescription>
<para>A return value of PENDING is only indicative, as the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> can complete concurrently. A return value of FAILURE or SUCCESS is definitive, though. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="263" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="263" bodyend="266"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1a5dd58e6ba0ffd155c0e6757f8a306f27" prot="public" static="no" const="yes" explicit="no" inline="yes" refqual="lvalue" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename U</type>
            <defval>T</defval>
          </param>
        </templateparamlist>
        <type>const <ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; T &gt; &amp;</type>
        <definition>const Result&lt;T&gt;&amp; arrow::Future&lt; T &gt;::result</definition>
        <argsstring>(EnableResult&lt; U &gt; *=NULLPTR) const &amp;</argsstring>
        <name>result</name>
        <param>
          <type>EnableResult&lt; U &gt; *</type>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
<para>Wait for the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> to complete and return its <ref refid="classarrow_1_1_result" kindref="compound">Result</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>This function is not available on Future&lt;void&gt; and Future&lt;Status&gt;. For these specializations, please call <ref refid="classarrow_1_1_future_1af690abcebd3049d956dd39b04dd29463" kindref="member">status()</ref> instead. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="273" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="273" bodyend="277"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1a1fae482e513493f2a7d4da21193fcdd9" prot="public" static="no" const="no" explicit="no" inline="yes" refqual="rvalue" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename U</type>
            <defval>T</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt; T &gt;</type>
        <definition>Result&lt;T&gt; arrow::Future&lt; T &gt;::result</definition>
        <argsstring>(EnableResult&lt; U &gt; *=NULLPTR) &amp;&amp;</argsstring>
        <name>result</name>
        <param>
          <type>EnableResult&lt; U &gt; *</type>
          <defval><ref refid="macros_8h_1a3ef7eab8cd0e570b6586628cc9d5ccab" kindref="member">NULLPTR</ref></defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="280" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="280" bodyend="284"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1af690abcebd3049d956dd39b04dd29463" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Future&lt; T &gt;::status</definition>
        <argsstring>() const</argsstring>
        <name>status</name>
        <briefdescription>
<para>Wait for the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> to complete and return its <ref refid="classarrow_1_1_status" kindref="compound">Status</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="287" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="287" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1aa0af9b784ec0ebf42360f1c64b3fdf4c" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::Future&lt; T &gt;::Wait</definition>
        <argsstring>() const</argsstring>
        <name>Wait</name>
        <briefdescription>
<para>Wait for the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> to complete. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="294" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="294" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1aef547d9d980e9d011812886ba0f6fae2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::Future&lt; T &gt;::Wait</definition>
        <argsstring>(double seconds) const</argsstring>
        <name>Wait</name>
        <param>
          <type>double</type>
          <declname>seconds</declname>
        </param>
        <briefdescription>
<para>Wait for the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> to complete, or for the timeout to expire. </para>        </briefdescription>
        <detaileddescription>
<para><computeroutput>true</computeroutput> is returned if the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> completed, <computeroutput>false</computeroutput> if the timeout expired. Note a <computeroutput>false</computeroutput> value is only indicative, as the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> can complete concurrently. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="306" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="306" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1a045fd7356132f0655f4fea480d9616ac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Func</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void arrow::Future&lt; T &gt;::ExecuteAndMarkFinished</definition>
        <argsstring>(Func &amp;&amp;func)</argsstring>
        <name>ExecuteAndMarkFinished</name>
        <param>
          <type>Func &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
<para>Producer API: execute function and mark <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> finished. </para>        </briefdescription>
        <detaileddescription>
<para>The function&apos;s return value is used to set the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&apos;s result. The function can have the following return types:<itemizedlist>
<listitem><para><computeroutput>T</computeroutput></para></listitem><listitem><para><computeroutput><ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;T&gt;</computeroutput>, if T is neither <computeroutput>void</computeroutput> nor <computeroutput><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></computeroutput> </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="323" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="323" bodyend="325"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1aecfdd8249da4b7a6bbceb4216d084643" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void arrow::Future&lt; T &gt;::MarkFinished</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>MarkFinished</name>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Producer API: mark <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> finished. </para>        </briefdescription>
        <detaileddescription>
<para>The arguments are used to set the <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&apos;s result. This function accepts the following signatures:<itemizedlist>
<listitem><para><computeroutput>(T val)</computeroutput>, if T is neither <computeroutput>void</computeroutput> nor <computeroutput><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></computeroutput></para></listitem><listitem><para><computeroutput>(<ref refid="classarrow_1_1_result" kindref="compound">Result</ref>&lt;T&gt; val)</computeroutput>, if T is neither <computeroutput>void</computeroutput> nor <computeroutput><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></computeroutput></para></listitem><listitem><para><computeroutput>(<ref refid="classarrow_1_1_status" kindref="compound">Status</ref> st)</computeroutput>, if T is <computeroutput>void</computeroutput> or <computeroutput><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></computeroutput></para></listitem><listitem><para><computeroutput>()</computeroutput>, if T is <computeroutput>void</computeroutput> </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="336" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="336" bodyend="338"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classarrow_1_1_future_1a100c35295441f491f161120c815091f2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarrow_1_1_future" kindref="compound">Future</ref></type>
        <definition>static Future arrow::Future&lt; T &gt;::Make</definition>
        <argsstring>()</argsstring>
        <name>Make</name>
        <briefdescription>
<para>Producer API: instantiate a valid <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>The <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&apos;s state is initialized with PENDING. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="343" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="343" bodyend="348"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_future_1af06bbaf371e3028b86d9b2d898a1846a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classarrow_1_1_future" kindref="compound">Future</ref></type>
        <definition>static Future arrow::Future&lt; T &gt;::MakeFinished</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>MakeFinished</name>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Producer API: instantiate a finished <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>The given arguments are passed to <ref refid="classarrow_1_1_future_1aecfdd8249da4b7a6bbceb4216d084643" kindref="member">MarkFinished()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="354" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="354" bodyend="359"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classarrow_1_1_future_1a6433ca67fd5783a26a4baa2f6f004202" prot="protected" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::Future&lt; T &gt;::CheckValid</definition>
        <argsstring>() const</argsstring>
        <name>CheckValid</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/future.h" line="362" column="1" bodyfile="/arrow/cpp/src/arrow/util/future.h" bodystart="362" bodyend="368"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>EXPERIMENTAL A std::future-like class with more functionality. </para>    </briefdescription>
    <detaileddescription>
<para>A <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> represents the results of a past or future computation. The <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> API has two sides: a producer side and a consumer side.</para><para>The producer API allows creating a <ref refid="classarrow_1_1_future" kindref="compound">Future</ref> and setting its result or status, possibly after running a computation function.</para><para>The consumer API allows querying a <ref refid="classarrow_1_1_future" kindref="compound">Future</ref>&apos;s current state, wait for it to complete, or wait on multiple Futures at once (using WaitForAll, WaitForAny or <ref refid="classarrow_1_1_as_completed_iterator" kindref="compound">AsCompletedIterator</ref>). </para>    </detaileddescription>
    <collaborationgraph>
      <node id="2089">
        <label>arrow::Future&lt; T &gt;</label>
        <link refid="classarrow_1_1_future"/>
        <childnode refid="2090" relation="usage">
          <edgelabel>impl_</edgelabel>
        </childnode>
      </node>
      <node id="2090">
        <label>arrow::FutureImpl</label>
        <link refid="classarrow_1_1_future_impl"/>
      </node>
    </collaborationgraph>
    <location file="/arrow/cpp/src/arrow/io/interfaces.h" line="34" column="1" bodyfile="/arrow/cpp/src/arrow/io/interfaces.h" bodystart="34" bodyend="-1"/>
    <listofallmembers>
      <member refid="classarrow_1_1_future_1a6433ca67fd5783a26a4baa2f6f004202" prot="protected" virt="non-virtual"><scope>arrow::Future</scope><name>CheckValid</name></member>
      <member refid="classarrow_1_1_future_1ac2f0ba0d2d3c23dae10f10df7618065d" prot="private" virt="non-virtual"><scope>arrow::Future</scope><name>EnableResult</name></member>
      <member refid="classarrow_1_1_future_1a045fd7356132f0655f4fea480d9616ac" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>ExecuteAndMarkFinished</name></member>
      <member refid="classarrow_1_1_future_1a3e69c5d668fdfdb3c0bf485228146393" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>Future</name></member>
      <member refid="classarrow_1_1_future_1a2ba01fc6ef9c09d587c287c6e8204010" prot="private" virt="non-virtual"><scope>arrow::Future</scope><name>HasValue</name></member>
      <member refid="classarrow_1_1_future_1acadfe2e4dc340be798b940aadf9fd230" prot="protected" virt="non-virtual"><scope>arrow::Future</scope><name>impl_</name></member>
      <member refid="classarrow_1_1_future_1af2ba2618de95a29e50181cfbe4803764" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>is_valid</name></member>
      <member refid="classarrow_1_1_future_1a007dafa635b5f0aac2b4f8a979646095" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>kInfinity</name></member>
      <member refid="classarrow_1_1_future_1a100c35295441f491f161120c815091f2" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>Make</name></member>
      <member refid="classarrow_1_1_future_1af06bbaf371e3028b86d9b2d898a1846a" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>MakeFinished</name></member>
      <member refid="classarrow_1_1_future_1aecfdd8249da4b7a6bbceb4216d084643" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>MarkFinished</name></member>
      <member refid="classarrow_1_1_future_1a5dd58e6ba0ffd155c0e6757f8a306f27" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>result</name></member>
      <member refid="classarrow_1_1_future_1a1fae482e513493f2a7d4da21193fcdd9" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>result</name></member>
      <member refid="classarrow_1_1_future_1af5ed07708946f090bb76f7544f68e483" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>state</name></member>
      <member refid="classarrow_1_1_future_1af690abcebd3049d956dd39b04dd29463" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>status</name></member>
      <member refid="classarrow_1_1_future_1aa51be76771324fc42b9d7b168e7f7813" prot="protected" virt="non-virtual"><scope>arrow::Future</scope><name>storage_</name></member>
      <member refid="classarrow_1_1_future_1aa0af9b784ec0ebf42360f1c64b3fdf4c" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>Wait</name></member>
      <member refid="classarrow_1_1_future_1aef547d9d980e9d011812886ba0f6fae2" prot="public" virt="non-virtual"><scope>arrow::Future</scope><name>Wait</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
