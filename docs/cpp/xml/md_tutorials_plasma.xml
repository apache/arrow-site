<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="md_tutorials_plasma" kind="page">
    <compoundname>md_tutorials_plasma</compoundname>
    <title>plasma</title>
    <detaileddescription>
<para><heading level="1">Using the Plasma In-Memory Object Store from C++ </heading>
</para><para>Apache Arrow offers the ability to share your data structures among multiple processes simultaneously through Plasma, an in-memory object store.</para><para>Note that <bold>the Plasma API is not stable</bold>.</para><para>Plasma clients are processes that run on the same machine as the object store. They communicate with the object store over Unix domain sockets, and they read and write data in the object store through shared memory.</para><para>Plasma objects are immutable once they have been created.</para><para>The following goes over the basics so you can begin using Plasma in your big data applications.</para><para><heading level="2">Starting the Plasma store </heading>
</para><para>To start running the Plasma object store so that clients may connect and access the data, run the following command:</para><para><programlisting><codeline><highlight class="normal">plasma_store_server<sp/>-m<sp/>1000000000<sp/>-s<sp/>/tmp/plasma</highlight></codeline>
</programlisting></para><para>The <computeroutput>-m</computeroutput> flag specifies the size of the object store in bytes. The <computeroutput>-s</computeroutput> flag specifies the path of the Unix domain socket that the store will listen at.</para><para>Therefore, the above command initializes a Plasma store up to 1 GB of memory and sets the socket to <computeroutput>/tmp/plasma.</computeroutput></para><para>The Plasma store will remain available as long as the <computeroutput>plasma_store_server</computeroutput> process is running in a terminal window. Messages, such as alerts for disconnecting clients, may occasionally be output. To stop running the Plasma store, you can press <computeroutput>Ctrl-C</computeroutput> in the terminal window.</para><para>Alternatively, you can run the Plasma store in the background and ignore all message output with the following terminal command:</para><para><programlisting><codeline><highlight class="normal">plasma_store_server<sp/>-m<sp/>1000000000<sp/>-s<sp/>/tmp/plasma<sp/>1&gt;<sp/>/dev/null<sp/>2&gt;<sp/>/dev/null<sp/>&amp;</highlight></codeline>
</programlisting></para><para>The Plasma store will instead run silently in the background. To stop running the Plasma store in this case, issue the command below:</para><para><programlisting><codeline><highlight class="normal">killall<sp/>plasma_store_server</highlight></codeline>
</programlisting></para><para><heading level="2">Creating a Plasma client </heading>
</para><para>Now that the Plasma object store is up and running, it is time to make a client process connect to it. To use the Plasma object store as a client, your application should initialize a <computeroutput><ref refid="classplasma_1_1_plasma_client" kindref="compound">plasma::PlasmaClient</ref></computeroutput> object and tell it to connect to the socket specified when starting up the Plasma object store.</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="plasma_2client_8h" kindref="compound">plasma/client.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceplasma" kindref="compound">plasma</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="namespacebpacking__avx512__codegen_1ace7df4d4508bbb6ca8ea4424e00dc41e" kindref="member">main</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>up<sp/>and<sp/>connect<sp/>a<sp/>Plasma<sp/>client.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classplasma_1_1_plasma_client" kindref="compound">PlasmaClient</ref><sp/>client;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1aec01341bd801c10abbfb1f31f1e9eaa2" kindref="member">Connect</ref>(</highlight><highlight class="stringliteral">&quot;/tmp/plasma&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Disconnect<sp/>the<sp/>Plasma<sp/>client.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a82ff4d7b988c040aa46674a2fa907eff" kindref="member">Disconnect</ref>());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Save this program in a file <computeroutput>test.cc</computeroutput> and compile it with</para><para><programlisting><codeline><highlight class="normal">g++<sp/>test.cc<sp/>`pkg-config<sp/>--cflags<sp/>--libs<sp/>plasma`<sp/>--std=c++11</highlight></codeline>
</programlisting></para><para>Note that multiple clients can be created within the same process.</para><para>Note that a <computeroutput>PlasmaClient</computeroutput> object is <bold>not thread safe</bold>.</para><para>If the Plasma store is still running, you can now execute the <computeroutput>a.out</computeroutput> executable and the store will print something like</para><para><programlisting><codeline><highlight class="normal">Disconnecting<sp/>client<sp/>on<sp/>fd<sp/>5</highlight></codeline>
</programlisting></para><para>which shows that the client was successfully disconnected.</para><para><heading level="2">Object IDs </heading>
</para><para>The Plasma object store uses twenty-byte identifiers for accessing objects stored in shared memory. Each object in the Plasma store should be associated with a unique ID. The Object ID is then a key that can be used by <bold>any</bold> client to fetch that object from the Plasma store.</para><para>Random generation of Object IDs is often good enough to ensure unique IDs. For test purposes, you can use the function <computeroutput>random_object_id</computeroutput> from the header <computeroutput>plasma/test-util.h</computeroutput> to generate random Object IDs, which uses a global random number generator. In your own applications, we recommend to generate a string of <computeroutput>ObjectID::size()</computeroutput> many random bytes using your own random number generator and pass them to <computeroutput>ObjectID::from_bytes</computeroutput> to generate the ObjectID.</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;plasma/test-util.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Randomly<sp/>generate<sp/>an<sp/>Object<sp/>ID.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceplasma_1adf1aa2f87f6f11e1993628f574e31e75" kindref="member">ObjectID</ref><sp/>object_id<sp/>=<sp/>random_object_id();</highlight></codeline>
</programlisting></para><para>Now, any connected client that knows the object&apos;s Object ID can access the same object from the Plasma object store. For easy transportation of Object IDs, you can convert/serialize an Object ID into a binary string and back as follows:</para><para><programlisting><codeline><highlight class="comment">//<sp/>From<sp/>ObjectID<sp/>to<sp/>binary<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacestd" kindref="compound">std</ref>:</highlight><highlight class="keywordtype">string</highlight><highlight class="normal"><sp/>id_string<sp/>=<sp/>object_id.binary();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>From<sp/>binary<sp/>string<sp/>to<sp/>ObjectID</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceplasma_1adf1aa2f87f6f11e1993628f574e31e75" kindref="member">ObjectID</ref><sp/>id_object<sp/>=<sp/>ObjectID::from_binary(&amp;id_string);</highlight></codeline>
</programlisting></para><para>You can also get a human readable representation of ObjectIDs in the same format that git uses for commit hashes by running <computeroutput>ObjectID::hex</computeroutput>.</para><para>Here is a test program you can run:</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;iostream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;<ref refid="plasma_2client_8h" kindref="compound">plasma/client.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;plasma/test-util.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceplasma" kindref="compound">plasma</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="namespacebpacking__avx512__codegen_1ace7df4d4508bbb6ca8ea4424e00dc41e" kindref="member">main</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classplasma_1_1_unique_i_d" kindref="compound">ObjectID</ref><sp/>object_id1<sp/>=<sp/>random_object_id();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;object_id1<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>object_id1.<ref refid="classplasma_1_1_unique_i_d_1a7d960f1c661c8bef8281d30f6a2019a7" kindref="member">hex</ref>()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>id_string<sp/>=<sp/>object_id1.<ref refid="classplasma_1_1_unique_i_d_1a8646de53cd1ec9c3e4e68ba3f92a518a" kindref="member">binary</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classplasma_1_1_unique_i_d" kindref="compound">ObjectID</ref><sp/>object_id2<sp/>=<sp/><ref refid="classplasma_1_1_unique_i_d_1a35bce29897b79eb6215fbd1b9ebe99bb" kindref="member">ObjectID::from_binary</ref>(id_string);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;object_id2<sp/>is<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>object_id2.<ref refid="classplasma_1_1_unique_i_d_1a7d960f1c661c8bef8281d30f6a2019a7" kindref="member">hex</ref>()<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="2">Creating an Object </heading>
</para><para>Now that you learned about Object IDs that are used to refer to objects, let&apos;s look at how objects can be stored in Plasma.</para><para>Storing objects is a two-stage process. First a buffer is allocated with a call to <computeroutput>Create</computeroutput>. Then it can be constructed in place by the client. Then it is made immutable and shared with other clients via a call to <computeroutput>Seal</computeroutput>.</para><para>The <computeroutput>Create</computeroutput> call blocks while the Plasma store allocates a buffer of the appropriate size. The client will then map the buffer into its own address space. At this point the object can be constructed in place using a pointer that was written by the <computeroutput>Create</computeroutput> command.</para><para><programlisting><codeline><highlight class="normal">int64_t<sp/>data_size<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>address<sp/>of<sp/>the<sp/>buffer<sp/>allocated<sp/>by<sp/>the<sp/>Plasma<sp/>store<sp/>will<sp/>be<sp/>written<sp/>at</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>this<sp/>address.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::shared_ptr&lt;Buffer&gt;<sp/><ref refid="namespacemake__precompiled__bitcode_1a4be8fd83a685b255381089b8c3ecb5a0" kindref="member">data</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>Plasma<sp/>object<sp/>by<sp/>specifying<sp/>its<sp/>ID<sp/>and<sp/>size.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1abe3bad1cc4dca0445107953e7a15c390" kindref="member">Create</ref>(object_id,<sp/>data_size,<sp/>NULL,<sp/>0,<sp/>&amp;data));</highlight></codeline>
</programlisting></para><para>You can also specify metadata for the object; the third argument is the metadata (as raw bytes) and the fourth argument is the size of the metadata.</para><para><programlisting><codeline><highlight class="comment">//<sp/>Create<sp/>a<sp/>Plasma<sp/>object<sp/>with<sp/>metadata.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">int64_t<sp/>data_size<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>metadata<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;{&apos;author&apos;:<sp/>&apos;john&apos;}&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">std::shared_ptr&lt;Buffer&gt;<sp/><ref refid="namespacemake__precompiled__bitcode_1a4be8fd83a685b255381089b8c3ecb5a0" kindref="member">data</ref>;</highlight></codeline>
<codeline><highlight class="normal">client.<ref refid="classplasma_1_1_plasma_client_1abe3bad1cc4dca0445107953e7a15c390" kindref="member">Create</ref>(object_id,<sp/>data_size,<sp/>(uint8_t*)<sp/>metadata.data(),<sp/>metadata.size(),<sp/>&amp;<ref refid="namespacemake__precompiled__bitcode_1a4be8fd83a685b255381089b8c3ecb5a0" kindref="member">data</ref>);</highlight></codeline>
</programlisting></para><para>Now that we&apos;ve obtained a pointer to our object&apos;s data, we can write our data to it:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Write<sp/>some<sp/>data<sp/>for<sp/>the<sp/>Plasma<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int64_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>data_size;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>data[i]<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(i<sp/>%<sp/>4);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>When the client is done, the client <bold>seals</bold> the buffer, making the object immutable, and making it available to other Plasma clients:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Seal<sp/>the<sp/>object.<sp/>This<sp/>makes<sp/>it<sp/>available<sp/>for<sp/>all<sp/>clients.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">client.<ref refid="classplasma_1_1_plasma_client_1ae06a7b43528f66b2dd28abf7138e5b6d" kindref="member">Seal</ref>(object_id);</highlight></codeline>
</programlisting></para><para>Here is an example that combines all these features:</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="plasma_2client_8h" kindref="compound">plasma/client.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceplasma" kindref="compound">plasma</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="namespacebpacking__avx512__codegen_1ace7df4d4508bbb6ca8ea4424e00dc41e" kindref="member">main</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>up<sp/>and<sp/>connect<sp/>a<sp/>Plasma<sp/>client.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classplasma_1_1_plasma_client" kindref="compound">PlasmaClient</ref><sp/>client;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1aec01341bd801c10abbfb1f31f1e9eaa2" kindref="member">Connect</ref>(</highlight><highlight class="stringliteral">&quot;/tmp/plasma&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>an<sp/>object<sp/>with<sp/>a<sp/>fixed<sp/>ObjectID.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classplasma_1_1_unique_i_d" kindref="compound">ObjectID</ref><sp/>object_id<sp/>=<sp/><ref refid="classplasma_1_1_unique_i_d_1a35bce29897b79eb6215fbd1b9ebe99bb" kindref="member">ObjectID::from_binary</ref>(</highlight><highlight class="stringliteral">&quot;00000000000000000000&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>data_size<sp/>=<sp/>1000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::shared_ptr&lt;Buffer&gt;<sp/><ref refid="namespacemake__precompiled__bitcode_1a4be8fd83a685b255381089b8c3ecb5a0" kindref="member">data</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>metadata<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;{&apos;author&apos;:<sp/>&apos;john&apos;}&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1abe3bad1cc4dca0445107953e7a15c390" kindref="member">Create</ref>(object_id,<sp/>data_size,<sp/>(uint8_t*)<sp/>metadata.data(),<sp/>metadata.size(),<sp/>&amp;<ref refid="namespacemake__precompiled__bitcode_1a4be8fd83a685b255381089b8c3ecb5a0" kindref="member">data</ref>));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Write<sp/>some<sp/>data<sp/>into<sp/>the<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>d<sp/>=<sp/>data-&gt;mutable_data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int64_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>data_size;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>d[i]<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal">uint8_t</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(i<sp/>%<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Seal<sp/>the<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1ae06a7b43528f66b2dd28abf7138e5b6d" kindref="member">Seal</ref>(object_id));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Disconnect<sp/>the<sp/>client.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a82ff4d7b988c040aa46674a2fa907eff" kindref="member">Disconnect</ref>());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This example can be compiled with</para><para><programlisting><codeline><highlight class="normal">g++<sp/>create.cc<sp/>`pkg-config<sp/>--cflags<sp/>--libs<sp/>plasma`<sp/>--std=c++11<sp/>-o<sp/>create</highlight></codeline>
</programlisting></para><para>To verify that an object exists in the Plasma object store, you can call <computeroutput>PlasmaClient::Contains()</computeroutput> to check if an object has been created and sealed for a given Object ID. Note that this function will still return False if the object has been created, but not yet sealed:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Check<sp/>if<sp/>an<sp/>object<sp/>has<sp/>been<sp/>created<sp/>and<sp/>sealed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>has_object;</highlight></codeline>
<codeline><highlight class="normal">client.<ref refid="classplasma_1_1_plasma_client_1af573b2ba35f48bf012393e9438ef086d" kindref="member">Contains</ref>(object_id,<sp/>&amp;has_object);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(has_object)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Object<sp/>has<sp/>been<sp/>created<sp/>and<sp/>sealed,<sp/>proceed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><heading level="2">Getting an Object </heading>
</para><para>After an object has been sealed, any client who knows the Object ID can get the object. To store the retrieved object contents, you should create an <computeroutput>ObjectBuffer</computeroutput>, then call <computeroutput>PlasmaClient::Get()</computeroutput> as follows:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Get<sp/>from<sp/>the<sp/>Plasma<sp/>store<sp/>by<sp/>Object<sp/>ID.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ObjectBuffer<sp/>object_buffer;</highlight></codeline>
<codeline><highlight class="normal">client.<ref refid="classplasma_1_1_plasma_client_1a5b2626c32d557a57e66800027ba24b96" kindref="member">Get</ref>(&amp;object_id,<sp/>1,<sp/>-1,<sp/>&amp;object_buffer);</highlight></codeline>
</programlisting></para><para><computeroutput>PlasmaClient::Get()</computeroutput> isn&apos;t limited to fetching a single object from the Plasma store at once. You can specify an array of Object IDs and <computeroutput>ObjectBuffers</computeroutput> to fetch at once, so long as you also specify the number of objects being fetched:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Get<sp/>two<sp/>objects<sp/>at<sp/>once<sp/>from<sp/>the<sp/>Plasma<sp/>store.<sp/>This<sp/>function</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>call<sp/>will<sp/>block<sp/>until<sp/>both<sp/>objects<sp/>have<sp/>been<sp/>fetched.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ObjectBuffer<sp/>multiple_buffers[2];</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceplasma_1adf1aa2f87f6f11e1993628f574e31e75" kindref="member">ObjectID</ref><sp/>multiple_ids[2]<sp/>=<sp/>{object_id1,<sp/>object_id2};</highlight></codeline>
<codeline><highlight class="normal">client.<ref refid="classplasma_1_1_plasma_client_1a5b2626c32d557a57e66800027ba24b96" kindref="member">Get</ref>(multiple_ids,<sp/>2,<sp/>-1,<sp/>multiple_buffers);</highlight></codeline>
</programlisting></para><para>Since <computeroutput>PlasmaClient::Get()</computeroutput> is a blocking function call, it may be necessary to limit the amount of time the function is allowed to take when trying to fetch from the Plasma store. You can pass in a timeout in milliseconds when calling <computeroutput>PlasmaClient::Get().</computeroutput> To use <computeroutput>PlasmaClient::Get()</computeroutput> without a timeout, just pass in -1 like in the previous example calls:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Make<sp/>the<sp/>function<sp/>call<sp/>give<sp/>up<sp/>fetching<sp/>the<sp/>object<sp/>if<sp/>it<sp/>takes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>more<sp/>than<sp/>100<sp/>milliseconds.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">int64_t<sp/>timeout<sp/>=<sp/>100;</highlight></codeline>
<codeline><highlight class="normal">client.<ref refid="classplasma_1_1_plasma_client_1a5b2626c32d557a57e66800027ba24b96" kindref="member">Get</ref>(&amp;object_id,<sp/>1,<sp/>timeout,<sp/>&amp;object_buffer);</highlight></codeline>
</programlisting></para><para>Finally, to access the object, you can access the <computeroutput>data</computeroutput> and <computeroutput>metadata</computeroutput> attributes of the <computeroutput>ObjectBuffer</computeroutput>. The <computeroutput>data</computeroutput> can be indexed like any array:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Access<sp/>object<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">uint8_t*<sp/>data<sp/>=<sp/>object_buffer.data;</highlight></codeline>
<codeline><highlight class="normal">int64_t<sp/>data_size<sp/>=<sp/>object_buffer.data_size;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Access<sp/>object<sp/>metadata.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">uint8_t*<sp/>metadata<sp/>=<sp/>object_buffer.metadata;</highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>metadata_size<sp/>=<sp/>object_buffer.metadata_size;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Index<sp/>into<sp/>data<sp/>array.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">uint8_t<sp/>first_data_byte<sp/>=<sp/>data[0];</highlight></codeline>
</programlisting></para><para>Here is a longer example that shows these capabilities:</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="plasma_2client_8h" kindref="compound">plasma/client.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceplasma" kindref="compound">plasma</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="namespacebpacking__avx512__codegen_1ace7df4d4508bbb6ca8ea4424e00dc41e" kindref="member">main</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>up<sp/>and<sp/>connect<sp/>a<sp/>Plasma<sp/>client.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classplasma_1_1_plasma_client" kindref="compound">PlasmaClient</ref><sp/>client;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1aec01341bd801c10abbfb1f31f1e9eaa2" kindref="member">Connect</ref>(</highlight><highlight class="stringliteral">&quot;/tmp/plasma&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classplasma_1_1_unique_i_d" kindref="compound">ObjectID</ref><sp/>object_id<sp/>=<sp/><ref refid="classplasma_1_1_unique_i_d_1a35bce29897b79eb6215fbd1b9ebe99bb" kindref="member">ObjectID::from_binary</ref>(</highlight><highlight class="stringliteral">&quot;00000000000000000000&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="structplasma_1_1_object_buffer" kindref="compound">ObjectBuffer</ref><sp/>object_buffer;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a5b2626c32d557a57e66800027ba24b96" kindref="member">Get</ref>(&amp;object_id,<sp/>1,<sp/>-1,<sp/>&amp;object_buffer));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Retrieve<sp/>object<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>buffer<sp/>=<sp/>object_buffer.<ref refid="structplasma_1_1_object_buffer_1ace0c6be03d13cc503d665fe976557558" kindref="member">data</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>uint8_t*<sp/>data<sp/>=<sp/>buffer-&gt;data();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>data_size<sp/>=<sp/>buffer-&gt;size();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>that<sp/>the<sp/>data<sp/>agrees<sp/>with<sp/>what<sp/>was<sp/>written<sp/>in<sp/>the<sp/>other<sp/>process.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(int64_t<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>data_size;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="arrow_2util_2logging_8h_1a389e6c69f3ba2e62c5a9e0372059f1a4" kindref="member">ARROW_CHECK</ref>(data[i]<sp/>==<sp/>static_cast&lt;uint8_t&gt;(i<sp/>%<sp/>4));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Disconnect<sp/>the<sp/>client.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a82ff4d7b988c040aa46674a2fa907eff" kindref="member">Disconnect</ref>());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>If you compile it with</para><para><programlisting><codeline><highlight class="normal">g++<sp/>get.cc<sp/>`pkg-config<sp/>--cflags<sp/>--libs<sp/>plasma`<sp/>--std=c++11<sp/>-o<sp/>get</highlight></codeline>
</programlisting></para><para>and run it with <computeroutput>./get</computeroutput>, all the assertions will pass if you run the <computeroutput>create</computeroutput> example from above on the same Plasma store.</para><para><heading level="2">Object Lifetime Management </heading>
</para><para>The Plasma store internally does reference counting to make sure objects that are mapped into the address space of one of the clients with <computeroutput>PlasmaClient::Get</computeroutput> are accessible. To unmap objects from a client, call <computeroutput>PlasmaClient::Release</computeroutput>. All objects that are mapped into a clients address space will automatically be released when the client is disconnected from the store (this happens even if the client process crashes or otherwise fails to call <computeroutput>Disconnect</computeroutput>).</para><para>If a new object is created and there is not enough space in the Plasma store, the store will evict the least recently used object (an object is in use if at least one client has gotten it but not released it).</para><para><heading level="2">Object notifications </heading>
</para><para>Additionally, you can arrange to have Plasma notify you when objects are sealed in the object store. This may especially be handy when your program is collaborating with other Plasma clients, and needs to know when they make objects available.</para><para>First, you can subscribe your current Plasma client to such notifications by getting a file descriptor:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Start<sp/>receiving<sp/>notifications<sp/>into<sp/>file_descriptor.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>fd;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a9975de6729ca214fa6cb8e9fe8abbb9a" kindref="member">Subscribe</ref>(&amp;fd));</highlight></codeline>
</programlisting></para><para>Once you have the file descriptor, you can have your current Plasma client wait to receive the next object notification. Object notifications include information such as Object ID, data size, and metadata size of the next newly available object:</para><para><programlisting><codeline><highlight class="comment">//<sp/>Receive<sp/>notification<sp/>of<sp/>the<sp/>next<sp/>newly<sp/>available<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Notification<sp/>information<sp/>is<sp/>stored<sp/>in<sp/>object_id,<sp/>data_size,<sp/>and<sp/>metadata_size</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespaceplasma_1adf1aa2f87f6f11e1993628f574e31e75" kindref="member">ObjectID</ref><sp/>object_id;</highlight></codeline>
<codeline><highlight class="normal">int64_t<sp/>data_size;</highlight></codeline>
<codeline><highlight class="normal">int64_t<sp/>metadata_size;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a5cf17041829848e39e1bfe9ea66ed2c2" kindref="member">GetNotification</ref>(fd,<sp/>&amp;object_id,<sp/>&amp;data_size,<sp/>&amp;metadata_size));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Get<sp/>the<sp/>newly<sp/>available<sp/>object.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ObjectBuffer<sp/>object_buffer;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a5b2626c32d557a57e66800027ba24b96" kindref="member">Get</ref>(&amp;object_id,<sp/>1,<sp/>-1,<sp/>&amp;object_buffer));</highlight></codeline>
</programlisting></para><para>Here is a full program that shows this capability:</para><para><programlisting><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="plasma_2client_8h" kindref="compound">plasma/client.h</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceplasma" kindref="compound">plasma</ref>;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="namespacebpacking__avx512__codegen_1ace7df4d4508bbb6ca8ea4424e00dc41e" kindref="member">main</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Start<sp/>up<sp/>and<sp/>connect<sp/>a<sp/>Plasma<sp/>client.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classplasma_1_1_plasma_client" kindref="compound">PlasmaClient</ref><sp/>client;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1aec01341bd801c10abbfb1f31f1e9eaa2" kindref="member">Connect</ref>(</highlight><highlight class="stringliteral">&quot;/tmp/plasma&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>fd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a9975de6729ca214fa6cb8e9fe8abbb9a" kindref="member">Subscribe</ref>(&amp;fd));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classplasma_1_1_unique_i_d" kindref="compound">ObjectID</ref><sp/>object_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>data_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int64_t<sp/>metadata_size;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">true</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a5cf17041829848e39e1bfe9ea66ed2c2" kindref="member">GetNotification</ref>(fd,<sp/>&amp;object_id,<sp/>&amp;data_size,<sp/>&amp;metadata_size));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Received<sp/>object<sp/>notification<sp/>for<sp/>object_id<sp/>=<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>object_id.hex()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>with<sp/>data_size<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>data_size</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>and<sp/>metadata_size<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>metadata_size<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Disconnect<sp/>the<sp/>client.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="arrow_2util_2logging_8h_1ab1dca026b4840fea1e82df4c176de6b3" kindref="member">ARROW_CHECK_OK</ref>(client.<ref refid="classplasma_1_1_plasma_client_1a82ff4d7b988c040aa46674a2fa907eff" kindref="member">Disconnect</ref>());</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>If you compile it with</para><para><programlisting><codeline><highlight class="normal">g++<sp/>subscribe.cc<sp/>`pkg-config<sp/>--cflags<sp/>--libs<sp/>plasma`<sp/>--std=c++11<sp/>-o<sp/>subscribe</highlight></codeline>
</programlisting></para><para>and invoke <computeroutput>./create</computeroutput> and <computeroutput>./subscribe</computeroutput> while the Plasma store is running, you can observe the new object arriving. </para>    </detaileddescription>
  </compounddef>
</doxygen>
