<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1util_1_1_rle_decoder" kind="class" language="C++" prot="public">
    <compoundname>arrow::util::RleDecoder</compoundname>
    <includes refid="rle__encoding_8h" local="no">arrow/util/rle_encoding.h</includes>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_decoder_1abc4bbe1847bd0dd04a51f81972d846e7" prot="protected" static="no" mutable="no">
        <type>BitUtil::BitReader</type>
        <definition>BitUtil::BitReader arrow::util::RleDecoder::bit_reader_</definition>
        <argsstring></argsstring>
        <name>bit_reader_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="139" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="139" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_decoder_1a43e57698def7bfd3cc7da70cb2979835" prot="protected" static="no" mutable="no">
        <type>int</type>
        <definition>int arrow::util::RleDecoder::bit_width_</definition>
        <argsstring></argsstring>
        <name>bit_width_</name>
        <briefdescription>
<para>Number of bits needed to encode the value. Must be between 0 and 64. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="141" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="141" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_decoder_1a5083cb6107087bce883571c34f37b619" prot="protected" static="no" mutable="no">
        <type>uint64_t</type>
        <definition>uint64_t arrow::util::RleDecoder::current_value_</definition>
        <argsstring></argsstring>
        <name>current_value_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="142" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="142" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_decoder_1a558ea1da20bf44666f7b5e7b9b0dba3d" prot="protected" static="no" mutable="no">
        <type>int32_t</type>
        <definition>int32_t arrow::util::RleDecoder::repeat_count_</definition>
        <argsstring></argsstring>
        <name>repeat_count_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="143" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="143" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_decoder_1ab3949c9b7429d7c5eca6b0e7785d4114" prot="protected" static="no" mutable="no">
        <type>int32_t</type>
        <definition>int32_t arrow::util::RleDecoder::literal_count_</definition>
        <argsstring></argsstring>
        <name>literal_count_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="144" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="144" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_decoder_1aaebb3e3674a08e0cdf1c7658e562543a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::util::RleDecoder::RleDecoder</definition>
        <argsstring>(const uint8_t *buffer, int buffer_len, int bit_width)</argsstring>
        <name>RleDecoder</name>
        <param>
          <type>const uint8_t *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>buffer_len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bit_width</declname>
        </param>
        <briefdescription>
<para>Create a decoder object. </para>        </briefdescription>
        <detaileddescription>
<para>buffer/buffer_len is the decoded data. bit_width is the width of each value (before encoding). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="89" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="89" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_decoder_1a25ddb7000f17bb7c694217afcacaf47c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::util::RleDecoder::RleDecoder</definition>
        <argsstring>()</argsstring>
        <name>RleDecoder</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="99" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="99" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_decoder_1a4424bd7ca2e897d429f94ee0d8d2d219" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::util::RleDecoder::Reset</definition>
        <argsstring>(const uint8_t *buffer, int buffer_len, int bit_width)</argsstring>
        <name>Reset</name>
        <param>
          <type>const uint8_t *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>buffer_len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bit_width</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="101" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="101" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_decoder_1adf113d49f938fcfeb11431e186d62d11" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool arrow::util::RleDecoder::Get</definition>
        <argsstring>(T *val)</argsstring>
        <name>Get</name>
        <param>
          <type>T *</type>
          <declname>val</declname>
        </param>
        <briefdescription>
<para>Gets the next value. Returns false if there are no more. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="113" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="289" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_decoder_1a5fddb45e23c7d3b0210f0851d3c91764" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int arrow::util::RleDecoder::GetBatch</definition>
        <argsstring>(T *values, int batch_size)</argsstring>
        <name>GetBatch</name>
        <param>
          <type>T *</type>
          <declname>values</declname>
        </param>
        <param>
          <type>int</type>
          <declname>batch_size</declname>
        </param>
        <briefdescription>
<para>Gets a batch of values. Returns the number of decoded elements. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="117" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="294" bodyend="326"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_decoder_1ac9c2ad67c5159f3ab3dce3fa5a4a156d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int arrow::util::RleDecoder::GetBatchSpaced</definition>
        <argsstring>(int batch_size, int null_count, const uint8_t *valid_bits, int64_t valid_bits_offset, T *out)</argsstring>
        <name>GetBatchSpaced</name>
        <param>
          <type>int</type>
          <declname>batch_size</declname>
        </param>
        <param>
          <type>int</type>
          <declname>null_count</declname>
        </param>
        <param>
          <type>const uint8_t *</type>
          <declname>valid_bits</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>valid_bits_offset</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Like GetBatch but add spacing for null entries. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="121" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="329" bodyend="408"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_decoder_1a1be9beaddad6debb63ed36d58f14aa33" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int arrow::util::RleDecoder::GetBatchWithDict</definition>
        <argsstring>(const T *dictionary, int32_t dictionary_length, T *values, int batch_size)</argsstring>
        <name>GetBatchWithDict</name>
        <param>
          <type>const T *</type>
          <declname>dictionary</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>dictionary_length</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>values</declname>
        </param>
        <param>
          <type>int</type>
          <declname>batch_size</declname>
        </param>
        <briefdescription>
<para>Like GetBatch but the values are then decoded using the provided dictionary. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="126" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="415" bodyend="469"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_decoder_1a41e5dcea59ec7365015ec9b4cde0276f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>int</type>
        <definition>int arrow::util::RleDecoder::GetBatchWithDictSpaced</definition>
        <argsstring>(const T *dictionary, int32_t dictionary_length, T *values, int batch_size, int null_count, const uint8_t *valid_bits, int64_t valid_bits_offset)</argsstring>
        <name>GetBatchWithDictSpaced</name>
        <param>
          <type>const T *</type>
          <declname>dictionary</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>dictionary_length</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>values</declname>
        </param>
        <param>
          <type>int</type>
          <declname>batch_size</declname>
        </param>
        <param>
          <type>int</type>
          <declname>null_count</declname>
        </param>
        <param>
          <type>const uint8_t *</type>
          <declname>valid_bits</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>valid_bits_offset</declname>
        </param>
        <briefdescription>
<para>Like GetBatchWithDict but add spacing for null entries. </para>        </briefdescription>
        <detaileddescription>
<para>Null entries will be zero-initialized in <computeroutput>values</computeroutput> to avoid leaking private data. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="134" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="472" bodyend="567"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_decoder_1a6b14fbe7e7827c69893948ff91836950" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool arrow::util::RleDecoder::NextCounts</definition>
        <argsstring>()</argsstring>
        <name>NextCounts</name>
        <briefdescription>
<para>Fills literal_count_ and repeat_count_ with next values. </para>        </briefdescription>
        <detaileddescription>
<para>Returns false if there are no more. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="150" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="570" bodyend="596"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Utility classes to do run length encoding (RLE) for fixed bit width values. </para>    </briefdescription>
    <detaileddescription>
<para>If runs are sufficiently long, RLE is used, otherwise, the values are just bit-packed (literal encoding). For both types of runs, there is a byte-aligned indicator which encodes the length of the run and the type of the run. This encoding has the benefit that when there aren&apos;t any long enough runs, values are always decoded at fixed (can be precomputed) bit offsets OR both the value and the run length are byte aligned. This allows for very efficient decoding implementations. The encoding is: encoded-block := run* run := literal-run | repeated-run literal-run := literal-indicator &lt; literal bytes &gt; repeated-run := repeated-indicator &lt; repeated value. padded to byte boundary &gt; literal-indicator := varint_encode( number_of_groups &lt;&lt; 1 | 1) repeated-indicator := varint_encode( number_of_repetitions &lt;&lt; 1 ) Each run is preceded by a varint. The varint&apos;s least significant bit is used to indicate whether the run is a literal run or a repeated run. The rest of the varint is used to determine the length of the run (eg how many times the value repeats). In the case of literal runs, the run length is always a multiple of 8 (i.e. encode in groups of 8), so that no matter the bit-width of the value, the sequence will end on a byte boundary without padding. Given that we know it is a multiple of 8, we store the number of 8-groups rather than the actual number of encoded ints. (This means that the total number of encoded values can not be determined from the encoded data, since the number of values in the last group may not be a multiple of 8). For the last group of literal runs, we pad the group to 8 with zeros. This allows for 8 at a time decoding on the read side without the need for additional checks. There is a break-even point when it is more storage efficient to do run length encoding. For 1 bit-width values, that point is 8 values. They require 2 bytes for both the repeated encoding or the literal encoding. This value can always be computed based on the bit-width. <heading level="2">TODO: think about how to use this for strings. The bit packing isn&apos;t quite the same. Examples with bit-width 1 (eg encoding booleans): </heading>
</para><para>100 1s followed by 100 0s: &lt;varint(100 &lt;&lt; 1)&gt; &lt;1, padded to 1 byte&gt; &lt;varint(100 &lt;&lt; 1)&gt; &lt;0, padded to 1 byte&gt;<itemizedlist>
<listitem><para>(total 4 bytes) alternating 1s and 0s (200 total): 200 ints = 25 groups of 8 &lt;varint((25 &lt;&lt; 1) | 1)&gt; &lt;25 bytes of values, bitpacked&gt; (total 26 bytes, 1 byte overhead) Decoder class for RLE encoded data. </para></listitem></itemizedlist>
</para>    </detaileddescription>
    <collaborationgraph>
      <node id="3925">
        <label>arrow::BitUtil::BitReader</label>
      </node>
      <node id="3924">
        <label>arrow::util::RleDecoder</label>
        <link refid="classarrow_1_1util_1_1_rle_decoder"/>
        <childnode refid="3925" relation="usage">
          <edgelabel>bit_reader_</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="85" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="85" bodyend="151"/>
    <listofallmembers>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1abc4bbe1847bd0dd04a51f81972d846e7" prot="protected" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>bit_reader_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1a43e57698def7bfd3cc7da70cb2979835" prot="protected" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>bit_width_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1a5083cb6107087bce883571c34f37b619" prot="protected" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>current_value_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1adf113d49f938fcfeb11431e186d62d11" prot="public" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>Get</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1a5fddb45e23c7d3b0210f0851d3c91764" prot="public" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>GetBatch</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1ac9c2ad67c5159f3ab3dce3fa5a4a156d" prot="public" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>GetBatchSpaced</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1a1be9beaddad6debb63ed36d58f14aa33" prot="public" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>GetBatchWithDict</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1a41e5dcea59ec7365015ec9b4cde0276f" prot="public" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>GetBatchWithDictSpaced</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1ab3949c9b7429d7c5eca6b0e7785d4114" prot="protected" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>literal_count_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1a6b14fbe7e7827c69893948ff91836950" prot="private" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>NextCounts</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1a558ea1da20bf44666f7b5e7b9b0dba3d" prot="protected" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>repeat_count_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1a4424bd7ca2e897d429f94ee0d8d2d219" prot="public" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>Reset</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1aaebb3e3674a08e0cdf1c7658e562543a" prot="public" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>RleDecoder</name></member>
      <member refid="classarrow_1_1util_1_1_rle_decoder_1a25ddb7000f17bb7c694217afcacaf47c" prot="public" virt="non-virtual"><scope>arrow::util::RleDecoder</scope><name>RleDecoder</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
