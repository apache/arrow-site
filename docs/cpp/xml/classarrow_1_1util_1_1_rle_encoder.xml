<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1util_1_1_rle_encoder" kind="class" language="C++" prot="public">
    <compoundname>arrow::util::RleEncoder</compoundname>
    <includes refid="rle__encoding_8h" local="no">arrow/util/rle_encoding.h</includes>
      <sectiondef kind="private-static-attrib">
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1af8bacd1372fba01ebd0c20f927a3145d" prot="private" static="yes" mutable="no">
        <type>const int</type>
        <definition>const int arrow::util::RleEncoder::MAX_VALUES_PER_LITERAL_RUN</definition>
        <argsstring></argsstring>
        <name>MAX_VALUES_PER_LITERAL_RUN</name>
        <initializer>= (1 &lt;&lt; 6) * 8</initializer>
        <briefdescription>
<para>The maximum number of values in a single literal run (number of groups encodable by a 1-byte indicator * 8) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="248" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="248" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1a2f7fbab1c03cedc269bc09592c2f0a9a" prot="private" static="no" mutable="no">
        <type>const int</type>
        <definition>const int arrow::util::RleEncoder::bit_width_</definition>
        <argsstring></argsstring>
        <name>bit_width_</name>
        <briefdescription>
<para>Number of bits needed to encode the value. Must be between 0 and 64. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="251" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="251" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1aadb9d6f5df2169e5d01ec08c5e49ae12" prot="private" static="no" mutable="no">
        <type>BitUtil::BitWriter</type>
        <definition>BitUtil::BitWriter arrow::util::RleEncoder::bit_writer_</definition>
        <argsstring></argsstring>
        <name>bit_writer_</name>
        <briefdescription>
<para>Underlying buffer. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="254" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="254" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1a42efaa18d66507d0f9ac883d9394f8b0" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool arrow::util::RleEncoder::buffer_full_</definition>
        <argsstring></argsstring>
        <name>buffer_full_</name>
        <briefdescription>
<para>If true, the buffer is full and subsequent <ref refid="classarrow_1_1util_1_1_rle_encoder_1a2e5e59b665781890ccc559c6b5c13c85" kindref="member">Put()</ref>&apos;s will fail. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="257" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="257" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1a24c0e937b2cc5ac0bf50987570d6b00f" prot="private" static="no" mutable="no">
        <type>int</type>
        <definition>int arrow::util::RleEncoder::max_run_byte_size_</definition>
        <argsstring></argsstring>
        <name>max_run_byte_size_</name>
        <briefdescription>
<para>The maximum byte size a single run can take. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="260" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="260" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1a5f938e41189798adce165abecb3ba6fd" prot="private" static="no" mutable="no">
        <type>int64_t</type>
        <definition>int64_t arrow::util::RleEncoder::buffered_values_[8]</definition>
        <argsstring>[8]</argsstring>
        <name>buffered_values_</name>
        <briefdescription>
<para>We need to buffer at most 8 values for literals. </para>        </briefdescription>
        <detaileddescription>
<para>This happens when the bit_width is 1 (so 8 values fit in one byte). TODO: generalize this to other bit widths </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="265" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="265" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1a5a12cf2b8dfedad523a899251b6f2dd4" prot="private" static="no" mutable="no">
        <type>int</type>
        <definition>int arrow::util::RleEncoder::num_buffered_values_</definition>
        <argsstring></argsstring>
        <name>num_buffered_values_</name>
        <briefdescription>
<para>Number of values in buffered_values_. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="268" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="268" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1aa6f6ec7517d0e95d33ad7cfec017aa92" prot="private" static="no" mutable="no">
        <type>uint64_t</type>
        <definition>uint64_t arrow::util::RleEncoder::current_value_</definition>
        <argsstring></argsstring>
        <name>current_value_</name>
        <briefdescription>
<para>The current (also last) value that was written and the count of how many times in a row that value has been seen. </para>        </briefdescription>
        <detaileddescription>
<para>This is maintained even if we are in a literal run. If the repeat_count_ get high enough, we switch to encoding repeated runs. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="274" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="274" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1aff9c6cf440583db14c1d1f50fd014183" prot="private" static="no" mutable="no">
        <type>int</type>
        <definition>int arrow::util::RleEncoder::repeat_count_</definition>
        <argsstring></argsstring>
        <name>repeat_count_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="275" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="275" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1a9db564343911801fb780c58ba0c3cfef" prot="private" static="no" mutable="no">
        <type>int</type>
        <definition>int arrow::util::RleEncoder::literal_count_</definition>
        <argsstring></argsstring>
        <name>literal_count_</name>
        <briefdescription>
<para>Number of literals in the current run. </para>        </briefdescription>
        <detaileddescription>
<para>This does not include the literals that might be in buffered_values_. Only after we&apos;ve got a group big enough can we decide if they should part of the literal_count_ or repeat_count_ </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="280" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="280" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classarrow_1_1util_1_1_rle_encoder_1aafbf615d26b5660f891aa10afc1230a5" prot="private" static="no" mutable="no">
        <type>uint8_t *</type>
        <definition>uint8_t* arrow::util::RleEncoder::literal_indicator_byte_</definition>
        <argsstring></argsstring>
        <name>literal_indicator_byte_</name>
        <briefdescription>
<para>Pointer to a byte in the underlying buffer that stores the indicator byte. </para>        </briefdescription>
        <detaileddescription>
<para>This is reserved as soon as we need a literal run but the value is written when the literal run is complete. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="285" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="285" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1a60a51d6cfef536ffc4da20d22db50b53" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>arrow::util::RleEncoder::RleEncoder</definition>
        <argsstring>(uint8_t *buffer, int buffer_len, int bit_width)</argsstring>
        <name>RleEncoder</name>
        <param>
          <type>uint8_t *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>buffer_len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>bit_width</declname>
        </param>
        <briefdescription>
<para>buffer/buffer_len: preallocated output buffer. </para>        </briefdescription>
        <detaileddescription>
<para>bit_width: max number of bits for value. TODO: consider adding a min_repeated_run_length so the caller can control when values should be encoded as repeated runs. Currently this is derived based on the bit_width, which can determine a storage optimal choice. TODO: allow 0 bit_width (and have dict encoder use it) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="167" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="167" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1a2e5e59b665781890ccc559c6b5c13c85" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool arrow::util::RleEncoder::Put</definition>
        <argsstring>(uint64_t value)</argsstring>
        <name>Put</name>
        <param>
          <type>uint64_t</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Encode value. </para>        </briefdescription>
        <detaileddescription>
<para>This function buffers input values 8 at a time.</para><para>Returns true if the value fits in buffer, false otherwise. This value must be representable with bit_width_ bits.</para><para>After seeing all 8 values, it decides whether they should be encoded as a literal or repeated run. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="211" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="600" bodyend="629"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1ab8b9ede6f970e92aa90543f2ac22097b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int arrow::util::RleEncoder::Flush</definition>
        <argsstring>()</argsstring>
        <name>Flush</name>
        <briefdescription>
<para>Flushes any pending values to the underlying buffer. </para>        </briefdescription>
        <detaileddescription>
<para>Returns the total number of bytes written </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="215" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="707" bodyend="732"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1adcb2d9b0ecc749bec776f7e1a3baa654" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::util::RleEncoder::Clear</definition>
        <argsstring>()</argsstring>
        <name>Clear</name>
        <briefdescription>
<para>Resets all the state in the encoder. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="218" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="741" bodyend="749"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1ae7b580281acc8cb2589fe21d8c8ab815" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>uint8_t *</type>
        <definition>uint8_t* arrow::util::RleEncoder::buffer</definition>
        <argsstring>()</argsstring>
        <name>buffer</name>
        <briefdescription>
<para>Returns pointer to underlying buffer. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="221" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="221" bodyend="221"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1a73af478811cec4e51ca6ae3d676649ac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int32_t</type>
        <definition>int32_t arrow::util::RleEncoder::len</definition>
        <argsstring>()</argsstring>
        <name>len</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="222" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="222" bodyend="222"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1aee4f9f8c6998224e9fb530f889b0bfa0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int arrow::util::RleEncoder::MinBufferSize</definition>
        <argsstring>(int bit_width)</argsstring>
        <name>MinBufferSize</name>
        <param>
          <type>int</type>
          <declname>bit_width</declname>
        </param>
        <briefdescription>
<para>Returns the minimum buffer size needed to use the encoder for &apos;bit_width&apos; This is the maximum length of a single run for &apos;bit_width&apos;. </para>        </briefdescription>
        <detaileddescription>
<para>It is not valid to pass a buffer less than this length. </para>        </detaileddescription>
        <inbodydescription>
<para>1 indicator byte and MAX_VALUES_PER_LITERAL_RUN &apos;bit_width&apos; values.</para><para>Up to kMaxVlqByteLength indicator and a single &apos;bit_width&apos; value. </para>        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="179" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="179" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1acdb52f24fec353f0c59a3efbc5a20d0d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int arrow::util::RleEncoder::MaxBufferSize</definition>
        <argsstring>(int bit_width, int num_values)</argsstring>
        <name>MaxBufferSize</name>
        <param>
          <type>int</type>
          <declname>bit_width</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_values</declname>
        </param>
        <briefdescription>
<para>Returns the maximum byte size it could take to encode &apos;num_values&apos;. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="191" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="191" bodyend="207"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1ae50b9a6d5d190d697fcd7eedfc38c7c8" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::util::RleEncoder::FlushBufferedValues</definition>
        <argsstring>(bool done)</argsstring>
        <name>FlushBufferedValues</name>
        <param>
          <type>bool</type>
          <declname>done</declname>
        </param>
        <briefdescription>
<para>Flushes any buffered values. </para>        </briefdescription>
        <detaileddescription>
<para>Flush the values that have been buffered.</para><para>If this is part of a repeated run, this is largely a no-op. If it is part of a literal run, this will call FlushLiteralRun, which writes out the buffered literal values. If &apos;done&apos; is true, the current run would be written even if it would normally have been buffered more. This should only be called at the end, when the encoder has received all values even if it would normally continue to be buffered.</para><para>At this point we decide whether we need to switch between the run types or continue the current one. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="233" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="677" bodyend="705"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1a4bba98bf536cb550b1af82ec8f446e61" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::util::RleEncoder::FlushLiteralRun</definition>
        <argsstring>(bool update_indicator_byte)</argsstring>
        <name>FlushLiteralRun</name>
        <param>
          <type>bool</type>
          <declname>update_indicator_byte</declname>
        </param>
        <briefdescription>
<para>Flushes literal values to the underlying buffer. </para>        </briefdescription>
        <detaileddescription>
<para>If update_indicator_byte, then the current literal run is complete and the indicator byte is updated. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="237" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="631" bodyend="659"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1a757b2b030bc33d6f998e114aac1f4ff5" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::util::RleEncoder::FlushRepeatedRun</definition>
        <argsstring>()</argsstring>
        <name>FlushRepeatedRun</name>
        <briefdescription>
<para>Flushes a repeated run to the underlying buffer. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="240" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="661" bodyend="673"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1util_1_1_rle_encoder_1a0906e2e104fe895cfc7de3ad26d8bba2" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void arrow::util::RleEncoder::CheckBufferFull</definition>
        <argsstring>()</argsstring>
        <name>CheckBufferFull</name>
        <briefdescription>
<para>Checks and sets buffer_full_. </para>        </briefdescription>
        <detaileddescription>
<para>This must be called after flushing a run to make sure there are enough bytes remaining to encode the next run. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="244" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="734" bodyend="739"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Class to incrementally build the rle data. </para>    </briefdescription>
    <detaileddescription>
<para>This class does not allocate any memory. The encoding has two modes: encoding repeated runs and literal runs. If the run is sufficiently short, it is more efficient to encode as a literal run. This class does so by buffering 8 values at a time. If they are not all the same they are added to the literal run. If they are the same, they are added to the repeated run. When we switch modes, the previous run is flushed out. </para>    </detaileddescription>
    <location file="/arrow/cpp/src/arrow/util/rle_encoding.h" line="159" column="1" bodyfile="/arrow/cpp/src/arrow/util/rle_encoding.h" bodystart="159" bodyend="286"/>
    <listofallmembers>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a2f7fbab1c03cedc269bc09592c2f0a9a" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>bit_width_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1aadb9d6f5df2169e5d01ec08c5e49ae12" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>bit_writer_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1ae7b580281acc8cb2589fe21d8c8ab815" prot="public" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>buffer</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a42efaa18d66507d0f9ac883d9394f8b0" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>buffer_full_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a5f938e41189798adce165abecb3ba6fd" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>buffered_values_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a0906e2e104fe895cfc7de3ad26d8bba2" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>CheckBufferFull</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1adcb2d9b0ecc749bec776f7e1a3baa654" prot="public" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>Clear</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1aa6f6ec7517d0e95d33ad7cfec017aa92" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>current_value_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1ab8b9ede6f970e92aa90543f2ac22097b" prot="public" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>Flush</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1ae50b9a6d5d190d697fcd7eedfc38c7c8" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>FlushBufferedValues</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a4bba98bf536cb550b1af82ec8f446e61" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>FlushLiteralRun</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a757b2b030bc33d6f998e114aac1f4ff5" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>FlushRepeatedRun</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a73af478811cec4e51ca6ae3d676649ac" prot="public" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>len</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a9db564343911801fb780c58ba0c3cfef" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>literal_count_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1aafbf615d26b5660f891aa10afc1230a5" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>literal_indicator_byte_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a24c0e937b2cc5ac0bf50987570d6b00f" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>max_run_byte_size_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1af8bacd1372fba01ebd0c20f927a3145d" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>MAX_VALUES_PER_LITERAL_RUN</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1acdb52f24fec353f0c59a3efbc5a20d0d" prot="public" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>MaxBufferSize</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1aee4f9f8c6998224e9fb530f889b0bfa0" prot="public" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>MinBufferSize</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a5a12cf2b8dfedad523a899251b6f2dd4" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>num_buffered_values_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a2e5e59b665781890ccc559c6b5c13c85" prot="public" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>Put</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1aff9c6cf440583db14c1d1f50fd014183" prot="private" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>repeat_count_</name></member>
      <member refid="classarrow_1_1util_1_1_rle_encoder_1a60a51d6cfef536ffc4da20d22db50b53" prot="public" virt="non-virtual"><scope>arrow::util::RleEncoder</scope><name>RleEncoder</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
