<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classarrow_1_1_chunker" kind="class" language="C++" prot="public">
    <compoundname>arrow::Chunker</compoundname>
    <includes refid="delimiting_8h" local="no">arrow/util/delimiting.h</includes>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classarrow_1_1_chunker_1ae5c17bce68f098fc85268de619b234c3" prot="protected" static="no" mutable="no">
        <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_boundary_finder" kindref="compound">BoundaryFinder</ref> &gt;</type>
        <definition>std::shared_ptr&lt;BoundaryFinder&gt; arrow::Chunker::boundary_finder_</definition>
        <argsstring></argsstring>
        <name>boundary_finder_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/delimiting.h" line="143" column="1" bodyfile="/arrow/cpp/src/arrow/util/delimiting.h" bodystart="143" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classarrow_1_1_chunker_1ad875ac998b6788fd63891ad5ae745c23" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>arrow::Chunker::Chunker</definition>
        <argsstring>(std::shared_ptr&lt; BoundaryFinder &gt; delimiter)</argsstring>
        <name>Chunker</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_boundary_finder" kindref="compound">BoundaryFinder</ref> &gt;</type>
          <declname>delimiter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/delimiting.h" line="71" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_chunker_1a45664aaad47882d33d8982f26b0724dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>arrow::Chunker::~Chunker</definition>
        <argsstring>()</argsstring>
        <name>~Chunker</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/delimiting.h" line="72" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_chunker_1a13e938f7798cae70a8d19c3f29d021cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Chunker::Process</definition>
        <argsstring>(std::shared_ptr&lt; Buffer &gt; block, std::shared_ptr&lt; Buffer &gt; *whole, std::shared_ptr&lt; Buffer &gt; *partial)</argsstring>
        <name>Process</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>block</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>whole</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>partial</declname>
        </param>
        <briefdescription>
<para>Carve up a chunk in a block of data to contain only whole objects. </para>        </briefdescription>
        <detaileddescription>
<para>Pre-conditions:<itemizedlist>
<listitem><para><computeroutput>block</computeroutput> is the start of a valid block of delimited data (i.e. starts just after a delimiter)</para></listitem></itemizedlist>
</para><para>Post-conditions:<itemizedlist>
<listitem><para>block == whole + partial</para></listitem><listitem><para><computeroutput>whole</computeroutput> is a valid block of delimited data (i.e. starts just after a delimiter and ends with a delimiter)</para></listitem><listitem><para><computeroutput>partial</computeroutput> doesn&apos;t contain an entire delimited object (IOW: <computeroutput>partial</computeroutput> is generally small)</para></listitem></itemizedlist>
</para><para>This method will look for the last delimiter in <computeroutput>block</computeroutput> and may therefore be costly.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">block</parametername>
</parameternamelist>
<parameterdescription>
<para>data to be chunked </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">whole</parametername>
</parameternamelist>
<parameterdescription>
<para>subrange of block containing whole delimited objects </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">partial</parametername>
</parameternamelist>
<parameterdescription>
<para>subrange of block starting with a partial delimited object </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/delimiting.h" line="93" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_chunker_1a15db452249fd65dc70e331ced61bf694" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Chunker::ProcessWithPartial</definition>
        <argsstring>(std::shared_ptr&lt; Buffer &gt; partial, std::shared_ptr&lt; Buffer &gt; block, std::shared_ptr&lt; Buffer &gt; *completion, std::shared_ptr&lt; Buffer &gt; *rest)</argsstring>
        <name>ProcessWithPartial</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>partial</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>block</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>completion</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>rest</declname>
        </param>
        <briefdescription>
<para>Carve the completion of a partial object out of a block. </para>        </briefdescription>
        <detaileddescription>
<para>Pre-conditions:<itemizedlist>
<listitem><para><computeroutput>partial</computeroutput> is the start of a valid block of delimited data (i.e. starts just after a delimiter)</para></listitem><listitem><para><computeroutput>block</computeroutput> follows <computeroutput>partial</computeroutput> in file order</para></listitem></itemizedlist>
</para><para>Post-conditions:<itemizedlist>
<listitem><para>block == completion + rest</para></listitem><listitem><para><computeroutput>partial + completion</computeroutput> is a valid block of delimited data (i.e. starts just after a delimiter and ends with a delimiter)</para></listitem><listitem><para><computeroutput>completion</computeroutput> doesn&apos;t contain an entire delimited object (IOW: <computeroutput>completion</computeroutput> is generally small)</para></listitem></itemizedlist>
</para><para>This method will look for the first delimiter in <computeroutput>block</computeroutput> and should therefore be reasonably cheap.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">partial</parametername>
</parameternamelist>
<parameterdescription>
<para>incomplete delimited data </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">block</parametername>
</parameternamelist>
<parameterdescription>
<para>delimited data following partial </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">completion</parametername>
</parameternamelist>
<parameterdescription>
<para>subrange of block containing the completion of partial </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">rest</parametername>
</parameternamelist>
<parameterdescription>
<para>subrange of block containing what completion does not cover </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/delimiting.h" line="117" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classarrow_1_1_chunker_1aaeecbfe78518c8eb739fd364c0c7e37c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classarrow_1_1_status" kindref="compound">Status</ref></type>
        <definition>Status arrow::Chunker::ProcessFinal</definition>
        <argsstring>(std::shared_ptr&lt; Buffer &gt; partial, std::shared_ptr&lt; Buffer &gt; block, std::shared_ptr&lt; Buffer &gt; *completion, std::shared_ptr&lt; Buffer &gt; *rest)</argsstring>
        <name>ProcessFinal</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>partial</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>block</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>completion</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classarrow_1_1_buffer" kindref="compound">Buffer</ref> &gt; *</type>
          <declname>rest</declname>
        </param>
        <briefdescription>
<para>Like ProcessWithPartial, but for the last block of a file. </para>        </briefdescription>
        <detaileddescription>
<para>This method allows for a final delimited object without a trailing delimiter (ProcessWithPartial would return an error in that case).</para><para>Pre-conditions:<itemizedlist>
<listitem><para><computeroutput>partial</computeroutput> is the start of a valid block of delimited data</para></listitem><listitem><para><computeroutput>block</computeroutput> follows <computeroutput>partial</computeroutput> in file order and is the last data block</para></listitem></itemizedlist>
</para><para>Post-conditions:<itemizedlist>
<listitem><para>block == completion + rest</para></listitem><listitem><para><computeroutput>partial + completion</computeroutput> is a valid block of delimited data</para></listitem><listitem><para><computeroutput>completion</computeroutput> doesn&apos;t contain an entire delimited object (IOW: <computeroutput>completion</computeroutput> is generally small) </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/delimiting.h" line="137" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classarrow_1_1_chunker_1a0199ca79368d614152b8e94cc2f0bd17" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>arrow::Chunker::ARROW_DISALLOW_COPY_AND_ASSIGN</definition>
        <argsstring>(Chunker)</argsstring>
        <name>ARROW_DISALLOW_COPY_AND_ASSIGN</name>
        <param>
          <type><ref refid="classarrow_1_1_chunker" kindref="compound">Chunker</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/arrow/cpp/src/arrow/util/delimiting.h" line="141" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>A reusable block-based chunker for delimited data. </para>    </briefdescription>
    <detaileddescription>
<para>The chunker takes a block of delimited data and helps carve a sub-block which begins and ends on delimiters (suitable for consumption by parsers which can only parse whole objects). </para>    </detaileddescription>
    <location file="/arrow/cpp/src/arrow/util/delimiting.h" line="69" column="1" bodyfile="/arrow/cpp/src/arrow/util/delimiting.h" bodystart="69" bodyend="144"/>
    <listofallmembers>
      <member refid="classarrow_1_1_chunker_1a0199ca79368d614152b8e94cc2f0bd17" prot="protected" virt="non-virtual"><scope>arrow::Chunker</scope><name>ARROW_DISALLOW_COPY_AND_ASSIGN</name></member>
      <member refid="classarrow_1_1_chunker_1ae5c17bce68f098fc85268de619b234c3" prot="protected" virt="non-virtual"><scope>arrow::Chunker</scope><name>boundary_finder_</name></member>
      <member refid="classarrow_1_1_chunker_1ad875ac998b6788fd63891ad5ae745c23" prot="public" virt="non-virtual"><scope>arrow::Chunker</scope><name>Chunker</name></member>
      <member refid="classarrow_1_1_chunker_1a13e938f7798cae70a8d19c3f29d021cf" prot="public" virt="non-virtual"><scope>arrow::Chunker</scope><name>Process</name></member>
      <member refid="classarrow_1_1_chunker_1aaeecbfe78518c8eb739fd364c0c7e37c" prot="public" virt="non-virtual"><scope>arrow::Chunker</scope><name>ProcessFinal</name></member>
      <member refid="classarrow_1_1_chunker_1a15db452249fd65dc70e331ced61bf694" prot="public" virt="non-virtual"><scope>arrow::Chunker</scope><name>ProcessWithPartial</name></member>
      <member refid="classarrow_1_1_chunker_1a45664aaad47882d33d8982f26b0724dd" prot="public" virt="non-virtual"><scope>arrow::Chunker</scope><name>~Chunker</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
