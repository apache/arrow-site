<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Arrow (C++): arrow::util::RleEncoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Arrow (C++)
   </div>
   <div id="projectbrief">A columnar in-memory analytics layer designed to accelerate big data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacearrow.html">arrow</a></li><li class="navelem"><a class="el" href="namespacearrow_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classarrow_1_1util_1_1_rle_encoder.html">RleEncoder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classarrow_1_1util_1_1_rle_encoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">arrow::util::RleEncoder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to incrementally build the rle data.  
 <a href="classarrow_1_1util_1_1_rle_encoder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rle-encoding_8h_source.html">arrow/util/rle-encoding.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a60a51d6cfef536ffc4da20d22db50b53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_encoder.html#a60a51d6cfef536ffc4da20d22db50b53">RleEncoder</a> (uint8_t *<a class="el" href="classarrow_1_1util_1_1_rle_encoder.html#ae7b580281acc8cb2589fe21d8c8ab815">buffer</a>, int buffer_len, int bit_width)</td></tr>
<tr class="memdesc:a60a51d6cfef536ffc4da20d22db50b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer/buffer_len: preallocated output buffer.  <a href="#a60a51d6cfef536ffc4da20d22db50b53">More...</a><br /></td></tr>
<tr class="separator:a60a51d6cfef536ffc4da20d22db50b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5e59b665781890ccc559c6b5c13c85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_encoder.html#a2e5e59b665781890ccc559c6b5c13c85">Put</a> (uint64_t value)</td></tr>
<tr class="memdesc:a2e5e59b665781890ccc559c6b5c13c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode value.  <a href="#a2e5e59b665781890ccc559c6b5c13c85">More...</a><br /></td></tr>
<tr class="separator:a2e5e59b665781890ccc559c6b5c13c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b9ede6f970e92aa90543f2ac22097b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_encoder.html#ab8b9ede6f970e92aa90543f2ac22097b">Flush</a> ()</td></tr>
<tr class="memdesc:ab8b9ede6f970e92aa90543f2ac22097b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes any pending values to the underlying buffer.  <a href="#ab8b9ede6f970e92aa90543f2ac22097b">More...</a><br /></td></tr>
<tr class="separator:ab8b9ede6f970e92aa90543f2ac22097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb2d9b0ecc749bec776f7e1a3baa654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_encoder.html#adcb2d9b0ecc749bec776f7e1a3baa654">Clear</a> ()</td></tr>
<tr class="memdesc:adcb2d9b0ecc749bec776f7e1a3baa654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all the state in the encoder.  <a href="#adcb2d9b0ecc749bec776f7e1a3baa654">More...</a><br /></td></tr>
<tr class="separator:adcb2d9b0ecc749bec776f7e1a3baa654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b580281acc8cb2589fe21d8c8ab815"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_encoder.html#ae7b580281acc8cb2589fe21d8c8ab815">buffer</a> ()</td></tr>
<tr class="memdesc:ae7b580281acc8cb2589fe21d8c8ab815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to underlying buffer.  <a href="#ae7b580281acc8cb2589fe21d8c8ab815">More...</a><br /></td></tr>
<tr class="separator:ae7b580281acc8cb2589fe21d8c8ab815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73af478811cec4e51ca6ae3d676649ac"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_encoder.html#a73af478811cec4e51ca6ae3d676649ac">len</a> ()</td></tr>
<tr class="separator:a73af478811cec4e51ca6ae3d676649ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aee4f9f8c6998224e9fb530f889b0bfa0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_encoder.html#aee4f9f8c6998224e9fb530f889b0bfa0">MinBufferSize</a> (int bit_width)</td></tr>
<tr class="memdesc:aee4f9f8c6998224e9fb530f889b0bfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum buffer size needed to use the encoder for 'bit_width' This is the maximum length of a single run for 'bit_width'.  <a href="#aee4f9f8c6998224e9fb530f889b0bfa0">More...</a><br /></td></tr>
<tr class="separator:aee4f9f8c6998224e9fb530f889b0bfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb52f24fec353f0c59a3efbc5a20d0d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarrow_1_1util_1_1_rle_encoder.html#acdb52f24fec353f0c59a3efbc5a20d0d">MaxBufferSize</a> (int bit_width, int num_values)</td></tr>
<tr class="memdesc:acdb52f24fec353f0c59a3efbc5a20d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum byte size it could take to encode 'num_values'.  <a href="#acdb52f24fec353f0c59a3efbc5a20d0d">More...</a><br /></td></tr>
<tr class="separator:acdb52f24fec353f0c59a3efbc5a20d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to incrementally build the rle data. </p>
<p>This class does not allocate any memory. The encoding has two modes: encoding repeated runs and literal runs. If the run is sufficiently short, it is more efficient to encode as a literal run. This class does so by buffering 8 values at a time. If they are not all the same they are added to the literal run. If they are the same, they are added to the repeated run. When we switch modes, the previous run is flushed out. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a60a51d6cfef536ffc4da20d22db50b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a51d6cfef536ffc4da20d22db50b53">&#9670;&nbsp;</a></span>RleEncoder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arrow::util::RleEncoder::RleEncoder </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>buffer/buffer_len: preallocated output buffer. </p>
<p>bit_width: max number of bits for value. TODO: consider adding a min_repeated_run_length so the caller can control when values should be encoded as repeated runs. Currently this is derived based on the bit_width, which can determine a storage optimal choice. TODO: allow 0 bit_width (and have dict encoder use it) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae7b580281acc8cb2589fe21d8c8ab815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b580281acc8cb2589fe21d8c8ab815">&#9670;&nbsp;</a></span>buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* arrow::util::RleEncoder::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to underlying buffer. </p>

</div>
</div>
<a id="adcb2d9b0ecc749bec776f7e1a3baa654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb2d9b0ecc749bec776f7e1a3baa654">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arrow::util::RleEncoder::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all the state in the encoder. </p>

</div>
</div>
<a id="ab8b9ede6f970e92aa90543f2ac22097b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b9ede6f970e92aa90543f2ac22097b">&#9670;&nbsp;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int arrow::util::RleEncoder::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes any pending values to the underlying buffer. </p>
<p>Returns the total number of bytes written </p>

</div>
</div>
<a id="a73af478811cec4e51ca6ae3d676649ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73af478811cec4e51ca6ae3d676649ac">&#9670;&nbsp;</a></span>len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t arrow::util::RleEncoder::len </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdb52f24fec353f0c59a3efbc5a20d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb52f24fec353f0c59a3efbc5a20d0d">&#9670;&nbsp;</a></span>MaxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int arrow::util::RleEncoder::MaxBufferSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum byte size it could take to encode 'num_values'. </p>

</div>
</div>
<a id="aee4f9f8c6998224e9fb530f889b0bfa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4f9f8c6998224e9fb530f889b0bfa0">&#9670;&nbsp;</a></span>MinBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int arrow::util::RleEncoder::MinBufferSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bit_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum buffer size needed to use the encoder for 'bit_width' This is the maximum length of a single run for 'bit_width'. </p>
<p>It is not valid to pass a buffer less than this length. </p>
<p>1 indicator byte and MAX_VALUES_PER_LITERAL_RUN 'bit_width' values.</p>
<p>Up to MAX_VLQ_BYTE_LEN indicator and a single 'bit_width' value. </p>

</div>
</div>
<a id="a2e5e59b665781890ccc559c6b5c13c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5e59b665781890ccc559c6b5c13c85">&#9670;&nbsp;</a></span>Put()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool arrow::util::RleEncoder::Put </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode value. </p>
<p>This function buffers input values 8 at a time.</p>
<p>Returns true if the value fits in buffer, false otherwise. This value must be representable with bit_width_ bits.</p>
<p>After seeing all 8 values, it decides whether they should be encoded as a literal or repeated run. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/arrow/cpp/src/arrow/util/<a class="el" href="rle-encoding_8h_source.html">rle-encoding.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107500873-1');
</script>
</body>
</html>
