


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Arrays &mdash; Apache Arrow v0.15.0</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Array Builders" href="builder.html" />
    <link rel="prev" title="Data Types" href="datatype.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Apache Arrow
          

          
          </a>

          
            
            
              <div class="version">
                0.15.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../format/Guidelines.html">Implementation Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Layout.html">Physical Memory Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/IPC.html">IPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Metadata.html">Format Metadata</a></li>
</ul>
<p class="caption"><span class="caption-text">Arrow Specifications and Protocols</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../format/Versioning.html">Format Versioning and Stability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Columnar.html">Arrow Columnar Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Flight.html">Arrow Flight RPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Integration.html">Integration Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Other.html">Other Data Structures</a></li>
</ul>
<p class="caption"><span class="caption-text">Arrow Libraries</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">C++ Implementation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../getting_started.html">User Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/index.html">Examples</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../api.html">API Reference</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="support.html">Programming Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory.html">Memory (management)</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype.html">Data Types</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Arrays</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concrete-array-subclasses">Concrete array subclasses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chunked-arrays">Chunked Arrays</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="builder.html">Array Builders</a></li>
<li class="toctree-l3"><a class="reference internal" href="table.html">Two-dimensional Datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="tensor.html">Tensors</a></li>
<li class="toctree-l3"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="io.html">Input / output</a></li>
<li class="toctree-l3"><a class="reference internal" href="formats.html">File Formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="cuda.html">CUDA support</a></li>
<li class="toctree-l3"><a class="reference internal" href="flight.html">Arrow Flight RPC</a></li>
<li class="toctree-l3"><a class="reference internal" href="filesystem.html">Filesystems</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../python/index.html">Python bindings</a></li>
</ul>
<p class="caption"><span class="caption-text">Development and Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developers/contributing.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/cpp.html">C++ Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/python.html">Python Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/integration.html">Integration Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/crossbow.html">Packaging and Testing with Crossbow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/documentation.html">Building the Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Apache Arrow</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">C++ Implementation</a> &raquo;</li>
        
          <li><a href="../api.html">API Reference</a> &raquo;</li>
        
      <li>Arrays</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/cpp/api/array.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="arrays">
<h1>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="_CPPv4N5arrow5ArrayE">
<span id="_CPPv3N5arrow5ArrayE"></span><span id="_CPPv2N5arrow5ArrayE"></span><span id="arrow::Array"></span><span class="target" id="classarrow_1_1_array"></span><em class="property">class </em><code class="sig-name descname">Array</code><a class="headerlink" href="#_CPPv4N5arrow5ArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> base type Immutable data array with some logical type and some length. </p>
<p>Any memory is owned by the respective <a class="reference internal" href="memory.html#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> instance (or its parents).</p>
<p>The base class is only required to have a null bitmap buffer if the null count is greater than 0</p>
<p>If known, the null count can be provided in the base <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> constructor. If the null count is not known, pass -1 to indicate that the null count is to be computed on the first call to <a class="reference internal" href="#classarrow_1_1_array_1a0537d3b69a889b951e88be2fe9f3d96a"><span class="std std-ref">null_count()</span></a> </p>
<p>Subclassed by arrow::BaseListArray&lt; TYPE &gt;, <a class="reference internal" href="#classarrow_1_1_dictionary_array"><span class="std std-ref">arrow::DictionaryArray</span></a>, arrow::ExtensionArray, arrow::FixedSizeListArray, <a class="reference internal" href="#classarrow_1_1_flat_array"><span class="std std-ref">arrow::FlatArray</span></a>, <a class="reference internal" href="#classarrow_1_1_struct_array"><span class="std std-ref">arrow::StructArray</span></a>, <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">arrow::UnionArray</span></a>, arrow::BaseListArray&lt; LargeListType &gt;, arrow::BaseListArray&lt; ListType &gt;</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5arrow5Array6IsNullE7int64_t">
<span id="_CPPv3NK5arrow5Array6IsNullE7int64_t"></span><span id="_CPPv2NK5arrow5Array6IsNullE7int64_t"></span><span id="arrow::Array::IsNull__int64_tC"></span><span class="target" id="classarrow_1_1_array_1a18c61cd4c8c158a30f30023eabc83acb"></span>bool <code class="sig-name descname">IsNull</code><span class="sig-paren">(</span>int64_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array6IsNullE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true if value at index is null. Does not boundscheck. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array7IsValidE7int64_t">
<span id="_CPPv3NK5arrow5Array7IsValidE7int64_t"></span><span id="_CPPv2NK5arrow5Array7IsValidE7int64_t"></span><span id="arrow::Array::IsValid__int64_tC"></span><span class="target" id="classarrow_1_1_array_1ae554bfb313cd6b161f63fb2966dbd662"></span>bool <code class="sig-name descname">IsValid</code><span class="sig-paren">(</span>int64_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array7IsValidE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true if value at index is valid (not null). </p>
<p>Does not boundscheck </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array6lengthEv">
<span id="_CPPv3NK5arrow5Array6lengthEv"></span><span id="_CPPv2NK5arrow5Array6lengthEv"></span><span id="arrow::Array::lengthC"></span><span class="target" id="classarrow_1_1_array_1a49c7fb3f73d2d43e7338591c5a8bd8bf"></span>int64_t <code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array6lengthEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Size in the number of elements this array contains. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array6offsetEv">
<span id="_CPPv3NK5arrow5Array6offsetEv"></span><span id="_CPPv2NK5arrow5Array6offsetEv"></span><span id="arrow::Array::offsetC"></span><span class="target" id="classarrow_1_1_array_1a1a0c6c1aa06cffd1dcb3813f0d24b2fd"></span>int64_t <code class="sig-name descname">offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array6offsetEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A relative position into another array’s data, to enable zero-copy slicing. </p>
<p>This value defaults to zero </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array10null_countEv">
<span id="_CPPv3NK5arrow5Array10null_countEv"></span><span id="_CPPv2NK5arrow5Array10null_countEv"></span><span id="arrow::Array::null_countC"></span><span class="target" id="classarrow_1_1_array_1a0537d3b69a889b951e88be2fe9f3d96a"></span>int64_t <code class="sig-name descname">null_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array10null_countEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of null entries in the array. </p>
<p>If the null count was not known at time of construction (and set to a negative value), then the null count will be computed and cached on the first invocation of this function </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array11null_bitmapEv">
<span id="_CPPv3NK5arrow5Array11null_bitmapEv"></span><span id="_CPPv2NK5arrow5Array11null_bitmapEv"></span><span id="arrow::Array::null_bitmapC"></span><span class="target" id="classarrow_1_1_array_1a76c4756ac85b29f9135064d68d2ef908"></span>std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">null_bitmap</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array11null_bitmapEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="memory.html#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> for the null bitmap. </p>
<p>Note that for <code class="docutils literal notranslate"><span class="pre">null_count</span> <span class="pre">==</span> <span class="pre">0</span></code>, this can be null. This buffer does not account for any slice offset </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array16null_bitmap_dataEv">
<span id="_CPPv3NK5arrow5Array16null_bitmap_dataEv"></span><span id="_CPPv2NK5arrow5Array16null_bitmap_dataEv"></span><span id="arrow::Array::null_bitmap_dataC"></span><span class="target" id="classarrow_1_1_array_1a7a8838fbc97b9b3b8ca15cb163b2027c"></span><em class="property">const</em> uint8_t *<code class="sig-name descname">null_bitmap_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array16null_bitmap_dataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Raw pointer to the null bitmap. </p>
<p>Note that for <code class="docutils literal notranslate"><span class="pre">null_count</span> <span class="pre">==</span> <span class="pre">0</span></code>, this can be null. This buffer does not account for any slice offset </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array6EqualsERK5ArrayRK12EqualOptions">
<span id="_CPPv3NK5arrow5Array6EqualsERK5ArrayRK12EqualOptions"></span><span id="_CPPv2NK5arrow5Array6EqualsERK5ArrayRK12EqualOptions"></span><span id="arrow::Array::Equals__ArrayCR.EqualOptionsCRC"></span><span class="target" id="classarrow_1_1_array_1a686cf58bab513d8ecfe3a285f4562eab"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>arr</em>, <em class="property">const</em> EqualOptions&amp; = EqualOptions::Defaults()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array6EqualsERK5ArrayRK12EqualOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Equality comparison with another array. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array4DiffERK5Array">
<span id="_CPPv3NK5arrow5Array4DiffERK5Array"></span><span id="_CPPv2NK5arrow5Array4DiffERK5Array"></span><span id="arrow::Array::Diff__ArrayCRC"></span><span class="target" id="classarrow_1_1_array_1a95ff1c7489e9d2fd5ff52fde1b8b5c46"></span>std::string <code class="sig-name descname">Diff</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array4DiffERK5Array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the formatted unified diff of arrow::Diff between this <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> and another <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array12ApproxEqualsERKNSt10shared_ptrI5ArrayEERK12EqualOptions">
<span id="_CPPv3NK5arrow5Array12ApproxEqualsERKNSt10shared_ptrI5ArrayEERK12EqualOptions"></span><span id="_CPPv2NK5arrow5Array12ApproxEqualsERKNSt10shared_ptrI5ArrayEERK12EqualOptions"></span><span id="arrow::Array::ApproxEquals__std::shared_ptr:Array:CR.EqualOptionsCRC"></span><span class="target" id="classarrow_1_1_array_1a381e6469686eccd2545cf1dc171f6cb7"></span>bool <code class="sig-name descname">ApproxEquals</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; &amp;<em>arr</em>, <em class="property">const</em> EqualOptions&amp; = EqualOptions::Defaults()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array12ApproxEqualsERKNSt10shared_ptrI5ArrayEERK12EqualOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Approximate equality comparison with another array. </p>
<p>epsilon is only used if this is FloatArray or DoubleArray </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array11RangeEqualsE7int64_t7int64_t7int64_tRK5Array">
<span id="_CPPv3NK5arrow5Array11RangeEqualsE7int64_t7int64_t7int64_tRK5Array"></span><span id="_CPPv2NK5arrow5Array11RangeEqualsE7int64_t7int64_t7int64_tRK5Array"></span><span id="arrow::Array::RangeEquals__int64_t.int64_t.int64_t.ArrayCRC"></span><span class="target" id="classarrow_1_1_array_1ace5ac1affa59422d70a8b3f6929b70bc"></span>bool <code class="sig-name descname">RangeEquals</code><span class="sig-paren">(</span>int64_t <em>start_idx</em>, int64_t <em>end_idx</em>, int64_t <em>other_start_idx</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array11RangeEqualsE7int64_t7int64_t7int64_tRK5Array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compare if the range of slots specified are equal for the given array and this array. </p>
<p>end_idx exclusive. This methods does not bounds check. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array4ViewERKNSt10shared_ptrI8DataTypeEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3NK5arrow5Array4ViewERKNSt10shared_ptrI8DataTypeEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2NK5arrow5Array4ViewERKNSt10shared_ptrI8DataTypeEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::Array::View__std::shared_ptr:DataType:CR.std::shared_ptr:Array:PC"></span><span class="target" id="classarrow_1_1_array_1ad015904c8c6e5e2513c791fb577f2679"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">View</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; &amp;<em>type</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array4ViewERKNSt10shared_ptrI8DataTypeEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a zero-copy view of this array with the given type. </p>
<p>This method checks if the types are layout-compatible. Nested types are traversed in depth-first order. Data buffers must have the same item sizes, even though the logical types may be different. An error is returned if the types are not layout-compatible. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array5SliceE7int64_t7int64_t">
<span id="_CPPv3NK5arrow5Array5SliceE7int64_t7int64_t"></span><span id="_CPPv2NK5arrow5Array5SliceE7int64_t7int64_t"></span><span id="arrow::Array::Slice__int64_t.int64_tC"></span><span class="target" id="classarrow_1_1_array_1ae32f72c78fe10ce17f0a817e302e17d1"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">Slice</code><span class="sig-paren">(</span>int64_t <em>offset</em>, int64_t <em>length</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array5SliceE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a zero-copy slice of the array with the indicated offset and length. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new object wrapped in std::shared_ptr&lt;Array&gt; </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">offset</span></code>: the position of the first element in the constructed slice </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">length</span></code>: the length of the slice. If there are not enough elements in the array, the length will be adjusted accordingly</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array5SliceE7int64_t">
<span id="_CPPv3NK5arrow5Array5SliceE7int64_t"></span><span id="_CPPv2NK5arrow5Array5SliceE7int64_t"></span><span id="arrow::Array::Slice__int64_tC"></span><span class="target" id="classarrow_1_1_array_1a5cf4c3330e850670aa52dab3b21869ea"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">Slice</code><span class="sig-paren">(</span>int64_t <em>offset</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array5SliceE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Slice from offset until end of the array. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array8ToStringEv">
<span id="_CPPv3NK5arrow5Array8ToStringEv"></span><span id="_CPPv2NK5arrow5Array8ToStringEv"></span><span id="arrow::Array::ToStringC"></span><span class="target" id="classarrow_1_1_array_1a41c7af0e40ac55f2ce11785fea3e051e"></span>std::string <code class="sig-name descname">ToString</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array8ToStringEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>PrettyPrint representation of array suitable for debugging </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow5Array8ValidateEv">
<span id="_CPPv3NK5arrow5Array8ValidateEv"></span><span id="_CPPv2NK5arrow5Array8ValidateEv"></span><span id="arrow::Array::ValidateC"></span><span class="target" id="classarrow_1_1_array_1ad62bad8fde2bb8fbd5a52df3fa4bd56c"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array8ValidateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform any validation checks to determine obvious inconsistencies within the array’s internal data. </p>
<p>This can be an expensive check, potentially O(length).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<div class="section" id="concrete-array-subclasses">
<h2>Concrete array subclasses<a class="headerlink" href="#concrete-array-subclasses" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5arrow15DictionaryArrayE">
<span id="_CPPv3N5arrow15DictionaryArrayE"></span><span id="_CPPv2N5arrow15DictionaryArrayE"></span><span id="arrow::DictionaryArray"></span><span class="target" id="classarrow_1_1_dictionary_array"></span><em class="property">class </em><code class="sig-name descname">DictionaryArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a><a class="headerlink" href="#_CPPv4N5arrow15DictionaryArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> type for dictionary-encoded data with a data-dependent dictionary. </p>
<p>A dictionary array contains an array of non-negative integers (the “dictionary indices”) along with a data type containing a “dictionary” corresponding to the distinct values represented in the data.</p>
<p>For example, the array</p>
<p>[“foo”, “bar”, “foo”, “bar”, “foo”, “bar”]</p>
<p>with dictionary [“bar”, “foo”], would have dictionary array representation</p>
<p>indices: [1, 0, 1, 0, 1, 0] dictionary: [“bar”, “foo”]</p>
<p>The indices in principle may have any integer type (signed or unsigned), though presently data in IPC exchanges must be signed int32. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5arrow15DictionaryArray9TransposeEP10MemoryPoolRKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEEPK7int32_tPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3NK5arrow15DictionaryArray9TransposeEP10MemoryPoolRKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEEPK7int32_tPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2NK5arrow15DictionaryArray9TransposeEP10MemoryPoolRKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEEPK7int32_tPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::DictionaryArray::Transpose__MemoryPoolP.std::shared_ptr:DataType:CR.std::shared_ptr:Array:CR.int32_tCP.std::shared_ptr:Array:PC"></span><span class="target" id="classarrow_1_1_dictionary_array_1a8b1bf19ac8e472581b5493a32785021c"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Transpose</code><span class="sig-paren">(</span><a class="reference internal" href="memory.html#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; &amp;<em>type</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; &amp;<em>dictionary</em>, <em class="property">const</em> int32_t *<em>transpose_map</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow15DictionaryArray9TransposeEP10MemoryPoolRKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEEPK7int32_tPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transpose this <a class="reference internal" href="#classarrow_1_1_dictionary_array"><span class="std std-ref">DictionaryArray</span></a>. </p>
<p>This method constructs a new dictionary array with the given dictionary type, transposing indices using the transpose map. The type and the transpose map are typically computed using DictionaryUnifier.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: a pool to allocate the array data from </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type</span></code>: the new type object </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">dictionary</span></code>: the new dictionary </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">transpose_map</span></code>: transposition array of this array’s indices into the target array’s indices </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: the resulting <a class="reference internal" href="#classarrow_1_1_dictionary_array"><span class="std std-ref">DictionaryArray</span></a> instance </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow15DictionaryArray17CanCompareIndicesERK15DictionaryArray">
<span id="_CPPv3NK5arrow15DictionaryArray17CanCompareIndicesERK15DictionaryArray"></span><span id="_CPPv2NK5arrow15DictionaryArray17CanCompareIndicesERK15DictionaryArray"></span><span id="arrow::DictionaryArray::CanCompareIndices__DictionaryArrayCRC"></span><span class="target" id="classarrow_1_1_dictionary_array_1a174e8f2555d0833a45e5ad6c49f7ebab"></span>bool <code class="sig-name descname">CanCompareIndices</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow15DictionaryArrayE" title="arrow::DictionaryArray">DictionaryArray</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow15DictionaryArray17CanCompareIndicesERK15DictionaryArray" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine whether dictionary arrays may be compared without unification. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow15DictionaryArray10dictionaryEv">
<span id="_CPPv3NK5arrow15DictionaryArray10dictionaryEv"></span><span id="_CPPv2NK5arrow15DictionaryArray10dictionaryEv"></span><span id="arrow::DictionaryArray::dictionaryC"></span><span class="target" id="classarrow_1_1_dictionary_array_1ab77f454477e3695592274f6266647175"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">dictionary</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow15DictionaryArray10dictionaryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the dictionary for this array, which is stored as a member of the ArrayData internal structure. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow15DictionaryArray10FromArraysERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEERKNSt10shared_ptrI5ArrayEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow15DictionaryArray10FromArraysERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEERKNSt10shared_ptrI5ArrayEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow15DictionaryArray10FromArraysERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEERKNSt10shared_ptrI5ArrayEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::DictionaryArray::FromArrays__std::shared_ptr:DataType:CR.std::shared_ptr:Array:CR.std::shared_ptr:Array:CR.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_dictionary_array_1a68f94be272f020e8044bd2346ecf1083"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">FromArrays</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; &amp;<em>type</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; &amp;<em>indices</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; &amp;<em>dictionary</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow15DictionaryArray10FromArraysERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEERKNSt10shared_ptrI5ArrayEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct <a class="reference internal" href="#classarrow_1_1_dictionary_array"><span class="std std-ref">DictionaryArray</span></a> from dictionary and indices array and validate. </p>
<p>This function does the validation of the indices and input type. It checks if all indices are non-negative and smaller than the size of the dictionary</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type</span></code>: a dictionary type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">dictionary</span></code>: the dictionary with same value type as the type object </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: an array of non-negative signed integers smaller than the size of the dictionary </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: the resulting <a class="reference internal" href="#classarrow_1_1_dictionary_array"><span class="std std-ref">DictionaryArray</span></a> instance </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<div class="section" id="non-nested">
<h3>Non-nested<a class="headerlink" href="#non-nested" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv4N5arrow9FlatArrayE">
<span id="_CPPv3N5arrow9FlatArrayE"></span><span id="_CPPv2N5arrow9FlatArrayE"></span><span id="arrow::FlatArray"></span><span class="target" id="classarrow_1_1_flat_array"></span><em class="property">class </em><code class="sig-name descname">FlatArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a><a class="headerlink" href="#_CPPv4N5arrow9FlatArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for non-nested arrays. </p>
<p>Subclassed by arrow::BaseBinaryArray&lt; TYPE &gt;, <a class="reference internal" href="#classarrow_1_1_null_array"><span class="std std-ref">arrow::NullArray</span></a>, <a class="reference internal" href="#classarrow_1_1_primitive_array"><span class="std std-ref">arrow::PrimitiveArray</span></a>, arrow::BaseBinaryArray&lt; BinaryType &gt;, arrow::BaseBinaryArray&lt; LargeBinaryType &gt;</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow9NullArrayE">
<span id="_CPPv3N5arrow9NullArrayE"></span><span id="_CPPv2N5arrow9NullArrayE"></span><span id="arrow::NullArray"></span><span class="target" id="classarrow_1_1_null_array"></span><em class="property">class </em><code class="sig-name descname">NullArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow9FlatArrayE" title="arrow::FlatArray">FlatArray</a><a class="headerlink" href="#_CPPv4N5arrow9NullArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Degenerate null type <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a>. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow11BinaryArrayE">
<span id="_CPPv3N5arrow11BinaryArrayE"></span><span id="_CPPv2N5arrow11BinaryArrayE"></span><span id="arrow::BinaryArray"></span><span class="target" id="classarrow_1_1_binary_array"></span><em class="property">class </em><code class="sig-name descname">BinaryArray</code> : <em class="property">public</em> arrow::BaseBinaryArray&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow10BinaryTypeE" title="arrow::BinaryType">BinaryType</a>&gt;<a class="headerlink" href="#_CPPv4N5arrow11BinaryArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for variable-size binary data. </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_string_array"><span class="std std-ref">arrow::StringArray</span></a></p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow11StringArrayE">
<span id="_CPPv3N5arrow11StringArrayE"></span><span id="_CPPv2N5arrow11StringArrayE"></span><span id="arrow::StringArray"></span><span class="target" id="classarrow_1_1_string_array"></span><em class="property">class </em><code class="sig-name descname">StringArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow11BinaryArrayE" title="arrow::BinaryArray">BinaryArray</a><a class="headerlink" href="#_CPPv4N5arrow11StringArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for variable-size string (utf-8) data. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow14PrimitiveArrayE">
<span id="_CPPv3N5arrow14PrimitiveArrayE"></span><span id="_CPPv2N5arrow14PrimitiveArrayE"></span><span id="arrow::PrimitiveArray"></span><span class="target" id="classarrow_1_1_primitive_array"></span><em class="property">class </em><code class="sig-name descname">PrimitiveArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow9FlatArrayE" title="arrow::FlatArray">FlatArray</a><a class="headerlink" href="#_CPPv4N5arrow14PrimitiveArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for arrays of fixed-size logical types. </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_boolean_array"><span class="std std-ref">arrow::BooleanArray</span></a>, arrow::DayTimeIntervalArray, <a class="reference internal" href="#classarrow_1_1_fixed_size_binary_array"><span class="std std-ref">arrow::FixedSizeBinaryArray</span></a>, <a class="reference internal" href="#classarrow_1_1_numeric_array"><span class="std std-ref">arrow::NumericArray&lt; TYPE &gt;</span></a>, <a class="reference internal" href="#classarrow_1_1_numeric_array"><span class="std std-ref">arrow::NumericArray&lt; IndexType &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5arrow14PrimitiveArray6valuesEv">
<span id="_CPPv3NK5arrow14PrimitiveArray6valuesEv"></span><span id="_CPPv2NK5arrow14PrimitiveArray6valuesEv"></span><span id="arrow::PrimitiveArray::valuesC"></span><span class="target" id="classarrow_1_1_primitive_array_1a0c05d9ba21020050abe94e1446a3cee1"></span>std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow14PrimitiveArray6valuesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Does not account for any slice offset. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow12BooleanArrayE">
<span id="_CPPv3N5arrow12BooleanArrayE"></span><span id="_CPPv2N5arrow12BooleanArrayE"></span><span id="arrow::BooleanArray"></span><span class="target" id="classarrow_1_1_boolean_array"></span><em class="property">class </em><code class="sig-name descname">BooleanArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow14PrimitiveArrayE" title="arrow::PrimitiveArray">PrimitiveArray</a><a class="headerlink" href="#_CPPv4N5arrow12BooleanArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for boolean data. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow20FixedSizeBinaryArrayE">
<span id="_CPPv3N5arrow20FixedSizeBinaryArrayE"></span><span id="_CPPv2N5arrow20FixedSizeBinaryArrayE"></span><span id="arrow::FixedSizeBinaryArray"></span><span class="target" id="classarrow_1_1_fixed_size_binary_array"></span><em class="property">class </em><code class="sig-name descname">FixedSizeBinaryArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow14PrimitiveArrayE" title="arrow::PrimitiveArray">PrimitiveArray</a><a class="headerlink" href="#_CPPv4N5arrow20FixedSizeBinaryArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for fixed-size binary data. </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_decimal128_array"><span class="std std-ref">arrow::Decimal128Array</span></a></p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow15Decimal128ArrayE">
<span id="_CPPv3N5arrow15Decimal128ArrayE"></span><span id="_CPPv2N5arrow15Decimal128ArrayE"></span><span id="arrow::Decimal128Array"></span><span class="target" id="classarrow_1_1_decimal128_array"></span><em class="property">class </em><code class="sig-name descname">Decimal128Array</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow20FixedSizeBinaryArrayE" title="arrow::FixedSizeBinaryArray">FixedSizeBinaryArray</a><a class="headerlink" href="#_CPPv4N5arrow15Decimal128ArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for 128-bit decimal data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow15Decimal128Array15Decimal128ArrayERKNSt10shared_ptrI9ArrayDataEE">
<span id="_CPPv3N5arrow15Decimal128Array15Decimal128ArrayERKNSt10shared_ptrI9ArrayDataEE"></span><span id="_CPPv2N5arrow15Decimal128Array15Decimal128ArrayERKNSt10shared_ptrI9ArrayDataEE"></span><span id="arrow::Decimal128Array::Decimal128Array__std::shared_ptr:ArrayData:CR"></span><span class="target" id="classarrow_1_1_decimal128_array_1a1520cf3809bc92851ad099403164538a"></span><code class="sig-name descname">Decimal128Array</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;ArrayData&gt; &amp;<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow15Decimal128Array15Decimal128ArrayERKNSt10shared_ptrI9ArrayDataEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct <a class="reference internal" href="#classarrow_1_1_decimal128_array"><span class="std std-ref">Decimal128Array</span></a> from ArrayData instance. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4I0EN5arrow12NumericArrayE">
<span id="_CPPv3I0EN5arrow12NumericArrayE"></span><span id="_CPPv2I0EN5arrow12NumericArrayE"></span><span class="target" id="classarrow_1_1_numeric_array"></span>template&lt;typename <code class="sig-name descname">TYPE</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">NumericArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow14PrimitiveArrayE" title="arrow::PrimitiveArray">PrimitiveArray</a><a class="headerlink" href="#_CPPv4I0EN5arrow12NumericArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for numeric data. </p>
</dd></dl>

</div>
<div class="section" id="nested">
<h3>Nested<a class="headerlink" href="#nested" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv4N5arrow10UnionArrayE">
<span id="_CPPv3N5arrow10UnionArrayE"></span><span id="_CPPv2N5arrow10UnionArrayE"></span><span id="arrow::UnionArray"></span><span class="target" id="classarrow_1_1_union_array"></span><em class="property">class </em><code class="sig-name descname">UnionArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a><a class="headerlink" href="#_CPPv4N5arrow10UnionArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for union data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5arrow10UnionArray8type_idsEv">
<span id="_CPPv3NK5arrow10UnionArray8type_idsEv"></span><span id="_CPPv2NK5arrow10UnionArray8type_idsEv"></span><span id="arrow::UnionArray::type_idsC"></span><span class="target" id="classarrow_1_1_union_array_1a679049e92aec3deacda4178e55cd1215"></span>std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">type_ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow10UnionArray8type_idsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Note that this buffer does not account for any slice offset. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow10UnionArray13value_offsetsEv">
<span id="_CPPv3NK5arrow10UnionArray13value_offsetsEv"></span><span id="_CPPv2NK5arrow10UnionArray13value_offsetsEv"></span><span id="arrow::UnionArray::value_offsetsC"></span><span class="target" id="classarrow_1_1_union_array_1a8b2f7da8a7e992670924f06d40c3fd58"></span>std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">value_offsets</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow10UnionArray13value_offsetsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Note that this buffer does not account for any slice offset. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::UnionArray::MakeDense__ArrayCR.ArrayCR.std::vector:std::shared_ptr:Array::CR.std::vector:ss:CR.std::vector:uint8_t:CR.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_union_array_1a4876f53e3393a81deacb8e8e6fa8cd83"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">MakeDense</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>type_ids</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>value_offsets</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, <em class="property">const</em> std::vector&lt;std::string&gt; &amp;<em>field_names</em>, <em class="property">const</em> std::vector&lt;uint8_t&gt; &amp;<em>type_codes</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct Dense <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">UnionArray</span></a> from types_ids, value_offsets and children. </p>
<p>This function does the bare minimum of validation of the offsets and input types. The value_offsets are assumed to be well-formed.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_ids</span></code>: An array of 8-bit signed integers, enumerated from 0 corresponding to each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">value_offsets</span></code>: An array of signed int32 values indicating the relative offset into the respective child array for the type in a given slot. The respective offsets for each child value array must be in order / increasing. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">children</span></code>: Vector of children Arrays containing the data for each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">field_names</span></code>: Vector of strings containing the name of each field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_codes</span></code>: Vector of type codes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: Will have length equal to value_offsets.length() </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::UnionArray::MakeDense__ArrayCR.ArrayCR.std::vector:std::shared_ptr:Array::CR.std::vector:ss:CR.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_union_array_1ae3f98d2930cfb3abd5c0c7e9f4668b12"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">MakeDense</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>type_ids</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>value_offsets</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, <em class="property">const</em> std::vector&lt;std::string&gt; &amp;<em>field_names</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct Dense <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">UnionArray</span></a> from types_ids, value_offsets and children. </p>
<p>This function does the bare minimum of validation of the offsets and input types. The value_offsets are assumed to be well-formed.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_ids</span></code>: An array of 8-bit signed integers, enumerated from 0 corresponding to each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">value_offsets</span></code>: An array of signed int32 values indicating the relative offset into the respective child array for the type in a given slot. The respective offsets for each child value array must be in order / increasing. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">children</span></code>: Vector of children Arrays containing the data for each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">field_names</span></code>: Vector of strings containing the name of each field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: Will have length equal to value_offsets.length() </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::UnionArray::MakeDense__ArrayCR.ArrayCR.std::vector:std::shared_ptr:Array::CR.std::vector:uint8_t:CR.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_union_array_1aafbd310f3be680c102218b7000948377"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">MakeDense</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>type_ids</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>value_offsets</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, <em class="property">const</em> std::vector&lt;uint8_t&gt; &amp;<em>type_codes</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct Dense <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">UnionArray</span></a> from types_ids, value_offsets and children. </p>
<p>This function does the bare minimum of validation of the offsets and input types. The value_offsets are assumed to be well-formed.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_ids</span></code>: An array of 8-bit signed integers, enumerated from 0 corresponding to each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">value_offsets</span></code>: An array of signed int32 values indicating the relative offset into the respective child array for the type in a given slot. The respective offsets for each child value array must be in order / increasing. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">children</span></code>: Vector of children Arrays containing the data for each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_codes</span></code>: Vector of type codes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: Will have length equal to value_offsets.length() </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::UnionArray::MakeDense__ArrayCR.ArrayCR.std::vector:std::shared_ptr:Array::CR.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_union_array_1a1e25bd6a74bb47aee3612d82516ae9fe"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">MakeDense</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>type_ids</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>value_offsets</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10UnionArray9MakeDenseERK5ArrayRK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct Dense <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">UnionArray</span></a> from types_ids, value_offsets and children. </p>
<p>This function does the bare minimum of validation of the offsets and input types. The value_offsets are assumed to be well-formed.</p>
<p>The name of each field is filled by the index of the field.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_ids</span></code>: An array of 8-bit signed integers, enumerated from 0 corresponding to each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">value_offsets</span></code>: An array of signed int32 values indicating the relative offset into the respective child array for the type in a given slot. The respective offsets for each child value array must be in order / increasing. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">children</span></code>: Vector of children Arrays containing the data for each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: Will have length equal to value_offsets.length() </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::UnionArray::MakeSparse__ArrayCR.std::vector:std::shared_ptr:Array::CR.std::vector:ss:CR.std::vector:uint8_t:CR.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_union_array_1a60ffe64e138341cbaa077ccd5a535b15"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">MakeSparse</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>type_ids</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, <em class="property">const</em> std::vector&lt;std::string&gt; &amp;<em>field_names</em>, <em class="property">const</em> std::vector&lt;uint8_t&gt; &amp;<em>type_codes</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct Sparse <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">UnionArray</span></a> from type_ids and children. </p>
<p>This function does the bare minimum of validation of the offsets and input types.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_ids</span></code>: An array of 8-bit signed integers, enumerated from 0 corresponding to each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">children</span></code>: Vector of children Arrays containing the data for each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">field_names</span></code>: Vector of strings containing the name of each field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_codes</span></code>: Vector of type codes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: Will have length equal to type_ids.length() </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::UnionArray::MakeSparse__ArrayCR.std::vector:std::shared_ptr:Array::CR.std::vector:ss:CR.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_union_array_1ad9b9ccdc1f3c086170c5f7e9624fd643"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">MakeSparse</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>type_ids</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, <em class="property">const</em> std::vector&lt;std::string&gt; &amp;<em>field_names</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct Sparse <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">UnionArray</span></a> from type_ids and children. </p>
<p>This function does the bare minimum of validation of the offsets and input types.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_ids</span></code>: An array of 8-bit signed integers, enumerated from 0 corresponding to each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">children</span></code>: Vector of children Arrays containing the data for each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">field_names</span></code>: Vector of strings containing the name of each field. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: Will have length equal to type_ids.length() </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::UnionArray::MakeSparse__ArrayCR.std::vector:std::shared_ptr:Array::CR.std::vector:uint8_t:CR.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_union_array_1a4294d06b3dfd937145ac9ed8a3b1ef9d"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">MakeSparse</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>type_ids</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, <em class="property">const</em> std::vector&lt;uint8_t&gt; &amp;<em>type_codes</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorI7uint8_tEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct Sparse <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">UnionArray</span></a> from type_ids and children. </p>
<p>This function does the bare minimum of validation of the offsets and input types.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_ids</span></code>: An array of 8-bit signed integers, enumerated from 0 corresponding to each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">children</span></code>: Vector of children Arrays containing the data for each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_codes</span></code>: Vector of type codes. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: Will have length equal to type_ids.length() </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEEPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEEPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEEPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::UnionArray::MakeSparse__ArrayCR.std::vector:std::shared_ptr:Array::CR.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_union_array_1a570002863522922769fde0ad36260f7f"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">MakeSparse</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>type_ids</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10UnionArray10MakeSparseERK5ArrayRKNSt6vectorINSt10shared_ptrI5ArrayEEEEPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct Sparse <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">UnionArray</span></a> from type_ids and children. </p>
<p>This function does the bare minimum of validation of the offsets and input types.</p>
<p>The name of each field is filled by the index of the field.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type_ids</span></code>: An array of 8-bit signed integers, enumerated from 0 corresponding to each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">children</span></code>: Vector of children Arrays containing the data for each type. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: Will have length equal to type_ids.length() </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow9ListArrayE">
<span id="_CPPv3N5arrow9ListArrayE"></span><span id="_CPPv2N5arrow9ListArrayE"></span><span id="arrow::ListArray"></span><span class="target" id="classarrow_1_1_list_array"></span><em class="property">class </em><code class="sig-name descname">ListArray</code> : <em class="property">public</em> arrow::BaseListArray&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8ListTypeE" title="arrow::ListType">ListType</a>&gt;<a class="headerlink" href="#_CPPv4N5arrow9ListArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for list data. </p>
<p>Subclassed by arrow::MapArray</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow9ListArray10FromArraysERK5ArrayRK5ArrayP10MemoryPoolPNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow9ListArray10FromArraysERK5ArrayRK5ArrayP10MemoryPoolPNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow9ListArray10FromArraysERK5ArrayRK5ArrayP10MemoryPoolPNSt10shared_ptrI5ArrayEE"></span><span id="arrow::ListArray::FromArrays__ArrayCR.ArrayCR.MemoryPoolP.std::shared_ptr:Array:P"></span><span class="target" id="classarrow_1_1_list_array_1a62dff3a3932441aeeaa0d768adec91ca"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">FromArrays</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>offsets</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>values</em>, <a class="reference internal" href="memory.html#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow9ListArray10FromArraysERK5ArrayRK5ArrayP10MemoryPoolPNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct <a class="reference internal" href="#classarrow_1_1_list_array"><span class="std std-ref">ListArray</span></a> from array of offsets and child value array. </p>
<p>This function does the bare minimum of validation of the offsets and input types, and will allocate a new offsets array if necessary (i.e. if the offsets contain any nulls). If the offsets do not have nulls, they are assumed to be well-formed</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">offsets</span></code>: <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> containing n + 1 offsets encoding length and size. Must be of int32 type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">values</span></code>: <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> containing list values </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: <a class="reference internal" href="memory.html#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> in case new offsets array needs to be allocated because of null values </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: Will have length equal to offsets.length() - 1 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow11StructArrayE">
<span id="_CPPv3N5arrow11StructArrayE"></span><span id="_CPPv2N5arrow11StructArrayE"></span><span id="arrow::StructArray"></span><span class="target" id="classarrow_1_1_struct_array"></span><em class="property">class </em><code class="sig-name descname">StructArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a><a class="headerlink" href="#_CPPv4N5arrow11StructArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for struct data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4NK5arrow11StructArray14GetFieldByNameERKNSt6stringE">
<span id="_CPPv3NK5arrow11StructArray14GetFieldByNameERKNSt6stringE"></span><span id="_CPPv2NK5arrow11StructArray14GetFieldByNameERKNSt6stringE"></span><span id="arrow::StructArray::GetFieldByName__ssCRC"></span><span class="target" id="classarrow_1_1_struct_array_1a3ae1f625a93bdc6592821e7e9ef3f054"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">GetFieldByName</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>name</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow11StructArray14GetFieldByNameERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns null if name not found. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow11StructArray7FlattenEP10MemoryPoolP11ArrayVector">
<span id="_CPPv3NK5arrow11StructArray7FlattenEP10MemoryPoolP11ArrayVector"></span><span id="_CPPv2NK5arrow11StructArray7FlattenEP10MemoryPoolP11ArrayVector"></span><span id="arrow::StructArray::Flatten__MemoryPoolP.ArrayVectorPC"></span><span class="target" id="classarrow_1_1_struct_array_1a33cb8ba10aa4e3ea908c1711cbaa3c5b"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Flatten</code><span class="sig-paren">(</span><a class="reference internal" href="memory.html#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, ArrayVector *<em>out</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow11StructArray7FlattenEP10MemoryPoolP11ArrayVector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flatten this array as a vector of arrays, one for each field. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: The pool to allocate null bitmaps from, if necessary </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: The resulting vector of arrays </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow11StructArray4MakeERKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEENSt10shared_ptrI6BufferEE7int64_t7int64_t">
<span id="_CPPv3N5arrow11StructArray4MakeERKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEENSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="_CPPv2N5arrow11StructArray4MakeERKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEENSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="arrow::StructArray::Make__std::vector:std::shared_ptr:Array::CR.std::vector:ss:CR.std::shared_ptr:Buffer:.int64_t.int64_t"></span><span class="target" id="classarrow_1_1_struct_array_1aa60c2cc106d51d976d3ced8d1b8233b8"></span><em class="property">static</em> Result&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow11StructArrayE" title="arrow::StructArray">StructArray</a>&gt;&gt; <code class="sig-name descname">Make</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, <em class="property">const</em> std::vector&lt;std::string&gt; &amp;<em>field_names</em>, std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>null_bitmap</em> = NULLPTR, int64_t <em>null_count</em> = kUnknownNullCount, int64_t <em>offset</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow11StructArray4MakeERKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt6stringEEENSt10shared_ptrI6BufferEE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="#classarrow_1_1_struct_array"><span class="std std-ref">StructArray</span></a> from child arrays and field names. </p>
<p>The length and data type are automatically inferred from the arguments. There should be at least one child array. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow11StructArray4MakeERKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt10shared_ptrI5FieldEEEENSt10shared_ptrI6BufferEE7int64_t7int64_t">
<span id="_CPPv3N5arrow11StructArray4MakeERKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt10shared_ptrI5FieldEEEENSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="_CPPv2N5arrow11StructArray4MakeERKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt10shared_ptrI5FieldEEEENSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="arrow::StructArray::Make__std::vector:std::shared_ptr:Array::CR.std::vector:std::shared_ptr:Field::CR.std::shared_ptr:Buffer:.int64_t.int64_t"></span><span class="target" id="classarrow_1_1_struct_array_1a08cc2031c4a888d696c0b0fd4449b6ff"></span><em class="property">static</em> Result&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow11StructArrayE" title="arrow::StructArray">StructArray</a>&gt;&gt; <code class="sig-name descname">Make</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; &amp;<em>children</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow5FieldE" title="arrow::Field">Field</a>&gt;&gt; &amp;<em>fields</em>, std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>null_bitmap</em> = NULLPTR, int64_t <em>null_count</em> = kUnknownNullCount, int64_t <em>offset</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow11StructArray4MakeERKNSt6vectorINSt10shared_ptrI5ArrayEEEERKNSt6vectorINSt10shared_ptrI5FieldEEEENSt10shared_ptrI6BufferEE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="#classarrow_1_1_struct_array"><span class="std std-ref">StructArray</span></a> from child arrays and fields. </p>
<p>The length is automatically inferred from the arguments. There should be at least one child array. This method does not check that field types and child array types are consistent. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="chunked-arrays">
<h2>Chunked Arrays<a class="headerlink" href="#chunked-arrays" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5arrow12ChunkedArrayE">
<span id="_CPPv3N5arrow12ChunkedArrayE"></span><span id="_CPPv2N5arrow12ChunkedArrayE"></span><span id="arrow::ChunkedArray"></span><span class="target" id="classarrow_1_1_chunked_array"></span><em class="property">class </em><code class="sig-name descname">ChunkedArray</code><a class="headerlink" href="#_CPPv4N5arrow12ChunkedArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A data structure managing a list of primitive Arrow arrays logically as one large array. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow12ChunkedArray12ChunkedArrayERK11ArrayVector">
<span id="_CPPv3N5arrow12ChunkedArray12ChunkedArrayERK11ArrayVector"></span><span id="_CPPv2N5arrow12ChunkedArray12ChunkedArrayERK11ArrayVector"></span><span id="arrow::ChunkedArray::ChunkedArray__ArrayVectorCR"></span><span class="target" id="classarrow_1_1_chunked_array_1a2640fe6c89743e608e6e2495d5041d87"></span><code class="sig-name descname">ChunkedArray</code><span class="sig-paren">(</span><em class="property">const</em> ArrayVector &amp;<em>chunks</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow12ChunkedArray12ChunkedArrayERK11ArrayVector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a chunked array from a vector of arrays. </p>
<p>The vector must be non-empty and all its elements must have the same data type. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow12ChunkedArray12ChunkedArrayERKNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow12ChunkedArray12ChunkedArrayERKNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow12ChunkedArray12ChunkedArrayERKNSt10shared_ptrI5ArrayEE"></span><span id="arrow::ChunkedArray::ChunkedArray__std::shared_ptr:Array:CR"></span><span class="target" id="classarrow_1_1_chunked_array_1a09cbc488c79b1ee9d20526fc99d71d93"></span><code class="sig-name descname">ChunkedArray</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; &amp;<em>chunk</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow12ChunkedArray12ChunkedArrayERKNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a chunked array from a single <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow12ChunkedArray12ChunkedArrayERK11ArrayVectorRKNSt10shared_ptrI8DataTypeEE">
<span id="_CPPv3N5arrow12ChunkedArray12ChunkedArrayERK11ArrayVectorRKNSt10shared_ptrI8DataTypeEE"></span><span id="_CPPv2N5arrow12ChunkedArray12ChunkedArrayERK11ArrayVectorRKNSt10shared_ptrI8DataTypeEE"></span><span id="arrow::ChunkedArray::ChunkedArray__ArrayVectorCR.std::shared_ptr:DataType:CR"></span><span class="target" id="classarrow_1_1_chunked_array_1ae73d53d335133270c6653e5de0d352cc"></span><code class="sig-name descname">ChunkedArray</code><span class="sig-paren">(</span><em class="property">const</em> ArrayVector &amp;<em>chunks</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; &amp;<em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow12ChunkedArray12ChunkedArrayERK11ArrayVectorRKNSt10shared_ptrI8DataTypeEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a chunked array from a vector of arrays and a data type. </p>
<p>As the data type is passed explicitly, the vector may be empty. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray6lengthEv">
<span id="_CPPv3NK5arrow12ChunkedArray6lengthEv"></span><span id="_CPPv2NK5arrow12ChunkedArray6lengthEv"></span><span id="arrow::ChunkedArray::lengthC"></span><span class="target" id="classarrow_1_1_chunked_array_1a4df41bf1a05cd1083a2c4502e0a85f87"></span>int64_t <code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray6lengthEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the total length of the chunked array; computed on construction </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray10null_countEv">
<span id="_CPPv3NK5arrow12ChunkedArray10null_countEv"></span><span id="_CPPv2NK5arrow12ChunkedArray10null_countEv"></span><span id="arrow::ChunkedArray::null_countC"></span><span class="target" id="classarrow_1_1_chunked_array_1a962541b044ac5a7a6a87499cef7957bb"></span>int64_t <code class="sig-name descname">null_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray10null_countEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the total number of nulls among all chunks </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray5chunkEi">
<span id="_CPPv3NK5arrow12ChunkedArray5chunkEi"></span><span id="_CPPv2NK5arrow12ChunkedArray5chunkEi"></span><span id="arrow::ChunkedArray::chunk__iC"></span><span class="target" id="classarrow_1_1_chunked_array_1a92ec02f5904ac3e4dac5328e44ebf0fb"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">chunk</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray5chunkEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>chunk a particular chunk from the chunked array </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray5SliceE7int64_t7int64_t">
<span id="_CPPv3NK5arrow12ChunkedArray5SliceE7int64_t7int64_t"></span><span id="_CPPv2NK5arrow12ChunkedArray5SliceE7int64_t7int64_t"></span><span id="arrow::ChunkedArray::Slice__int64_t.int64_tC"></span><span class="target" id="classarrow_1_1_chunked_array_1a99573028501f20b3f0707d85e8cce2ad"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt; <code class="sig-name descname">Slice</code><span class="sig-paren">(</span>int64_t <em>offset</em>, int64_t <em>length</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray5SliceE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a zero-copy slice of the chunked array with the indicated offset and length. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new object wrapped in std::shared_ptr&lt;ChunkedArray&gt; </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">offset</span></code>: the position of the first element in the constructed slice </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">length</span></code>: the length of the slice. If there are not enough elements in the chunked array, the length will be adjusted accordingly</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray5SliceE7int64_t">
<span id="_CPPv3NK5arrow12ChunkedArray5SliceE7int64_t"></span><span id="_CPPv2NK5arrow12ChunkedArray5SliceE7int64_t"></span><span id="arrow::ChunkedArray::Slice__int64_tC"></span><span class="target" id="classarrow_1_1_chunked_array_1abf30b26c92cf037191e8574763e22a2e"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt; <code class="sig-name descname">Slice</code><span class="sig-paren">(</span>int64_t <em>offset</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray5SliceE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Slice from offset until end of the chunked array. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray7FlattenEP10MemoryPoolPNSt6vectorINSt10shared_ptrI12ChunkedArrayEEEE">
<span id="_CPPv3NK5arrow12ChunkedArray7FlattenEP10MemoryPoolPNSt6vectorINSt10shared_ptrI12ChunkedArrayEEEE"></span><span id="_CPPv2NK5arrow12ChunkedArray7FlattenEP10MemoryPoolPNSt6vectorINSt10shared_ptrI12ChunkedArrayEEEE"></span><span id="arrow::ChunkedArray::Flatten__MemoryPoolP.std::vector:std::shared_ptr:ChunkedArray::PC"></span><span class="target" id="classarrow_1_1_chunked_array_1a8d4af28e378addf17162ad421bc0cdd6"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Flatten</code><span class="sig-paren">(</span><a class="reference internal" href="memory.html#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt;&gt; *<em>out</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray7FlattenEP10MemoryPoolPNSt6vectorINSt10shared_ptrI12ChunkedArrayEEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flatten this chunked array as a vector of chunked arrays, one for each struct field. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: The pool for buffer allocations, if any </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: The resulting vector of arrays </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray4ViewERKNSt10shared_ptrI8DataTypeEEPNSt10shared_ptrI12ChunkedArrayEE">
<span id="_CPPv3NK5arrow12ChunkedArray4ViewERKNSt10shared_ptrI8DataTypeEEPNSt10shared_ptrI12ChunkedArrayEE"></span><span id="_CPPv2NK5arrow12ChunkedArray4ViewERKNSt10shared_ptrI8DataTypeEEPNSt10shared_ptrI12ChunkedArrayEE"></span><span id="arrow::ChunkedArray::View__std::shared_ptr:DataType:CR.std::shared_ptr:ChunkedArray:PC"></span><span class="target" id="classarrow_1_1_chunked_array_1ad5d7f457d2b87d9e28045b69b1ae9efb"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">View</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; &amp;<em>type</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt; *<em>out</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray4ViewERKNSt10shared_ptrI8DataTypeEEPNSt10shared_ptrI12ChunkedArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a zero-copy view of this chunked array with the given type. </p>
<p>Calls <a class="reference internal" href="#classarrow_1_1_array_1ad015904c8c6e5e2513c791fb577f2679"><span class="std std-ref">Array::View</span></a> on each constituent chunk. Always succeeds if there are zero chunks </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray6EqualsERK12ChunkedArray">
<span id="_CPPv3NK5arrow12ChunkedArray6EqualsERK12ChunkedArray"></span><span id="_CPPv2NK5arrow12ChunkedArray6EqualsERK12ChunkedArray"></span><span id="arrow::ChunkedArray::Equals__ChunkedArrayCRC"></span><span class="target" id="classarrow_1_1_chunked_array_1ab7ad74cc587d5d622c7e62cbf1b0b9f9"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray6EqualsERK12ChunkedArray" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if two chunked arrays are equal. </p>
<p>Two chunked arrays can be equal only if they have equal datatypes. However, they may be equal even if they have different chunkings. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray6EqualsERKNSt10shared_ptrI12ChunkedArrayEE">
<span id="_CPPv3NK5arrow12ChunkedArray6EqualsERKNSt10shared_ptrI12ChunkedArrayEE"></span><span id="_CPPv2NK5arrow12ChunkedArray6EqualsERKNSt10shared_ptrI12ChunkedArrayEE"></span><span id="arrow::ChunkedArray::Equals__std::shared_ptr:ChunkedArray:CRC"></span><span class="target" id="classarrow_1_1_chunked_array_1a67c23032d122d1a87acf0bc2b2e52d54"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt; &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray6EqualsERKNSt10shared_ptrI12ChunkedArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if two chunked arrays are equal. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow12ChunkedArray8ValidateEv">
<span id="_CPPv3NK5arrow12ChunkedArray8ValidateEv"></span><span id="_CPPv2NK5arrow12ChunkedArray8ValidateEv"></span><span id="arrow::ChunkedArray::ValidateC"></span><span class="target" id="classarrow_1_1_chunked_array_1a06ca5def32987d58b7577db269e39520"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray8ValidateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check that all chunks have the same data type. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="builder.html" class="btn btn-neutral float-right" title="Array Builders" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="datatype.html" class="btn btn-neutral float-left" title="Data Types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2019 Apache Software Foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-107500873-1');
</script>


</body>
</html>