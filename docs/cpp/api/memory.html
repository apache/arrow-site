


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Memory (management) &mdash; Apache Arrow v0.13.0</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Data Types" href="datatype.html" />
    <link rel="prev" title="Programming Support" href="support.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Apache Arrow
          

          
          </a>

          
            
            
              <div class="version">
                0.13.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Arrow Columnar Format</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../format/README.html">Arrow specification documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Guidelines.html">Implementation guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Layout.html">Physical memory layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Metadata.html">Metadata: Logical types, schemas, data headers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/IPC.html">Interprocess messaging / communication (IPC)</a></li>
</ul>
<p class="caption"><span class="caption-text">Arrow Libraries</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">C++ Implementation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/index.html">Examples</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../api.html">API Reference</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="support.html">Programming Support</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Memory (management)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#buffers">Buffers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-pools">Memory Pools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#allocation-functions">Allocation Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slicing">Slicing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-builders">Buffer Builders</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stl-integration">STL Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="datatype.html">Data Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="array.html">Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="builder.html">Array Builders</a></li>
<li class="toctree-l3"><a class="reference internal" href="table.html">Two-dimensional Datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="cuda.html">CUDA support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../python/index.html">Python bindings</a></li>
</ul>
<p class="caption"><span class="caption-text">Development and Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developers/contributing.html">Contribution Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/cpp.html">C++ Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/python.html">Python Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/integration.html">Integration Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/documentation.html">Building the Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Apache Arrow</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">C++ Implementation</a> &raquo;</li>
        
          <li><a href="../api.html">API Reference</a> &raquo;</li>
        
      <li>Memory (management)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/cpp/api/memory.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memory-management">
<h1>Memory (management)<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h1>
<div class="section" id="buffers">
<h2>Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5arrow6BufferE">
<span id="_CPPv3N5arrow6BufferE"></span><span id="_CPPv2N5arrow6BufferE"></span><span id="arrow::Buffer"></span><span class="target" id="classarrow_1_1_buffer"></span><em class="property">class </em><code class="descname">Buffer</code><a class="headerlink" href="#_CPPv4N5arrow6BufferE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Object containing a pointer to a piece of contiguous memory with a particular size. </p>
<p>Buffers have two related notions of length: size and capacity. Size is the number of bytes that might have valid data. Capacity is the number of bytes that were allocated for the buffer in total.</p>
<p>The <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> base class does not own its memory, but subclasses often do.</p>
<p>The following invariant is always true: Size &lt;= Capacity </p>
<p>Subclassed by <a class="reference internal" href="cuda.html#classarrow_1_1cuda_1_1_cuda_buffer"><span class="std std-ref">arrow::cuda::CudaBuffer</span></a>, <a class="reference internal" href="#classarrow_1_1_mutable_buffer"><span class="std std-ref">arrow::MutableBuffer</span></a>, arrow::py::NumPyBuffer, arrow::py::PyBuffer, arrow::py::PyForeignBuffer</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow6Buffer6BufferEPK7uint8_t7int64_t">
<span id="_CPPv3N5arrow6Buffer6BufferEPK7uint8_t7int64_t"></span><span id="_CPPv2N5arrow6Buffer6BufferEPK7uint8_t7int64_t"></span><span id="arrow::Buffer::Buffer__uint8_tCP.int64_t"></span><span class="target" id="classarrow_1_1_buffer_1a801078c559b0c351f1ca5a6b6a04488f"></span><code class="descname">Buffer</code><span class="sig-paren">(</span><em class="property">const</em> uint8_t *<em>data</em>, int64_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer6BufferEPK7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct from buffer and size without copying memory. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The passed memory must be kept alive through some other means </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: a memory buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: buffer size</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow6Buffer6BufferERKNSt6stringE">
<span id="_CPPv3N5arrow6Buffer6BufferERKNSt6stringE"></span><span id="_CPPv2N5arrow6Buffer6BufferERKNSt6stringE"></span><span id="arrow::Buffer::Buffer__ssCR"></span><span class="target" id="classarrow_1_1_buffer_1a5dfd60984e0ac8474f20dbd49f628e54"></span><code class="descname">Buffer</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer6BufferERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct from std::string without copying memory. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The std::string must stay alive for the lifetime of the <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a>, so temporary rvalue strings must be stored in an lvalue somewhere </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: a std::string object</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow6Buffer6BufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t">
<span id="_CPPv3N5arrow6Buffer6BufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="_CPPv2N5arrow6Buffer6BufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="arrow::Buffer::Buffer__std::shared_ptr:Buffer:CR.int64_tC.int64_tC"></span><span class="target" id="classarrow_1_1_buffer_1af694696afedb9313cf5dc874ffa9a453"></span><code class="descname">Buffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6Buffer6BufferEPK7uint8_t7int64_t" title="arrow::Buffer::Buffer">Buffer</a>&gt; &amp;<em>parent</em>, <em class="property">const</em> int64_t <em>offset</em>, <em class="property">const</em> int64_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer6BufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An offset into data that is owned by another buffer, but we want to be able to retain a valid pointer to it even after other shared_ptr’s to the parent buffer have been destroyed. </p>
<p>This method makes no assertions about alignment or padding of the buffer but in general we expected buffers to be aligned and padded to 64 bytes. In the future we might add utility methods to help determine if a buffer satisfies this contract. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow6Buffer6EqualsERK6Buffer7int64_t">
<span id="_CPPv3NK5arrow6Buffer6EqualsERK6Buffer7int64_t"></span><span id="_CPPv2NK5arrow6Buffer6EqualsERK6Buffer7int64_t"></span><span id="arrow::Buffer::Equals__BufferCR.int64_tC"></span><span class="target" id="classarrow_1_1_buffer_1a94918db73183b750716a07133dd8384d"></span>bool <code class="descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a> &amp;<em>other</em>, int64_t <em>nbytes</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer6EqualsERK6Buffer7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true if both buffers are the same size and contain the same bytes up to the number of compared bytes. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow6Buffer6EqualsERK6Buffer">
<span id="_CPPv3NK5arrow6Buffer6EqualsERK6Buffer"></span><span id="_CPPv2NK5arrow6Buffer6EqualsERK6Buffer"></span><span id="arrow::Buffer::Equals__BufferCRC"></span><span class="target" id="classarrow_1_1_buffer_1a0d3d3bd95a3297046a6ab24f5e957bfd"></span>bool <code class="descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer6EqualsERK6Buffer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true if both buffers are the same size and contain the same bytes. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow6Buffer4CopyEK7int64_tK7int64_tP10MemoryPoolPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3NK5arrow6Buffer4CopyEK7int64_tK7int64_tP10MemoryPoolPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2NK5arrow6Buffer4CopyEK7int64_tK7int64_tP10MemoryPoolPNSt10shared_ptrI6BufferEE"></span><span id="arrow::Buffer::Copy__int64_tC.int64_tC.MemoryPoolP.std::shared_ptr:Buffer:PC"></span><span class="target" id="classarrow_1_1_buffer_1a7081913a08b88c2ca674c36354d5e171"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Copy</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>start</em>, <em class="property">const</em> int64_t <em>nbytes</em>, <a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer4CopyEK7int64_tK7int64_tP10MemoryPoolPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a section of the buffer into a new <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow6Buffer4CopyEK7int64_tK7int64_tPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3NK5arrow6Buffer4CopyEK7int64_tK7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2NK5arrow6Buffer4CopyEK7int64_tK7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="arrow::Buffer::Copy__int64_tC.int64_tC.std::shared_ptr:Buffer:PC"></span><span class="target" id="classarrow_1_1_buffer_1adcf891e5c72d591f1c293027dbf7f22a"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Copy</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>start</em>, <em class="property">const</em> int64_t <em>nbytes</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer4CopyEK7int64_tK7int64_tPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a section of the buffer using the default memory pool into a new <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow6Buffer11ZeroPaddingEv">
<span id="_CPPv3N5arrow6Buffer11ZeroPaddingEv"></span><span id="_CPPv2N5arrow6Buffer11ZeroPaddingEv"></span><span id="arrow::Buffer::ZeroPadding"></span><span class="target" id="classarrow_1_1_buffer_1a885f7b3329f3adb43a826e9403732a15"></span>void <code class="descname">ZeroPadding</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer11ZeroPaddingEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Zero bytes in padding, i.e. bytes between size_ and capacity_. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow6Buffer8ToStringEv">
<span id="_CPPv3NK5arrow6Buffer8ToStringEv"></span><span id="_CPPv2NK5arrow6Buffer8ToStringEv"></span><span id="arrow::Buffer::ToStringC"></span><span class="target" id="classarrow_1_1_buffer_1a90034bddee753d83af07e97cdd252b8f"></span>std::string <code class="descname">ToString</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer8ToStringEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy buffer contents into a new std::string. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>std::string </dd>
<dt><strong>Note</strong></dt>
<dd>Can throw std::bad_alloc if buffer is large </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow6Buffer4dataEv">
<span id="_CPPv3NK5arrow6Buffer4dataEv"></span><span id="_CPPv2NK5arrow6Buffer4dataEv"></span><span id="arrow::Buffer::dataC"></span><span class="target" id="classarrow_1_1_buffer_1a81c3dd8c11dd804be2ada6df5ce8fad2"></span><em class="property">const</em> uint8_t *<code class="descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer4dataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a pointer to the buffer’s data. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow6Buffer12mutable_dataEv">
<span id="_CPPv3N5arrow6Buffer12mutable_dataEv"></span><span id="_CPPv2N5arrow6Buffer12mutable_dataEv"></span><span id="arrow::Buffer::mutable_data"></span><span class="target" id="classarrow_1_1_buffer_1a5a9cb9324d3f7e323eb070b553c925aa"></span>uint8_t *<code class="descname">mutable_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer12mutable_dataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a writable pointer to the buffer’s data. </p>
<p>The buffer has to be mutable. Otherwise, an assertion may be thrown or a null pointer may be returned. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow6Buffer4sizeEv">
<span id="_CPPv3NK5arrow6Buffer4sizeEv"></span><span id="_CPPv2NK5arrow6Buffer4sizeEv"></span><span id="arrow::Buffer::sizeC"></span><span class="target" id="classarrow_1_1_buffer_1a2a49871341c300996a39145d22aa8054"></span>int64_t <code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the buffer’s size in bytes. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow6Buffer8capacityEv">
<span id="_CPPv3NK5arrow6Buffer8capacityEv"></span><span id="_CPPv2NK5arrow6Buffer8capacityEv"></span><span id="arrow::Buffer::capacityC"></span><span class="target" id="classarrow_1_1_buffer_1a4c75902129b5f2fb471fd166907361dc"></span>int64_t <code class="descname">capacity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer8capacityEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the buffer’s capacity (number of allocated bytes) </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow6Buffer10FromStringERKNSt6stringEP10MemoryPoolPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow6Buffer10FromStringERKNSt6stringEP10MemoryPoolPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow6Buffer10FromStringERKNSt6stringEP10MemoryPoolPNSt10shared_ptrI6BufferEE"></span><span id="arrow::Buffer::FromString__ssCR.MemoryPoolP.std::shared_ptr:Buffer:P"></span><span class="target" id="classarrow_1_1_buffer_1adeea70eb65ff53f3ec94d3a7b754c7c0"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">FromString</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>data</em>, <a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer10FromStringERKNSt6stringEP10MemoryPoolPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a new buffer that owns its memory from a std::string. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: a std::string object </li>
<li><code class="docutils literal notranslate"><span class="pre">pool</span></code>: a memory pool </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the created buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow6Buffer10FromStringERKNSt6stringEPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow6Buffer10FromStringERKNSt6stringEPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow6Buffer10FromStringERKNSt6stringEPNSt10shared_ptrI6BufferEE"></span><span id="arrow::Buffer::FromString__ssCR.std::shared_ptr:Buffer:P"></span><span class="target" id="classarrow_1_1_buffer_1a65e1ae0e908b997d371fc80ff1cb8f43"></span><em class="property">static</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">FromString</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>data</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer10FromStringERKNSt6stringEPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a new buffer that owns its memory from a std::string using the default memory pool. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow6Buffer10FromStringERRNSt6stringE">
<span id="_CPPv3N5arrow6Buffer10FromStringERRNSt6stringE"></span><span id="_CPPv2N5arrow6Buffer10FromStringERRNSt6stringE"></span><span id="arrow::Buffer::FromString__ssRR"></span><span class="target" id="classarrow_1_1_buffer_1ab80d43f61a9396c2041343cde4255d24"></span><em class="property">static</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="descname">FromString</code><span class="sig-paren">(</span>std::string &amp;&amp;<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer10FromStringERRNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an immutable buffer that takes ownership of the contents of an std::string. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a new <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> instance </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: an rvalue-reference of a string </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow6Buffer4WrapEPK1T8SizeType">
<span id="_CPPv3N5arrow6Buffer4WrapEPK1T8SizeType"></span><span id="_CPPv2N5arrow6Buffer4WrapEPK1T8SizeType"></span><span id="arrow::Buffer::Wrap__TCP.SizeType"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> SizeType = int64_t&gt;<br /><span class="target" id="classarrow_1_1_buffer_1abd877e4c900427798762d0abaa92b679"></span><em class="property">static</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="descname">Wrap</code><span class="sig-paren">(</span><em class="property">const</em> T *<em>data</em>, SizeType <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer4WrapEPK1T8SizeType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create buffer referencing typed memory with some length without copying. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a new shared_ptr&lt;Buffer&gt; </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: the typed memory as C array </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>: the number of values in the array </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow6Buffer4WrapERKNSt6vectorI1TEE">
<span id="_CPPv3N5arrow6Buffer4WrapERKNSt6vectorI1TEE"></span><span id="_CPPv2N5arrow6Buffer4WrapERKNSt6vectorI1TEE"></span><span id="arrow::Buffer::Wrap__std::vector:T:CR"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="classarrow_1_1_buffer_1a62d1926a69dd12ce6821dd8c96eafea2"></span><em class="property">static</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="descname">Wrap</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;T&gt; &amp;<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer4WrapERKNSt6vectorI1TEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create buffer referencing std::vector with some length without copying. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a new shared_ptr&lt;Buffer&gt; </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: the vector to be referenced. If this vector is changed, the buffer may become invalid </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow13MutableBufferE">
<span id="_CPPv3N5arrow13MutableBufferE"></span><span id="_CPPv2N5arrow13MutableBufferE"></span><span id="arrow::MutableBuffer"></span><span class="target" id="classarrow_1_1_mutable_buffer"></span><em class="property">class </em><code class="descname">MutableBuffer</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a><a class="headerlink" href="#_CPPv4N5arrow13MutableBufferE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> whose contents can be mutated. </p>
<p>May or may not own its data. </p>
<p>Subclassed by <a class="reference internal" href="cuda.html#classarrow_1_1cuda_1_1_cuda_host_buffer"><span class="std std-ref">arrow::cuda::CudaHostBuffer</span></a>, <a class="reference internal" href="#classarrow_1_1_resizable_buffer"><span class="std std-ref">arrow::ResizableBuffer</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow13MutableBuffer4WrapEP1T8SizeType">
<span id="_CPPv3N5arrow13MutableBuffer4WrapEP1T8SizeType"></span><span id="_CPPv2N5arrow13MutableBuffer4WrapEP1T8SizeType"></span><span id="arrow::MutableBuffer::Wrap__TP.SizeType"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> SizeType = int64_t&gt;<br /><span class="target" id="classarrow_1_1_mutable_buffer_1ae06e3a980614bc6db4239e337f721b33"></span><em class="property">static</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="descname">Wrap</code><span class="sig-paren">(</span>T *<em>data</em>, SizeType <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13MutableBuffer4WrapEP1T8SizeType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create buffer referencing typed memory with some length. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a new shared_ptr&lt;Buffer&gt; </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: the typed memory as C array </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>: the number of values in the array </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow15ResizableBufferE">
<span id="_CPPv3N5arrow15ResizableBufferE"></span><span id="_CPPv2N5arrow15ResizableBufferE"></span><span id="arrow::ResizableBuffer"></span><span class="target" id="classarrow_1_1_resizable_buffer"></span><em class="property">class </em><code class="descname">ResizableBuffer</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow13MutableBufferE" title="arrow::MutableBuffer">MutableBuffer</a><a class="headerlink" href="#_CPPv4N5arrow15ResizableBufferE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A mutable buffer that can be resized. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow15ResizableBuffer6ResizeEK7int64_tb">
<span id="_CPPv3N5arrow15ResizableBuffer6ResizeEK7int64_tb"></span><span id="_CPPv2N5arrow15ResizableBuffer6ResizeEK7int64_tb"></span><span id="arrow::ResizableBuffer::Resize__int64_tC.b"></span><span class="target" id="classarrow_1_1_resizable_buffer_1ac2d6a69440b5f438f1b02c610622d8f2"></span><em class="property">virtual</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Resize</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>new_size</em>, bool <em>shrink_to_fit</em> = true<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow15ResizableBuffer6ResizeEK7int64_tb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Change buffer reported size to indicated size, allocating memory if necessary. </p>
<p>This will ensure that the capacity of the buffer is a multiple of 64 bytes as defined in Layout.md. Consider using ZeroPadding afterwards, to conform to the Arrow layout specification.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">new_size</span></code>: The new size for the buffer. </li>
<li><code class="docutils literal notranslate"><span class="pre">shrink_to_fit</span></code>: Whether to shrink the capacity if new size &lt; current size </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow15ResizableBuffer7ReserveEK7int64_t">
<span id="_CPPv3N5arrow15ResizableBuffer7ReserveEK7int64_t"></span><span id="_CPPv2N5arrow15ResizableBuffer7ReserveEK7int64_t"></span><span id="arrow::ResizableBuffer::Reserve__int64_tC"></span><span class="target" id="classarrow_1_1_resizable_buffer_1ae3e4b7569105c6cd980ab2d10b5bbf73"></span><em class="property">virtual</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Reserve</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>new_capacity</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow15ResizableBuffer7ReserveEK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ensure that buffer has enough memory allocated to fit the indicated capacity (and meets the 64 byte padding requirement in Layout.md). </p>
<p>It does not change buffer’s reported size and doesn’t zero the padding. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="memory-pools">
<h2>Memory Pools<a class="headerlink" href="#memory-pools" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv4N5arrow19default_memory_poolEv">
<span id="_CPPv3N5arrow19default_memory_poolEv"></span><span id="_CPPv2N5arrow19default_memory_poolEv"></span><span id="arrow::default_memory_pool"></span><span class="target" id="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820"></span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">default_memory_pool</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow19default_memory_poolEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the process-wide default memory pool. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow10MemoryPoolE">
<span id="_CPPv3N5arrow10MemoryPoolE"></span><span id="_CPPv2N5arrow10MemoryPoolE"></span><span id="arrow::MemoryPool"></span><span class="target" id="classarrow_1_1_memory_pool"></span><em class="property">class </em><code class="descname">MemoryPool</code><a class="headerlink" href="#_CPPv4N5arrow10MemoryPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for memory allocation. </p>
<p>Besides tracking the number of allocated bytes, the allocator also should take care of the required 64-byte alignment. </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_logging_memory_pool"><span class="std std-ref">arrow::LoggingMemoryPool</span></a>, <a class="reference internal" href="#classarrow_1_1_proxy_memory_pool"><span class="std std-ref">arrow::ProxyMemoryPool</span></a>, <a class="reference internal" href="#classarrow_1_1_s_t_l_memory_pool"><span class="std std-ref">arrow::STLMemoryPool&lt; Allocator &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow10MemoryPool8AllocateE7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow10MemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow10MemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="arrow::MemoryPool::Allocate__int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_memory_pool_1afa452b21a4d401403cc509cc50a384f9"></span><em class="property">virtual</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Allocate</code><span class="sig-paren">(</span>int64_t <em>size</em>, uint8_t **<em>out</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow10MemoryPool8AllocateE7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new memory region of at least size bytes. </p>
<p>The allocated region shall be 64-byte aligned. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow10MemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow10MemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow10MemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="arrow::MemoryPool::Reallocate__int64_t.int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_memory_pool_1af64bda5eccc8fa42ce9ae0aba1ad9077"></span><em class="property">virtual</em> <a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Reallocate</code><span class="sig-paren">(</span>int64_t <em>old_size</em>, int64_t <em>new_size</em>, uint8_t **<em>ptr</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow10MemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize an already allocated memory section. </p>
<p>As by default most default allocators on a platform don’t support aligned reallocation, this function can involve a copy of the underlying data. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow10MemoryPool4FreeEP7uint8_t7int64_t">
<span id="_CPPv3N5arrow10MemoryPool4FreeEP7uint8_t7int64_t"></span><span id="_CPPv2N5arrow10MemoryPool4FreeEP7uint8_t7int64_t"></span><span id="arrow::MemoryPool::Free__uint8_tP.int64_t"></span><span class="target" id="classarrow_1_1_memory_pool_1a5a45c822a4ca7b3d8387501acfa69911"></span><em class="property">virtual</em> void <code class="descname">Free</code><span class="sig-paren">(</span>uint8_t *<em>buffer</em>, int64_t <em>size</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow10MemoryPool4FreeEP7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an allocated region. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Pointer to the start of the allocated memory region </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Allocated size located at buffer. An allocator implementation may use this for tracking the amount of allocated bytes as well as for faster deallocation if supported by its backend. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow10MemoryPool15bytes_allocatedEv">
<span id="_CPPv3NK5arrow10MemoryPool15bytes_allocatedEv"></span><span id="_CPPv2NK5arrow10MemoryPool15bytes_allocatedEv"></span><span id="arrow::MemoryPool::bytes_allocatedC"></span><span class="target" id="classarrow_1_1_memory_pool_1abd12cd4bfb8ce8afcfc7a25d0293cd85"></span><em class="property">virtual</em> int64_t <code class="descname">bytes_allocated</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrow10MemoryPool15bytes_allocatedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes that were allocated and not yet free’d through this allocator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow10MemoryPool10max_memoryEv">
<span id="_CPPv3NK5arrow10MemoryPool10max_memoryEv"></span><span id="_CPPv2NK5arrow10MemoryPool10max_memoryEv"></span><span id="arrow::MemoryPool::max_memoryC"></span><span class="target" id="classarrow_1_1_memory_pool_1a4d1fe541389b4afd4d49d727dc3088f0"></span><em class="property">virtual</em> int64_t <code class="descname">max_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow10MemoryPool10max_memoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return peak memory allocation in this memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Maximum bytes allocated. If not known (or not implemented), returns -1 </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow10MemoryPool13CreateDefaultEv">
<span id="_CPPv3N5arrow10MemoryPool13CreateDefaultEv"></span><span id="_CPPv2N5arrow10MemoryPool13CreateDefaultEv"></span><span id="arrow::MemoryPool::CreateDefault"></span><span class="target" id="classarrow_1_1_memory_pool_1a844c3276d2f14daf186ceb9585fe3581"></span><em class="property">static</em> std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a>&gt; <code class="descname">CreateDefault</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10MemoryPool13CreateDefaultEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>EXPERIMENTAL. Create a new instance of the default <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a>. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow17LoggingMemoryPoolE">
<span id="_CPPv3N5arrow17LoggingMemoryPoolE"></span><span id="_CPPv2N5arrow17LoggingMemoryPoolE"></span><span id="arrow::LoggingMemoryPool"></span><span class="target" id="classarrow_1_1_logging_memory_pool"></span><em class="property">class </em><code class="descname">LoggingMemoryPool</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a><a class="headerlink" href="#_CPPv4N5arrow17LoggingMemoryPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow17LoggingMemoryPool8AllocateE7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow17LoggingMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow17LoggingMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="arrow::LoggingMemoryPool::Allocate__int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1a3eb03f4e10b9fbf1e06fd72d65b6601c"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Allocate</code><span class="sig-paren">(</span>int64_t <em>size</em>, uint8_t **<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow17LoggingMemoryPool8AllocateE7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new memory region of at least size bytes. </p>
<p>The allocated region shall be 64-byte aligned. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow17LoggingMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow17LoggingMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow17LoggingMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="arrow::LoggingMemoryPool::Reallocate__int64_t.int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1a3e548a7bc1d434fa30fbe1e43be52a3b"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Reallocate</code><span class="sig-paren">(</span>int64_t <em>old_size</em>, int64_t <em>new_size</em>, uint8_t **<em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow17LoggingMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize an already allocated memory section. </p>
<p>As by default most default allocators on a platform don’t support aligned reallocation, this function can involve a copy of the underlying data. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow17LoggingMemoryPool4FreeEP7uint8_t7int64_t">
<span id="_CPPv3N5arrow17LoggingMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="_CPPv2N5arrow17LoggingMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="arrow::LoggingMemoryPool::Free__uint8_tP.int64_t"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1ac68ae6be2a6b8c2c44e0ad6d0c2b0cc8"></span>void <code class="descname">Free</code><span class="sig-paren">(</span>uint8_t *<em>buffer</em>, int64_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow17LoggingMemoryPool4FreeEP7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an allocated region. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Pointer to the start of the allocated memory region </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Allocated size located at buffer. An allocator implementation may use this for tracking the amount of allocated bytes as well as for faster deallocation if supported by its backend. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow17LoggingMemoryPool15bytes_allocatedEv">
<span id="_CPPv3NK5arrow17LoggingMemoryPool15bytes_allocatedEv"></span><span id="_CPPv2NK5arrow17LoggingMemoryPool15bytes_allocatedEv"></span><span id="arrow::LoggingMemoryPool::bytes_allocatedC"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1aa5a4ee8ec0299fea7125d89dc8553a46"></span>int64_t <code class="descname">bytes_allocated</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow17LoggingMemoryPool15bytes_allocatedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes that were allocated and not yet free’d through this allocator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow17LoggingMemoryPool10max_memoryEv">
<span id="_CPPv3NK5arrow17LoggingMemoryPool10max_memoryEv"></span><span id="_CPPv2NK5arrow17LoggingMemoryPool10max_memoryEv"></span><span id="arrow::LoggingMemoryPool::max_memoryC"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1af41a546412c98aa4439b53ec4df257bf"></span>int64_t <code class="descname">max_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow17LoggingMemoryPool10max_memoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return peak memory allocation in this memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Maximum bytes allocated. If not known (or not implemented), returns -1 </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow15ProxyMemoryPoolE">
<span id="_CPPv3N5arrow15ProxyMemoryPoolE"></span><span id="_CPPv2N5arrow15ProxyMemoryPoolE"></span><span id="arrow::ProxyMemoryPool"></span><span class="target" id="classarrow_1_1_proxy_memory_pool"></span><em class="property">class </em><code class="descname">ProxyMemoryPool</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a><a class="headerlink" href="#_CPPv4N5arrow15ProxyMemoryPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Derived class for memory allocation. </p>
<p>Tracks the number of bytes and maximum memory allocated through its direct calls. Actual allocation is delegated to <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> class. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow15ProxyMemoryPool8AllocateE7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow15ProxyMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow15ProxyMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="arrow::ProxyMemoryPool::Allocate__int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1a335a8650da63a1ebf8ecbdf692e512b5"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Allocate</code><span class="sig-paren">(</span>int64_t <em>size</em>, uint8_t **<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow15ProxyMemoryPool8AllocateE7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new memory region of at least size bytes. </p>
<p>The allocated region shall be 64-byte aligned. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow15ProxyMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow15ProxyMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow15ProxyMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="arrow::ProxyMemoryPool::Reallocate__int64_t.int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1a6e21a87edb6fac307950ba03900ea5cc"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Reallocate</code><span class="sig-paren">(</span>int64_t <em>old_size</em>, int64_t <em>new_size</em>, uint8_t **<em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow15ProxyMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize an already allocated memory section. </p>
<p>As by default most default allocators on a platform don’t support aligned reallocation, this function can involve a copy of the underlying data. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow15ProxyMemoryPool4FreeEP7uint8_t7int64_t">
<span id="_CPPv3N5arrow15ProxyMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="_CPPv2N5arrow15ProxyMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="arrow::ProxyMemoryPool::Free__uint8_tP.int64_t"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1ac93a0a8e3f1c5274ecee4d59499a6888"></span>void <code class="descname">Free</code><span class="sig-paren">(</span>uint8_t *<em>buffer</em>, int64_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow15ProxyMemoryPool4FreeEP7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an allocated region. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Pointer to the start of the allocated memory region </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Allocated size located at buffer. An allocator implementation may use this for tracking the amount of allocated bytes as well as for faster deallocation if supported by its backend. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow15ProxyMemoryPool15bytes_allocatedEv">
<span id="_CPPv3NK5arrow15ProxyMemoryPool15bytes_allocatedEv"></span><span id="_CPPv2NK5arrow15ProxyMemoryPool15bytes_allocatedEv"></span><span id="arrow::ProxyMemoryPool::bytes_allocatedC"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1ae067aaf2cbe1dd6ea54ec01d835131cc"></span>int64_t <code class="descname">bytes_allocated</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow15ProxyMemoryPool15bytes_allocatedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes that were allocated and not yet free’d through this allocator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow15ProxyMemoryPool10max_memoryEv">
<span id="_CPPv3NK5arrow15ProxyMemoryPool10max_memoryEv"></span><span id="_CPPv2NK5arrow15ProxyMemoryPool10max_memoryEv"></span><span id="arrow::ProxyMemoryPool::max_memoryC"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1a0369b487efeb564ff40ed1101d86e8ad"></span>int64_t <code class="descname">max_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow15ProxyMemoryPool10max_memoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return peak memory allocation in this memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Maximum bytes allocated. If not known (or not implemented), returns -1 </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="allocation-functions">
<h2>Allocation Functions<a class="headerlink" href="#allocation-functions" title="Permalink to this headline">¶</a></h2>
<p>These functions allocate a buffer from a particular memory pool.</p>
<dl class="function">
<dt id="_CPPv4N5arrow14AllocateBufferEP10MemoryPoolK7int64_tPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow14AllocateBufferEP10MemoryPoolK7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow14AllocateBufferEP10MemoryPoolK7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="arrow::AllocateBuffer__MemoryPoolP.int64_tC.std::shared_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1gaff11ee23eb038410107ea5246f2fb330"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateBuffer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, <em class="property">const</em> int64_t <em>size</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow14AllocateBufferEP10MemoryPoolK7int64_tPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a fixed size mutable buffer from a memory pool, zero its padding. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pool</span></code>: a memory pool </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of buffer to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the allocated buffer (contains padding)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow14AllocateBufferEP10MemoryPoolK7int64_tPNSt10unique_ptrI6BufferEE">
<span id="_CPPv3N5arrow14AllocateBufferEP10MemoryPoolK7int64_tPNSt10unique_ptrI6BufferEE"></span><span id="_CPPv2N5arrow14AllocateBufferEP10MemoryPoolK7int64_tPNSt10unique_ptrI6BufferEE"></span><span id="arrow::AllocateBuffer__MemoryPoolP.int64_tC.std::unique_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1gad9698aacbd4ac435cc0cb676e2cb1fe0"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateBuffer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, <em class="property">const</em> int64_t <em>size</em>, std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow14AllocateBufferEP10MemoryPoolK7int64_tPNSt10unique_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a fixed size mutable buffer from a memory pool, zero its padding. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pool</span></code>: a memory pool </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of buffer to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the allocated buffer (contains padding)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow14AllocateBufferEK7int64_tPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow14AllocateBufferEK7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow14AllocateBufferEK7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="arrow::AllocateBuffer__int64_tC.std::shared_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1gae4d3ff86145cc77724a56967ea8a3f5f"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateBuffer</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>size</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow14AllocateBufferEK7int64_tPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a fixed-size mutable buffer from the default memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of buffer to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the allocated buffer (contains padding)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow14AllocateBufferEK7int64_tPNSt10unique_ptrI6BufferEE">
<span id="_CPPv3N5arrow14AllocateBufferEK7int64_tPNSt10unique_ptrI6BufferEE"></span><span id="_CPPv2N5arrow14AllocateBufferEK7int64_tPNSt10unique_ptrI6BufferEE"></span><span id="arrow::AllocateBuffer__int64_tC.std::unique_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga06f0e830cd9d1892b243dda5cc66429a"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateBuffer</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>size</em>, std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow14AllocateBufferEK7int64_tPNSt10unique_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a fixed-size mutable buffer from the default memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of buffer to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the allocated buffer (contains padding)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow23AllocateResizableBufferEP10MemoryPoolK7int64_tPNSt10shared_ptrI15ResizableBufferEE">
<span id="_CPPv3N5arrow23AllocateResizableBufferEP10MemoryPoolK7int64_tPNSt10shared_ptrI15ResizableBufferEE"></span><span id="_CPPv2N5arrow23AllocateResizableBufferEP10MemoryPoolK7int64_tPNSt10shared_ptrI15ResizableBufferEE"></span><span id="arrow::AllocateResizableBuffer__MemoryPoolP.int64_tC.std::shared_ptr:ResizableBuffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga9c3ce000978a518fad942be4a54e9870"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateResizableBuffer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, <em class="property">const</em> int64_t <em>size</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow15ResizableBufferE" title="arrow::ResizableBuffer">ResizableBuffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow23AllocateResizableBufferEP10MemoryPoolK7int64_tPNSt10shared_ptrI15ResizableBufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a resizeable buffer from a memory pool, zero its padding. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pool</span></code>: a memory pool </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of buffer to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the allocated buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow23AllocateResizableBufferEP10MemoryPoolK7int64_tPNSt10unique_ptrI15ResizableBufferEE">
<span id="_CPPv3N5arrow23AllocateResizableBufferEP10MemoryPoolK7int64_tPNSt10unique_ptrI15ResizableBufferEE"></span><span id="_CPPv2N5arrow23AllocateResizableBufferEP10MemoryPoolK7int64_tPNSt10unique_ptrI15ResizableBufferEE"></span><span id="arrow::AllocateResizableBuffer__MemoryPoolP.int64_tC.std::unique_ptr:ResizableBuffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga2fdac7fee8638d46c79b8136aa38c956"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateResizableBuffer</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, <em class="property">const</em> int64_t <em>size</em>, std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow15ResizableBufferE" title="arrow::ResizableBuffer">ResizableBuffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow23AllocateResizableBufferEP10MemoryPoolK7int64_tPNSt10unique_ptrI15ResizableBufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a resizeable buffer from a memory pool, zero its padding. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pool</span></code>: a memory pool </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of buffer to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the allocated buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow23AllocateResizableBufferEK7int64_tPNSt10shared_ptrI15ResizableBufferEE">
<span id="_CPPv3N5arrow23AllocateResizableBufferEK7int64_tPNSt10shared_ptrI15ResizableBufferEE"></span><span id="_CPPv2N5arrow23AllocateResizableBufferEK7int64_tPNSt10shared_ptrI15ResizableBufferEE"></span><span id="arrow::AllocateResizableBuffer__int64_tC.std::shared_ptr:ResizableBuffer:P"></span><span class="target" id="group__buffer-allocation-functions_1gaa80acc74f413afe7f8ed46cde85a5a80"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateResizableBuffer</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>size</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow15ResizableBufferE" title="arrow::ResizableBuffer">ResizableBuffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow23AllocateResizableBufferEK7int64_tPNSt10shared_ptrI15ResizableBufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a resizeable buffer from the default memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of buffer to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the allocated buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow23AllocateResizableBufferEK7int64_tPNSt10unique_ptrI15ResizableBufferEE">
<span id="_CPPv3N5arrow23AllocateResizableBufferEK7int64_tPNSt10unique_ptrI15ResizableBufferEE"></span><span id="_CPPv2N5arrow23AllocateResizableBufferEK7int64_tPNSt10unique_ptrI15ResizableBufferEE"></span><span id="arrow::AllocateResizableBuffer__int64_tC.std::unique_ptr:ResizableBuffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga6eb313aa6e6d83310dcc2a951875b9d2"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateResizableBuffer</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>size</em>, std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow15ResizableBufferE" title="arrow::ResizableBuffer">ResizableBuffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow23AllocateResizableBufferEK7int64_tPNSt10unique_ptrI15ResizableBufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a resizeable buffer from the default memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: size of buffer to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the allocated buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow14AllocateBitmapEP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow14AllocateBitmapEP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow14AllocateBitmapEP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="arrow::AllocateBitmap__MemoryPoolP.int64_t.std::shared_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga93c20471c43a7a35eaabf2506d5b533e"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateBitmap</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, int64_t <em>length</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow14AllocateBitmapEP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a bitmap buffer from a memory pool no guarantee on values is provided. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pool</span></code>: memory pool to allocate memory from </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>: size in bits of bitmap to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the resulting buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow19AllocateEmptyBitmapEP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow19AllocateEmptyBitmapEP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow19AllocateEmptyBitmapEP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="arrow::AllocateEmptyBitmap__MemoryPoolP.int64_t.std::shared_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga79907066edd38d36e95c56673aa46a3b"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateEmptyBitmap</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, int64_t <em>length</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow19AllocateEmptyBitmapEP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a zero-initialized bitmap buffer from a memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pool</span></code>: memory pool to allocate memory from </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>: size in bits of bitmap to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the resulting buffer (zero-initialized).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow19AllocateEmptyBitmapE7int64_tPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow19AllocateEmptyBitmapE7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow19AllocateEmptyBitmapE7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="arrow::AllocateEmptyBitmap__int64_t.std::shared_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga2c62ce65a76507d648998fc260e5ead1"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">AllocateEmptyBitmap</code><span class="sig-paren">(</span>int64_t <em>length</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow19AllocateEmptyBitmapE7int64_tPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a zero-initialized bitmap buffer from the default memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> message </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>: size in bits of bitmap to allocate </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the resulting buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow18ConcatenateBuffersERK12BufferVectorP10MemoryPoolPNSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow18ConcatenateBuffersERK12BufferVectorP10MemoryPoolPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow18ConcatenateBuffersERK12BufferVectorP10MemoryPoolPNSt10shared_ptrI6BufferEE"></span><span id="arrow::ConcatenateBuffers__BufferVectorCR.MemoryPoolP.std::shared_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga193a7618d4456e8d4f40d305c8d683f1"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">ConcatenateBuffers</code><span class="sig-paren">(</span><em class="property">const</em> BufferVector &amp;<em>buffers</em>, <a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow18ConcatenateBuffersERK12BufferVectorP10MemoryPoolPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concatenate multiple buffers into a single buffer. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">buffers</span></code>: to be concatenated </li>
<li><code class="docutils literal notranslate"><span class="pre">pool</span></code>: memory pool to allocate the new buffer from </li>
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the concatenated buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="slicing">
<h2>Slicing<a class="headerlink" href="#slicing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv4N5arrow11SliceBufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t">
<span id="_CPPv3N5arrow11SliceBufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="_CPPv2N5arrow11SliceBufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="arrow::SliceBuffer__std::shared_ptr:Buffer:CR.int64_tC.int64_tC"></span><span class="target" id="group__buffer-slicing-functions_1ga23386d14ecaa97d5c1c93b53676c34e2"></span><em class="property">static</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">SliceBuffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; &amp;<em>buffer</em>, <em class="property">const</em> int64_t <em>offset</em>, <em class="property">const</em> int64_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow11SliceBufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a view on a buffer at the given offset and length. </p>
<p>This function cannot fail and does not check for errors (except in debug builds) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow11SliceBufferERKNSt10shared_ptrI6BufferEEK7int64_t">
<span id="_CPPv3N5arrow11SliceBufferERKNSt10shared_ptrI6BufferEEK7int64_t"></span><span id="_CPPv2N5arrow11SliceBufferERKNSt10shared_ptrI6BufferEEK7int64_t"></span><span id="arrow::SliceBuffer__std::shared_ptr:Buffer:CR.int64_tC"></span><span class="target" id="group__buffer-slicing-functions_1gab051c8518e0c9881042fdf8cf1416cbe"></span><em class="property">static</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">SliceBuffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; &amp;<em>buffer</em>, <em class="property">const</em> int64_t <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow11SliceBufferERKNSt10shared_ptrI6BufferEEK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a view on a buffer at the given offset, up to the buffer’s end. </p>
<p>This function cannot fail and does not check for errors (except in debug builds) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow18SliceMutableBufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t">
<span id="_CPPv3N5arrow18SliceMutableBufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="_CPPv2N5arrow18SliceMutableBufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="arrow::SliceMutableBuffer__std::shared_ptr:Buffer:CR.int64_tC.int64_tC"></span><span class="target" id="group__buffer-slicing-functions_1ga44c8f98a2874248eb7d5658ccee5718e"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="descclassname">arrow<code class="descclassname">::</code></code><code class="descname">SliceMutableBuffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; &amp;<em>buffer</em>, <em class="property">const</em> int64_t <em>offset</em>, <em class="property">const</em> int64_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow18SliceMutableBufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Like SliceBuffer, but construct a mutable buffer slice. </p>
<p>If the parent buffer is not mutable, behavior is undefined (it may abort in debug builds). </p>
</dd></dl>

</div>
<div class="section" id="buffer-builders">
<h2>Buffer Builders<a class="headerlink" href="#buffer-builders" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5arrow13BufferBuilderE">
<span id="_CPPv3N5arrow13BufferBuilderE"></span><span id="_CPPv2N5arrow13BufferBuilderE"></span><span id="arrow::BufferBuilder"></span><span class="target" id="classarrow_1_1_buffer_builder"></span><em class="property">class </em><code class="descname">BufferBuilder</code><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilderE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A class for incrementally building a contiguous chunk of in-memory data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow13BufferBuilder6ResizeEK7int64_tb">
<span id="_CPPv3N5arrow13BufferBuilder6ResizeEK7int64_tb"></span><span id="_CPPv2N5arrow13BufferBuilder6ResizeEK7int64_tb"></span><span id="arrow::BufferBuilder::Resize__int64_tC.b"></span><span class="target" id="classarrow_1_1_buffer_builder_1a865e377404f5e80e3b716e654d0f3ec9"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Resize</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>new_capacity</em>, bool <em>shrink_to_fit</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6ResizeEK7int64_tb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize the buffer to the nearest multiple of 64 bytes. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">new_capacity</span></code>: the new capacity of the of the builder. Will be rounded up to a multiple of 64 bytes for padding</li>
<li><code class="docutils literal notranslate"><span class="pre">shrink_to_fit</span></code>: if new capacity is smaller than the existing size, reallocate internal buffer. Set to false to avoid reallocations when shrinking the builder. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow13BufferBuilder7ReserveEK7int64_tb">
<span id="_CPPv3N5arrow13BufferBuilder7ReserveEK7int64_tb"></span><span id="_CPPv2N5arrow13BufferBuilder7ReserveEK7int64_tb"></span><span id="arrow::BufferBuilder::Reserve__int64_tC.b"></span><span class="target" id="classarrow_1_1_buffer_builder_1a3a1474ceabc356cf1927edc400c6e2fc"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Reserve</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>additional_bytes</em>, bool <em>grow_by_factor</em> = false<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder7ReserveEK7int64_tb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ensure that builder can accommodate the additional number of bytes without the need to perform allocations. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">additional_bytes</span></code>: number of additional bytes to make space for </li>
<li><code class="docutils literal notranslate"><span class="pre">grow_by_factor</span></code>: if true, round up allocations using the strategy in <a class="reference internal" href="#classarrow_1_1_buffer_builder_1a4be4f4efd20c51b1d6cf3f704c01a3c2"><span class="std std-ref">BufferBuilder::GrowByFactor</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow13BufferBuilder6AppendEPKvK7int64_t">
<span id="_CPPv3N5arrow13BufferBuilder6AppendEPKvK7int64_t"></span><span id="_CPPv2N5arrow13BufferBuilder6AppendEPKvK7int64_t"></span><span id="arrow::BufferBuilder::Append__voidCP.int64_tC"></span><span class="target" id="classarrow_1_1_buffer_builder_1a9f2f25ecb063582ceaca0a5b7bd5d128"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Append</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>data</em>, <em class="property">const</em> int64_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6AppendEPKvK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append the given data to the buffer. </p>
<p>The buffer is automatically expanded if necessary. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow13BufferBuilder6AppendEK7int64_t7uint8_t">
<span id="_CPPv3N5arrow13BufferBuilder6AppendEK7int64_t7uint8_t"></span><span id="_CPPv2N5arrow13BufferBuilder6AppendEK7int64_t7uint8_t"></span><span id="arrow::BufferBuilder::Append__int64_tC.uint8_t"></span><span class="target" id="classarrow_1_1_buffer_builder_1a2936c8b4601d3529af547290bc5b808b"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Append</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>num_copies</em>, uint8_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6AppendEK7int64_t7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append copies of a value to the buffer. </p>
<p>The buffer is automatically expanded if necessary. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow13BufferBuilder6AppendERKNSt5arrayI7uint8_t6NBYTESEE">
<span id="_CPPv3N5arrow13BufferBuilder6AppendERKNSt5arrayI7uint8_t6NBYTESEE"></span><span id="_CPPv2N5arrow13BufferBuilder6AppendERKNSt5arrayI7uint8_t6NBYTESEE"></span><span id="arrow::BufferBuilder::Append__std::array:uint8_t.NBYTES:CR"></span><em class="property">template </em>&lt;size_t <em>NBYTES</em>&gt;<br /><span class="target" id="classarrow_1_1_buffer_builder_1a6d1756245bb061a66e69e0e8ffbd4aac"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Append</code><span class="sig-paren">(</span><em class="property">const</em> std::array&lt;uint8_t, NBYTES&gt; &amp;<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6AppendERKNSt5arrayI7uint8_t6NBYTESEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append the given data to the buffer. </p>
<p>The buffer is automatically expanded if necessary. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow13BufferBuilder6FinishEPNSt10shared_ptrI6BufferEEb">
<span id="_CPPv3N5arrow13BufferBuilder6FinishEPNSt10shared_ptrI6BufferEEb"></span><span id="_CPPv2N5arrow13BufferBuilder6FinishEPNSt10shared_ptrI6BufferEEb"></span><span id="arrow::BufferBuilder::Finish__std::shared_ptr:Buffer:P.b"></span><span class="target" id="classarrow_1_1_buffer_builder_1a1d24a7508b789222ab27939a3ac3b481"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Finish</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em>, bool <em>shrink_to_fit</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6FinishEPNSt10shared_ptrI6BufferEEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return result of builder as a <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> object. </p>
<p>The builder is reset and can be reused afterwards.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">out</span></code>: the finalized <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> object </li>
<li><code class="docutils literal notranslate"><span class="pre">shrink_to_fit</span></code>: if the buffer size is smaller than its capacity, reallocate to fit more tightly in memory. Set to false to avoid a reallocation, at the expense of potentially more memory consumption. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow13BufferBuilder12GrowByFactorEK7int64_t">
<span id="_CPPv3N5arrow13BufferBuilder12GrowByFactorEK7int64_t"></span><span id="_CPPv2N5arrow13BufferBuilder12GrowByFactorEK7int64_t"></span><span id="arrow::BufferBuilder::GrowByFactor__int64_tC"></span><span class="target" id="classarrow_1_1_buffer_builder_1a4be4f4efd20c51b1d6cf3f704c01a3c2"></span><em class="property">static</em> int64_t <code class="descname">GrowByFactor</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>min_capacity</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder12GrowByFactorEK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a capacity expanded by a growth factor of 2. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow18TypedBufferBuilderE">
<span id="_CPPv3N5arrow18TypedBufferBuilderE"></span><span id="_CPPv2N5arrow18TypedBufferBuilderE"></span><span id="arrow::TypedBufferBuilder"></span><span class="target" id="classarrow_1_1_typed_buffer_builder"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> Enable = void&gt;<br /><em class="property">class </em><code class="descname">TypedBufferBuilder</code><a class="headerlink" href="#_CPPv4N5arrow18TypedBufferBuilderE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="stl-integration">
<h2>STL Integration<a class="headerlink" href="#stl-integration" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv4N5arrow13stl_allocatorE">
<span id="_CPPv3N5arrow13stl_allocatorE"></span><span id="_CPPv2N5arrow13stl_allocatorE"></span><span id="arrow::stl_allocator"></span><span class="target" id="classarrow_1_1stl__allocator"></span><em class="property">template </em>&lt;class <em>T</em>&gt;<br /><em class="property">class </em><code class="descname">stl_allocator</code><a class="headerlink" href="#_CPPv4N5arrow13stl_allocatorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A STL allocator delegating allocations to a Arrow <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow13stl_allocator13stl_allocatorEv">
<span id="_CPPv3N5arrow13stl_allocator13stl_allocatorEv"></span><span id="_CPPv2N5arrow13stl_allocator13stl_allocatorEv"></span><span id="arrow::stl_allocator::stl_allocator"></span><span class="target" id="classarrow_1_1stl__allocator_1acc68d9df47ec479864980e24e5206c0b"></span><code class="descname">stl_allocator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13stl_allocator13stl_allocatorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an allocator from the default <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow13stl_allocator13stl_allocatorEP10MemoryPool">
<span id="_CPPv3N5arrow13stl_allocator13stl_allocatorEP10MemoryPool"></span><span id="_CPPv2N5arrow13stl_allocator13stl_allocatorEP10MemoryPool"></span><span id="arrow::stl_allocator::stl_allocator__MemoryPoolP"></span><span class="target" id="classarrow_1_1stl__allocator_1affeec274a43deb7cc79152837558eab5"></span><code class="descname">stl_allocator</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13stl_allocator13stl_allocatorEP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an allocator from the given <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a>. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv4N5arrow13STLMemoryPoolE">
<span id="_CPPv3N5arrow13STLMemoryPoolE"></span><span id="_CPPv2N5arrow13STLMemoryPoolE"></span><span id="arrow::STLMemoryPool"></span><span class="target" id="classarrow_1_1_s_t_l_memory_pool"></span><em class="property">template </em>&lt;<em class="property">typename</em> Allocator = std::allocator&lt;uint8_t&gt;&gt;<br /><em class="property">class </em><code class="descname">STLMemoryPool</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a><a class="headerlink" href="#_CPPv4N5arrow13STLMemoryPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> implementation delegating allocations to a STL allocator. </p>
<p>Note that STL allocators don’t provide a resizing operation, and therefore any buffer resizes will do a full reallocation and copy. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv4N5arrow13STLMemoryPool13STLMemoryPoolERK9Allocator">
<span id="_CPPv3N5arrow13STLMemoryPool13STLMemoryPoolERK9Allocator"></span><span id="_CPPv2N5arrow13STLMemoryPool13STLMemoryPoolERK9Allocator"></span><span id="arrow::STLMemoryPool::STLMemoryPool__AllocatorCR"></span><span class="target" id="classarrow_1_1_s_t_l_memory_pool_1ac7aae46fc3464ca5f12e49ac6f6c9fba"></span><code class="descname">STLMemoryPool</code><span class="sig-paren">(</span><em class="property">const</em> Allocator &amp;<em>alloc</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13STLMemoryPool13STLMemoryPoolERK9Allocator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a memory pool from the given allocator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow13STLMemoryPool8AllocateE7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow13STLMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow13STLMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="arrow::STLMemoryPool::Allocate__int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_s_t_l_memory_pool_1afdcccc43ea710e39d76d871be4236660"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Allocate</code><span class="sig-paren">(</span>int64_t <em>size</em>, uint8_t **<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13STLMemoryPool8AllocateE7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new memory region of at least size bytes. </p>
<p>The allocated region shall be 64-byte aligned. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow13STLMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow13STLMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow13STLMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="arrow::STLMemoryPool::Reallocate__int64_t.int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_s_t_l_memory_pool_1a057f25bbb73d00a3c3d9b5336ec3bad3"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="descname">Reallocate</code><span class="sig-paren">(</span>int64_t <em>old_size</em>, int64_t <em>new_size</em>, uint8_t **<em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13STLMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize an already allocated memory section. </p>
<p>As by default most default allocators on a platform don’t support aligned reallocation, this function can involve a copy of the underlying data. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4N5arrow13STLMemoryPool4FreeEP7uint8_t7int64_t">
<span id="_CPPv3N5arrow13STLMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="_CPPv2N5arrow13STLMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="arrow::STLMemoryPool::Free__uint8_tP.int64_t"></span><span class="target" id="classarrow_1_1_s_t_l_memory_pool_1a7a9945fab43ea769503a028dc24da46d"></span>void <code class="descname">Free</code><span class="sig-paren">(</span>uint8_t *<em>buffer</em>, int64_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13STLMemoryPool4FreeEP7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an allocated region. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Pointer to the start of the allocated memory region </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Allocated size located at buffer. An allocator implementation may use this for tracking the amount of allocated bytes as well as for faster deallocation if supported by its backend. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow13STLMemoryPool15bytes_allocatedEv">
<span id="_CPPv3NK5arrow13STLMemoryPool15bytes_allocatedEv"></span><span id="_CPPv2NK5arrow13STLMemoryPool15bytes_allocatedEv"></span><span id="arrow::STLMemoryPool::bytes_allocatedC"></span><span class="target" id="classarrow_1_1_s_t_l_memory_pool_1aeaa8f5af9163d25bf6cf2be82f87b58d"></span>int64_t <code class="descname">bytes_allocated</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow13STLMemoryPool15bytes_allocatedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes that were allocated and not yet free’d through this allocator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv4NK5arrow13STLMemoryPool10max_memoryEv">
<span id="_CPPv3NK5arrow13STLMemoryPool10max_memoryEv"></span><span id="_CPPv2NK5arrow13STLMemoryPool10max_memoryEv"></span><span id="arrow::STLMemoryPool::max_memoryC"></span><span class="target" id="classarrow_1_1_s_t_l_memory_pool_1ab10b66d25f42d62b5f9c471db726a388"></span>int64_t <code class="descname">max_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow13STLMemoryPool10max_memoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return peak memory allocation in this memory pool. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Maximum bytes allocated. If not known (or not implemented), returns -1 </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="datatype.html" class="btn btn-neutral float-right" title="Data Types" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="support.html" class="btn btn-neutral float-left" title="Programming Support" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2018 Apache Software Foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-107500873-1');
</script>


</body>
</html>