


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Arrays &mdash; Apache Arrow v3.0.0</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="canonical" href="https://arrow.apache.org/docs/cpp/api/array.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Scalars" href="scalar.html" />
    <link rel="prev" title="Data Types" href="datatype.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Apache Arrow
          

          
          </a>

          
            
            
              <div class="version">
                3.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Specifications and Protocols</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../format/Versioning.html">Format Versioning and Stability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Columnar.html">Arrow Columnar Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Flight.html">Arrow Flight RPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Integration.html">Integration Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/CDataInterface.html">The Arrow C data interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/CStreamInterface.html">The Arrow C stream interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Other.html">Other Data Structures</a></li>
</ul>
<p class="caption"><span class="caption-text">Libraries</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../status.html">Implementation Status</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/c_glib/">C/GLib</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">C++</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../getting_started.html">User Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/index.html">Examples</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../api.html">API Reference</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="support.html">Programming Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="memory.html">Memory (management)</a></li>
<li class="toctree-l3"><a class="reference internal" href="datatype.html">Data Types</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Arrays</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concrete-array-subclasses">Concrete array subclasses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chunked-arrays">Chunked Arrays</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="scalar.html">Scalars</a></li>
<li class="toctree-l3"><a class="reference internal" href="builder.html">Array Builders</a></li>
<li class="toctree-l3"><a class="reference internal" href="table.html">Two-dimensional Datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="c_abi.html">C Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="compute.html">Compute Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="tensor.html">Tensors</a></li>
<li class="toctree-l3"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="io.html">Input / output</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">Arrow IPC</a></li>
<li class="toctree-l3"><a class="reference internal" href="formats.html">File Formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="cuda.html">CUDA support</a></li>
<li class="toctree-l3"><a class="reference internal" href="flight.html">Arrow Flight RPC</a></li>
<li class="toctree-l3"><a class="reference internal" href="filesystem.html">Filesystems</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apache/arrow/blob/master/csharp/README.md">C#</a></li>
<li class="toctree-l1"><a class="reference external" href="https://godoc.org/github.com/apache/arrow/go/arrow">Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../java/index.html">Java</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/js/">JavaScript</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apache/arrow/blob/master/julia/Arrow/README.md">Julia</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apache/arrow/blob/master/matlab/README.md">MATLAB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python/index.html">Python</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/r/">R</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apache/arrow/blob/master/ruby/README.md">Ruby</a></li>
<li class="toctree-l1"><a class="reference external" href="https://docs.rs/crate/arrow/">Rust</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developers/contributing.html">Contributing to Apache Arrow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/cpp/index.html">C++ Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/python.html">Python Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/archery.html">Daily Development using Archery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/crossbow.html">Packaging and Testing with Crossbow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/docker.html">Running Docker Builds</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/documentation.html">Building the Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Apache Arrow</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">C++ Implementation</a> &raquo;</li>
        
          <li><a href="../api.html">API Reference</a> &raquo;</li>
        
      <li>Arrays</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/cpp/api/array.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="arrays">
<h1>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h1>
<div class="sidebar">
<p class="sidebar-title">Contents</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#concrete-array-subclasses" id="id1">Concrete array subclasses</a></p>
<ul>
<li><p><a class="reference internal" href="#non-nested" id="id2">Non-nested</a></p></li>
<li><p><a class="reference internal" href="#nested" id="id3">Nested</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#chunked-arrays" id="id4">Chunked Arrays</a></p></li>
</ul>
</div>
</div>
<dl class="cpp class">
<dt id="_CPPv4N5arrow5ArrayE">
<span id="_CPPv3N5arrow5ArrayE"></span><span id="_CPPv2N5arrow5ArrayE"></span><span id="arrow::Array"></span><span class="target" id="classarrow_1_1_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Array</code><a class="headerlink" href="#_CPPv4N5arrow5ArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> base type Immutable data array with some logical type and some length. </p>
<p>Any memory is owned by the respective <a class="reference internal" href="memory.html#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> instance (or its parents).</p>
<p>The base class is only required to have a null bitmap buffer if the null count is greater than 0</p>
<p>If known, the null count can be provided in the base <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> constructor. If the null count is not known, pass -1 to indicate that the null count is to be computed on the first call to <a class="reference internal" href="#classarrow_1_1_array_1a0537d3b69a889b951e88be2fe9f3d96a"><span class="std std-ref">null_count()</span></a> </p>
<p>Subclassed by arrow::BaseListArray&lt; TYPE &gt;, <a class="reference internal" href="#classarrow_1_1_dictionary_array"><span class="std std-ref">arrow::DictionaryArray</span></a>, arrow::ExtensionArray, arrow::FixedSizeListArray, <a class="reference internal" href="#classarrow_1_1_flat_array"><span class="std std-ref">arrow::FlatArray</span></a>, <a class="reference internal" href="#classarrow_1_1_struct_array"><span class="std std-ref">arrow::StructArray</span></a>, <a class="reference internal" href="#classarrow_1_1_union_array"><span class="std std-ref">arrow::UnionArray</span></a>, arrow::BaseListArray&lt; LargeListType &gt;, arrow::BaseListArray&lt; ListType &gt;</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array6IsNullE7int64_t">
<span id="_CPPv3NK5arrow5Array6IsNullE7int64_t"></span><span id="_CPPv2NK5arrow5Array6IsNullE7int64_t"></span><span id="arrow::Array::IsNull__int64_tC"></span><span class="target" id="classarrow_1_1_array_1a18c61cd4c8c158a30f30023eabc83acb"></span>bool <code class="sig-name descname">IsNull</code><span class="sig-paren">(</span>int64_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array6IsNullE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true if value at index is null. Does not boundscheck. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array7IsValidE7int64_t">
<span id="_CPPv3NK5arrow5Array7IsValidE7int64_t"></span><span id="_CPPv2NK5arrow5Array7IsValidE7int64_t"></span><span id="arrow::Array::IsValid__int64_tC"></span><span class="target" id="classarrow_1_1_array_1ae554bfb313cd6b161f63fb2966dbd662"></span>bool <code class="sig-name descname">IsValid</code><span class="sig-paren">(</span>int64_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array7IsValidE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true if value at index is valid (not null). </p>
<p>Does not boundscheck </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array9GetScalarE7int64_t">
<span id="_CPPv3NK5arrow5Array9GetScalarE7int64_t"></span><span id="_CPPv2NK5arrow5Array9GetScalarE7int64_t"></span><span id="arrow::Array::GetScalar__int64_tC"></span><span class="target" id="classarrow_1_1_array_1a65165e18f7a73cebdf73659427a00db1"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="scalar.html#_CPPv4N5arrow6ScalarE" title="arrow::Scalar">Scalar</a>&gt;&gt; <code class="sig-name descname">GetScalar</code><span class="sig-paren">(</span>int64_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array9GetScalarE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="scalar.html#structarrow_1_1_scalar"><span class="std std-ref">Scalar</span></a> containing the value of this array at i. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array6lengthEv">
<span id="_CPPv3NK5arrow5Array6lengthEv"></span><span id="_CPPv2NK5arrow5Array6lengthEv"></span><span id="arrow::Array::lengthC"></span><span class="target" id="classarrow_1_1_array_1a49c7fb3f73d2d43e7338591c5a8bd8bf"></span>int64_t <code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array6lengthEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Size in the number of elements this array contains. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array6offsetEv">
<span id="_CPPv3NK5arrow5Array6offsetEv"></span><span id="_CPPv2NK5arrow5Array6offsetEv"></span><span id="arrow::Array::offsetC"></span><span class="target" id="classarrow_1_1_array_1a1a0c6c1aa06cffd1dcb3813f0d24b2fd"></span>int64_t <code class="sig-name descname">offset</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array6offsetEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A relative position into another array’s data, to enable zero-copy slicing. </p>
<p>This value defaults to zero </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array10null_countEv">
<span id="_CPPv3NK5arrow5Array10null_countEv"></span><span id="_CPPv2NK5arrow5Array10null_countEv"></span><span id="arrow::Array::null_countC"></span><span class="target" id="classarrow_1_1_array_1a0537d3b69a889b951e88be2fe9f3d96a"></span>int64_t <code class="sig-name descname">null_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array10null_countEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of null entries in the array. </p>
<p>If the null count was not known at time of construction (and set to a negative value), then the null count will be computed and cached on the first invocation of this function </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array11null_bitmapEv">
<span id="_CPPv3NK5arrow5Array11null_bitmapEv"></span><span id="_CPPv2NK5arrow5Array11null_bitmapEv"></span><span id="arrow::Array::null_bitmapC"></span><span class="target" id="classarrow_1_1_array_1a76c4756ac85b29f9135064d68d2ef908"></span>std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">null_bitmap</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array11null_bitmapEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="memory.html#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> for the validity (null) bitmap, if any. </p>
<p>Note that Union types never have a null bitmap.</p>
<p>Note that for <code class="docutils literal notranslate"><span class="pre">null_count</span> <span class="pre">==</span> <span class="pre">0</span></code> or for null type, this will be null. This buffer does not account for any slice offset </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array16null_bitmap_dataEv">
<span id="_CPPv3NK5arrow5Array16null_bitmap_dataEv"></span><span id="_CPPv2NK5arrow5Array16null_bitmap_dataEv"></span><span id="arrow::Array::null_bitmap_dataC"></span><span class="target" id="classarrow_1_1_array_1a7a8838fbc97b9b3b8ca15cb163b2027c"></span><em class="property">const</em> uint8_t *<code class="sig-name descname">null_bitmap_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array16null_bitmap_dataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Raw pointer to the null bitmap. </p>
<p>Note that for <code class="docutils literal notranslate"><span class="pre">null_count</span> <span class="pre">==</span> <span class="pre">0</span></code> or for null type, this will be null. This buffer does not account for any slice offset </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array6EqualsERK5ArrayRK12EqualOptions">
<span id="_CPPv3NK5arrow5Array6EqualsERK5ArrayRK12EqualOptions"></span><span id="_CPPv2NK5arrow5Array6EqualsERK5ArrayRK12EqualOptions"></span><span id="arrow::Array::Equals__ArrayCR.EqualOptionsCRC"></span><span class="target" id="classarrow_1_1_array_1a686cf58bab513d8ecfe3a285f4562eab"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>arr</em>, <em class="property">const</em> EqualOptions&amp; = EqualOptions::Defaults()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array6EqualsERK5ArrayRK12EqualOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Equality comparison with another array. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array4DiffERK5Array">
<span id="_CPPv3NK5arrow5Array4DiffERK5Array"></span><span id="_CPPv2NK5arrow5Array4DiffERK5Array"></span><span id="arrow::Array::Diff__ArrayCRC"></span><span class="target" id="classarrow_1_1_array_1a95ff1c7489e9d2fd5ff52fde1b8b5c46"></span>std::string <code class="sig-name descname">Diff</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array4DiffERK5Array" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the formatted unified diff of arrow::Diff between this <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> and another <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array12ApproxEqualsERKNSt10shared_ptrI5ArrayEERK12EqualOptions">
<span id="_CPPv3NK5arrow5Array12ApproxEqualsERKNSt10shared_ptrI5ArrayEERK12EqualOptions"></span><span id="_CPPv2NK5arrow5Array12ApproxEqualsERKNSt10shared_ptrI5ArrayEERK12EqualOptions"></span><span id="arrow::Array::ApproxEquals__std::shared_ptr:Array:CR.EqualOptionsCRC"></span><span class="target" id="classarrow_1_1_array_1a381e6469686eccd2545cf1dc171f6cb7"></span>bool <code class="sig-name descname">ApproxEquals</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; &amp;<em>arr</em>, <em class="property">const</em> EqualOptions&amp; = EqualOptions::Defaults()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array12ApproxEqualsERKNSt10shared_ptrI5ArrayEERK12EqualOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Approximate equality comparison with another array. </p>
<p>epsilon is only used if this is FloatArray or DoubleArray </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array11RangeEqualsE7int64_t7int64_t7int64_tRK5ArrayRK12EqualOptions">
<span id="_CPPv3NK5arrow5Array11RangeEqualsE7int64_t7int64_t7int64_tRK5ArrayRK12EqualOptions"></span><span id="_CPPv2NK5arrow5Array11RangeEqualsE7int64_t7int64_t7int64_tRK5ArrayRK12EqualOptions"></span><span id="arrow::Array::RangeEquals__int64_t.int64_t.int64_t.ArrayCR.EqualOptionsCRC"></span><span class="target" id="classarrow_1_1_array_1a4593999b3aec404e9ad3259acff63fa2"></span>bool <code class="sig-name descname">RangeEquals</code><span class="sig-paren">(</span>int64_t <em>start_idx</em>, int64_t <em>end_idx</em>, int64_t <em>other_start_idx</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>other</em>, <em class="property">const</em> EqualOptions&amp; = EqualOptions::Defaults()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array11RangeEqualsE7int64_t7int64_t7int64_tRK5ArrayRK12EqualOptions" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Compare if the range of slots specified are equal for the given array and this array. </p>
<p>end_idx exclusive. This methods does not bounds check. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array4ViewERKNSt10shared_ptrI8DataTypeEE">
<span id="_CPPv3NK5arrow5Array4ViewERKNSt10shared_ptrI8DataTypeEE"></span><span id="_CPPv2NK5arrow5Array4ViewERKNSt10shared_ptrI8DataTypeEE"></span><span id="arrow::Array::View__std::shared_ptr:DataType:CRC"></span><span class="target" id="classarrow_1_1_array_1aa2b5f248c09a41c089e1fbc911beecb0"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; <code class="sig-name descname">View</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; &amp;<em>type</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array4ViewERKNSt10shared_ptrI8DataTypeEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a zero-copy view of this array with the given type. </p>
<p>This method checks if the types are layout-compatible. Nested types are traversed in depth-first order. Data buffers must have the same item sizes, even though the logical types may be different. An error is returned if the types are not layout-compatible. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array5SliceE7int64_t7int64_t">
<span id="_CPPv3NK5arrow5Array5SliceE7int64_t7int64_t"></span><span id="_CPPv2NK5arrow5Array5SliceE7int64_t7int64_t"></span><span id="arrow::Array::Slice__int64_t.int64_tC"></span><span class="target" id="classarrow_1_1_array_1ae32f72c78fe10ce17f0a817e302e17d1"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">Slice</code><span class="sig-paren">(</span>int64_t <em>offset</em>, int64_t <em>length</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array5SliceE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a zero-copy slice of the array with the indicated offset and length. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new object wrapped in std::shared_ptr&lt;Array&gt; </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">offset</span></code>: the position of the first element in the constructed slice </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">length</span></code>: the length of the slice. If there are not enough elements in the array, the length will be adjusted accordingly</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array5SliceE7int64_t">
<span id="_CPPv3NK5arrow5Array5SliceE7int64_t"></span><span id="_CPPv2NK5arrow5Array5SliceE7int64_t"></span><span id="arrow::Array::Slice__int64_tC"></span><span class="target" id="classarrow_1_1_array_1a5cf4c3330e850670aa52dab3b21869ea"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">Slice</code><span class="sig-paren">(</span>int64_t <em>offset</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array5SliceE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Slice from offset until end of the array. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array9SliceSafeE7int64_t7int64_t">
<span id="_CPPv3NK5arrow5Array9SliceSafeE7int64_t7int64_t"></span><span id="_CPPv2NK5arrow5Array9SliceSafeE7int64_t7int64_t"></span><span id="arrow::Array::SliceSafe__int64_t.int64_tC"></span><span class="target" id="classarrow_1_1_array_1acfd39e942b28a6deaa737995cd029409"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; <code class="sig-name descname">SliceSafe</code><span class="sig-paren">(</span>int64_t <em>offset</em>, int64_t <em>length</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array9SliceSafeE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Input-checking variant of <a class="reference internal" href="#classarrow_1_1_array_1ae32f72c78fe10ce17f0a817e302e17d1"><span class="std std-ref">Array::Slice</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array9SliceSafeE7int64_t">
<span id="_CPPv3NK5arrow5Array9SliceSafeE7int64_t"></span><span id="_CPPv2NK5arrow5Array9SliceSafeE7int64_t"></span><span id="arrow::Array::SliceSafe__int64_tC"></span><span class="target" id="classarrow_1_1_array_1ab0280861f5d2a09c9e1d1976f056a88f"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; <code class="sig-name descname">SliceSafe</code><span class="sig-paren">(</span>int64_t <em>offset</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array9SliceSafeE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Input-checking variant of <a class="reference internal" href="#classarrow_1_1_array_1ae32f72c78fe10ce17f0a817e302e17d1"><span class="std std-ref">Array::Slice</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array8ToStringEv">
<span id="_CPPv3NK5arrow5Array8ToStringEv"></span><span id="_CPPv2NK5arrow5Array8ToStringEv"></span><span id="arrow::Array::ToStringC"></span><span class="target" id="classarrow_1_1_array_1a41c7af0e40ac55f2ce11785fea3e051e"></span>std::string <code class="sig-name descname">ToString</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array8ToStringEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>PrettyPrint representation of array suitable for debugging </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array8ValidateEv">
<span id="_CPPv3NK5arrow5Array8ValidateEv"></span><span id="_CPPv2NK5arrow5Array8ValidateEv"></span><span id="arrow::Array::ValidateC"></span><span class="target" id="classarrow_1_1_array_1ad62bad8fde2bb8fbd5a52df3fa4bd56c"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array8ValidateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform cheap validation checks to determine obvious inconsistencies within the array’s internal data. </p>
<p>This is O(k) where k is the number of descendents.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow5Array12ValidateFullEv">
<span id="_CPPv3NK5arrow5Array12ValidateFullEv"></span><span id="_CPPv2NK5arrow5Array12ValidateFullEv"></span><span id="arrow::Array::ValidateFullC"></span><span class="target" id="classarrow_1_1_array_1a793321da66d2d1839e6c89a956e4cb07"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">ValidateFull</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow5Array12ValidateFullEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform extensive validation checks to determine inconsistencies within the array’s internal data. </p>
<p>This is potentially O(k*n) where k is the number of descendents and n is the array length.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<div class="section" id="concrete-array-subclasses">
<h2><a class="toc-backref" href="#id1">Concrete array subclasses</a><a class="headerlink" href="#concrete-array-subclasses" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv4N5arrow15DictionaryArrayE">
<span id="_CPPv3N5arrow15DictionaryArrayE"></span><span id="_CPPv2N5arrow15DictionaryArrayE"></span><span id="arrow::DictionaryArray"></span><span class="target" id="classarrow_1_1_dictionary_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">DictionaryArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a><a class="headerlink" href="#_CPPv4N5arrow15DictionaryArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> type for dictionary-encoded data with a data-dependent dictionary. </p>
<p>A dictionary array contains an array of non-negative integers (the “dictionary indices”) along with a data type containing a “dictionary” corresponding to the distinct values represented in the data.</p>
<p>For example, the array</p>
<p>[“foo”, “bar”, “foo”, “bar”, “foo”, “bar”]</p>
<p>with dictionary [“bar”, “foo”], would have dictionary array representation</p>
<p>indices: [1, 0, 1, 0, 1, 0] dictionary: [“bar”, “foo”]</p>
<p>The indices in principle may be any integer type. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow15DictionaryArray9TransposeERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEEPK7int32_tP10MemoryPool">
<span id="_CPPv3NK5arrow15DictionaryArray9TransposeERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEEPK7int32_tP10MemoryPool"></span><span id="_CPPv2NK5arrow15DictionaryArray9TransposeERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEEPK7int32_tP10MemoryPool"></span><span id="arrow::DictionaryArray::Transpose__std::shared_ptr:DataType:CR.std::shared_ptr:Array:CR.int32_tCP.MemoryPoolPC"></span><span class="target" id="classarrow_1_1_dictionary_array_1a6f491c929655df6641a03a12c67a6b8d"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; <code class="sig-name descname">Transpose</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; &amp;<em>type</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; &amp;<em>dictionary</em>, <em class="property">const</em> int32_t *<em>transpose_map</em>, <a class="reference internal" href="memory.html#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em> = <a class="reference internal" href="memory.html#_CPPv4N5arrow19default_memory_poolEv" title="arrow::default_memory_pool">default_memory_pool</a>()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow15DictionaryArray9TransposeERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEEPK7int32_tP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Transpose this <a class="reference internal" href="#classarrow_1_1_dictionary_array"><span class="std std-ref">DictionaryArray</span></a>. </p>
<p>This method constructs a new dictionary array with the given dictionary type, transposing indices using the transpose map. The type and the transpose map are typically computed using DictionaryUnifier.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type</span></code>: the new type object </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">dictionary</span></code>: the new dictionary </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">transpose_map</span></code>: transposition array of this array’s indices into the target array’s indices </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: a pool to allocate the array data from </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow15DictionaryArray17CanCompareIndicesERK15DictionaryArray">
<span id="_CPPv3NK5arrow15DictionaryArray17CanCompareIndicesERK15DictionaryArray"></span><span id="_CPPv2NK5arrow15DictionaryArray17CanCompareIndicesERK15DictionaryArray"></span><span id="arrow::DictionaryArray::CanCompareIndices__DictionaryArrayCRC"></span><span class="target" id="classarrow_1_1_dictionary_array_1a174e8f2555d0833a45e5ad6c49f7ebab"></span>bool <code class="sig-name descname">CanCompareIndices</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow15DictionaryArrayE" title="arrow::DictionaryArray">DictionaryArray</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow15DictionaryArray17CanCompareIndicesERK15DictionaryArray" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine whether dictionary arrays may be compared without unification. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow15DictionaryArray10dictionaryEv">
<span id="_CPPv3NK5arrow15DictionaryArray10dictionaryEv"></span><span id="_CPPv2NK5arrow15DictionaryArray10dictionaryEv"></span><span id="arrow::DictionaryArray::dictionaryC"></span><span class="target" id="classarrow_1_1_dictionary_array_1ab77f454477e3695592274f6266647175"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">dictionary</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow15DictionaryArray10dictionaryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the dictionary for this array, which is stored as a member of the ArrayData internal structure. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow15DictionaryArray13GetValueIndexE7int64_t">
<span id="_CPPv3NK5arrow15DictionaryArray13GetValueIndexE7int64_t"></span><span id="_CPPv2NK5arrow15DictionaryArray13GetValueIndexE7int64_t"></span><span id="arrow::DictionaryArray::GetValueIndex__int64_tC"></span><span class="target" id="classarrow_1_1_dictionary_array_1afd412221a4087eb6fdb5a369d3763bbe"></span>int64_t <code class="sig-name descname">GetValueIndex</code><span class="sig-paren">(</span>int64_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow15DictionaryArray13GetValueIndexE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the ith value of indices, cast to int64_t. </p>
<p>Not recommended for use in performance-sensitive code. Does not validate whether the value is null or out-of-bounds. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow15DictionaryArray10FromArraysERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEERKNSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow15DictionaryArray10FromArraysERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEERKNSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow15DictionaryArray10FromArraysERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEERKNSt10shared_ptrI5ArrayEE"></span><span id="arrow::DictionaryArray::FromArrays__std::shared_ptr:DataType:CR.std::shared_ptr:Array:CR.std::shared_ptr:Array:CR"></span><span class="target" id="classarrow_1_1_dictionary_array_1ab272b5854125c3d1f62e1d865eff06d7"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; <code class="sig-name descname">FromArrays</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; &amp;<em>type</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; &amp;<em>indices</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; &amp;<em>dictionary</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow15DictionaryArray10FromArraysERKNSt10shared_ptrI8DataTypeEERKNSt10shared_ptrI5ArrayEERKNSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct <a class="reference internal" href="#classarrow_1_1_dictionary_array"><span class="std std-ref">DictionaryArray</span></a> from dictionary and indices array and validate. </p>
<p>This function does the validation of the indices and input type. It checks if all indices are non-negative and smaller than the size of the dictionary.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">type</span></code>: a dictionary type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">dictionary</span></code>: the dictionary with same value type as the type object </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">indices</span></code>: an array of non-negative integers smaller than the size of the dictionary </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<div class="section" id="non-nested">
<h3><a class="toc-backref" href="#id2">Non-nested</a><a class="headerlink" href="#non-nested" title="Permalink to this headline">¶</a></h3>
<dl class="cpp class">
<dt id="_CPPv4N5arrow9FlatArrayE">
<span id="_CPPv3N5arrow9FlatArrayE"></span><span id="_CPPv2N5arrow9FlatArrayE"></span><span id="arrow::FlatArray"></span><span class="target" id="classarrow_1_1_flat_array"></span><em class="property">class </em><code class="sig-name descname">FlatArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a><a class="headerlink" href="#_CPPv4N5arrow9FlatArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for non-nested arrays. </p>
<p>Subclassed by arrow::BaseBinaryArray&lt; TYPE &gt;, <a class="reference internal" href="#classarrow_1_1_null_array"><span class="std std-ref">arrow::NullArray</span></a>, <a class="reference internal" href="#classarrow_1_1_primitive_array"><span class="std std-ref">arrow::PrimitiveArray</span></a>, arrow::BaseBinaryArray&lt; BinaryType &gt;, arrow::BaseBinaryArray&lt; LargeBinaryType &gt;</p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow9NullArrayE">
<span id="_CPPv3N5arrow9NullArrayE"></span><span id="_CPPv2N5arrow9NullArrayE"></span><span id="arrow::NullArray"></span><span class="target" id="classarrow_1_1_null_array"></span><em class="property">class </em><code class="sig-name descname">NullArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow9FlatArrayE" title="arrow::FlatArray">FlatArray</a><a class="headerlink" href="#_CPPv4N5arrow9NullArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Degenerate null type <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a>. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow11BinaryArrayE">
<span id="_CPPv3N5arrow11BinaryArrayE"></span><span id="_CPPv2N5arrow11BinaryArrayE"></span><span id="arrow::BinaryArray"></span><span class="target" id="classarrow_1_1_binary_array"></span><em class="property">class </em><code class="sig-name descname">BinaryArray</code> : <em class="property">public</em> arrow::BaseBinaryArray&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow10BinaryTypeE" title="arrow::BinaryType">BinaryType</a>&gt;<a class="headerlink" href="#_CPPv4N5arrow11BinaryArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for variable-size binary data. </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_string_array"><span class="std std-ref">arrow::StringArray</span></a></p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow11StringArrayE">
<span id="_CPPv3N5arrow11StringArrayE"></span><span id="_CPPv2N5arrow11StringArrayE"></span><span id="arrow::StringArray"></span><span class="target" id="classarrow_1_1_string_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">StringArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow11BinaryArrayE" title="arrow::BinaryArray">BinaryArray</a><a class="headerlink" href="#_CPPv4N5arrow11StringArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for variable-size string (utf-8) data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow11StringArray12ValidateUTF8Ev">
<span id="_CPPv3NK5arrow11StringArray12ValidateUTF8Ev"></span><span id="_CPPv2NK5arrow11StringArray12ValidateUTF8Ev"></span><span id="arrow::StringArray::ValidateUTF8C"></span><span class="target" id="classarrow_1_1_string_array_1a1e5562e4d73cd2a0ac468c562109c326"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">ValidateUTF8</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow11StringArray12ValidateUTF8Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Validate that this array contains only valid UTF8 entries. </p>
<p>This check is also implied by <a class="reference internal" href="#classarrow_1_1_array_1a793321da66d2d1839e6c89a956e4cb07"><span class="std std-ref">ValidateFull()</span></a> </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow14PrimitiveArrayE">
<span id="_CPPv3N5arrow14PrimitiveArrayE"></span><span id="_CPPv2N5arrow14PrimitiveArrayE"></span><span id="arrow::PrimitiveArray"></span><span class="target" id="classarrow_1_1_primitive_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">PrimitiveArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow9FlatArrayE" title="arrow::FlatArray">FlatArray</a><a class="headerlink" href="#_CPPv4N5arrow14PrimitiveArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for arrays of fixed-size logical types. </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_boolean_array"><span class="std std-ref">arrow::BooleanArray</span></a>, arrow::DayTimeIntervalArray, <a class="reference internal" href="#classarrow_1_1_fixed_size_binary_array"><span class="std std-ref">arrow::FixedSizeBinaryArray</span></a>, <a class="reference internal" href="#classarrow_1_1_numeric_array"><span class="std std-ref">arrow::NumericArray&lt; TYPE &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow14PrimitiveArray6valuesEv">
<span id="_CPPv3NK5arrow14PrimitiveArray6valuesEv"></span><span id="_CPPv2NK5arrow14PrimitiveArray6valuesEv"></span><span id="arrow::PrimitiveArray::valuesC"></span><span class="target" id="classarrow_1_1_primitive_array_1a0c05d9ba21020050abe94e1446a3cee1"></span>std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow14PrimitiveArray6valuesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Does not account for any slice offset. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow12BooleanArrayE">
<span id="_CPPv3N5arrow12BooleanArrayE"></span><span id="_CPPv2N5arrow12BooleanArrayE"></span><span id="arrow::BooleanArray"></span><span class="target" id="classarrow_1_1_boolean_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">BooleanArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow14PrimitiveArrayE" title="arrow::PrimitiveArray">PrimitiveArray</a><a class="headerlink" href="#_CPPv4N5arrow12BooleanArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for boolean data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow12BooleanArray11false_countEv">
<span id="_CPPv3NK5arrow12BooleanArray11false_countEv"></span><span id="_CPPv2NK5arrow12BooleanArray11false_countEv"></span><span id="arrow::BooleanArray::false_countC"></span><span class="target" id="classarrow_1_1_boolean_array_1a681486a5b6e0842b907fbd84cb4cc59a"></span>int64_t <code class="sig-name descname">false_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12BooleanArray11false_countEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of false (0) values among the valid values. </p>
<p><a class="reference internal" href="support.html#classarrow_1_1_result"><span class="std std-ref">Result</span></a> is not cached. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12BooleanArray10true_countEv">
<span id="_CPPv3NK5arrow12BooleanArray10true_countEv"></span><span id="_CPPv2NK5arrow12BooleanArray10true_countEv"></span><span id="arrow::BooleanArray::true_countC"></span><span class="target" id="classarrow_1_1_boolean_array_1afc9c2a1af99b595a3639921d0e7270fd"></span>int64_t <code class="sig-name descname">true_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12BooleanArray10true_countEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of true (1) values among the valid values. </p>
<p><a class="reference internal" href="support.html#classarrow_1_1_result"><span class="std std-ref">Result</span></a> is not cached. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow20FixedSizeBinaryArrayE">
<span id="_CPPv3N5arrow20FixedSizeBinaryArrayE"></span><span id="_CPPv2N5arrow20FixedSizeBinaryArrayE"></span><span id="arrow::FixedSizeBinaryArray"></span><span class="target" id="classarrow_1_1_fixed_size_binary_array"></span><em class="property">class </em><code class="sig-name descname">FixedSizeBinaryArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow14PrimitiveArrayE" title="arrow::PrimitiveArray">PrimitiveArray</a><a class="headerlink" href="#_CPPv4N5arrow20FixedSizeBinaryArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for fixed-size binary data. </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_decimal128_array"><span class="std std-ref">arrow::Decimal128Array</span></a>, arrow::Decimal256Array</p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow15Decimal128ArrayE">
<span id="_CPPv3N5arrow15Decimal128ArrayE"></span><span id="_CPPv2N5arrow15Decimal128ArrayE"></span><span id="arrow::Decimal128Array"></span><span class="target" id="classarrow_1_1_decimal128_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Decimal128Array</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow20FixedSizeBinaryArrayE" title="arrow::FixedSizeBinaryArray">FixedSizeBinaryArray</a><a class="headerlink" href="#_CPPv4N5arrow15Decimal128ArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for 128-bit decimal data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow15Decimal128Array15Decimal128ArrayERKNSt10shared_ptrI9ArrayDataEE">
<span id="_CPPv3N5arrow15Decimal128Array15Decimal128ArrayERKNSt10shared_ptrI9ArrayDataEE"></span><span id="_CPPv2N5arrow15Decimal128Array15Decimal128ArrayERKNSt10shared_ptrI9ArrayDataEE"></span><span id="arrow::Decimal128Array::Decimal128Array__std::shared_ptr:ArrayData:CR"></span><span class="target" id="classarrow_1_1_decimal128_array_1a1520cf3809bc92851ad099403164538a"></span><code class="sig-name descname">Decimal128Array</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;ArrayData&gt; &amp;<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow15Decimal128Array15Decimal128ArrayERKNSt10shared_ptrI9ArrayDataEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct <a class="reference internal" href="#classarrow_1_1_decimal128_array"><span class="std std-ref">Decimal128Array</span></a> from ArrayData instance. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4I0EN5arrow12NumericArrayE">
<span id="_CPPv3I0EN5arrow12NumericArrayE"></span><span id="_CPPv2I0EN5arrow12NumericArrayE"></span>template&lt;typename <code class="sig-name descname">TYPE</code>&gt;<br /><span class="target" id="classarrow_1_1_numeric_array"></span><em class="property">class </em><code class="sig-name descname">NumericArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow14PrimitiveArrayE" title="arrow::PrimitiveArray">PrimitiveArray</a><a class="headerlink" href="#_CPPv4I0EN5arrow12NumericArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for numeric data. </p>
</dd></dl>

</div>
<div class="section" id="nested">
<h3><a class="toc-backref" href="#id3">Nested</a><a class="headerlink" href="#nested" title="Permalink to this headline">¶</a></h3>
<dl class="cpp class">
<dt id="_CPPv4N5arrow10UnionArrayE">
<span id="_CPPv3N5arrow10UnionArrayE"></span><span id="_CPPv2N5arrow10UnionArrayE"></span><span id="arrow::UnionArray"></span><span class="target" id="classarrow_1_1_union_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">UnionArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a><a class="headerlink" href="#_CPPv4N5arrow10UnionArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for SparseUnionArray and DenseUnionArray. </p>
<p>Subclassed by arrow::DenseUnionArray, arrow::SparseUnionArray</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow10UnionArray10type_codesEv">
<span id="_CPPv3NK5arrow10UnionArray10type_codesEv"></span><span id="_CPPv2NK5arrow10UnionArray10type_codesEv"></span><span id="arrow::UnionArray::type_codesC"></span><span class="target" id="classarrow_1_1_union_array_1a37dee73e4d44c4a946c412b94165f0d0"></span>std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">type_codes</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow10UnionArray10type_codesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Note that this buffer does not account for any slice offset. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow10UnionArray8child_idE7int64_t">
<span id="_CPPv3NK5arrow10UnionArray8child_idE7int64_t"></span><span id="_CPPv2NK5arrow10UnionArray8child_idE7int64_t"></span><span id="arrow::UnionArray::child_id__int64_tC"></span><span class="target" id="classarrow_1_1_union_array_1abc77f1ae9bfe6f11013adfd48b3f4dc2"></span>int <code class="sig-name descname">child_id</code><span class="sig-paren">(</span>int64_t <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow10UnionArray8child_idE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The physical child id containing value at index. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow10UnionArray5fieldEi">
<span id="_CPPv3NK5arrow10UnionArray5fieldEi"></span><span id="_CPPv2NK5arrow10UnionArray5fieldEi"></span><span id="arrow::UnionArray::field__iC"></span><span class="target" id="classarrow_1_1_union_array_1ac1fc5c7ea1e52b0d07a90533fec81ac6"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">field</code><span class="sig-paren">(</span>int <em>pos</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow10UnionArray5fieldEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the given field as an individual array. </p>
<p>For sparse unions, the returned array has its offset, length and null count adjusted. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow9ListArrayE">
<span id="_CPPv3N5arrow9ListArrayE"></span><span id="_CPPv2N5arrow9ListArrayE"></span><span id="arrow::ListArray"></span><span class="target" id="classarrow_1_1_list_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">ListArray</code> : <em class="property">public</em> arrow::BaseListArray&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8ListTypeE" title="arrow::ListType">ListType</a>&gt;<a class="headerlink" href="#_CPPv4N5arrow9ListArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for list data. </p>
<p>Subclassed by arrow::MapArray</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow9ListArray7FlattenEP10MemoryPool">
<span id="_CPPv3NK5arrow9ListArray7FlattenEP10MemoryPool"></span><span id="_CPPv2NK5arrow9ListArray7FlattenEP10MemoryPool"></span><span id="arrow::ListArray::Flatten__MemoryPoolPC"></span><span class="target" id="classarrow_1_1_list_array_1a7b2872001debb71704dec19e59d45fdc"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt;&gt; <code class="sig-name descname">Flatten</code><span class="sig-paren">(</span><a class="reference internal" href="memory.html#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>memory_pool</em> = <a class="reference internal" href="memory.html#_CPPv4N5arrow19default_memory_poolEv" title="arrow::default_memory_pool">default_memory_pool</a>()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow9ListArray7FlattenEP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return an <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> that is a concatenation of the lists in this array. </p>
<p>Note that it’s different from <code class="docutils literal notranslate"><span class="pre">values()</span></code> in that it takes into consideration of this array’s offsets as well as null elements backed by non-empty lists (they are skipped, thus copying may be needed). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow9ListArray7offsetsEv">
<span id="_CPPv3NK5arrow9ListArray7offsetsEv"></span><span id="_CPPv2NK5arrow9ListArray7offsetsEv"></span><span id="arrow::ListArray::offsetsC"></span><span class="target" id="classarrow_1_1_list_array_1a9521fc11ef38c19dae63928d5f8f951d"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">offsets</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow9ListArray7offsetsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return list offsets as an Int32Array. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow9ListArray10FromArraysERK5ArrayRK5ArrayP10MemoryPool">
<span id="_CPPv3N5arrow9ListArray10FromArraysERK5ArrayRK5ArrayP10MemoryPool"></span><span id="_CPPv2N5arrow9ListArray10FromArraysERK5ArrayRK5ArrayP10MemoryPool"></span><span id="arrow::ListArray::FromArrays__ArrayCR.ArrayCR.MemoryPoolP"></span><span class="target" id="classarrow_1_1_list_array_1a1bc117a2b89cb2e0334527aba9606354"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow9ListArrayE" title="arrow::ListArray">ListArray</a>&gt;&gt; <code class="sig-name descname">FromArrays</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>offsets</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a> &amp;<em>values</em>, <a class="reference internal" href="memory.html#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em> = <a class="reference internal" href="memory.html#_CPPv4N5arrow19default_memory_poolEv" title="arrow::default_memory_pool">default_memory_pool</a>()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow9ListArray10FromArraysERK5ArrayRK5ArrayP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct <a class="reference internal" href="#classarrow_1_1_list_array"><span class="std std-ref">ListArray</span></a> from array of offsets and child value array. </p>
<p>This function does the bare minimum of validation of the offsets and input types, and will allocate a new offsets array if necessary (i.e. if the offsets contain any nulls). If the offsets do not have nulls, they are assumed to be well-formed</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">offsets</span></code>: <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> containing n + 1 offsets encoding length and size. Must be of int32 type </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">values</span></code>: <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> containing list values </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: <a class="reference internal" href="memory.html#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> in case new offsets array needs to be allocated because of null values </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow11StructArrayE">
<span id="_CPPv3N5arrow11StructArrayE"></span><span id="_CPPv2N5arrow11StructArrayE"></span><span id="arrow::StructArray"></span><span class="target" id="classarrow_1_1_struct_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">StructArray</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a><a class="headerlink" href="#_CPPv4N5arrow11StructArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concrete <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> class for struct data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow11StructArray14GetFieldByNameERKNSt6stringE">
<span id="_CPPv3NK5arrow11StructArray14GetFieldByNameERKNSt6stringE"></span><span id="_CPPv2NK5arrow11StructArray14GetFieldByNameERKNSt6stringE"></span><span id="arrow::StructArray::GetFieldByName__ssCRC"></span><span class="target" id="classarrow_1_1_struct_array_1a3ae1f625a93bdc6592821e7e9ef3f054"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">GetFieldByName</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>name</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow11StructArray14GetFieldByNameERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns null if name not found. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow11StructArray7FlattenEP10MemoryPool">
<span id="_CPPv3NK5arrow11StructArray7FlattenEP10MemoryPool"></span><span id="_CPPv2NK5arrow11StructArray7FlattenEP10MemoryPool"></span><span id="arrow::StructArray::Flatten__MemoryPoolPC"></span><span class="target" id="classarrow_1_1_struct_array_1a3f4d5a2dbe3205772c21491160508c66"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;ArrayVector&gt; <code class="sig-name descname">Flatten</code><span class="sig-paren">(</span><a class="reference internal" href="memory.html#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em> = <a class="reference internal" href="memory.html#_CPPv4N5arrow19default_memory_poolEv" title="arrow::default_memory_pool">default_memory_pool</a>()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow11StructArray7FlattenEP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flatten this array as a vector of arrays, one for each field. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: The pool to allocate null bitmaps from, if necessary </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow11StructArray4MakeERK11ArrayVectorRKNSt6vectorINSt6stringEEENSt10shared_ptrI6BufferEE7int64_t7int64_t">
<span id="_CPPv3N5arrow11StructArray4MakeERK11ArrayVectorRKNSt6vectorINSt6stringEEENSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="_CPPv2N5arrow11StructArray4MakeERK11ArrayVectorRKNSt6vectorINSt6stringEEENSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="arrow::StructArray::Make__ArrayVectorCR.std::vector:ss:CR.std::shared_ptr:Buffer:.int64_t.int64_t"></span><span class="target" id="classarrow_1_1_struct_array_1abc6cf0de6f61122a0d38072c3ac6e4b8"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow11StructArrayE" title="arrow::StructArray">StructArray</a>&gt;&gt; <code class="sig-name descname">Make</code><span class="sig-paren">(</span><em class="property">const</em> ArrayVector &amp;<em>children</em>, <em class="property">const</em> std::vector&lt;std::string&gt; &amp;<em>field_names</em>, std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>null_bitmap</em> = NULLPTR, int64_t <em>null_count</em> = kUnknownNullCount, int64_t <em>offset</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow11StructArray4MakeERK11ArrayVectorRKNSt6vectorINSt6stringEEENSt10shared_ptrI6BufferEE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="#classarrow_1_1_struct_array"><span class="std std-ref">StructArray</span></a> from child arrays and field names. </p>
<p>The length and data type are automatically inferred from the arguments. There should be at least one child array. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow11StructArray4MakeERK11ArrayVectorRK11FieldVectorNSt10shared_ptrI6BufferEE7int64_t7int64_t">
<span id="_CPPv3N5arrow11StructArray4MakeERK11ArrayVectorRK11FieldVectorNSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="_CPPv2N5arrow11StructArray4MakeERK11ArrayVectorRK11FieldVectorNSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="arrow::StructArray::Make__ArrayVectorCR.FieldVectorCR.std::shared_ptr:Buffer:.int64_t.int64_t"></span><span class="target" id="classarrow_1_1_struct_array_1aa71239a2b33485de51043fd5d4951bbc"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow11StructArrayE" title="arrow::StructArray">StructArray</a>&gt;&gt; <code class="sig-name descname">Make</code><span class="sig-paren">(</span><em class="property">const</em> ArrayVector &amp;<em>children</em>, <em class="property">const</em> FieldVector &amp;<em>fields</em>, std::shared_ptr&lt;<a class="reference internal" href="memory.html#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>null_bitmap</em> = NULLPTR, int64_t <em>null_count</em> = kUnknownNullCount, int64_t <em>offset</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow11StructArray4MakeERK11ArrayVectorRK11FieldVectorNSt10shared_ptrI6BufferEE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="#classarrow_1_1_struct_array"><span class="std std-ref">StructArray</span></a> from child arrays and fields. </p>
<p>The length is automatically inferred from the arguments. There should be at least one child array. This method does not check that field types and child array types are consistent. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="chunked-arrays">
<h2><a class="toc-backref" href="#id4">Chunked Arrays</a><a class="headerlink" href="#chunked-arrays" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv4N5arrow12ChunkedArrayE">
<span id="_CPPv3N5arrow12ChunkedArrayE"></span><span id="_CPPv2N5arrow12ChunkedArrayE"></span><span id="arrow::ChunkedArray"></span><span class="target" id="classarrow_1_1_chunked_array"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">ChunkedArray</code><a class="headerlink" href="#_CPPv4N5arrow12ChunkedArrayE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A data structure managing a list of primitive Arrow arrays logically as one large array. </p>
<p>Data chunking is treated throughout this project largely as an implementation detail for performance and memory use optimization. <a class="reference internal" href="#classarrow_1_1_chunked_array"><span class="std std-ref">ChunkedArray</span></a> allows <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> objects to be collected and interpreted as a single logical array without requiring an expensive concatenation step.</p>
<p>In some cases, data produced by a function may exceed the capacity of an <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a> (like <a class="reference internal" href="#classarrow_1_1_binary_array"><span class="std std-ref">BinaryArray</span></a> or <a class="reference internal" href="#classarrow_1_1_string_array"><span class="std std-ref">StringArray</span></a>) and so returning multiple Arrays is the only possibility. In these cases, we recommend returning a <a class="reference internal" href="#classarrow_1_1_chunked_array"><span class="std std-ref">ChunkedArray</span></a> instead of vector of Arrays or some alternative.</p>
<p>When data is processed in parallel, it may not be practical or possible to create large contiguous memory allocations and write output into them. With some data types, like binary and string types, it is not possible at all to produce non-chunked array outputs without requiring a concatenation step at the end of processing.</p>
<p>Application developers may tune chunk sizes based on analysis of performance profiles but many developer-users will not need to be especially concerned with the chunking details.</p>
<p>Preserving the chunk layout/sizes in processing steps is generally not considered to be a contract in APIs. A function may decide to alter the chunking of its result. Similarly, APIs accepting multiple <a class="reference internal" href="#classarrow_1_1_chunked_array"><span class="std std-ref">ChunkedArray</span></a> inputs should not expect the chunk layout to be the same in each input. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow12ChunkedArray12ChunkedArrayE11ArrayVector">
<span id="_CPPv3N5arrow12ChunkedArray12ChunkedArrayE11ArrayVector"></span><span id="_CPPv2N5arrow12ChunkedArray12ChunkedArrayE11ArrayVector"></span><span id="arrow::ChunkedArray::ChunkedArray__ArrayVector"></span><span class="target" id="classarrow_1_1_chunked_array_1a20e9e43c646d7f55d57b3c039bbabde1"></span><code class="sig-name descname">ChunkedArray</code><span class="sig-paren">(</span>ArrayVector <em>chunks</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow12ChunkedArray12ChunkedArrayE11ArrayVector" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a chunked array from a vector of arrays. </p>
<p>The vector must be non-empty and all its elements must have the same data type. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow12ChunkedArray12ChunkedArrayENSt10shared_ptrI5ArrayEE">
<span id="_CPPv3N5arrow12ChunkedArray12ChunkedArrayENSt10shared_ptrI5ArrayEE"></span><span id="_CPPv2N5arrow12ChunkedArray12ChunkedArrayENSt10shared_ptrI5ArrayEE"></span><span id="arrow::ChunkedArray::ChunkedArray__std::shared_ptr:Array:"></span><span class="target" id="classarrow_1_1_chunked_array_1a2d66448b2733e29fe02d6334defa7e47"></span><code class="sig-name descname">ChunkedArray</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <em>chunk</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow12ChunkedArray12ChunkedArrayENSt10shared_ptrI5ArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a chunked array from a single <a class="reference internal" href="#classarrow_1_1_array"><span class="std std-ref">Array</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow12ChunkedArray12ChunkedArrayE11ArrayVectorNSt10shared_ptrI8DataTypeEE">
<span id="_CPPv3N5arrow12ChunkedArray12ChunkedArrayE11ArrayVectorNSt10shared_ptrI8DataTypeEE"></span><span id="_CPPv2N5arrow12ChunkedArray12ChunkedArrayE11ArrayVectorNSt10shared_ptrI8DataTypeEE"></span><span id="arrow::ChunkedArray::ChunkedArray__ArrayVector.std::shared_ptr:DataType:"></span><span class="target" id="classarrow_1_1_chunked_array_1a8b8947395f527581001a0d9c06e8f9b3"></span><code class="sig-name descname">ChunkedArray</code><span class="sig-paren">(</span>ArrayVector <em>chunks</em>, std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow12ChunkedArray12ChunkedArrayE11ArrayVectorNSt10shared_ptrI8DataTypeEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a chunked array from a vector of arrays and a data type. </p>
<p>As the data type is passed explicitly, the vector may be empty. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray6lengthEv">
<span id="_CPPv3NK5arrow12ChunkedArray6lengthEv"></span><span id="_CPPv2NK5arrow12ChunkedArray6lengthEv"></span><span id="arrow::ChunkedArray::lengthC"></span><span class="target" id="classarrow_1_1_chunked_array_1a4df41bf1a05cd1083a2c4502e0a85f87"></span>int64_t <code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray6lengthEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the total length of the chunked array; computed on construction </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray10null_countEv">
<span id="_CPPv3NK5arrow12ChunkedArray10null_countEv"></span><span id="_CPPv2NK5arrow12ChunkedArray10null_countEv"></span><span id="arrow::ChunkedArray::null_countC"></span><span class="target" id="classarrow_1_1_chunked_array_1a962541b044ac5a7a6a87499cef7957bb"></span>int64_t <code class="sig-name descname">null_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray10null_countEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>the total number of nulls among all chunks </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray5chunkEi">
<span id="_CPPv3NK5arrow12ChunkedArray5chunkEi"></span><span id="_CPPv2NK5arrow12ChunkedArray5chunkEi"></span><span id="arrow::ChunkedArray::chunk__iC"></span><span class="target" id="classarrow_1_1_chunked_array_1a92ec02f5904ac3e4dac5328e44ebf0fb"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow5ArrayE" title="arrow::Array">Array</a>&gt; <code class="sig-name descname">chunk</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray5chunkEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>chunk a particular chunk from the chunked array </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray5SliceE7int64_t7int64_t">
<span id="_CPPv3NK5arrow12ChunkedArray5SliceE7int64_t7int64_t"></span><span id="_CPPv2NK5arrow12ChunkedArray5SliceE7int64_t7int64_t"></span><span id="arrow::ChunkedArray::Slice__int64_t.int64_tC"></span><span class="target" id="classarrow_1_1_chunked_array_1a99573028501f20b3f0707d85e8cce2ad"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt; <code class="sig-name descname">Slice</code><span class="sig-paren">(</span>int64_t <em>offset</em>, int64_t <em>length</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray5SliceE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a zero-copy slice of the chunked array with the indicated offset and length. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new object wrapped in std::shared_ptr&lt;ChunkedArray&gt; </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">offset</span></code>: the position of the first element in the constructed slice </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">length</span></code>: the length of the slice. If there are not enough elements in the chunked array, the length will be adjusted accordingly</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray5SliceE7int64_t">
<span id="_CPPv3NK5arrow12ChunkedArray5SliceE7int64_t"></span><span id="_CPPv2NK5arrow12ChunkedArray5SliceE7int64_t"></span><span id="arrow::ChunkedArray::Slice__int64_tC"></span><span class="target" id="classarrow_1_1_chunked_array_1abf30b26c92cf037191e8574763e22a2e"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt; <code class="sig-name descname">Slice</code><span class="sig-paren">(</span>int64_t <em>offset</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray5SliceE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Slice from offset until end of the chunked array. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray7FlattenEP10MemoryPool">
<span id="_CPPv3NK5arrow12ChunkedArray7FlattenEP10MemoryPool"></span><span id="_CPPv2NK5arrow12ChunkedArray7FlattenEP10MemoryPool"></span><span id="arrow::ChunkedArray::Flatten__MemoryPoolPC"></span><span class="target" id="classarrow_1_1_chunked_array_1ac4fd4aa712dd636d52dc3199c8276c2c"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt;&gt;&gt; <code class="sig-name descname">Flatten</code><span class="sig-paren">(</span><a class="reference internal" href="memory.html#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em> = <a class="reference internal" href="memory.html#_CPPv4N5arrow19default_memory_poolEv" title="arrow::default_memory_pool">default_memory_pool</a>()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray7FlattenEP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flatten this chunked array as a vector of chunked arrays, one for each struct field. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: The pool for buffer allocations, if any </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray4ViewERKNSt10shared_ptrI8DataTypeEE">
<span id="_CPPv3NK5arrow12ChunkedArray4ViewERKNSt10shared_ptrI8DataTypeEE"></span><span id="_CPPv2NK5arrow12ChunkedArray4ViewERKNSt10shared_ptrI8DataTypeEE"></span><span id="arrow::ChunkedArray::View__std::shared_ptr:DataType:CRC"></span><span class="target" id="classarrow_1_1_chunked_array_1a6486c77d9ba68feb3a0205691f5bc7d4"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt;&gt; <code class="sig-name descname">View</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="datatype.html#_CPPv4N5arrow8DataTypeE" title="arrow::DataType">DataType</a>&gt; &amp;<em>type</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray4ViewERKNSt10shared_ptrI8DataTypeEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a zero-copy view of this chunked array with the given type. </p>
<p>Calls <a class="reference internal" href="#classarrow_1_1_array_1aa2b5f248c09a41c089e1fbc911beecb0"><span class="std std-ref">Array::View</span></a> on each constituent chunk. Always succeeds if there are zero chunks </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray6EqualsERK12ChunkedArray">
<span id="_CPPv3NK5arrow12ChunkedArray6EqualsERK12ChunkedArray"></span><span id="_CPPv2NK5arrow12ChunkedArray6EqualsERK12ChunkedArray"></span><span id="arrow::ChunkedArray::Equals__ChunkedArrayCRC"></span><span class="target" id="classarrow_1_1_chunked_array_1ab7ad74cc587d5d622c7e62cbf1b0b9f9"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray6EqualsERK12ChunkedArray" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if two chunked arrays are equal. </p>
<p>Two chunked arrays can be equal only if they have equal datatypes. However, they may be equal even if they have different chunkings. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray6EqualsERKNSt10shared_ptrI12ChunkedArrayEE">
<span id="_CPPv3NK5arrow12ChunkedArray6EqualsERKNSt10shared_ptrI12ChunkedArrayEE"></span><span id="_CPPv2NK5arrow12ChunkedArray6EqualsERKNSt10shared_ptrI12ChunkedArrayEE"></span><span id="arrow::ChunkedArray::Equals__std::shared_ptr:ChunkedArray:CRC"></span><span class="target" id="classarrow_1_1_chunked_array_1a67c23032d122d1a87acf0bc2b2e52d54"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow12ChunkedArrayE" title="arrow::ChunkedArray">ChunkedArray</a>&gt; &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray6EqualsERKNSt10shared_ptrI12ChunkedArrayEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determine if two chunked arrays are equal. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray8ToStringEv">
<span id="_CPPv3NK5arrow12ChunkedArray8ToStringEv"></span><span id="_CPPv2NK5arrow12ChunkedArray8ToStringEv"></span><span id="arrow::ChunkedArray::ToStringC"></span><span class="target" id="classarrow_1_1_chunked_array_1aba4644e58ea8d1b43080691a4e945ca8"></span>std::string <code class="sig-name descname">ToString</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray8ToStringEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>PrettyPrint representation suitable for debugging </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray8ValidateEv">
<span id="_CPPv3NK5arrow12ChunkedArray8ValidateEv"></span><span id="_CPPv2NK5arrow12ChunkedArray8ValidateEv"></span><span id="arrow::ChunkedArray::ValidateC"></span><span class="target" id="classarrow_1_1_chunked_array_1a06ca5def32987d58b7577db269e39520"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray8ValidateEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform cheap validation checks to determine obvious inconsistencies within the chunk array’s internal data. </p>
<p>This is O(k*m) where k is the number of array descendents, and m is the number of chunks.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow12ChunkedArray12ValidateFullEv">
<span id="_CPPv3NK5arrow12ChunkedArray12ValidateFullEv"></span><span id="_CPPv2NK5arrow12ChunkedArray12ValidateFullEv"></span><span id="arrow::ChunkedArray::ValidateFullC"></span><span class="target" id="classarrow_1_1_chunked_array_1a85899961a35888fcdfed462418ba6498"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">ValidateFull</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow12ChunkedArray12ValidateFullEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform extensive validation checks to determine inconsistencies within the chunk array’s internal data. </p>
<p>This is O(k*n) where k is the number of array descendents, and n is the length in elements.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </p>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="scalar.html" class="btn btn-neutral float-right" title="Scalars" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="datatype.html" class="btn btn-neutral float-left" title="Data Types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2016-2019 Apache Software Foundation.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-107500873-1');
</script>


<script type="text/javascript" src="arrow.apache.org/docs/versionwarning.js"></script></body>
</html>