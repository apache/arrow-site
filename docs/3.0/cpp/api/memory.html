


<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Memory (management) &mdash; Apache Arrow v3.0.0</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Data Types" href="datatype.html" />
    <link rel="prev" title="Programming Support" href="support.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Apache Arrow
          

          
          </a>

          
            
            
              <div class="version">
                3.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Specifications and Protocols</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../format/Versioning.html">Format Versioning and Stability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Columnar.html">Arrow Columnar Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Flight.html">Arrow Flight RPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Integration.html">Integration Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/CDataInterface.html">The Arrow C data interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/CStreamInterface.html">The Arrow C stream interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../format/Other.html">Other Data Structures</a></li>
</ul>
<p class="caption"><span class="caption-text">Libraries</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../status.html">Implementation Status</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/c_glib/">C/GLib</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">C++</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../getting_started.html">User Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/index.html">Examples</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../api.html">API Reference</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="support.html">Programming Support</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Memory (management)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#devices">Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-managers">Memory Managers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffers">Buffers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-pools">Memory Pools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#allocation-functions">Allocation Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slicing">Slicing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-builders">Buffer Builders</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stl-integration">STL Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="datatype.html">Data Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="array.html">Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="scalar.html">Scalars</a></li>
<li class="toctree-l3"><a class="reference internal" href="builder.html">Array Builders</a></li>
<li class="toctree-l3"><a class="reference internal" href="table.html">Two-dimensional Datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="c_abi.html">C Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="compute.html">Compute Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="tensor.html">Tensors</a></li>
<li class="toctree-l3"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="io.html">Input / output</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">Arrow IPC</a></li>
<li class="toctree-l3"><a class="reference internal" href="formats.html">File Formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="cuda.html">CUDA support</a></li>
<li class="toctree-l3"><a class="reference internal" href="flight.html">Arrow Flight RPC</a></li>
<li class="toctree-l3"><a class="reference internal" href="filesystem.html">Filesystems</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apache/arrow/blob/master/csharp/README.md">C#</a></li>
<li class="toctree-l1"><a class="reference external" href="https://godoc.org/github.com/apache/arrow/go/arrow">Go</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../java/index.html">Java</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/js/">JavaScript</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apache/arrow/blob/master/julia/Arrow/README.md">Julia</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apache/arrow/blob/master/matlab/README.md">MATLAB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../python/index.html">Python</a></li>
<li class="toctree-l1"><a class="reference external" href="https://arrow.apache.org/docs/r/">R</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/apache/arrow/blob/master/ruby/README.md">Ruby</a></li>
<li class="toctree-l1"><a class="reference external" href="https://docs.rs/crate/arrow/">Rust</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../developers/contributing.html">Contributing to Apache Arrow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/cpp/index.html">C++ Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/python.html">Python Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/archery.html">Daily Development using Archery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/crossbow.html">Packaging and Testing with Crossbow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/docker.html">Running Docker Builds</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developers/documentation.html">Building the Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Apache Arrow</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">C++ Implementation</a> &raquo;</li>
        
          <li><a href="../api.html">API Reference</a> &raquo;</li>
        
      <li>Memory (management)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/cpp/api/memory.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memory-management">
<h1>Memory (management)<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h1>
<div class="section" id="devices">
<h2>Devices<a class="headerlink" href="#devices" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv4N5arrow6DeviceE">
<span id="_CPPv3N5arrow6DeviceE"></span><span id="_CPPv2N5arrow6DeviceE"></span><span id="arrow::Device"></span><span class="target" id="classarrow_1_1_device"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Device</code> : <em class="property">public</em> std::enable_shared_from_this&lt;<a class="reference internal" href="#_CPPv4N5arrow6DeviceE" title="arrow::Device">Device</a>&gt;, <em class="property">public</em> arrow::util::EqualityComparable&lt;<a class="reference internal" href="#_CPPv4N5arrow6DeviceE" title="arrow::Device">Device</a>&gt;<a class="headerlink" href="#_CPPv4N5arrow6DeviceE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>EXPERIMENTAL: Abstract interface for hardware devices. </p>
<p>This object represents a device with access to some memory spaces. When handling a <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> or raw memory address, it allows deciding in which context the raw memory address should be interpreted (e.g. CPU-accessible memory, or embedded memory on some particular GPU). </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_c_p_u_device"><span class="std std-ref">arrow::CPUDevice</span></a>, <a class="reference internal" href="cuda.html#classarrow_1_1cuda_1_1_cuda_device"><span class="std std-ref">arrow::cuda::CudaDevice</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Device9type_nameEv">
<span id="_CPPv3NK5arrow6Device9type_nameEv"></span><span id="_CPPv2NK5arrow6Device9type_nameEv"></span><span id="arrow::Device::type_nameC"></span><span class="target" id="classarrow_1_1_device_1a64fa6c42b0237fab3002c0da05be613d"></span><em class="property">const</em> char *<code class="sig-name descname">type_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrow6Device9type_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A shorthand for this device’s type. </p>
<p>The returned value is different for each device class, but is the same for all instances of a given class. It can be used as a replacement for RTTI. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Device8ToStringEv">
<span id="_CPPv3NK5arrow6Device8ToStringEv"></span><span id="_CPPv2NK5arrow6Device8ToStringEv"></span><span id="arrow::Device::ToStringC"></span><span class="target" id="classarrow_1_1_device_1a308203da24624f8ef8df7329f214ef6f"></span>std::string <code class="sig-name descname">ToString</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrow6Device8ToStringEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A human-readable description of the device. </p>
<p>The returned value should be detailed enough to distinguish between different instances, where necessary. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Device6EqualsERK6Device">
<span id="_CPPv3NK5arrow6Device6EqualsERK6Device"></span><span id="_CPPv2NK5arrow6Device6EqualsERK6Device"></span><span id="arrow::Device::Equals__DeviceCRC"></span><span class="target" id="classarrow_1_1_device_1acaaa334c017c8e0d097918a730d8544b"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow6DeviceE" title="arrow::Device">Device</a>&amp;<span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrow6Device6EqualsERK6Device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether this instance points to the same device as another one. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Device6is_cpuEv">
<span id="_CPPv3NK5arrow6Device6is_cpuEv"></span><span id="_CPPv2NK5arrow6Device6is_cpuEv"></span><span id="arrow::Device::is_cpuC"></span><span class="target" id="classarrow_1_1_device_1acd6a82de24ea679e2041159b18cfe294"></span>bool <code class="sig-name descname">is_cpu</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Device6is_cpuEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether this device is the main CPU device. </p>
<p>This shorthand method is very useful when deciding whether a memory address is CPU-accessible. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Device22default_memory_managerEv">
<span id="_CPPv3N5arrow6Device22default_memory_managerEv"></span><span id="_CPPv2N5arrow6Device22default_memory_managerEv"></span><span id="arrow::Device::default_memory_manager"></span><span class="target" id="classarrow_1_1_device_1a9615d7d1f5136d43bcf1061782197412"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt; <code class="sig-name descname">default_memory_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow6Device22default_memory_managerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> instance tied to this device. </p>
<p>The returned instance uses default parameters for this device type’s <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> implementation. Some devices also allow constructing <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> instances with non-default parameters. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow9CPUDeviceE">
<span id="_CPPv3N5arrow9CPUDeviceE"></span><span id="_CPPv2N5arrow9CPUDeviceE"></span><span id="arrow::CPUDevice"></span><span class="target" id="classarrow_1_1_c_p_u_device"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">CPUDevice</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow6DeviceE" title="arrow::Device">Device</a><a class="headerlink" href="#_CPPv4N5arrow9CPUDeviceE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow9CPUDevice9type_nameEv">
<span id="_CPPv3NK5arrow9CPUDevice9type_nameEv"></span><span id="_CPPv2NK5arrow9CPUDevice9type_nameEv"></span><span id="arrow::CPUDevice::type_nameC"></span><span class="target" id="classarrow_1_1_c_p_u_device_1a56de6467569661983bf89cca4e23e313"></span><em class="property">const</em> char *<code class="sig-name descname">type_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow9CPUDevice9type_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A shorthand for this device’s type. </p>
<p>The returned value is different for each device class, but is the same for all instances of a given class. It can be used as a replacement for RTTI. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow9CPUDevice8ToStringEv">
<span id="_CPPv3NK5arrow9CPUDevice8ToStringEv"></span><span id="_CPPv2NK5arrow9CPUDevice8ToStringEv"></span><span id="arrow::CPUDevice::ToStringC"></span><span class="target" id="classarrow_1_1_c_p_u_device_1af136696c33197fac051e3cca0688f31e"></span>std::string <code class="sig-name descname">ToString</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow9CPUDevice8ToStringEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A human-readable description of the device. </p>
<p>The returned value should be detailed enough to distinguish between different instances, where necessary. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow9CPUDevice6EqualsERK6Device">
<span id="_CPPv3NK5arrow9CPUDevice6EqualsERK6Device"></span><span id="_CPPv2NK5arrow9CPUDevice6EqualsERK6Device"></span><span id="arrow::CPUDevice::Equals__DeviceCRC"></span><span class="target" id="classarrow_1_1_c_p_u_device_1a23a4f5100acda607a63371a89e5bb7e5"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow6DeviceE" title="arrow::Device">Device</a>&amp;<span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow9CPUDevice6EqualsERK6Device" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether this instance points to the same device as another one. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow9CPUDevice22default_memory_managerEv">
<span id="_CPPv3N5arrow9CPUDevice22default_memory_managerEv"></span><span id="_CPPv2N5arrow9CPUDevice22default_memory_managerEv"></span><span id="arrow::CPUDevice::default_memory_manager"></span><span class="target" id="classarrow_1_1_c_p_u_device_1ab5acfa03ea867c7b7fe4f903e8b19547"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt; <code class="sig-name descname">default_memory_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow9CPUDevice22default_memory_managerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> instance tied to this device. </p>
<p>The returned instance uses default parameters for this device type’s <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> implementation. Some devices also allow constructing <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> instances with non-default parameters. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow9CPUDevice8InstanceEv">
<span id="_CPPv3N5arrow9CPUDevice8InstanceEv"></span><span id="_CPPv2N5arrow9CPUDevice8InstanceEv"></span><span id="arrow::CPUDevice::Instance"></span><span class="target" id="classarrow_1_1_c_p_u_device_1a2639c1933007a4c0b553b245c9a59896"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6DeviceE" title="arrow::Device">Device</a>&gt; <code class="sig-name descname">Instance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow9CPUDevice8InstanceEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the global <a class="reference internal" href="#classarrow_1_1_c_p_u_device"><span class="std std-ref">CPUDevice</span></a> instance. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow9CPUDevice14memory_managerEP10MemoryPool">
<span id="_CPPv3N5arrow9CPUDevice14memory_managerEP10MemoryPool"></span><span id="_CPPv2N5arrow9CPUDevice14memory_managerEP10MemoryPool"></span><span id="arrow::CPUDevice::memory_manager__MemoryPoolP"></span><span class="target" id="classarrow_1_1_c_p_u_device_1a477fdfe0a1f4400985dd0efe1da6ad34"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt; <code class="sig-name descname">memory_manager</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow9CPUDevice14memory_managerEP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>. </p>
<p>The returned <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> will use the given <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> for allocations. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow26default_cpu_memory_managerEv">
<span id="_CPPv3N5arrow26default_cpu_memory_managerEv"></span><span id="_CPPv2N5arrow26default_cpu_memory_managerEv"></span><span id="arrow::default_cpu_memory_manager"></span><span class="target" id="namespacearrow_1a6945ae85a9bf9faebabefcb308098cc8"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt; <code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">default_cpu_memory_manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow26default_cpu_memory_managerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the default CPU <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> instance. </p>
<p>The returned singleton instance uses the default <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a>. This function is a faster spelling of <code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_c_p_u_device_1a2639c1933007a4c0b553b245c9a59896"><span class="std std-ref"><span class="pre">CPUDevice::Instance()</span></span></a><span class="pre">-&gt;default_memory_manager()</span></code>. </p>
</dd></dl>

</div>
<div class="section" id="memory-managers">
<h2>Memory Managers<a class="headerlink" href="#memory-managers" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv4N5arrow13MemoryManagerE">
<span id="_CPPv3N5arrow13MemoryManagerE"></span><span id="_CPPv2N5arrow13MemoryManagerE"></span><span id="arrow::MemoryManager"></span><span class="target" id="classarrow_1_1_memory_manager"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">MemoryManager</code> : <em class="property">public</em> std::enable_shared_from_this&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt;<a class="headerlink" href="#_CPPv4N5arrow13MemoryManagerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>EXPERIMENTAL: An object that provides memory management primitives. </p>
<p>A <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> is always tied to a particular <a class="reference internal" href="#classarrow_1_1_device"><span class="std std-ref">Device</span></a> instance. It can also have additional parameters (such as a <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> to allocate CPU memory). </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_c_p_u_memory_manager"><span class="std std-ref">arrow::CPUMemoryManager</span></a>, <a class="reference internal" href="cuda.html#classarrow_1_1cuda_1_1_cuda_memory_manager"><span class="std std-ref">arrow::cuda::CudaMemoryManager</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4NK5arrow13MemoryManager6deviceEv">
<span id="_CPPv3NK5arrow13MemoryManager6deviceEv"></span><span id="_CPPv2NK5arrow13MemoryManager6deviceEv"></span><span id="arrow::MemoryManager::deviceC"></span><span class="target" id="classarrow_1_1_memory_manager_1a5b5e7539c2b6a3dcec4ed283a314d4a1"></span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6DeviceE" title="arrow::Device">Device</a>&gt; &amp;<code class="sig-name descname">device</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow13MemoryManager6deviceEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The device this <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> is tied to. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow13MemoryManager6is_cpuEv">
<span id="_CPPv3NK5arrow13MemoryManager6is_cpuEv"></span><span id="_CPPv2NK5arrow13MemoryManager6is_cpuEv"></span><span id="arrow::MemoryManager::is_cpuC"></span><span class="target" id="classarrow_1_1_memory_manager_1abfed9ff4dc52b5952f43c1c43a830372"></span>bool <code class="sig-name descname">is_cpu</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow13MemoryManager6is_cpuEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether this <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a> is tied to the main CPU device. </p>
<p>This shorthand method is very useful when deciding whether a memory address is CPU-accessible. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13MemoryManager15GetBufferReaderENSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow13MemoryManager15GetBufferReaderENSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow13MemoryManager15GetBufferReaderENSt10shared_ptrI6BufferEE"></span><span id="arrow::MemoryManager::GetBufferReader__std::shared_ptr:Buffer:"></span><span class="target" id="classarrow_1_1_memory_manager_1a95ff2d7345e5892f6f0750fc1b9543a5"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;io::<a class="reference internal" href="io.html#_CPPv4N5arrow2io16RandomAccessFileE" title="arrow::io::RandomAccessFile">RandomAccessFile</a>&gt;&gt; <code class="sig-name descname">GetBufferReader</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>buf</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow13MemoryManager15GetBufferReaderENSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a RandomAccessFile to read a particular buffer. </p>
<p>The given buffer must be tied to this <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>.</p>
<p>See also the <a class="reference internal" href="#classarrow_1_1_buffer_1ae2eded44b1379542966cd441a49fe953"><span class="std std-ref">Buffer::GetReader</span></a> shorthand. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13MemoryManager15GetBufferWriterENSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow13MemoryManager15GetBufferWriterENSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow13MemoryManager15GetBufferWriterENSt10shared_ptrI6BufferEE"></span><span id="arrow::MemoryManager::GetBufferWriter__std::shared_ptr:Buffer:"></span><span class="target" id="classarrow_1_1_memory_manager_1a7888256d7a122d4bbda0b1c6d36efc08"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;io::<a class="reference internal" href="io.html#_CPPv4N5arrow2io12OutputStreamE" title="arrow::io::OutputStream">OutputStream</a>&gt;&gt; <code class="sig-name descname">GetBufferWriter</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>buf</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow13MemoryManager15GetBufferWriterENSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a OutputStream to write to a particular buffer. </p>
<p>The given buffer must be mutable and tied to this <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>. The returned stream object writes into the buffer’s underlying memory (but it won’t resize it).</p>
<p>See also the <a class="reference internal" href="#classarrow_1_1_buffer_1a3131f10cde81c53e4d6615eb5e4850ec"><span class="std std-ref">Buffer::GetWriter</span></a> shorthand. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13MemoryManager14AllocateBufferE7int64_t">
<span id="_CPPv3N5arrow13MemoryManager14AllocateBufferE7int64_t"></span><span id="_CPPv2N5arrow13MemoryManager14AllocateBufferE7int64_t"></span><span id="arrow::MemoryManager::AllocateBuffer__int64_t"></span><span class="target" id="classarrow_1_1_memory_manager_1af9a8d3491d119faea0e4c9b4581bcb00"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;&gt; <code class="sig-name descname">AllocateBuffer</code><span class="sig-paren">(</span>int64_t <em>size</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow13MemoryManager14AllocateBufferE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a (mutable) <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a>. </p>
<p>The buffer will be allocated in the device’s memory. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow13MemoryManager10CopyBufferERKNSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE">
<span id="_CPPv3N5arrow13MemoryManager10CopyBufferERKNSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="_CPPv2N5arrow13MemoryManager10CopyBufferERKNSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="arrow::MemoryManager::CopyBuffer__std::shared_ptr:Buffer:CR.std::shared_ptr:MemoryManager:CR"></span><span class="target" id="classarrow_1_1_memory_manager_1ade50a93d074fd3ccbddad215371784c2"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;&gt; <code class="sig-name descname">CopyBuffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; &amp;<em>source</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt; &amp;<em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13MemoryManager10CopyBufferERKNSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> to a destination <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>. </p>
<p>See also the <a class="reference internal" href="#classarrow_1_1_buffer_1a9dcc66ada966d56a9294531e72a0e1d9"><span class="std std-ref">Buffer::Copy</span></a> shorthand. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13MemoryManager10ViewBufferERKNSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE">
<span id="_CPPv3N5arrow13MemoryManager10ViewBufferERKNSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="_CPPv2N5arrow13MemoryManager10ViewBufferERKNSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="arrow::MemoryManager::ViewBuffer__std::shared_ptr:Buffer:CR.std::shared_ptr:MemoryManager:CR"></span><span class="target" id="classarrow_1_1_memory_manager_1ab53a4d3f8077ca1df66a49f904b3ce43"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;&gt; <code class="sig-name descname">ViewBuffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; &amp;<em>source</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt; &amp;<em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13MemoryManager10ViewBufferERKNSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Make a no-copy <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> view in a destination <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>. </p>
<p>See also the <a class="reference internal" href="#classarrow_1_1_buffer_1ac4b959d7080e383ab0a9ff54d8dd9fa3"><span class="std std-ref">Buffer::View</span></a> shorthand. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow16CPUMemoryManagerE">
<span id="_CPPv3N5arrow16CPUMemoryManagerE"></span><span id="_CPPv2N5arrow16CPUMemoryManagerE"></span><span id="arrow::CPUMemoryManager"></span><span class="target" id="classarrow_1_1_c_p_u_memory_manager"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">CPUMemoryManager</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a><a class="headerlink" href="#_CPPv4N5arrow16CPUMemoryManagerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow16CPUMemoryManager15GetBufferReaderENSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow16CPUMemoryManager15GetBufferReaderENSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow16CPUMemoryManager15GetBufferReaderENSt10shared_ptrI6BufferEE"></span><span id="arrow::CPUMemoryManager::GetBufferReader__std::shared_ptr:Buffer:"></span><span class="target" id="classarrow_1_1_c_p_u_memory_manager_1a07924a8c0461e97e98e98c846af8c36c"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;io::<a class="reference internal" href="io.html#_CPPv4N5arrow2io16RandomAccessFileE" title="arrow::io::RandomAccessFile">RandomAccessFile</a>&gt;&gt; <code class="sig-name descname">GetBufferReader</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>buf</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow16CPUMemoryManager15GetBufferReaderENSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a RandomAccessFile to read a particular buffer. </p>
<p>The given buffer must be tied to this <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>.</p>
<p>See also the <a class="reference internal" href="#classarrow_1_1_buffer_1ae2eded44b1379542966cd441a49fe953"><span class="std std-ref">Buffer::GetReader</span></a> shorthand. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow16CPUMemoryManager15GetBufferWriterENSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow16CPUMemoryManager15GetBufferWriterENSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow16CPUMemoryManager15GetBufferWriterENSt10shared_ptrI6BufferEE"></span><span id="arrow::CPUMemoryManager::GetBufferWriter__std::shared_ptr:Buffer:"></span><span class="target" id="classarrow_1_1_c_p_u_memory_manager_1a9e1fcfe610697191b005d836ffce0fcb"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;io::<a class="reference internal" href="io.html#_CPPv4N5arrow2io12OutputStreamE" title="arrow::io::OutputStream">OutputStream</a>&gt;&gt; <code class="sig-name descname">GetBufferWriter</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>buf</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow16CPUMemoryManager15GetBufferWriterENSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a OutputStream to write to a particular buffer. </p>
<p>The given buffer must be mutable and tied to this <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>. The returned stream object writes into the buffer’s underlying memory (but it won’t resize it).</p>
<p>See also the <a class="reference internal" href="#classarrow_1_1_buffer_1a3131f10cde81c53e4d6615eb5e4850ec"><span class="std std-ref">Buffer::GetWriter</span></a> shorthand. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow16CPUMemoryManager14AllocateBufferE7int64_t">
<span id="_CPPv3N5arrow16CPUMemoryManager14AllocateBufferE7int64_t"></span><span id="_CPPv2N5arrow16CPUMemoryManager14AllocateBufferE7int64_t"></span><span id="arrow::CPUMemoryManager::AllocateBuffer__int64_t"></span><span class="target" id="classarrow_1_1_c_p_u_memory_manager_1aa56db7f8369860e6e4b3795db1af8743"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;&gt; <code class="sig-name descname">AllocateBuffer</code><span class="sig-paren">(</span>int64_t <em>size</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow16CPUMemoryManager14AllocateBufferE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a (mutable) <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a>. </p>
<p>The buffer will be allocated in the device’s memory. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow16CPUMemoryManager4poolEv">
<span id="_CPPv3NK5arrow16CPUMemoryManager4poolEv"></span><span id="_CPPv2NK5arrow16CPUMemoryManager4poolEv"></span><span id="arrow::CPUMemoryManager::poolC"></span><span class="target" id="classarrow_1_1_c_p_u_memory_manager_1a9e2959997a429add03ba6d58f364d1be"></span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<code class="sig-name descname">pool</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow16CPUMemoryManager4poolEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> associated with this <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="buffers">
<h2>Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv4N5arrow6BufferE">
<span id="_CPPv3N5arrow6BufferE"></span><span id="_CPPv2N5arrow6BufferE"></span><span id="arrow::Buffer"></span><span class="target" id="classarrow_1_1_buffer"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Buffer</code><a class="headerlink" href="#_CPPv4N5arrow6BufferE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Object containing a pointer to a piece of contiguous memory with a particular size. </p>
<p>Buffers have two related notions of length: size and capacity. Size is the number of bytes that might have valid data. Capacity is the number of bytes that were allocated for the buffer in total.</p>
<p>The <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> base class does not own its memory, but subclasses often do.</p>
<p>The following invariant is always true: Size &lt;= Capacity </p>
<p>Subclassed by <a class="reference internal" href="cuda.html#classarrow_1_1cuda_1_1_cuda_buffer"><span class="std std-ref">arrow::cuda::CudaBuffer</span></a>, <a class="reference internal" href="#classarrow_1_1_mutable_buffer"><span class="std std-ref">arrow::MutableBuffer</span></a>, arrow::py::NumPyBuffer, arrow::py::PyBuffer, arrow::py::PyForeignBuffer</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer6BufferEPK7uint8_t7int64_t">
<span id="_CPPv3N5arrow6Buffer6BufferEPK7uint8_t7int64_t"></span><span id="_CPPv2N5arrow6Buffer6BufferEPK7uint8_t7int64_t"></span><span id="arrow::Buffer::Buffer__uint8_tCP.int64_t"></span><span class="target" id="classarrow_1_1_buffer_1a801078c559b0c351f1ca5a6b6a04488f"></span><code class="sig-name descname">Buffer</code><span class="sig-paren">(</span><em class="property">const</em> uint8_t *<em>data</em>, int64_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer6BufferEPK7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct from buffer and size without copying memory. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The passed memory must be kept alive through some other means </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">data</span></code>: a memory buffer </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">size</span></code>: buffer size</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer6BufferEN4util11string_viewE">
<span id="_CPPv3N5arrow6Buffer6BufferEN4util11string_viewE"></span><span id="_CPPv2N5arrow6Buffer6BufferEN4util11string_viewE"></span><span id="arrow::Buffer::Buffer__util::string_view"></span><span class="target" id="classarrow_1_1_buffer_1a5a918801b40b57a959dd9405f87948f2"></span><code class="sig-name descname">Buffer</code><span class="sig-paren">(</span>util::string_view <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer6BufferEN4util11string_viewE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct from string_view without copying memory. </p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>The memory viewed by data must not be deallocated in the lifetime of the <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a>; temporary rvalue strings must be stored in an lvalue somewhere </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">data</span></code>: a string_view object</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer6BufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t">
<span id="_CPPv3N5arrow6Buffer6BufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="_CPPv2N5arrow6Buffer6BufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="arrow::Buffer::Buffer__std::shared_ptr:Buffer:CR.int64_tC.int64_tC"></span><span class="target" id="classarrow_1_1_buffer_1af694696afedb9313cf5dc874ffa9a453"></span><code class="sig-name descname">Buffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6Buffer6BufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t" title="arrow::Buffer::Buffer">Buffer</a>&gt; &amp;<em>parent</em>, <em class="property">const</em> int64_t <em>offset</em>, <em class="property">const</em> int64_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer6BufferERKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An offset into data that is owned by another buffer, but we want to be able to retain a valid pointer to it even after other shared_ptr’s to the parent buffer have been destroyed. </p>
<p>This method makes no assertions about alignment or padding of the buffer but in general we expected buffers to be aligned and padded to 64 bytes. In the future we might add utility methods to help determine if a buffer satisfies this contract. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer11ToHexStringEv">
<span id="_CPPv3N5arrow6Buffer11ToHexStringEv"></span><span id="_CPPv2N5arrow6Buffer11ToHexStringEv"></span><span id="arrow::Buffer::ToHexString"></span><span class="target" id="classarrow_1_1_buffer_1adf6316bf6733c0f308dfa8f6db540b19"></span>std::string <code class="sig-name descname">ToHexString</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer11ToHexStringEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a new std::string with a hexadecimal representation of the buffer. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>std::string </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer6EqualsERK6Buffer7int64_t">
<span id="_CPPv3NK5arrow6Buffer6EqualsERK6Buffer7int64_t"></span><span id="_CPPv2NK5arrow6Buffer6EqualsERK6Buffer7int64_t"></span><span id="arrow::Buffer::Equals__BufferCR.int64_tC"></span><span class="target" id="classarrow_1_1_buffer_1a94918db73183b750716a07133dd8384d"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a> &amp;<em>other</em>, int64_t <em>nbytes</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer6EqualsERK6Buffer7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true if both buffers are the same size and contain the same bytes up to the number of compared bytes. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer6EqualsERK6Buffer">
<span id="_CPPv3NK5arrow6Buffer6EqualsERK6Buffer"></span><span id="_CPPv2NK5arrow6Buffer6EqualsERK6Buffer"></span><span id="arrow::Buffer::Equals__BufferCRC"></span><span class="target" id="classarrow_1_1_buffer_1a0d3d3bd95a3297046a6ab24f5e957bfd"></span>bool <code class="sig-name descname">Equals</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a> &amp;<em>other</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer6EqualsERK6Buffer" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return true if both buffers are the same size and contain the same bytes. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer9CopySliceEK7int64_tK7int64_tP10MemoryPool">
<span id="_CPPv3NK5arrow6Buffer9CopySliceEK7int64_tK7int64_tP10MemoryPool"></span><span id="_CPPv2NK5arrow6Buffer9CopySliceEK7int64_tK7int64_tP10MemoryPool"></span><span id="arrow::Buffer::CopySlice__int64_tC.int64_tC.MemoryPoolPC"></span><span class="target" id="classarrow_1_1_buffer_1a8e6500a2eb6667f2e7ebf0277627d435"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;&gt; <code class="sig-name descname">CopySlice</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>start</em>, <em class="property">const</em> int64_t <em>nbytes</em>, <a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em> = <a class="reference internal" href="#_CPPv4N5arrow19default_memory_poolEv" title="arrow::default_memory_pool">default_memory_pool</a>()<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer9CopySliceEK7int64_tK7int64_tP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy a section of the buffer into a new <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer11ZeroPaddingEv">
<span id="_CPPv3N5arrow6Buffer11ZeroPaddingEv"></span><span id="_CPPv2N5arrow6Buffer11ZeroPaddingEv"></span><span id="arrow::Buffer::ZeroPadding"></span><span class="target" id="classarrow_1_1_buffer_1a885f7b3329f3adb43a826e9403732a15"></span>void <code class="sig-name descname">ZeroPadding</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer11ZeroPaddingEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Zero bytes in padding, i.e. bytes between size_ and capacity_. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer8ToStringEv">
<span id="_CPPv3NK5arrow6Buffer8ToStringEv"></span><span id="_CPPv2NK5arrow6Buffer8ToStringEv"></span><span id="arrow::Buffer::ToStringC"></span><span class="target" id="classarrow_1_1_buffer_1a90034bddee753d83af07e97cdd252b8f"></span>std::string <code class="sig-name descname">ToString</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer8ToStringEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy buffer contents into a new std::string. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>std::string </p>
</dd>
<dt><strong>Note</strong></dt><dd><p>Can throw std::bad_alloc if buffer is large </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6BuffercvN4util11string_viewEEv">
<span id="_CPPv3NK5arrow6BuffercvN4util11string_viewEEv"></span><span id="_CPPv2NK5arrow6BuffercvN4util11string_viewEEv"></span><span id="arrow::Buffer::castto-util::string_view-operatorC"></span><span class="target" id="classarrow_1_1_buffer_1a3553bee276a12793c601d92789388052"></span><code class="sig-name descname">operator util::string_view</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6BuffercvN4util11string_viewEEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>View buffer contents as a util::string_view. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>util::string_view </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6BuffercvN4util10bytes_viewEEv">
<span id="_CPPv3NK5arrow6BuffercvN4util10bytes_viewEEv"></span><span id="_CPPv2NK5arrow6BuffercvN4util10bytes_viewEEv"></span><span id="arrow::Buffer::castto-util::bytes_view-operatorC"></span><span class="target" id="classarrow_1_1_buffer_1a63f0eb8387cb5a9717c11e9d5e720cbb"></span><code class="sig-name descname">operator util::bytes_view</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6BuffercvN4util10bytes_viewEEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>View buffer contents as a util::bytes_view. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>util::bytes_view </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer4dataEv">
<span id="_CPPv3NK5arrow6Buffer4dataEv"></span><span id="_CPPv2NK5arrow6Buffer4dataEv"></span><span id="arrow::Buffer::dataC"></span><span class="target" id="classarrow_1_1_buffer_1a81c3dd8c11dd804be2ada6df5ce8fad2"></span><em class="property">const</em> uint8_t *<code class="sig-name descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer4dataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a pointer to the buffer’s data. </p>
<p>The buffer has to be a CPU buffer (<code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1ad349be0b3ddf33c20e96501ad64e1ff6"><span class="std std-ref"><span class="pre">is_cpu()</span></span></a></code> is true). Otherwise, an assertion may be thrown or a null pointer may be returned.</p>
<p>To get the buffer’s data address regardless of its device, call <code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1a48683d9fd81454ba10ea0046775f38f3"><span class="std std-ref"><span class="pre">address()</span></span></a></code>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer12mutable_dataEv">
<span id="_CPPv3N5arrow6Buffer12mutable_dataEv"></span><span id="_CPPv2N5arrow6Buffer12mutable_dataEv"></span><span id="arrow::Buffer::mutable_data"></span><span class="target" id="classarrow_1_1_buffer_1a5a9cb9324d3f7e323eb070b553c925aa"></span>uint8_t *<code class="sig-name descname">mutable_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer12mutable_dataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a writable pointer to the buffer’s data. </p>
<p>The buffer has to be a mutable CPU buffer (<code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1ad349be0b3ddf33c20e96501ad64e1ff6"><span class="std std-ref"><span class="pre">is_cpu()</span></span></a></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1a8244f9c354364788161f11bedc6f2ab9"><span class="std std-ref"><span class="pre">is_mutable()</span></span></a></code> are true). Otherwise, an assertion may be thrown or a null pointer may be returned.</p>
<p>To get the buffer’s mutable data address regardless of its device, call <code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1ab7a69ac4d88bd02c39fbe57225ff387a"><span class="std std-ref"><span class="pre">mutable_address()</span></span></a></code>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer7addressEv">
<span id="_CPPv3NK5arrow6Buffer7addressEv"></span><span id="_CPPv2NK5arrow6Buffer7addressEv"></span><span id="arrow::Buffer::addressC"></span><span class="target" id="classarrow_1_1_buffer_1a48683d9fd81454ba10ea0046775f38f3"></span>uintptr_t <code class="sig-name descname">address</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer7addressEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the device address of the buffer’s data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer15mutable_addressEv">
<span id="_CPPv3NK5arrow6Buffer15mutable_addressEv"></span><span id="_CPPv2NK5arrow6Buffer15mutable_addressEv"></span><span id="arrow::Buffer::mutable_addressC"></span><span class="target" id="classarrow_1_1_buffer_1ab7a69ac4d88bd02c39fbe57225ff387a"></span>uintptr_t <code class="sig-name descname">mutable_address</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer15mutable_addressEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a writable device address to the buffer’s data. </p>
<p>The buffer has to be a mutable buffer (<code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1a8244f9c354364788161f11bedc6f2ab9"><span class="std std-ref"><span class="pre">is_mutable()</span></span></a></code> is true). Otherwise, an assertion may be thrown or 0 may be returned. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer4sizeEv">
<span id="_CPPv3NK5arrow6Buffer4sizeEv"></span><span id="_CPPv2NK5arrow6Buffer4sizeEv"></span><span id="arrow::Buffer::sizeC"></span><span class="target" id="classarrow_1_1_buffer_1a2a49871341c300996a39145d22aa8054"></span>int64_t <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the buffer’s size in bytes. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer8capacityEv">
<span id="_CPPv3NK5arrow6Buffer8capacityEv"></span><span id="_CPPv2NK5arrow6Buffer8capacityEv"></span><span id="arrow::Buffer::capacityC"></span><span class="target" id="classarrow_1_1_buffer_1a4c75902129b5f2fb471fd166907361dc"></span>int64_t <code class="sig-name descname">capacity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer8capacityEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the buffer’s capacity (number of allocated bytes) </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer6is_cpuEv">
<span id="_CPPv3NK5arrow6Buffer6is_cpuEv"></span><span id="_CPPv2NK5arrow6Buffer6is_cpuEv"></span><span id="arrow::Buffer::is_cpuC"></span><span class="target" id="classarrow_1_1_buffer_1ad349be0b3ddf33c20e96501ad64e1ff6"></span>bool <code class="sig-name descname">is_cpu</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer6is_cpuEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether the buffer is directly CPU-accessible. </p>
<p>If this function returns true, you can read directly from the buffer’s <code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1a81c3dd8c11dd804be2ada6df5ce8fad2"><span class="std std-ref"><span class="pre">data()</span></span></a></code> pointer. Otherwise, you’ll have to <code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1ac4b959d7080e383ab0a9ff54d8dd9fa3"><span class="std std-ref"><span class="pre">View()</span></span></a></code> or <code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1a9dcc66ada966d56a9294531e72a0e1d9"><span class="std std-ref"><span class="pre">Copy()</span></span></a></code> it. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow6Buffer10is_mutableEv">
<span id="_CPPv3NK5arrow6Buffer10is_mutableEv"></span><span id="_CPPv2NK5arrow6Buffer10is_mutableEv"></span><span id="arrow::Buffer::is_mutableC"></span><span class="target" id="classarrow_1_1_buffer_1a8244f9c354364788161f11bedc6f2ab9"></span>bool <code class="sig-name descname">is_mutable</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow6Buffer10is_mutableEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Whether the buffer is mutable. </p>
<p>If this function returns true, you are allowed to modify buffer contents using the pointer returned by <code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1a5a9cb9324d3f7e323eb070b553c925aa"><span class="std std-ref"><span class="pre">mutable_data()</span></span></a></code> or <code class="docutils literal notranslate"><a class="reference internal" href="#classarrow_1_1_buffer_1ab7a69ac4d88bd02c39fbe57225ff387a"><span class="std std-ref"><span class="pre">mutable_address()</span></span></a></code>. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer10FromStringENSt6stringE">
<span id="_CPPv3N5arrow6Buffer10FromStringENSt6stringE"></span><span id="_CPPv2N5arrow6Buffer10FromStringENSt6stringE"></span><span id="arrow::Buffer::FromString__ss"></span><span class="target" id="classarrow_1_1_buffer_1aa88d832230101259ad4f06cbb4c27582"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">FromString</code><span class="sig-paren">(</span>std::string <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer10FromStringENSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an immutable buffer that takes ownership of the contents of an std::string (without copying it). </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> instance </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">data</span></code>: a string to own </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN5arrow6Buffer4WrapENSt10shared_ptrI6BufferEEPK1T8SizeType">
<span id="_CPPv3I00EN5arrow6Buffer4WrapEPK1T8SizeType"></span><span id="_CPPv2I00EN5arrow6Buffer4WrapEPK1T8SizeType"></span>template&lt;typename <code class="sig-name descname">T</code>, typename <code class="sig-name descname">SizeType</code> = int64_t&gt;<br /><span class="target" id="classarrow_1_1_buffer_1abd877e4c900427798762d0abaa92b679"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">Wrap</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I00EN5arrow6Buffer4WrapENSt10shared_ptrI6BufferEEPK1T8SizeType" title="arrow::Buffer::Wrap::T">T</a> *<em>data</em>, <a class="reference internal" href="#_CPPv4I00EN5arrow6Buffer4WrapENSt10shared_ptrI6BufferEEPK1T8SizeType" title="arrow::Buffer::Wrap::SizeType">SizeType</a> <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN5arrow6Buffer4WrapENSt10shared_ptrI6BufferEEPK1T8SizeType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create buffer referencing typed memory with some length without copying. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new shared_ptr&lt;Buffer&gt; </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">data</span></code>: the typed memory as C array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">length</span></code>: the number of values in the array </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0EN5arrow6Buffer4WrapENSt10shared_ptrI6BufferEERKNSt6vectorI1TEE">
<span id="_CPPv3I0EN5arrow6Buffer4WrapERKNSt6vectorI1TEE"></span><span id="_CPPv2I0EN5arrow6Buffer4WrapERKNSt6vectorI1TEE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classarrow_1_1_buffer_1a62d1926a69dd12ce6821dd8c96eafea2"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">Wrap</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I0EN5arrow6Buffer4WrapENSt10shared_ptrI6BufferEERKNSt6vectorI1TEE" title="arrow::Buffer::Wrap::T">T</a>&gt; &amp;<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN5arrow6Buffer4WrapENSt10shared_ptrI6BufferEERKNSt6vectorI1TEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create buffer referencing std::vector with some length without copying. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new shared_ptr&lt;Buffer&gt; </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">data</span></code>: the vector to be referenced. If this vector is changed, the buffer may become invalid </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer9GetReaderENSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow6Buffer9GetReaderENSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow6Buffer9GetReaderENSt10shared_ptrI6BufferEE"></span><span id="arrow::Buffer::GetReader__std::shared_ptr:Buffer:"></span><span class="target" id="classarrow_1_1_buffer_1ae2eded44b1379542966cd441a49fe953"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;io::<a class="reference internal" href="io.html#_CPPv4N5arrow2io16RandomAccessFileE" title="arrow::io::RandomAccessFile">RandomAccessFile</a>&gt;&gt; <code class="sig-name descname">GetReader</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer9GetReaderENSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a RandomAccessFile for reading a buffer. </p>
<p>The returned file object reads from this buffer’s underlying memory. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer9GetWriterENSt10shared_ptrI6BufferEE">
<span id="_CPPv3N5arrow6Buffer9GetWriterENSt10shared_ptrI6BufferEE"></span><span id="_CPPv2N5arrow6Buffer9GetWriterENSt10shared_ptrI6BufferEE"></span><span id="arrow::Buffer::GetWriter__std::shared_ptr:Buffer:"></span><span class="target" id="classarrow_1_1_buffer_1a3131f10cde81c53e4d6615eb5e4850ec"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;io::<a class="reference internal" href="io.html#_CPPv4N5arrow2io12OutputStreamE" title="arrow::io::OutputStream">OutputStream</a>&gt;&gt; <code class="sig-name descname">GetWriter</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer9GetWriterENSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a OutputStream for writing to a buffer. </p>
<p>The buffer must be mutable. The returned stream object writes into the buffer’s underlying memory (but it won’t resize it). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer4CopyENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE">
<span id="_CPPv3N5arrow6Buffer4CopyENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="_CPPv2N5arrow6Buffer4CopyENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="arrow::Buffer::Copy__std::shared_ptr:Buffer:.std::shared_ptr:MemoryManager:CR"></span><span class="target" id="classarrow_1_1_buffer_1a9dcc66ada966d56a9294531e72a0e1d9"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;&gt; <code class="sig-name descname">Copy</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>source</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt; &amp;<em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer4CopyENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy buffer. </p>
<p>The buffer contents will be copied into a new buffer allocated by the given <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>. This function supports cross-device copies. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer4ViewENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE">
<span id="_CPPv3N5arrow6Buffer4ViewENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="_CPPv2N5arrow6Buffer4ViewENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="arrow::Buffer::View__std::shared_ptr:Buffer:.std::shared_ptr:MemoryManager:CR"></span><span class="target" id="classarrow_1_1_buffer_1ac4b959d7080e383ab0a9ff54d8dd9fa3"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;&gt; <code class="sig-name descname">View</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>source</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt; &amp;<em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer4ViewENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>View buffer. </p>
<p>Return a <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> that reflects this buffer, seen potentially from another device, without making an explicit copy of the contents. The underlying mechanism is typically implemented by the kernel or device driver, and may involve lazy caching of parts of the buffer contents on the destination device’s memory.</p>
<p>If a non-copy view is unsupported for the buffer on the given device, nullptr is returned. An error can be returned if some low-level operation fails (such as an out-of-memory condition). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow6Buffer10ViewOrCopyENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE">
<span id="_CPPv3N5arrow6Buffer10ViewOrCopyENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="_CPPv2N5arrow6Buffer10ViewOrCopyENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE"></span><span id="arrow::Buffer::ViewOrCopy__std::shared_ptr:Buffer:.std::shared_ptr:MemoryManager:CR"></span><span class="target" id="classarrow_1_1_buffer_1ac54ad71b05ab0d1847bc6b8921399752"></span><a class="reference internal" href="support.html#_CPPv4I0EN5arrow6ResultE" title="arrow::Result">Result</a>&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt;&gt; <code class="sig-name descname">ViewOrCopy</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <em>source</em>, <em class="property">const</em> std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow13MemoryManagerE" title="arrow::MemoryManager">MemoryManager</a>&gt; &amp;<em>to</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow6Buffer10ViewOrCopyENSt10shared_ptrI6BufferEERKNSt10shared_ptrI13MemoryManagerEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>View or copy buffer. </p>
<p>Try to view buffer contents on the given <a class="reference internal" href="#classarrow_1_1_memory_manager"><span class="std std-ref">MemoryManager</span></a>’s device, but fall back to copying if a no-copy view isn’t supported. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow13MutableBufferE">
<span id="_CPPv3N5arrow13MutableBufferE"></span><span id="_CPPv2N5arrow13MutableBufferE"></span><span id="arrow::MutableBuffer"></span><span class="target" id="classarrow_1_1_mutable_buffer"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">MutableBuffer</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a><a class="headerlink" href="#_CPPv4N5arrow13MutableBufferE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> whose contents can be mutated. </p>
<p>May or may not own its data. </p>
<p>Subclassed by <a class="reference internal" href="cuda.html#classarrow_1_1cuda_1_1_cuda_host_buffer"><span class="std std-ref">arrow::cuda::CudaHostBuffer</span></a>, <a class="reference internal" href="#classarrow_1_1_resizable_buffer"><span class="std std-ref">arrow::ResizableBuffer</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4I00EN5arrow13MutableBuffer4WrapENSt10shared_ptrI6BufferEEP1T8SizeType">
<span id="_CPPv3I00EN5arrow13MutableBuffer4WrapEP1T8SizeType"></span><span id="_CPPv2I00EN5arrow13MutableBuffer4WrapEP1T8SizeType"></span>template&lt;typename <code class="sig-name descname">T</code>, typename <code class="sig-name descname">SizeType</code> = int64_t&gt;<br /><span class="target" id="classarrow_1_1_mutable_buffer_1ae06e3a980614bc6db4239e337f721b33"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; <code class="sig-name descname">Wrap</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN5arrow13MutableBuffer4WrapENSt10shared_ptrI6BufferEEP1T8SizeType" title="arrow::MutableBuffer::Wrap::T">T</a> *<em>data</em>, <a class="reference internal" href="#_CPPv4I00EN5arrow13MutableBuffer4WrapENSt10shared_ptrI6BufferEEP1T8SizeType" title="arrow::MutableBuffer::Wrap::SizeType">SizeType</a> <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN5arrow13MutableBuffer4WrapENSt10shared_ptrI6BufferEEP1T8SizeType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create buffer referencing typed memory with some length. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a new shared_ptr&lt;Buffer&gt; </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">data</span></code>: the typed memory as C array </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">length</span></code>: the number of values in the array </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow15ResizableBufferE">
<span id="_CPPv3N5arrow15ResizableBufferE"></span><span id="_CPPv2N5arrow15ResizableBufferE"></span><span id="arrow::ResizableBuffer"></span><span class="target" id="classarrow_1_1_resizable_buffer"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">ResizableBuffer</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow13MutableBufferE" title="arrow::MutableBuffer">MutableBuffer</a><a class="headerlink" href="#_CPPv4N5arrow15ResizableBufferE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A mutable buffer that can be resized. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow15ResizableBuffer6ResizeEK7int64_tb">
<span id="_CPPv3N5arrow15ResizableBuffer6ResizeEK7int64_tb"></span><span id="_CPPv2N5arrow15ResizableBuffer6ResizeEK7int64_tb"></span><span id="arrow::ResizableBuffer::Resize__int64_tC.b"></span><span class="target" id="classarrow_1_1_resizable_buffer_1ac2d6a69440b5f438f1b02c610622d8f2"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Resize</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>new_size</em>, bool <em>shrink_to_fit</em> = true<span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow15ResizableBuffer6ResizeEK7int64_tb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Change buffer reported size to indicated size, allocating memory if necessary. </p>
<p>This will ensure that the capacity of the buffer is a multiple of 64 bytes as defined in Layout.md. Consider using ZeroPadding afterwards, to conform to the Arrow layout specification.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new_size</span></code>: The new size for the buffer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shrink_to_fit</span></code>: Whether to shrink the capacity if new size &lt; current size </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow15ResizableBuffer7ReserveEK7int64_t">
<span id="_CPPv3N5arrow15ResizableBuffer7ReserveEK7int64_t"></span><span id="_CPPv2N5arrow15ResizableBuffer7ReserveEK7int64_t"></span><span id="arrow::ResizableBuffer::Reserve__int64_tC"></span><span class="target" id="classarrow_1_1_resizable_buffer_1ae3e4b7569105c6cd980ab2d10b5bbf73"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Reserve</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>new_capacity</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow15ResizableBuffer7ReserveEK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ensure that buffer has enough memory allocated to fit the indicated capacity (and meets the 64 byte padding requirement in Layout.md). </p>
<p>It does not change buffer’s reported size and doesn’t zero the padding. </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="memory-pools">
<h2>Memory Pools<a class="headerlink" href="#memory-pools" title="Permalink to this headline">¶</a></h2>
<dl class="cpp function">
<dt id="_CPPv4N5arrow19default_memory_poolEv">
<span id="_CPPv3N5arrow19default_memory_poolEv"></span><span id="_CPPv2N5arrow19default_memory_poolEv"></span><span id="arrow::default_memory_pool"></span><span class="target" id="namespacearrow_1aebe81d544faaf827b8f32c5a80b99820"></span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">default_memory_pool</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow19default_memory_poolEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the process-wide default memory pool. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow20jemalloc_memory_poolEPP10MemoryPool">
<span id="_CPPv3N5arrow20jemalloc_memory_poolEPP10MemoryPool"></span><span id="_CPPv2N5arrow20jemalloc_memory_poolEPP10MemoryPool"></span><span id="arrow::jemalloc_memory_pool__MemoryPoolPP"></span><span class="target" id="namespacearrow_1a07e44d557d9f98ba7a42bbcba1fb7698"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">jemalloc_memory_pool</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> **<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow20jemalloc_memory_poolEPP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a process-wide memory pool based on jemalloc. </p>
<p>May return NotImplemented if jemalloc is not available. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow20mimalloc_memory_poolEPP10MemoryPool">
<span id="_CPPv3N5arrow20mimalloc_memory_poolEPP10MemoryPool"></span><span id="_CPPv2N5arrow20mimalloc_memory_poolEPP10MemoryPool"></span><span id="arrow::mimalloc_memory_pool__MemoryPoolPP"></span><span class="target" id="namespacearrow_1af03def88fd1ab05b0df699df9c3b9754"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">mimalloc_memory_pool</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> **<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow20mimalloc_memory_poolEPP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a process-wide memory pool based on mimalloc. </p>
<p>May return NotImplemented if mimalloc is not available. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow18system_memory_poolEv">
<span id="_CPPv3N5arrow18system_memory_poolEv"></span><span id="_CPPv2N5arrow18system_memory_poolEv"></span><span id="arrow::system_memory_pool"></span><span class="target" id="namespacearrow_1aab2dcf4f3003c334c3a337d65657e4c5"></span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">system_memory_pool</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow18system_memory_poolEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a process-wide memory pool based on the system allocator. </p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow10MemoryPoolE">
<span id="_CPPv3N5arrow10MemoryPoolE"></span><span id="_CPPv2N5arrow10MemoryPoolE"></span><span id="arrow::MemoryPool"></span><span class="target" id="classarrow_1_1_memory_pool"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">MemoryPool</code><a class="headerlink" href="#_CPPv4N5arrow10MemoryPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for memory allocation on the CPU. </p>
<p>Besides tracking the number of allocated bytes, the allocator also should take care of the required 64-byte alignment. </p>
<p>Subclassed by <a class="reference internal" href="#classarrow_1_1_logging_memory_pool"><span class="std std-ref">arrow::LoggingMemoryPool</span></a>, <a class="reference internal" href="#classarrow_1_1_proxy_memory_pool"><span class="std std-ref">arrow::ProxyMemoryPool</span></a>, <a class="reference internal" href="#classarrow_1_1stl_1_1_s_t_l_memory_pool"><span class="std std-ref">arrow::stl::STLMemoryPool&lt; Allocator &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow10MemoryPool8AllocateE7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow10MemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow10MemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="arrow::MemoryPool::Allocate__int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_memory_pool_1afa452b21a4d401403cc509cc50a384f9"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Allocate</code><span class="sig-paren">(</span>int64_t <em>size</em>, uint8_t **<em>out</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow10MemoryPool8AllocateE7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new memory region of at least size bytes. </p>
<p>The allocated region shall be 64-byte aligned. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow10MemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow10MemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow10MemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="arrow::MemoryPool::Reallocate__int64_t.int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_memory_pool_1af64bda5eccc8fa42ce9ae0aba1ad9077"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Reallocate</code><span class="sig-paren">(</span>int64_t <em>old_size</em>, int64_t <em>new_size</em>, uint8_t **<em>ptr</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow10MemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize an already allocated memory section. </p>
<p>As by default most default allocators on a platform don’t support aligned reallocation, this function can involve a copy of the underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow10MemoryPool4FreeEP7uint8_t7int64_t">
<span id="_CPPv3N5arrow10MemoryPool4FreeEP7uint8_t7int64_t"></span><span id="_CPPv2N5arrow10MemoryPool4FreeEP7uint8_t7int64_t"></span><span id="arrow::MemoryPool::Free__uint8_tP.int64_t"></span><span class="target" id="classarrow_1_1_memory_pool_1a5a45c822a4ca7b3d8387501acfa69911"></span>void <code class="sig-name descname">Free</code><span class="sig-paren">(</span>uint8_t *<em>buffer</em>, int64_t <em>size</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N5arrow10MemoryPool4FreeEP7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an allocated region. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Pointer to the start of the allocated memory region </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: Allocated size located at buffer. An allocator implementation may use this for tracking the amount of allocated bytes as well as for faster deallocation if supported by its backend. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow10MemoryPool15bytes_allocatedEv">
<span id="_CPPv3NK5arrow10MemoryPool15bytes_allocatedEv"></span><span id="_CPPv2NK5arrow10MemoryPool15bytes_allocatedEv"></span><span id="arrow::MemoryPool::bytes_allocatedC"></span><span class="target" id="classarrow_1_1_memory_pool_1abd12cd4bfb8ce8afcfc7a25d0293cd85"></span>int64_t <code class="sig-name descname">bytes_allocated</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrow10MemoryPool15bytes_allocatedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes that were allocated and not yet free’d through this allocator. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow10MemoryPool10max_memoryEv">
<span id="_CPPv3NK5arrow10MemoryPool10max_memoryEv"></span><span id="_CPPv2NK5arrow10MemoryPool10max_memoryEv"></span><span id="arrow::MemoryPool::max_memoryC"></span><span class="target" id="classarrow_1_1_memory_pool_1a4d1fe541389b4afd4d49d727dc3088f0"></span>int64_t <code class="sig-name descname">max_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK5arrow10MemoryPool10max_memoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return peak memory allocation in this memory pool. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Maximum bytes allocated. If not known (or not implemented), returns -1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow10MemoryPool12backend_nameEv">
<span id="_CPPv3NK5arrow10MemoryPool12backend_nameEv"></span><span id="_CPPv2NK5arrow10MemoryPool12backend_nameEv"></span><span id="arrow::MemoryPool::backend_nameC"></span><span class="target" id="classarrow_1_1_memory_pool_1a60f07985878503603da92c64ab4ba03c"></span>std::string <code class="sig-name descname">backend_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK5arrow10MemoryPool12backend_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The name of the backend used by this <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> (e.g. “system” or “jemalloc”). </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow10MemoryPool13CreateDefaultEv">
<span id="_CPPv3N5arrow10MemoryPool13CreateDefaultEv"></span><span id="_CPPv2N5arrow10MemoryPool13CreateDefaultEv"></span><span id="arrow::MemoryPool::CreateDefault"></span><span class="target" id="classarrow_1_1_memory_pool_1a844c3276d2f14daf186ceb9585fe3581"></span>std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a>&gt; <code class="sig-name descname">CreateDefault</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow10MemoryPool13CreateDefaultEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>EXPERIMENTAL. Create a new instance of the default <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a>. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow17LoggingMemoryPoolE">
<span id="_CPPv3N5arrow17LoggingMemoryPoolE"></span><span id="_CPPv2N5arrow17LoggingMemoryPoolE"></span><span id="arrow::LoggingMemoryPool"></span><span class="target" id="classarrow_1_1_logging_memory_pool"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">LoggingMemoryPool</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a><a class="headerlink" href="#_CPPv4N5arrow17LoggingMemoryPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow17LoggingMemoryPool8AllocateE7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow17LoggingMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow17LoggingMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="arrow::LoggingMemoryPool::Allocate__int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1a3eb03f4e10b9fbf1e06fd72d65b6601c"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Allocate</code><span class="sig-paren">(</span>int64_t <em>size</em>, uint8_t **<em>out</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow17LoggingMemoryPool8AllocateE7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new memory region of at least size bytes. </p>
<p>The allocated region shall be 64-byte aligned. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow17LoggingMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow17LoggingMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow17LoggingMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="arrow::LoggingMemoryPool::Reallocate__int64_t.int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1a3e548a7bc1d434fa30fbe1e43be52a3b"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Reallocate</code><span class="sig-paren">(</span>int64_t <em>old_size</em>, int64_t <em>new_size</em>, uint8_t **<em>ptr</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow17LoggingMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize an already allocated memory section. </p>
<p>As by default most default allocators on a platform don’t support aligned reallocation, this function can involve a copy of the underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow17LoggingMemoryPool4FreeEP7uint8_t7int64_t">
<span id="_CPPv3N5arrow17LoggingMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="_CPPv2N5arrow17LoggingMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="arrow::LoggingMemoryPool::Free__uint8_tP.int64_t"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1ac68ae6be2a6b8c2c44e0ad6d0c2b0cc8"></span>void <code class="sig-name descname">Free</code><span class="sig-paren">(</span>uint8_t *<em>buffer</em>, int64_t <em>size</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow17LoggingMemoryPool4FreeEP7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an allocated region. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Pointer to the start of the allocated memory region </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: Allocated size located at buffer. An allocator implementation may use this for tracking the amount of allocated bytes as well as for faster deallocation if supported by its backend. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow17LoggingMemoryPool15bytes_allocatedEv">
<span id="_CPPv3NK5arrow17LoggingMemoryPool15bytes_allocatedEv"></span><span id="_CPPv2NK5arrow17LoggingMemoryPool15bytes_allocatedEv"></span><span id="arrow::LoggingMemoryPool::bytes_allocatedC"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1aa5a4ee8ec0299fea7125d89dc8553a46"></span>int64_t <code class="sig-name descname">bytes_allocated</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow17LoggingMemoryPool15bytes_allocatedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes that were allocated and not yet free’d through this allocator. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow17LoggingMemoryPool10max_memoryEv">
<span id="_CPPv3NK5arrow17LoggingMemoryPool10max_memoryEv"></span><span id="_CPPv2NK5arrow17LoggingMemoryPool10max_memoryEv"></span><span id="arrow::LoggingMemoryPool::max_memoryC"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1af41a546412c98aa4439b53ec4df257bf"></span>int64_t <code class="sig-name descname">max_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow17LoggingMemoryPool10max_memoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return peak memory allocation in this memory pool. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Maximum bytes allocated. If not known (or not implemented), returns -1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow17LoggingMemoryPool12backend_nameEv">
<span id="_CPPv3NK5arrow17LoggingMemoryPool12backend_nameEv"></span><span id="_CPPv2NK5arrow17LoggingMemoryPool12backend_nameEv"></span><span id="arrow::LoggingMemoryPool::backend_nameC"></span><span class="target" id="classarrow_1_1_logging_memory_pool_1a446cdea471c19b84c1494727f6321eaf"></span>std::string <code class="sig-name descname">backend_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow17LoggingMemoryPool12backend_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The name of the backend used by this <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> (e.g. “system” or “jemalloc”). </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4N5arrow15ProxyMemoryPoolE">
<span id="_CPPv3N5arrow15ProxyMemoryPoolE"></span><span id="_CPPv2N5arrow15ProxyMemoryPoolE"></span><span id="arrow::ProxyMemoryPool"></span><span class="target" id="classarrow_1_1_proxy_memory_pool"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">ProxyMemoryPool</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a><a class="headerlink" href="#_CPPv4N5arrow15ProxyMemoryPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Derived class for memory allocation. </p>
<p>Tracks the number of bytes and maximum memory allocated through its direct calls. Actual allocation is delegated to <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> class. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow15ProxyMemoryPool8AllocateE7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow15ProxyMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow15ProxyMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="arrow::ProxyMemoryPool::Allocate__int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1a335a8650da63a1ebf8ecbdf692e512b5"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Allocate</code><span class="sig-paren">(</span>int64_t <em>size</em>, uint8_t **<em>out</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow15ProxyMemoryPool8AllocateE7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new memory region of at least size bytes. </p>
<p>The allocated region shall be 64-byte aligned. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow15ProxyMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow15ProxyMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow15ProxyMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="arrow::ProxyMemoryPool::Reallocate__int64_t.int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1a6e21a87edb6fac307950ba03900ea5cc"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Reallocate</code><span class="sig-paren">(</span>int64_t <em>old_size</em>, int64_t <em>new_size</em>, uint8_t **<em>ptr</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow15ProxyMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize an already allocated memory section. </p>
<p>As by default most default allocators on a platform don’t support aligned reallocation, this function can involve a copy of the underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow15ProxyMemoryPool4FreeEP7uint8_t7int64_t">
<span id="_CPPv3N5arrow15ProxyMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="_CPPv2N5arrow15ProxyMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="arrow::ProxyMemoryPool::Free__uint8_tP.int64_t"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1ac93a0a8e3f1c5274ecee4d59499a6888"></span>void <code class="sig-name descname">Free</code><span class="sig-paren">(</span>uint8_t *<em>buffer</em>, int64_t <em>size</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow15ProxyMemoryPool4FreeEP7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an allocated region. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Pointer to the start of the allocated memory region </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: Allocated size located at buffer. An allocator implementation may use this for tracking the amount of allocated bytes as well as for faster deallocation if supported by its backend. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow15ProxyMemoryPool15bytes_allocatedEv">
<span id="_CPPv3NK5arrow15ProxyMemoryPool15bytes_allocatedEv"></span><span id="_CPPv2NK5arrow15ProxyMemoryPool15bytes_allocatedEv"></span><span id="arrow::ProxyMemoryPool::bytes_allocatedC"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1ae067aaf2cbe1dd6ea54ec01d835131cc"></span>int64_t <code class="sig-name descname">bytes_allocated</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow15ProxyMemoryPool15bytes_allocatedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes that were allocated and not yet free’d through this allocator. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow15ProxyMemoryPool10max_memoryEv">
<span id="_CPPv3NK5arrow15ProxyMemoryPool10max_memoryEv"></span><span id="_CPPv2NK5arrow15ProxyMemoryPool10max_memoryEv"></span><span id="arrow::ProxyMemoryPool::max_memoryC"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1a0369b487efeb564ff40ed1101d86e8ad"></span>int64_t <code class="sig-name descname">max_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow15ProxyMemoryPool10max_memoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return peak memory allocation in this memory pool. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Maximum bytes allocated. If not known (or not implemented), returns -1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow15ProxyMemoryPool12backend_nameEv">
<span id="_CPPv3NK5arrow15ProxyMemoryPool12backend_nameEv"></span><span id="_CPPv2NK5arrow15ProxyMemoryPool12backend_nameEv"></span><span id="arrow::ProxyMemoryPool::backend_nameC"></span><span class="target" id="classarrow_1_1_proxy_memory_pool_1ac2eefc2b95c22f393fb6212954737c3f"></span>std::string <code class="sig-name descname">backend_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow15ProxyMemoryPool12backend_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The name of the backend used by this <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> (e.g. “system” or “jemalloc”). </p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="allocation-functions">
<h2>Allocation Functions<a class="headerlink" href="#allocation-functions" title="Permalink to this headline">¶</a></h2>
<p>These functions allocate a buffer from a particular memory pool.</p>
<dl class="cpp function">
<dt id="_CPPv414AllocateBufferK7int64_tP10MemoryPool">
<span id="_CPPv314AllocateBufferK7int64_tP10MemoryPool"></span><span id="_CPPv214AllocateBufferK7int64_tP10MemoryPool"></span><span id="AllocateBuffer__int64_tC.MemoryPoolP"></span><span class="target" id="group__buffer-allocation-functions_1gab7eeff2b27bb71cb821a1005d1d0a9be"></span>Result&lt;std::unique_ptr&lt;Buffer&gt;&gt; <code class="sig-name descname">AllocateBuffer</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>size</em>, MemoryPool *<em>pool</em> = NULLPTR<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414AllocateBufferK7int64_tP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a fixed size mutable buffer from a memory pool, zero its padding. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">size</span></code>: size of buffer to allocate </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: a memory pool </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv423AllocateResizableBufferK7int64_tP10MemoryPool">
<span id="_CPPv323AllocateResizableBufferK7int64_tP10MemoryPool"></span><span id="_CPPv223AllocateResizableBufferK7int64_tP10MemoryPool"></span><span id="AllocateResizableBuffer__int64_tC.MemoryPoolP"></span><span class="target" id="group__buffer-allocation-functions_1gaa44d72e6284de08b2171a710a01de2d6"></span>Result&lt;std::unique_ptr&lt;ResizableBuffer&gt;&gt; <code class="sig-name descname">AllocateResizableBuffer</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>size</em>, MemoryPool *<em>pool</em> = NULLPTR<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv423AllocateResizableBufferK7int64_tP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a resizeable buffer from a memory pool, zero its padding. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">size</span></code>: size of buffer to allocate </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: a memory pool </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv414AllocateBitmap7int64_tP10MemoryPool">
<span id="_CPPv314AllocateBitmap7int64_tP10MemoryPool"></span><span id="_CPPv214AllocateBitmap7int64_tP10MemoryPool"></span><span id="AllocateBitmap__int64_t.MemoryPoolP"></span><span class="target" id="group__buffer-allocation-functions_1ga4726342b8bd298b7bf05f741076e7527"></span>Result&lt;std::shared_ptr&lt;Buffer&gt;&gt; <code class="sig-name descname">AllocateBitmap</code><span class="sig-paren">(</span>int64_t <em>length</em>, MemoryPool *<em>pool</em> = NULLPTR<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414AllocateBitmap7int64_tP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a bitmap buffer from a memory pool no guarantee on values is provided. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">length</span></code>: size in bits of bitmap to allocate </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: memory pool to allocate memory from </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv414AllocateBitmapP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE">
<span id="_CPPv314AllocateBitmapP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv214AllocateBitmapP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE"></span><span id="AllocateBitmap__MemoryPoolP.int64_t.std::shared_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga93c20471c43a7a35eaabf2506d5b533e"></span>Status <code class="sig-name descname">AllocateBitmap</code><span class="sig-paren">(</span>MemoryPool *<em>pool</em>, int64_t <em>length</em>, std::shared_ptr&lt;Buffer&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414AllocateBitmapP10MemoryPool7int64_tPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt id="_CPPv419AllocateEmptyBitmap7int64_tP10MemoryPool">
<span id="_CPPv319AllocateEmptyBitmap7int64_tP10MemoryPool"></span><span id="_CPPv219AllocateEmptyBitmap7int64_tP10MemoryPool"></span><span id="AllocateEmptyBitmap__int64_t.MemoryPoolP"></span><span class="target" id="group__buffer-allocation-functions_1ga4bdacf00a6041fa3825f419698c7c40c"></span>Result&lt;std::shared_ptr&lt;Buffer&gt;&gt; <code class="sig-name descname">AllocateEmptyBitmap</code><span class="sig-paren">(</span>int64_t <em>length</em>, MemoryPool *<em>pool</em> = NULLPTR<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419AllocateEmptyBitmap7int64_tP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a zero-initialized bitmap buffer from a memory pool. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">length</span></code>: size in bits of bitmap to allocate </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: memory pool to allocate memory from </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv418ConcatenateBuffersRK12BufferVectorP10MemoryPool">
<span id="_CPPv318ConcatenateBuffersRK12BufferVectorP10MemoryPool"></span><span id="_CPPv218ConcatenateBuffersRK12BufferVectorP10MemoryPool"></span><span id="ConcatenateBuffers__BufferVectorCR.MemoryPoolP"></span><span class="target" id="group__buffer-allocation-functions_1ga614382b33dc47fa784c7a4b3be2c0f59"></span>Result&lt;std::shared_ptr&lt;Buffer&gt;&gt; <code class="sig-name descname">ConcatenateBuffers</code><span class="sig-paren">(</span><em class="property">const</em> BufferVector &amp;<em>buffers</em>, MemoryPool *<em>pool</em> = NULLPTR<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418ConcatenateBuffersRK12BufferVectorP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Concatenate multiple buffers into a single buffer. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">buffers</span></code>: to be concatenated </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">pool</span></code>: memory pool to allocate the new buffer from </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv418ConcatenateBuffersRK12BufferVectorP10MemoryPoolPNSt10shared_ptrI6BufferEE">
<span id="_CPPv318ConcatenateBuffersRK12BufferVectorP10MemoryPoolPNSt10shared_ptrI6BufferEE"></span><span id="_CPPv218ConcatenateBuffersRK12BufferVectorP10MemoryPoolPNSt10shared_ptrI6BufferEE"></span><span id="ConcatenateBuffers__BufferVectorCR.MemoryPoolP.std::shared_ptr:Buffer:P"></span><span class="target" id="group__buffer-allocation-functions_1ga193a7618d4456e8d4f40d305c8d683f1"></span>Status <code class="sig-name descname">ConcatenateBuffers</code><span class="sig-paren">(</span><em class="property">const</em> BufferVector &amp;<em>buffers</em>, MemoryPool *<em>pool</em>, std::shared_ptr&lt;Buffer&gt; *<em>out</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418ConcatenateBuffersRK12BufferVectorP10MemoryPoolPNSt10shared_ptrI6BufferEE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="slicing">
<h2>Slicing<a class="headerlink" href="#slicing" title="Permalink to this headline">¶</a></h2>
<dl class="cpp function">
<dt id="_CPPv411SliceBufferRKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t">
<span id="_CPPv311SliceBufferRKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="_CPPv211SliceBufferRKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="SliceBuffer__std::shared_ptr:Buffer:CR.int64_tC.int64_tC"></span><span class="target" id="group__buffer-slicing-functions_1ga23386d14ecaa97d5c1c93b53676c34e2"></span>std::shared_ptr&lt;Buffer&gt; <code class="sig-name descname">SliceBuffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;Buffer&gt; &amp;<em>buffer</em>, <em class="property">const</em> int64_t <em>offset</em>, <em class="property">const</em> int64_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411SliceBufferRKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a view on a buffer at the given offset and length. </p>
<p>This function cannot fail and does not check for errors (except in debug builds) </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv411SliceBufferRKNSt10shared_ptrI6BufferEEK7int64_t">
<span id="_CPPv311SliceBufferRKNSt10shared_ptrI6BufferEEK7int64_t"></span><span id="_CPPv211SliceBufferRKNSt10shared_ptrI6BufferEEK7int64_t"></span><span id="SliceBuffer__std::shared_ptr:Buffer:CR.int64_tC"></span><span class="target" id="group__buffer-slicing-functions_1gab051c8518e0c9881042fdf8cf1416cbe"></span>std::shared_ptr&lt;Buffer&gt; <code class="sig-name descname">SliceBuffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;Buffer&gt; &amp;<em>buffer</em>, <em class="property">const</em> int64_t <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411SliceBufferRKNSt10shared_ptrI6BufferEEK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a view on a buffer at the given offset, up to the buffer’s end. </p>
<p>This function cannot fail and does not check for errors (except in debug builds) </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv415SliceBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t">
<span id="_CPPv315SliceBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t"></span><span id="_CPPv215SliceBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t"></span><span id="SliceBufferSafe__std::shared_ptr:Buffer:CR.int64_t"></span><span class="target" id="group__buffer-slicing-functions_1ga41e702cd989315011f8068b2392faa11"></span>Result&lt;std::shared_ptr&lt;Buffer&gt;&gt; <code class="sig-name descname">SliceBufferSafe</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;Buffer&gt; &amp;<em>buffer</em>, int64_t <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415SliceBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Input-checking version of SliceBuffer. </p>
<p>An Invalid <a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> is returned if the requested slice falls out of bounds. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv415SliceBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t7int64_t">
<span id="_CPPv315SliceBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="_CPPv215SliceBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="SliceBufferSafe__std::shared_ptr:Buffer:CR.int64_t.int64_t"></span><span class="target" id="group__buffer-slicing-functions_1ga4c77ebd80eeabc2efd018f670a4d29ee"></span>Result&lt;std::shared_ptr&lt;Buffer&gt;&gt; <code class="sig-name descname">SliceBufferSafe</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;Buffer&gt; &amp;<em>buffer</em>, int64_t <em>offset</em>, int64_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415SliceBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Input-checking version of SliceBuffer. </p>
<p>An Invalid <a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> is returned if the requested slice falls out of bounds. Note that unlike SliceBuffer, <code class="docutils literal notranslate"><span class="pre">length</span></code> isn’t clamped to the available buffer size. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv418SliceMutableBufferRKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t">
<span id="_CPPv318SliceMutableBufferRKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="_CPPv218SliceMutableBufferRKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t"></span><span id="SliceMutableBuffer__std::shared_ptr:Buffer:CR.int64_tC.int64_tC"></span><span class="target" id="group__buffer-slicing-functions_1ga44c8f98a2874248eb7d5658ccee5718e"></span>std::shared_ptr&lt;Buffer&gt; <code class="sig-name descname">SliceMutableBuffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;Buffer&gt; &amp;<em>buffer</em>, <em class="property">const</em> int64_t <em>offset</em>, <em class="property">const</em> int64_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418SliceMutableBufferRKNSt10shared_ptrI6BufferEEK7int64_tK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Like SliceBuffer, but construct a mutable buffer slice. </p>
<p>If the parent buffer is not mutable, behavior is undefined (it may abort in debug builds). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv418SliceMutableBufferRKNSt10shared_ptrI6BufferEEK7int64_t">
<span id="_CPPv318SliceMutableBufferRKNSt10shared_ptrI6BufferEEK7int64_t"></span><span id="_CPPv218SliceMutableBufferRKNSt10shared_ptrI6BufferEEK7int64_t"></span><span id="SliceMutableBuffer__std::shared_ptr:Buffer:CR.int64_tC"></span><span class="target" id="group__buffer-slicing-functions_1ga5eccd6ba6b0902e9eab560b0dc960aae"></span>std::shared_ptr&lt;Buffer&gt; <code class="sig-name descname">SliceMutableBuffer</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;Buffer&gt; &amp;<em>buffer</em>, <em class="property">const</em> int64_t <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418SliceMutableBufferRKNSt10shared_ptrI6BufferEEK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Like SliceBuffer, but construct a mutable buffer slice. </p>
<p>If the parent buffer is not mutable, behavior is undefined (it may abort in debug builds). </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv422SliceMutableBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t">
<span id="_CPPv322SliceMutableBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t"></span><span id="_CPPv222SliceMutableBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t"></span><span id="SliceMutableBufferSafe__std::shared_ptr:Buffer:CR.int64_t"></span><span class="target" id="group__buffer-slicing-functions_1gadcdbe1ea905508543893b6f17998931e"></span>Result&lt;std::shared_ptr&lt;Buffer&gt;&gt; <code class="sig-name descname">SliceMutableBufferSafe</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;Buffer&gt; &amp;<em>buffer</em>, int64_t <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422SliceMutableBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Input-checking version of SliceMutableBuffer. </p>
<p>An Invalid <a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> is returned if the requested slice falls out of bounds. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv422SliceMutableBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t7int64_t">
<span id="_CPPv322SliceMutableBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="_CPPv222SliceMutableBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t7int64_t"></span><span id="SliceMutableBufferSafe__std::shared_ptr:Buffer:CR.int64_t.int64_t"></span><span class="target" id="group__buffer-slicing-functions_1ga614f56abf67cf25a269f8c539636e0e3"></span>Result&lt;std::shared_ptr&lt;Buffer&gt;&gt; <code class="sig-name descname">SliceMutableBufferSafe</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;Buffer&gt; &amp;<em>buffer</em>, int64_t <em>offset</em>, int64_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv422SliceMutableBufferSafeRKNSt10shared_ptrI6BufferEE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Input-checking version of SliceMutableBuffer. </p>
<p>An Invalid <a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> is returned if the requested slice falls out of bounds. Note that unlike SliceBuffer, <code class="docutils literal notranslate"><span class="pre">length</span></code> isn’t clamped to the available buffer size. </p>
</dd></dl>

</div>
<div class="section" id="buffer-builders">
<h2>Buffer Builders<a class="headerlink" href="#buffer-builders" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv4N5arrow13BufferBuilderE">
<span id="_CPPv3N5arrow13BufferBuilderE"></span><span id="_CPPv2N5arrow13BufferBuilderE"></span><span id="arrow::BufferBuilder"></span><span class="target" id="classarrow_1_1_buffer_builder"></span><em class="property">class </em><code class="sig-prename descclassname">arrow<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">BufferBuilder</code><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilderE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A class for incrementally building a contiguous chunk of in-memory data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow13BufferBuilder13BufferBuilderENSt10shared_ptrI15ResizableBufferEEP10MemoryPool">
<span id="_CPPv3N5arrow13BufferBuilder13BufferBuilderENSt10shared_ptrI15ResizableBufferEEP10MemoryPool"></span><span id="_CPPv2N5arrow13BufferBuilder13BufferBuilderENSt10shared_ptrI15ResizableBufferEEP10MemoryPool"></span><span id="arrow::BufferBuilder::BufferBuilder__std::shared_ptr:ResizableBuffer:.MemoryPoolP"></span><span class="target" id="classarrow_1_1_buffer_builder_1a9456c4811c844fd67a7d6fe64a4f704c"></span><code class="sig-name descname">BufferBuilder</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow15ResizableBufferE" title="arrow::ResizableBuffer">ResizableBuffer</a>&gt; <em>buffer</em>, <a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em> = <a class="reference internal" href="#_CPPv4N5arrow19default_memory_poolEv" title="arrow::default_memory_pool">default_memory_pool</a>()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder13BufferBuilderENSt10shared_ptrI15ResizableBufferEEP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs new Builder that will start using the provided buffer until Finish/Reset are called. </p>
<p>The buffer is not resized. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13BufferBuilder6ResizeEK7int64_tb">
<span id="_CPPv3N5arrow13BufferBuilder6ResizeEK7int64_tb"></span><span id="_CPPv2N5arrow13BufferBuilder6ResizeEK7int64_tb"></span><span id="arrow::BufferBuilder::Resize__int64_tC.b"></span><span class="target" id="classarrow_1_1_buffer_builder_1a865e377404f5e80e3b716e654d0f3ec9"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Resize</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>new_capacity</em>, bool <em>shrink_to_fit</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6ResizeEK7int64_tb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize the buffer to the nearest multiple of 64 bytes. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">new_capacity</span></code>: the new capacity of the of the builder. Will be rounded up to a multiple of 64 bytes for padding </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shrink_to_fit</span></code>: if new capacity is smaller than the existing size, reallocate internal buffer. Set to false to avoid reallocations when shrinking the builder. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13BufferBuilder7ReserveEK7int64_t">
<span id="_CPPv3N5arrow13BufferBuilder7ReserveEK7int64_t"></span><span id="_CPPv2N5arrow13BufferBuilder7ReserveEK7int64_t"></span><span id="arrow::BufferBuilder::Reserve__int64_tC"></span><span class="target" id="classarrow_1_1_buffer_builder_1a1935ba967d1358acf6775cb4a8135640"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Reserve</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>additional_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder7ReserveEK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Ensure that builder can accommodate the additional number of bytes without the need to perform allocations. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">additional_bytes</span></code>: number of additional bytes to make space for </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13BufferBuilder6AppendEPKvK7int64_t">
<span id="_CPPv3N5arrow13BufferBuilder6AppendEPKvK7int64_t"></span><span id="_CPPv2N5arrow13BufferBuilder6AppendEPKvK7int64_t"></span><span id="arrow::BufferBuilder::Append__voidCP.int64_tC"></span><span class="target" id="classarrow_1_1_buffer_builder_1a9f2f25ecb063582ceaca0a5b7bd5d128"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Append</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>data</em>, <em class="property">const</em> int64_t <em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6AppendEPKvK7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append the given data to the buffer. </p>
<p>The buffer is automatically expanded if necessary. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13BufferBuilder6AppendEK7int64_t7uint8_t">
<span id="_CPPv3N5arrow13BufferBuilder6AppendEK7int64_t7uint8_t"></span><span id="_CPPv2N5arrow13BufferBuilder6AppendEK7int64_t7uint8_t"></span><span id="arrow::BufferBuilder::Append__int64_tC.uint8_t"></span><span class="target" id="classarrow_1_1_buffer_builder_1a2936c8b4601d3529af547290bc5b808b"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Append</code><span class="sig-paren">(</span><em class="property">const</em> int64_t <em>num_copies</em>, uint8_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6AppendEK7int64_t7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append copies of a value to the buffer. </p>
<p>The buffer is automatically expanded if necessary. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13BufferBuilder6FinishEPNSt10shared_ptrI6BufferEEb">
<span id="_CPPv3N5arrow13BufferBuilder6FinishEPNSt10shared_ptrI6BufferEEb"></span><span id="_CPPv2N5arrow13BufferBuilder6FinishEPNSt10shared_ptrI6BufferEEb"></span><span id="arrow::BufferBuilder::Finish__std::shared_ptr:Buffer:P.b"></span><span class="target" id="classarrow_1_1_buffer_builder_1a1d24a7508b789222ab27939a3ac3b481"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Finish</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N5arrow6BufferE" title="arrow::Buffer">Buffer</a>&gt; *<em>out</em>, bool <em>shrink_to_fit</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6FinishEPNSt10shared_ptrI6BufferEEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return result of builder as a <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> object. </p>
<p>The builder is reset and can be reused afterwards.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="support.html#classarrow_1_1_status"><span class="std std-ref">Status</span></a> </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[out]</span> <span class="pre">out</span></code>: the finalized <a class="reference internal" href="#classarrow_1_1_buffer"><span class="std std-ref">Buffer</span></a> object </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shrink_to_fit</span></code>: if the buffer size is smaller than its capacity, reallocate to fit more tightly in memory. Set to false to avoid a reallocation, at the expense of potentially more memory consumption. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow13BufferBuilder6RewindE7int64_t">
<span id="_CPPv3N5arrow13BufferBuilder6RewindE7int64_t"></span><span id="_CPPv2N5arrow13BufferBuilder6RewindE7int64_t"></span><span id="arrow::BufferBuilder::Rewind__int64_t"></span><span class="target" id="classarrow_1_1_buffer_builder_1adb061b4250de92be4822316b207ddcee"></span>void <code class="sig-name descname">Rewind</code><span class="sig-paren">(</span>int64_t <em>position</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder6RewindE7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set size to a smaller value without modifying builder contents. </p>
<p>For reusable <a class="reference internal" href="#classarrow_1_1_buffer_builder"><span class="std std-ref">BufferBuilder</span></a> classes <dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[in]</span> <span class="pre">position</span></code>: must be non-negative and less than or equal to the current length() </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow13BufferBuilder12GrowByFactorE7int64_t7int64_t">
<span id="_CPPv3N5arrow13BufferBuilder12GrowByFactorE7int64_t7int64_t"></span><span id="_CPPv2N5arrow13BufferBuilder12GrowByFactorE7int64_t7int64_t"></span><span id="arrow::BufferBuilder::GrowByFactor__int64_t.int64_t"></span><span class="target" id="classarrow_1_1_buffer_builder_1a289bc7d6c344eb6fb1ec7936e99b05bb"></span>int64_t <code class="sig-name descname">GrowByFactor</code><span class="sig-paren">(</span>int64_t <em>current_capacity</em>, int64_t <em>new_capacity</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow13BufferBuilder12GrowByFactorE7int64_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a capacity expanded by the desired growth factor. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4I00EN5arrow18TypedBufferBuilderE">
<span id="_CPPv3I00EN5arrow18TypedBufferBuilderE"></span><span id="_CPPv2I00EN5arrow18TypedBufferBuilderE"></span>template&lt;typename <code class="sig-name descname">T</code>, typename <code class="sig-name descname">Enable</code> = void&gt;<br /><span class="target" id="classarrow_1_1_typed_buffer_builder"></span><em class="property">class </em><code class="sig-name descname">TypedBufferBuilder</code><a class="headerlink" href="#_CPPv4I00EN5arrow18TypedBufferBuilderE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="stl-integration">
<h2>STL Integration<a class="headerlink" href="#stl-integration" title="Permalink to this headline">¶</a></h2>
<dl class="cpp class">
<dt id="_CPPv4I0EN5arrow3stl9allocatorE">
<span id="_CPPv3I0EN5arrow3stl9allocatorE"></span><span id="_CPPv2I0EN5arrow3stl9allocatorE"></span>template&lt;class <code class="sig-name descname">T</code>&gt;<br /><span class="target" id="classarrow_1_1stl_1_1allocator"></span><em class="property">class </em><code class="sig-prename descclassname">arrow::stl<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">allocator</code><a class="headerlink" href="#_CPPv4I0EN5arrow3stl9allocatorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A STL allocator delegating allocations to a Arrow <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow3stl9allocator9allocatorEv">
<span id="_CPPv3N5arrow3stl9allocator9allocatorEv"></span><span id="_CPPv2N5arrow3stl9allocator9allocatorEv"></span><span id="arrow::stl::allocator::allocator"></span><span class="target" id="classarrow_1_1stl_1_1allocator_1a050d3840043ef30ec2648e7dc3b03425"></span><code class="sig-name descname">allocator</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N5arrow3stl9allocator9allocatorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an allocator from the default <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow3stl9allocator9allocatorEP10MemoryPool">
<span id="_CPPv3N5arrow3stl9allocator9allocatorEP10MemoryPool"></span><span id="_CPPv2N5arrow3stl9allocator9allocatorEP10MemoryPool"></span><span id="arrow::stl::allocator::allocator__MemoryPoolP"></span><span class="target" id="classarrow_1_1stl_1_1allocator_1a345b7fb4cd99930d1b606fac634e7ca3"></span><code class="sig-name descname">allocator</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a> *<em>pool</em><span class="sig-paren">)</span> <em class="property">noexcept</em><a class="headerlink" href="#_CPPv4N5arrow3stl9allocator9allocatorEP10MemoryPool" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an allocator from the given <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a>. </p>
</dd></dl>

</div>
<dl class="cpp struct">
<dt id="_CPPv4I0EN5arrow3stl9allocator6rebindE">
<span id="_CPPv3I0EN5arrow3stl9allocator6rebindE"></span><span id="_CPPv2I0EN5arrow3stl9allocator6rebindE"></span>template&lt;class <code class="sig-name descname">U</code>&gt;<br /><span class="target" id="structarrow_1_1stl_1_1allocator_1_1rebind"></span><em class="property">struct </em><code class="sig-name descname">rebind</code><a class="headerlink" href="#_CPPv4I0EN5arrow3stl9allocator6rebindE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4I0EN5arrow3stl13STLMemoryPoolE">
<span id="_CPPv3I0EN5arrow3stl13STLMemoryPoolE"></span><span id="_CPPv2I0EN5arrow3stl13STLMemoryPoolE"></span>template&lt;typename <code class="sig-name descname">Allocator</code> = std::allocator&lt;uint8_t&gt;&gt;<br /><span class="target" id="classarrow_1_1stl_1_1_s_t_l_memory_pool"></span><em class="property">class </em><code class="sig-prename descclassname">arrow::stl<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">STLMemoryPool</code> : <em class="property">public</em> arrow::<a class="reference internal" href="#_CPPv4N5arrow10MemoryPoolE" title="arrow::MemoryPool">MemoryPool</a><a class="headerlink" href="#_CPPv4I0EN5arrow3stl13STLMemoryPoolE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> implementation delegating allocations to a STL allocator. </p>
<p>Note that STL allocators don’t provide a resizing operation, and therefore any buffer resizes will do a full reallocation and copy. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N5arrow3stl13STLMemoryPool13STLMemoryPoolERK9Allocator">
<span id="_CPPv3N5arrow3stl13STLMemoryPool13STLMemoryPoolERK9Allocator"></span><span id="_CPPv2N5arrow3stl13STLMemoryPool13STLMemoryPoolERK9Allocator"></span><span id="arrow::stl::STLMemoryPool::STLMemoryPool__AllocatorCR"></span><span class="target" id="classarrow_1_1stl_1_1_s_t_l_memory_pool_1a04f9e7c6b4995ffad23f3a60f8e34a9f"></span><code class="sig-name descname">STLMemoryPool</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv4I0EN5arrow3stl13STLMemoryPoolE" title="arrow::stl::STLMemoryPool::Allocator">Allocator</a> &amp;<em>alloc</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N5arrow3stl13STLMemoryPool13STLMemoryPoolERK9Allocator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a memory pool from the given allocator. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow3stl13STLMemoryPool8AllocateE7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow3stl13STLMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow3stl13STLMemoryPool8AllocateE7int64_tPP7uint8_t"></span><span id="arrow::stl::STLMemoryPool::Allocate__int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1stl_1_1_s_t_l_memory_pool_1ae9533be0fa6306cf5045ab53a74bc79b"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Allocate</code><span class="sig-paren">(</span>int64_t <em>size</em>, uint8_t **<em>out</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow3stl13STLMemoryPool8AllocateE7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate a new memory region of at least size bytes. </p>
<p>The allocated region shall be 64-byte aligned. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow3stl13STLMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t">
<span id="_CPPv3N5arrow3stl13STLMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="_CPPv2N5arrow3stl13STLMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t"></span><span id="arrow::stl::STLMemoryPool::Reallocate__int64_t.int64_t.uint8_tPP"></span><span class="target" id="classarrow_1_1stl_1_1_s_t_l_memory_pool_1ae092742351b7986c620370b0b40a6a6f"></span><a class="reference internal" href="support.html#_CPPv4N5arrow6StatusE" title="arrow::Status">Status</a> <code class="sig-name descname">Reallocate</code><span class="sig-paren">(</span>int64_t <em>old_size</em>, int64_t <em>new_size</em>, uint8_t **<em>ptr</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow3stl13STLMemoryPool10ReallocateE7int64_t7int64_tPP7uint8_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize an already allocated memory section. </p>
<p>As by default most default allocators on a platform don’t support aligned reallocation, this function can involve a copy of the underlying data. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N5arrow3stl13STLMemoryPool4FreeEP7uint8_t7int64_t">
<span id="_CPPv3N5arrow3stl13STLMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="_CPPv2N5arrow3stl13STLMemoryPool4FreeEP7uint8_t7int64_t"></span><span id="arrow::stl::STLMemoryPool::Free__uint8_tP.int64_t"></span><span class="target" id="classarrow_1_1stl_1_1_s_t_l_memory_pool_1abb27dc235972168141885d167dd4097d"></span>void <code class="sig-name descname">Free</code><span class="sig-paren">(</span>uint8_t *<em>buffer</em>, int64_t <em>size</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N5arrow3stl13STLMemoryPool4FreeEP7uint8_t7int64_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free an allocated region. </p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Pointer to the start of the allocated memory region </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: Allocated size located at buffer. An allocator implementation may use this for tracking the amount of allocated bytes as well as for faster deallocation if supported by its backend. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow3stl13STLMemoryPool15bytes_allocatedEv">
<span id="_CPPv3NK5arrow3stl13STLMemoryPool15bytes_allocatedEv"></span><span id="_CPPv2NK5arrow3stl13STLMemoryPool15bytes_allocatedEv"></span><span id="arrow::stl::STLMemoryPool::bytes_allocatedC"></span><span class="target" id="classarrow_1_1stl_1_1_s_t_l_memory_pool_1a5de9db81dd9b9b6c854c7ece6d13e063"></span>int64_t <code class="sig-name descname">bytes_allocated</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow3stl13STLMemoryPool15bytes_allocatedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of bytes that were allocated and not yet free’d through this allocator. </p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow3stl13STLMemoryPool10max_memoryEv">
<span id="_CPPv3NK5arrow3stl13STLMemoryPool10max_memoryEv"></span><span id="_CPPv2NK5arrow3stl13STLMemoryPool10max_memoryEv"></span><span id="arrow::stl::STLMemoryPool::max_memoryC"></span><span class="target" id="classarrow_1_1stl_1_1_s_t_l_memory_pool_1ab65e96df014e555fa03f7e8ba043d003"></span>int64_t <code class="sig-name descname">max_memory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow3stl13STLMemoryPool10max_memoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return peak memory allocation in this memory pool. </p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Maximum bytes allocated. If not known (or not implemented), returns -1 </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK5arrow3stl13STLMemoryPool12backend_nameEv">
<span id="_CPPv3NK5arrow3stl13STLMemoryPool12backend_nameEv"></span><span id="_CPPv2NK5arrow3stl13STLMemoryPool12backend_nameEv"></span><span id="arrow::stl::STLMemoryPool::backend_nameC"></span><span class="target" id="classarrow_1_1stl_1_1_s_t_l_memory_pool_1ad90be605fdb1f922aff9a4abfedfad4b"></span>std::string <code class="sig-name descname">backend_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> <em class="property">override</em><a class="headerlink" href="#_CPPv4NK5arrow3stl13STLMemoryPool12backend_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The name of the backend used by this <a class="reference internal" href="#classarrow_1_1_memory_pool"><span class="std std-ref">MemoryPool</span></a> (e.g. “system” or “jemalloc”). </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="datatype.html" class="btn btn-neutral float-right" title="Data Types" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="support.html" class="btn btn-neutral float-left" title="Programming Support" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2016-2019 Apache Software Foundation.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107500873-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-107500873-1');
</script>


</body>
</html>