<div id="main" class="col-md-9" role="main">

# Read a CSV or other delimited file with Arrow

<div class="ref-description section level2">

These functions uses the Arrow C++ CSV reader to read into a `tibble`.
Arrow C++ options have been mapped to argument names that follow those
of `readr::read_delim()`, and `col_select` was inspired by
`vroom::vroom()`.

</div>

<div class="section level2">

## Usage

<div class="sourceCode">

``` r
read_delim_arrow(
  file,
  delim = ",",
  quote = "\"",
  escape_double = TRUE,
  escape_backslash = FALSE,
  schema = NULL,
  col_names = TRUE,
  col_types = NULL,
  col_select = NULL,
  na = c("", "NA"),
  quoted_na = TRUE,
  skip_empty_rows = TRUE,
  skip = 0L,
  parse_options = NULL,
  convert_options = NULL,
  read_options = NULL,
  as_data_frame = TRUE,
  timestamp_parsers = NULL,
  decimal_point = "."
)

read_csv_arrow(
  file,
  quote = "\"",
  escape_double = TRUE,
  escape_backslash = FALSE,
  schema = NULL,
  col_names = TRUE,
  col_types = NULL,
  col_select = NULL,
  na = c("", "NA"),
  quoted_na = TRUE,
  skip_empty_rows = TRUE,
  skip = 0L,
  parse_options = NULL,
  convert_options = NULL,
  read_options = NULL,
  as_data_frame = TRUE,
  timestamp_parsers = NULL
)

read_csv2_arrow(
  file,
  quote = "\"",
  escape_double = TRUE,
  escape_backslash = FALSE,
  schema = NULL,
  col_names = TRUE,
  col_types = NULL,
  col_select = NULL,
  na = c("", "NA"),
  quoted_na = TRUE,
  skip_empty_rows = TRUE,
  skip = 0L,
  parse_options = NULL,
  convert_options = NULL,
  read_options = NULL,
  as_data_frame = TRUE,
  timestamp_parsers = NULL
)

read_tsv_arrow(
  file,
  quote = "\"",
  escape_double = TRUE,
  escape_backslash = FALSE,
  schema = NULL,
  col_names = TRUE,
  col_types = NULL,
  col_select = NULL,
  na = c("", "NA"),
  quoted_na = TRUE,
  skip_empty_rows = TRUE,
  skip = 0L,
  parse_options = NULL,
  convert_options = NULL,
  read_options = NULL,
  as_data_frame = TRUE,
  timestamp_parsers = NULL
)
```

</div>

</div>

<div class="section level2">

## Arguments

-   file:

    A character file name or URI, connection, literal data (either a
    single string or a [raw](https://rdrr.io/r/base/raw.html) vector),
    an Arrow input stream, or a `FileSystem` with path
    (`SubTreeFileSystem`).

    If a file name, a memory-mapped Arrow
    [InputStream](https://arrow.apache.org/docs/r/reference/InputStream.md)
    will be opened and closed when finished; compression will be
    detected from the file extension and handled automatically. If an
    input stream is provided, it will be left open.

    To be recognised as literal data, the input must be wrapped with
    `I()`.

-   delim:

    Single character used to separate fields within a record.

-   quote:

    Single character used to quote strings.

-   escape_double:

    Does the file escape quotes by doubling them? i.e. If this option is
    `TRUE`, the value `""""` represents a single quote, `\"`.

-   escape_backslash:

    Does the file use backslashes to escape special characters? This is
    more general than `escape_double` as backslashes can be used to
    escape the delimiter character, the quote character, or to add
    special characters like `\\n`.

-   schema:

    [Schema](https://arrow.apache.org/docs/r/reference/Schema-class.md)
    that describes the table. If provided, it will be used to satisfy
    both `col_names` and `col_types`.

-   col_names:

    If `TRUE`, the first row of the input will be used as the column
    names and will not be included in the data frame. If `FALSE`, column
    names will be generated by Arrow, starting with "f0", "f1", ...,
    "fN". Alternatively, you can specify a character vector of column
    names.

-   col_types:

    A compact string representation of the column types, an Arrow
    [Schema](https://arrow.apache.org/docs/r/reference/Schema-class.md),
    or `NULL` (the default) to infer types from the data.

-   col_select:

    A character vector of column names to keep, as in the "select"
    argument to `data.table::fread()`, or a [tidy selection
    specification](https://tidyselect.r-lib.org/reference/eval_select.html)
    of columns, as used in `dplyr::select()`.

-   na:

    A character vector of strings to interpret as missing values.

-   quoted_na:

    Should missing values inside quotes be treated as missing values
    (the default) or strings. (Note that this is different from the the
    Arrow C++ default for the corresponding convert option,
    `strings_can_be_null`.)

-   skip_empty_rows:

    Should blank rows be ignored altogether? If `TRUE`, blank rows will
    not be represented at all. If `FALSE`, they will be filled with
    missings.

-   skip:

    Number of lines to skip before reading data.

-   parse_options:

    see [CSV parsing
    options](https://arrow.apache.org/docs/r/reference/csv_parse_options.md).
    If given, this overrides any parsing options provided in other
    arguments (e.g. `delim`, `quote`, etc.).

-   convert_options:

    see [CSV conversion
    options](https://arrow.apache.org/docs/r/reference/csv_convert_options.md)

-   read_options:

    see [CSV reading
    options](https://arrow.apache.org/docs/r/reference/csv_read_options.md)

-   as_data_frame:

    Should the function return a `tibble` (default) or an Arrow
    [Table](https://arrow.apache.org/docs/r/reference/Table-class.md)?

-   timestamp_parsers:

    User-defined timestamp parsers. If more than one parser is
    specified, the CSV conversion logic will try parsing values starting
    from the beginning of this vector. Possible values are:

    -   `NULL`: the default, which uses the ISO-8601 parser

    -   a character vector of
        [strptime](https://rdrr.io/r/base/strptime.html) parse strings

    -   a list of
        [TimestampParser](https://arrow.apache.org/docs/r/reference/CsvReadOptions.md)
        objects

-   decimal_point:

    Character to use for decimal point in floating point numbers.

</div>

<div class="section level2">

## Value

A `tibble`, or a Table if `as_data_frame = FALSE`.

</div>

<div class="section level2">

## Details

`read_csv_arrow()` and `read_tsv_arrow()` are wrappers around
`read_delim_arrow()` that specify a delimiter. `read_csv2_arrow()` uses
`;` for the delimiter and `,` for the decimal point.

Note that not all `readr` options are currently implemented here. Please
file an issue if you encounter one that `arrow` should support.

If you need to control Arrow-specific reader parameters that don't have
an equivalent in `readr::read_csv()`, you can either provide them in the
`parse_options`, `convert_options`, or `read_options` arguments, or you
can use
[CsvTableReader](https://arrow.apache.org/docs/r/reference/CsvTableReader.md)
directly for lower-level access.

</div>

<div class="section level2">

## Specifying column types and names

By default, the CSV reader will infer the column names and data types
from the file, but there are a few ways you can specify them directly.

One way is to provide an Arrow
[Schema](https://arrow.apache.org/docs/r/reference/Schema-class.md) in
the `schema` argument, which is an ordered map of column name to type.
When provided, it satisfies both the `col_names` and `col_types`
arguments. This is good if you know all of this information up front.

You can also pass a `Schema` to the `col_types` argument. If you do
this, column names will still be inferred from the file unless you also
specify `col_names`. In either case, the column names in the `Schema`
must match the data's column names, whether they are explicitly provided
or inferred. That said, this `Schema` does not have to reference all
columns: those omitted will have their types inferred.

Alternatively, you can declare column types by providing the compact
string representation that `readr` uses to the `col_types` argument.
This means you provide a single string, one character per column, where
the characters map to Arrow types analogously to the `readr` type
mapping:

-   "c": `utf8()`

-   "i": `int32()`

-   "n": `float64()`

-   "d": `float64()`

-   "l": `bool()`

-   "f": `dictionary()`

-   "D": `date32()`

-   "T": `timestamp(unit = "ns")`

-   "t": `time32()` (The `unit` arg is set to the default value `"ms"`)

-   "\_": `null()`

-   "-": `null()`

-   "?": infer the type from the data

If you use the compact string representation for `col_types`, you must
also specify `col_names`.

Regardless of how types are specified, all columns with a `null()` type
will be dropped.

Note that if you are specifying column names, whether by `schema` or
`col_names`, and the CSV file has a header row that would otherwise be
used to identify column names, you'll need to add `skip = 1` to skip
that row.

</div>

<div class="section level2">

## Examples

<div class="sourceCode">

``` r
tf <- tempfile()
on.exit(unlink(tf))
write.csv(mtcars, file = tf)
df <- read_csv_arrow(tf)
dim(df)
#> [1] 32 12
# Can select columns
df <- read_csv_arrow(tf, col_select = starts_with("d"))

# Specifying column types and names
write.csv(data.frame(x = c(1, 3), y = c(2, 4)), file = tf, row.names = FALSE)
read_csv_arrow(tf, schema = schema(x = int32(), y = utf8()), skip = 1)
#> # A tibble: 2 x 2
#>       x y    
#>   <int> <chr>
#> 1     1 2    
#> 2     3 4    
read_csv_arrow(tf, col_types = schema(y = utf8()))
#> # A tibble: 2 x 2
#>       x y    
#>   <int> <chr>
#> 1     1 2    
#> 2     3 4    
read_csv_arrow(tf, col_types = "ic", col_names = c("x", "y"), skip = 1)
#> # A tibble: 2 x 2
#>       x y    
#>   <int> <chr>
#> 1     1 2    
#> 2     3 4    

# Note that if a timestamp column contains time zones,
# the string "T" `col_types` specification won't work.
# To parse timestamps with time zones, provide a [Schema] to `col_types`
# and specify the time zone in the type object:
tf <- tempfile()
write.csv(data.frame(x = "1970-01-01T12:00:00+12:00"), file = tf, row.names = FALSE)
read_csv_arrow(
  tf,
  col_types = schema(x = timestamp(unit = "us", timezone = "UTC"))
)
#> # A tibble: 1 x 1
#>   x                  
#>   <dttm>             
#> 1 1970-01-01 00:00:00

# Read directly from strings with `I()`
read_csv_arrow(I("x,y\n1,2\n3,4"))
#> # A tibble: 2 x 2
#>       x     y
#>   <int> <int>
#> 1     1     2
#> 2     3     4
read_delim_arrow(I(c("x y", "1 2", "3 4")), delim = " ")
#> # A tibble: 2 x 2
#>       x     y
#>   <int> <int>
#> 1     1     2
#> 2     3     4
```

</div>

</div>

</div>
