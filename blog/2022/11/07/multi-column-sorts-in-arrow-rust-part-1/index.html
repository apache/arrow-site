<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above meta tags *must* come first in the head; any other head content must come *after* these tags -->
    
    <title>Fast and Memory Efficient Multi-Column Sorts in Apache Arrow Rust, Part 1 | Apache Arrow</title>
    

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Fast and Memory Efficient Multi-Column Sorts in Apache Arrow Rust, Part 1" />
<meta name="author" content="tustvold and alamb" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Sorting is one of the most fundamental operations in modern databases and other analytic systems, underpinning important operators such as aggregates, joins, window functions, merge, and more. By some estimates, more than half of the execution time in data processing systems is spent sorting. Optimizing sorts is therefore vital to improving query performance and overall system efficiency. Sorting is also one of the most well studied topics in computer science. The classic survey paper for databases is Implementing Sorting in Database Systems by Goetz Graefe which provides a thorough academic treatment and is still very applicable today. However, it may not be obvious how to apply the wisdom and advanced techniques described in that paper to modern systems. In addition, the excellent DuckDB blog on sorting highlights many sorting techniques, and mentions a comparable row format, but it does not explain how to efficiently sort variable length strings or dictionary encoded data. In this series we explain in detail the new row format in the Rust implementation of Apache Arrow, and how we used to make sorting more than 3x faster than an alternate comparator based approach. The benefits are especially pronounced for strings, dictionary encoded data, and sorts with large numbers of columns. Multicolumn / Lexicographical Sort Problem Most languages have native, optimized operations to sort a single column (array) of data, which are specialized based on the type of data being sorted. The reason that sorting is typically more challenging in analytic systems is that: They must support multiple columns of data The column types are not knowable at compile time, and thus the compiler can not typically generate optimized code Multicolumn sorting is also referred to as lexicographical sorting in some libraries. For example, given sales data for various customers and their state of residence, a user might want to find the lowest 10 orders for each state. Customer | State | Orders —--------+-------+------- 12345 | MA | 10.12 532432 | MA | 8.44 12345 | CA | 3.25 56232 | WA | 6.00 23442 | WA | 132.50 7844 | CA | 9.33 852353 | MA | 1.30 One way to do so is to order the data first by State and then by Orders: Customer | State | Orders —--------+-------+------- 12345 | CA | 3.25 7844 | CA | 9.33 852353 | MA | 1.30 532432 | MA | 8.44 12345 | MA | 10.12 56232 | WA | 6.00 23442 | WA | 132.50 (Note: While there are specialized ways for computing this particular query other than fully sorting the entire input (e.g. &quot;TopK&quot;), they typically need the same multi-column comparison operation described below. Thus while we will use the simplified example in this series, it applies much more broadly) Basic Implementation Let us take the example of a basic sort kernel which takes a set of columns as input, and returns a list of indices identifying a sorted order. &gt; lexsort_to_indices([ [&quot;MA&quot;, &quot;MA&quot;, &quot;CA&quot;, &quot;WA&quot;, &quot;WA&quot;, &quot;CA&quot;, &quot;MA&quot;] ]) [2, 5, 0, 1, 6, 3, 4] &gt; lexsort_to_indices([ [&quot;MA&quot;, &quot;MA&quot;, &quot;CA&quot;, &quot;WA&quot;, &quot;WA&quot;, &quot;CA&quot;, &quot;MA&quot;], [10.10, 8.44, 3.25, 6.00, 132.50, 9.33, 1.30] ]) [2, 5, 6, 1, 0, 3, 4] This function returns a list of indices instead of sorting the columns directly because it: Avoids expensive copying data during the sorting process Allows deferring copying of values until the latest possible moment Can be used to reorder additional columns that weren’t part of the sort key A straightforward implementation of lexsort_to_indices uses a comparator function, row index ┌─────┐ ┌─────┐ ┌─────┐ compare(left_index, right_index) 0 │ │ │ │ │ │ ┌├─────┤─ ─├─────┤─ ─├─────┤┐ │ │ │ │ │ │ │ │ ◀──────────────────┘ │ └├─────┤─ ─├─────┤─ ─├─────┤┘ │ │ │ │ │ │ │Comparator function compares one │ ├─────┤ ├─────┤ ├─────┤ multi-column row with another. │ │ │ │ │ │ │ │ ├─────┤ ├─────┤ ├─────┤ The data types of the columns │ │ │ │ │ │ │ and the sort options are not │ └─────┘ └─────┘ └─────┘ known at compile time, only │ ... runtime │ │ ┌┌─────┐─ ─┌─────┐─ ─┌─────┐┐ │ │ │ │ │ │ │ ◀────────────────────────────────┘ └├─────┤─ ─├─────┤─ ─├─────┤┘ │ │ │ │ │ │ ├─────┤ ├─────┤ ├─────┤ N-1 │ │ │ │ │ │ └─────┘ └─────┘ └─────┘ Customer State Orders UInt64 Utf8 F64 The comparator function compares each row a column at a time, based on the column types ┌────────────────────────────────┐ │ │ ▼ │ ┌ ─ ─ ─ ┐ ┌ ─ ─ ─ ┐ │ │ ┌─────┐ │┌─────┐│ │┌─────┐│ │ left_index │ │ │ │ │ │ │ └─────┘ │└─────┘│ │└─────┘│ Step 1: Compare State (UInt64) │ │ │ │ │ │ │ │ ┌─────┐ ┌─────┐ ┌─────┐ right_index│ │ ││ ││ ││ ││ └─────┘ └─────┘ └─────┘ Step 2: If State values equal │ │ │ │ compare Orders (F64) Customer State Orders │ UInt64 │ Utf8 │ │ F64 │ │ ─ ─ ─ ─ ─ ─ ─ ─ │ ▲ │ │ │ └───────────────────────┘ Pseudocode for this operation might look something like # Takes a list of columns and returns the lexicographically # sorted order as a list of indices def lexsort_to_indices(columns): comparator = build_comparator(columns) # Construct a list of integers from 0 to the number of rows # and sort it according to the comparator [0..columns.num_rows()].sort_by(comparator) # Build a function that given indexes (left_idx, right_idx) returns the comparison of the sort keys at the left and right indices respectively def build_comparator(columns): def comparator(left_idx, right_idx): for column in columns: # call a compare function which performs # dynamic dispatch on type of left and right columns ordering = compare(column, left_idx,right_idx) if ordering != Equal { return ordering } # All values equal Equal # Return comparator function comparator # compares the values in a single column at left_idx and right_idx def compare(column, left_idx, right_idx): # Choose comparison based on type of column (&quot;dynamic dispatch&quot;) if column.type == Int: cmp(column[left_idx].as_int(), column[right_idx].as_int()) elif column.type == Float: cmp(column[left_idx].as_float(), column[right_idx].as_float()) ... Greater detail is beyond the scope of this post, but in general the more predictable the behavior of a block of code, the better its performance will be. In the case of this pseudocode, there is clear room for improvement: comparator performs a large number of unpredictable conditional branches, where the path execution takes depends on the data values comparator and compare use dynamic dispatch, which not only adds further conditional branches, but also function call overhead comparator performs a large number of reads of memory at unpredictable locations You can find the complete implementation of multi-column comparator construction in arrow-rs in sort.rs and ord.rs. Normalized Keys / Byte Array Comparisons Now imagine we had a way to represent each logical row of data as a sequence of bytes, and that byte-wise comparison of that sequence yielded the same result as comparing the actual column values using the code above. Such a representation would require no switching on column types, and the kernel would become def lexsort_to_indices(columns): rows = convert_to_rows(columns) [0..columns.num_rows()].sort_by(lambda l, r: cmp(rows[l], rows[r])) While this approach does require converting to/from the byte array representation, it has some major advantages: Rows can be compared by comparing bytes in memory, which modern computer hardware excels at with the extremely well optimized memcmp Memory accesses are largely predictable There is no dynamic dispatch overhead Extends straightforwardly to more sophisticated sorting strategies such as Distribution-based sorting techniques such as radix sort Parallel merge sort External sort ... You can find more information on how to leverage such representation in the &quot;Binary String Comparison&quot; section of the DuckDB blog post on the topic as well as Graefe’s paper. However, we found it wasn’t immediately obvious how to apply this technique to variable length string or dictionary encoded data, which we will explain in the next post in this series. Next up: Row Format This post has introduced the concept and challenges of multi column sorting, and shown why a comparable byte array representation, such as the row format introduced to the Rust implementation of Apache Arrow, is such a compelling primitive. In the next post we explain how this encoding works, but if you just want to use it, check out the docs for getting started, and report any issues on our bugtracker. As always, the Arrow community very much looks forward to seeing what you build with it!" />
<meta property="og:description" content="Introduction Sorting is one of the most fundamental operations in modern databases and other analytic systems, underpinning important operators such as aggregates, joins, window functions, merge, and more. By some estimates, more than half of the execution time in data processing systems is spent sorting. Optimizing sorts is therefore vital to improving query performance and overall system efficiency. Sorting is also one of the most well studied topics in computer science. The classic survey paper for databases is Implementing Sorting in Database Systems by Goetz Graefe which provides a thorough academic treatment and is still very applicable today. However, it may not be obvious how to apply the wisdom and advanced techniques described in that paper to modern systems. In addition, the excellent DuckDB blog on sorting highlights many sorting techniques, and mentions a comparable row format, but it does not explain how to efficiently sort variable length strings or dictionary encoded data. In this series we explain in detail the new row format in the Rust implementation of Apache Arrow, and how we used to make sorting more than 3x faster than an alternate comparator based approach. The benefits are especially pronounced for strings, dictionary encoded data, and sorts with large numbers of columns. Multicolumn / Lexicographical Sort Problem Most languages have native, optimized operations to sort a single column (array) of data, which are specialized based on the type of data being sorted. The reason that sorting is typically more challenging in analytic systems is that: They must support multiple columns of data The column types are not knowable at compile time, and thus the compiler can not typically generate optimized code Multicolumn sorting is also referred to as lexicographical sorting in some libraries. For example, given sales data for various customers and their state of residence, a user might want to find the lowest 10 orders for each state. Customer | State | Orders —--------+-------+------- 12345 | MA | 10.12 532432 | MA | 8.44 12345 | CA | 3.25 56232 | WA | 6.00 23442 | WA | 132.50 7844 | CA | 9.33 852353 | MA | 1.30 One way to do so is to order the data first by State and then by Orders: Customer | State | Orders —--------+-------+------- 12345 | CA | 3.25 7844 | CA | 9.33 852353 | MA | 1.30 532432 | MA | 8.44 12345 | MA | 10.12 56232 | WA | 6.00 23442 | WA | 132.50 (Note: While there are specialized ways for computing this particular query other than fully sorting the entire input (e.g. &quot;TopK&quot;), they typically need the same multi-column comparison operation described below. Thus while we will use the simplified example in this series, it applies much more broadly) Basic Implementation Let us take the example of a basic sort kernel which takes a set of columns as input, and returns a list of indices identifying a sorted order. &gt; lexsort_to_indices([ [&quot;MA&quot;, &quot;MA&quot;, &quot;CA&quot;, &quot;WA&quot;, &quot;WA&quot;, &quot;CA&quot;, &quot;MA&quot;] ]) [2, 5, 0, 1, 6, 3, 4] &gt; lexsort_to_indices([ [&quot;MA&quot;, &quot;MA&quot;, &quot;CA&quot;, &quot;WA&quot;, &quot;WA&quot;, &quot;CA&quot;, &quot;MA&quot;], [10.10, 8.44, 3.25, 6.00, 132.50, 9.33, 1.30] ]) [2, 5, 6, 1, 0, 3, 4] This function returns a list of indices instead of sorting the columns directly because it: Avoids expensive copying data during the sorting process Allows deferring copying of values until the latest possible moment Can be used to reorder additional columns that weren’t part of the sort key A straightforward implementation of lexsort_to_indices uses a comparator function, row index ┌─────┐ ┌─────┐ ┌─────┐ compare(left_index, right_index) 0 │ │ │ │ │ │ ┌├─────┤─ ─├─────┤─ ─├─────┤┐ │ │ │ │ │ │ │ │ ◀──────────────────┘ │ └├─────┤─ ─├─────┤─ ─├─────┤┘ │ │ │ │ │ │ │Comparator function compares one │ ├─────┤ ├─────┤ ├─────┤ multi-column row with another. │ │ │ │ │ │ │ │ ├─────┤ ├─────┤ ├─────┤ The data types of the columns │ │ │ │ │ │ │ and the sort options are not │ └─────┘ └─────┘ └─────┘ known at compile time, only │ ... runtime │ │ ┌┌─────┐─ ─┌─────┐─ ─┌─────┐┐ │ │ │ │ │ │ │ ◀────────────────────────────────┘ └├─────┤─ ─├─────┤─ ─├─────┤┘ │ │ │ │ │ │ ├─────┤ ├─────┤ ├─────┤ N-1 │ │ │ │ │ │ └─────┘ └─────┘ └─────┘ Customer State Orders UInt64 Utf8 F64 The comparator function compares each row a column at a time, based on the column types ┌────────────────────────────────┐ │ │ ▼ │ ┌ ─ ─ ─ ┐ ┌ ─ ─ ─ ┐ │ │ ┌─────┐ │┌─────┐│ │┌─────┐│ │ left_index │ │ │ │ │ │ │ └─────┘ │└─────┘│ │└─────┘│ Step 1: Compare State (UInt64) │ │ │ │ │ │ │ │ ┌─────┐ ┌─────┐ ┌─────┐ right_index│ │ ││ ││ ││ ││ └─────┘ └─────┘ └─────┘ Step 2: If State values equal │ │ │ │ compare Orders (F64) Customer State Orders │ UInt64 │ Utf8 │ │ F64 │ │ ─ ─ ─ ─ ─ ─ ─ ─ │ ▲ │ │ │ └───────────────────────┘ Pseudocode for this operation might look something like # Takes a list of columns and returns the lexicographically # sorted order as a list of indices def lexsort_to_indices(columns): comparator = build_comparator(columns) # Construct a list of integers from 0 to the number of rows # and sort it according to the comparator [0..columns.num_rows()].sort_by(comparator) # Build a function that given indexes (left_idx, right_idx) returns the comparison of the sort keys at the left and right indices respectively def build_comparator(columns): def comparator(left_idx, right_idx): for column in columns: # call a compare function which performs # dynamic dispatch on type of left and right columns ordering = compare(column, left_idx,right_idx) if ordering != Equal { return ordering } # All values equal Equal # Return comparator function comparator # compares the values in a single column at left_idx and right_idx def compare(column, left_idx, right_idx): # Choose comparison based on type of column (&quot;dynamic dispatch&quot;) if column.type == Int: cmp(column[left_idx].as_int(), column[right_idx].as_int()) elif column.type == Float: cmp(column[left_idx].as_float(), column[right_idx].as_float()) ... Greater detail is beyond the scope of this post, but in general the more predictable the behavior of a block of code, the better its performance will be. In the case of this pseudocode, there is clear room for improvement: comparator performs a large number of unpredictable conditional branches, where the path execution takes depends on the data values comparator and compare use dynamic dispatch, which not only adds further conditional branches, but also function call overhead comparator performs a large number of reads of memory at unpredictable locations You can find the complete implementation of multi-column comparator construction in arrow-rs in sort.rs and ord.rs. Normalized Keys / Byte Array Comparisons Now imagine we had a way to represent each logical row of data as a sequence of bytes, and that byte-wise comparison of that sequence yielded the same result as comparing the actual column values using the code above. Such a representation would require no switching on column types, and the kernel would become def lexsort_to_indices(columns): rows = convert_to_rows(columns) [0..columns.num_rows()].sort_by(lambda l, r: cmp(rows[l], rows[r])) While this approach does require converting to/from the byte array representation, it has some major advantages: Rows can be compared by comparing bytes in memory, which modern computer hardware excels at with the extremely well optimized memcmp Memory accesses are largely predictable There is no dynamic dispatch overhead Extends straightforwardly to more sophisticated sorting strategies such as Distribution-based sorting techniques such as radix sort Parallel merge sort External sort ... You can find more information on how to leverage such representation in the &quot;Binary String Comparison&quot; section of the DuckDB blog post on the topic as well as Graefe’s paper. However, we found it wasn’t immediately obvious how to apply this technique to variable length string or dictionary encoded data, which we will explain in the next post in this series. Next up: Row Format This post has introduced the concept and challenges of multi column sorting, and shown why a comparable byte array representation, such as the row format introduced to the Rust implementation of Apache Arrow, is such a compelling primitive. In the next post we explain how this encoding works, but if you just want to use it, check out the docs for getting started, and report any issues on our bugtracker. As always, the Arrow community very much looks forward to seeing what you build with it!" />
<link rel="canonical" href="https://arrow.apache.org/blog/2022/11/07/multi-column-sorts-in-arrow-rust-part-1/" />
<meta property="og:url" content="https://arrow.apache.org/blog/2022/11/07/multi-column-sorts-in-arrow-rust-part-1/" />
<meta property="og:site_name" content="Apache Arrow" />
<meta property="og:image" content="https://arrow.apache.org/img/arrow-logo_horizontal_black-txt_white-bg.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-07T00:00:00-05:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://arrow.apache.org/img/arrow-logo_horizontal_black-txt_white-bg.png" />
<meta property="twitter:title" content="Fast and Memory Efficient Multi-Column Sorts in Apache Arrow Rust, Part 1" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"tustvold and alamb"},"dateModified":"2022-11-07T00:00:00-05:00","datePublished":"2022-11-07T00:00:00-05:00","description":"Introduction Sorting is one of the most fundamental operations in modern databases and other analytic systems, underpinning important operators such as aggregates, joins, window functions, merge, and more. By some estimates, more than half of the execution time in data processing systems is spent sorting. Optimizing sorts is therefore vital to improving query performance and overall system efficiency. Sorting is also one of the most well studied topics in computer science. The classic survey paper for databases is Implementing Sorting in Database Systems by Goetz Graefe which provides a thorough academic treatment and is still very applicable today. However, it may not be obvious how to apply the wisdom and advanced techniques described in that paper to modern systems. In addition, the excellent DuckDB blog on sorting highlights many sorting techniques, and mentions a comparable row format, but it does not explain how to efficiently sort variable length strings or dictionary encoded data. In this series we explain in detail the new row format in the Rust implementation of Apache Arrow, and how we used to make sorting more than 3x faster than an alternate comparator based approach. The benefits are especially pronounced for strings, dictionary encoded data, and sorts with large numbers of columns. Multicolumn / Lexicographical Sort Problem Most languages have native, optimized operations to sort a single column (array) of data, which are specialized based on the type of data being sorted. The reason that sorting is typically more challenging in analytic systems is that: They must support multiple columns of data The column types are not knowable at compile time, and thus the compiler can not typically generate optimized code Multicolumn sorting is also referred to as lexicographical sorting in some libraries. For example, given sales data for various customers and their state of residence, a user might want to find the lowest 10 orders for each state. Customer | State | Orders —--------+-------+------- 12345 | MA | 10.12 532432 | MA | 8.44 12345 | CA | 3.25 56232 | WA | 6.00 23442 | WA | 132.50 7844 | CA | 9.33 852353 | MA | 1.30 One way to do so is to order the data first by State and then by Orders: Customer | State | Orders —--------+-------+------- 12345 | CA | 3.25 7844 | CA | 9.33 852353 | MA | 1.30 532432 | MA | 8.44 12345 | MA | 10.12 56232 | WA | 6.00 23442 | WA | 132.50 (Note: While there are specialized ways for computing this particular query other than fully sorting the entire input (e.g. &quot;TopK&quot;), they typically need the same multi-column comparison operation described below. Thus while we will use the simplified example in this series, it applies much more broadly) Basic Implementation Let us take the example of a basic sort kernel which takes a set of columns as input, and returns a list of indices identifying a sorted order. &gt; lexsort_to_indices([ [&quot;MA&quot;, &quot;MA&quot;, &quot;CA&quot;, &quot;WA&quot;, &quot;WA&quot;, &quot;CA&quot;, &quot;MA&quot;] ]) [2, 5, 0, 1, 6, 3, 4] &gt; lexsort_to_indices([ [&quot;MA&quot;, &quot;MA&quot;, &quot;CA&quot;, &quot;WA&quot;, &quot;WA&quot;, &quot;CA&quot;, &quot;MA&quot;], [10.10, 8.44, 3.25, 6.00, 132.50, 9.33, 1.30] ]) [2, 5, 6, 1, 0, 3, 4] This function returns a list of indices instead of sorting the columns directly because it: Avoids expensive copying data during the sorting process Allows deferring copying of values until the latest possible moment Can be used to reorder additional columns that weren’t part of the sort key A straightforward implementation of lexsort_to_indices uses a comparator function, row index ┌─────┐ ┌─────┐ ┌─────┐ compare(left_index, right_index) 0 │ │ │ │ │ │ ┌├─────┤─ ─├─────┤─ ─├─────┤┐ │ │ │ │ │ │ │ │ ◀──────────────────┘ │ └├─────┤─ ─├─────┤─ ─├─────┤┘ │ │ │ │ │ │ │Comparator function compares one │ ├─────┤ ├─────┤ ├─────┤ multi-column row with another. │ │ │ │ │ │ │ │ ├─────┤ ├─────┤ ├─────┤ The data types of the columns │ │ │ │ │ │ │ and the sort options are not │ └─────┘ └─────┘ └─────┘ known at compile time, only │ ... runtime │ │ ┌┌─────┐─ ─┌─────┐─ ─┌─────┐┐ │ │ │ │ │ │ │ ◀────────────────────────────────┘ └├─────┤─ ─├─────┤─ ─├─────┤┘ │ │ │ │ │ │ ├─────┤ ├─────┤ ├─────┤ N-1 │ │ │ │ │ │ └─────┘ └─────┘ └─────┘ Customer State Orders UInt64 Utf8 F64 The comparator function compares each row a column at a time, based on the column types ┌────────────────────────────────┐ │ │ ▼ │ ┌ ─ ─ ─ ┐ ┌ ─ ─ ─ ┐ │ │ ┌─────┐ │┌─────┐│ │┌─────┐│ │ left_index │ │ │ │ │ │ │ └─────┘ │└─────┘│ │└─────┘│ Step 1: Compare State (UInt64) │ │ │ │ │ │ │ │ ┌─────┐ ┌─────┐ ┌─────┐ right_index│ │ ││ ││ ││ ││ └─────┘ └─────┘ └─────┘ Step 2: If State values equal │ │ │ │ compare Orders (F64) Customer State Orders │ UInt64 │ Utf8 │ │ F64 │ │ ─ ─ ─ ─ ─ ─ ─ ─ │ ▲ │ │ │ └───────────────────────┘ Pseudocode for this operation might look something like # Takes a list of columns and returns the lexicographically # sorted order as a list of indices def lexsort_to_indices(columns): comparator = build_comparator(columns) # Construct a list of integers from 0 to the number of rows # and sort it according to the comparator [0..columns.num_rows()].sort_by(comparator) # Build a function that given indexes (left_idx, right_idx) returns the comparison of the sort keys at the left and right indices respectively def build_comparator(columns): def comparator(left_idx, right_idx): for column in columns: # call a compare function which performs # dynamic dispatch on type of left and right columns ordering = compare(column, left_idx,right_idx) if ordering != Equal { return ordering } # All values equal Equal # Return comparator function comparator # compares the values in a single column at left_idx and right_idx def compare(column, left_idx, right_idx): # Choose comparison based on type of column (&quot;dynamic dispatch&quot;) if column.type == Int: cmp(column[left_idx].as_int(), column[right_idx].as_int()) elif column.type == Float: cmp(column[left_idx].as_float(), column[right_idx].as_float()) ... Greater detail is beyond the scope of this post, but in general the more predictable the behavior of a block of code, the better its performance will be. In the case of this pseudocode, there is clear room for improvement: comparator performs a large number of unpredictable conditional branches, where the path execution takes depends on the data values comparator and compare use dynamic dispatch, which not only adds further conditional branches, but also function call overhead comparator performs a large number of reads of memory at unpredictable locations You can find the complete implementation of multi-column comparator construction in arrow-rs in sort.rs and ord.rs. Normalized Keys / Byte Array Comparisons Now imagine we had a way to represent each logical row of data as a sequence of bytes, and that byte-wise comparison of that sequence yielded the same result as comparing the actual column values using the code above. Such a representation would require no switching on column types, and the kernel would become def lexsort_to_indices(columns): rows = convert_to_rows(columns) [0..columns.num_rows()].sort_by(lambda l, r: cmp(rows[l], rows[r])) While this approach does require converting to/from the byte array representation, it has some major advantages: Rows can be compared by comparing bytes in memory, which modern computer hardware excels at with the extremely well optimized memcmp Memory accesses are largely predictable There is no dynamic dispatch overhead Extends straightforwardly to more sophisticated sorting strategies such as Distribution-based sorting techniques such as radix sort Parallel merge sort External sort ... You can find more information on how to leverage such representation in the &quot;Binary String Comparison&quot; section of the DuckDB blog post on the topic as well as Graefe’s paper. However, we found it wasn’t immediately obvious how to apply this technique to variable length string or dictionary encoded data, which we will explain in the next post in this series. Next up: Row Format This post has introduced the concept and challenges of multi column sorting, and shown why a comparable byte array representation, such as the row format introduced to the Rust implementation of Apache Arrow, is such a compelling primitive. In the next post we explain how this encoding works, but if you just want to use it, check out the docs for getting started, and report any issues on our bugtracker. As always, the Arrow community very much looks forward to seeing what you build with it!","headline":"Fast and Memory Efficient Multi-Column Sorts in Apache Arrow Rust, Part 1","image":"https://arrow.apache.org/img/arrow-logo_horizontal_black-txt_white-bg.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://arrow.apache.org/blog/2022/11/07/multi-column-sorts-in-arrow-rust-part-1/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://arrow.apache.org/img/logo.png"},"name":"tustvold and alamb"},"url":"https://arrow.apache.org/blog/2022/11/07/multi-column-sorts-in-arrow-rust-part-1/"}</script>
<!-- End Jekyll SEO tag -->


    <!-- favicons -->
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png" id="light1">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png" id="light2">
    <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="/img/apple-touch-icon.png" id="light3">
    <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="/img/apple-touch-icon-120x120.png" id="light4">
    <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="/img/apple-touch-icon-76x76.png" id="light5">
    <link rel="apple-touch-icon" type="image/png" sizes="60x60" href="/img/apple-touch-icon-60x60.png" id="light6">
    <!-- dark mode favicons -->
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16-dark.png" id="dark1">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32-dark.png" id="dark2">
    <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="/img/apple-touch-icon-dark.png" id="dark3">
    <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="/img/apple-touch-icon-120x120-dark.png" id="dark4">
    <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="/img/apple-touch-icon-76x76-dark.png" id="dark5">
    <link rel="apple-touch-icon" type="image/png" sizes="60x60" href="/img/apple-touch-icon-60x60-dark.png" id="dark6">

    <script>
      // Switch to the dark-mode favicons if prefers-color-scheme: dark
      function onUpdate() {
        light1 = document.querySelector('link#light1');
        light2 = document.querySelector('link#light2');
        light3 = document.querySelector('link#light3');
        light4 = document.querySelector('link#light4');
        light5 = document.querySelector('link#light5');
        light6 = document.querySelector('link#light6');

        dark1 = document.querySelector('link#dark1');
        dark2 = document.querySelector('link#dark2');
        dark3 = document.querySelector('link#dark3');
        dark4 = document.querySelector('link#dark4');
        dark5 = document.querySelector('link#dark5');
        dark6 = document.querySelector('link#dark6');

        if (matcher.matches) {
          light1.remove();
          light2.remove();
          light3.remove();
          light4.remove();
          light5.remove();
          light6.remove();
          document.head.append(dark1);
          document.head.append(dark2);
          document.head.append(dark3);
          document.head.append(dark4);
          document.head.append(dark5);
          document.head.append(dark6);
        } else {
          dark1.remove();
          dark2.remove();
          dark3.remove();
          dark4.remove();
          dark5.remove();
          dark6.remove();
          document.head.append(light1);
          document.head.append(light2);
          document.head.append(light3);
          document.head.append(light4);
          document.head.append(light5);
          document.head.append(light6);
        }
      }
      matcher = window.matchMedia('(prefers-color-scheme: dark)');
      matcher.addListener(onUpdate);
      onUpdate();
    </script>

    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <script src="/javascript/main.js"></script>
    
    <!-- Matomo -->
<script>
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  /* We explicitly disable cookie tracking to avoid privacy issues */
  _paq.push(['disableCookies']);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="https://analytics.apache.org/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '20']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->

    
    <link type="application/atom+xml" rel="alternate" href="https://arrow.apache.org/feed.xml" title="Apache Arrow" />
  </head>


<body class="wrap">
  <header>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
  
  <a class="navbar-brand no-padding" href="/"><img src="/img/arrow-inverse-300px.png" height="40px"></a>
  
   <button class="navbar-toggler ml-auto" type="button" data-toggle="collapse" data-target="#arrow-navbar" aria-controls="arrow-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse justify-content-end" id="arrow-navbar">
      <ul class="nav navbar-nav">
        <li class="nav-item"><a class="nav-link" href="/overview/" role="button" aria-haspopup="true" aria-expanded="false">Overview</a></li>
        <li class="nav-item"><a class="nav-link" href="/faq/" role="button" aria-haspopup="true" aria-expanded="false">FAQ</a></li>
        <li class="nav-item"><a class="nav-link" href="/blog" role="button" aria-haspopup="true" aria-expanded="false">Blog</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownGetArrow" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Get Arrow
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownGetArrow">
            <a class="dropdown-item" href="/install/">Install</a>
            <a class="dropdown-item" href="/release/">Releases</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownDocumentation" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Docs
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownDocumentation">
            <a class="dropdown-item" href="/docs">Project Docs</a>
            <a class="dropdown-item" href="/docs/format/Columnar.html">Format</a>
            <hr>
            <a class="dropdown-item" href="/docs/c_glib">C GLib</a>
            <a class="dropdown-item" href="/docs/cpp">C++</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/blob/main/csharp/README.md" target="_blank" rel="noopener">C#</a>
            <a class="dropdown-item" href="https://godoc.org/github.com/apache/arrow/go/arrow" target="_blank" rel="noopener">Go</a>
            <a class="dropdown-item" href="/docs/java">Java</a>
            <a class="dropdown-item" href="/docs/js">JavaScript</a>
            <a class="dropdown-item" href="/julia/">Julia</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/blob/main/matlab/README.md" target="_blank" rel="noopener">MATLAB</a>
            <a class="dropdown-item" href="/docs/python">Python</a>
            <a class="dropdown-item" href="/docs/r">R</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/blob/main/ruby/README.md" target="_blank" rel="noopener">Ruby</a>
            <a class="dropdown-item" href="https://docs.rs/arrow/latest" target="_blank" rel="noopener">Rust</a>
            <a class="dropdown-item" href="/swift">Swift</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownSource" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Source
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownSource">
            <a class="dropdown-item" href="https://github.com/apache/arrow" target="_blank" rel="noopener">Main Repo</a>
            <hr>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/c_glib" target="_blank" rel="noopener">C GLib</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/cpp" target="_blank" rel="noopener">C++</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/csharp" target="_blank" rel="noopener">C#</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-go" target="_blank" rel="noopener">Go</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-java" target="_blank" rel="noopener">Java</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-js" target="_blank" rel="noopener">JavaScript</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-julia" target="_blank" rel="noopener">Julia</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/matlab" target="_blank" rel="noopener">MATLAB</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/python" target="_blank" rel="noopener">Python</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/r" target="_blank" rel="noopener">R</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/ruby" target="_blank" rel="noopener">Ruby</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-rs" target="_blank" rel="noopener">Rust</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-swift" target="_blank" rel="noopener">Swift</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownSubprojects" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Subprojects
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownSubprojects">
            <a class="dropdown-item" href="/adbc">ADBC</a>
            <a class="dropdown-item" href="/docs/format/Flight.html">Arrow Flight</a>
            <a class="dropdown-item" href="/docs/format/FlightSql.html">Arrow Flight SQL</a>
            <a class="dropdown-item" href="https://datafusion.apache.org" target="_blank" rel="noopener">DataFusion</a>
            <a class="dropdown-item" href="/nanoarrow">nanoarrow</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownCommunity" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Community
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownCommunity">
            <a class="dropdown-item" href="/community/">Communication</a>
            <a class="dropdown-item" href="/docs/developers/index.html">Contributing</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/issues" target="_blank" rel="noopener">Issue Tracker</a>
            <a class="dropdown-item" href="/committers/">Governance</a>
            <a class="dropdown-item" href="/use_cases/">Use Cases</a>
            <a class="dropdown-item" href="/powered_by/">Powered By</a>
            <a class="dropdown-item" href="/visual_identity/">Visual Identity</a>
            <a class="dropdown-item" href="/security/">Security</a>
            <a class="dropdown-item" href="https://www.apache.org/foundation/policies/conduct.html" target="_blank" rel="noopener">Code of Conduct</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownASF" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             ASF Links
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownASF">
            <a class="dropdown-item" href="https://www.apache.org/" target="_blank" rel="noopener">ASF Website</a>
            <a class="dropdown-item" href="https://www.apache.org/licenses/" target="_blank" rel="noopener">License</a>
            <a class="dropdown-item" href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener">Donate</a>
            <a class="dropdown-item" href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener">Thanks</a>
            <a class="dropdown-item" href="https://www.apache.org/security/" target="_blank" rel="noopener">Security</a>
          </div>
        </li>
      </ul>
    </div>
<!-- /.navbar-collapse -->
  </nav>

  </header>

  <div class="container p-4 pt-5">
    <div class="col-md-8 mx-auto">
      <main role="main" class="pb-5">
        
<h1>
  Fast and Memory Efficient Multi-Column Sorts in Apache Arrow Rust, Part 1
</h1>
<hr class="mt-4 mb-3">



<p class="mb-4 pb-1">
  <span class="badge badge-secondary">Published</span>
  <span class="published mr-3">
    07 Nov 2022
  </span>
  <br>
  <span class="badge badge-secondary">By</span>
  
    tustvold and alamb
  

  
</p>


        <!--

-->
<h2>Introduction</h2>
<p>Sorting is one of the most fundamental operations in modern databases and other analytic systems, underpinning important operators such as aggregates, joins, window functions, merge, and more. By some estimates, more than half of the execution time in data processing systems is spent sorting. Optimizing sorts is therefore vital to improving query performance and overall system efficiency.</p>
<p>Sorting is also one of the most well studied topics in computer science. The classic survey paper for databases is <a href="https://dl.acm.org/doi/10.1145/1132960.1132964" target="_blank" rel="noopener">Implementing Sorting in Database Systems</a> by Goetz Graefe which provides a thorough academic treatment and is still very applicable today. However, it may not be obvious how to apply the wisdom and advanced techniques described in that paper to modern systems. In addition, the excellent <a href="https://duckdb.org/2021/08/27/external-sorting.html" target="_blank" rel="noopener">DuckDB blog on sorting</a> highlights many sorting techniques, and mentions a comparable row format, but it does not explain how to efficiently sort variable length strings or dictionary encoded data.</p>
<p>In this series we explain in detail the new <a href="https://docs.rs/arrow/27.0.0/arrow/row/index.html" target="_blank" rel="noopener">row format</a> in the <a href="https://github.com/apache/arrow-rs" target="_blank" rel="noopener">Rust implementation</a> of <a href="https://arrow.apache.org/">Apache Arrow</a>, and how we used to make sorting more than <a href="https://github.com/apache/arrow-rs/pull/2929" target="_blank" rel="noopener">3x</a> faster than an alternate comparator based approach. The benefits are especially pronounced for strings, dictionary encoded data, and sorts with large numbers of columns.</p>
<h2>Multicolumn / Lexicographical Sort Problem</h2>
<p>Most languages have native, optimized operations to sort a single column (array) of data, which are specialized based on the type of data being sorted. The reason that sorting is typically more challenging in analytic systems is that:</p>
<ol>
<li>They must support multiple columns of data</li>
<li>The column types are not knowable at compile time, and thus the compiler can not typically generate optimized code</li>
</ol>
<p>Multicolumn sorting is also referred to as lexicographical sorting in some libraries.</p>
<p>For example, given sales data for various customers and their state of residence, a user might want to find the lowest 10 orders for each state.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code data-lang="text">Customer | State | Orders
—--------+-------+-------
12345    |  MA   |  10.12
532432   |  MA   |  8.44
12345    |  CA   |  3.25
56232    |  WA   |  6.00
23442    |  WA   |  132.50
7844     |  CA   |  9.33
852353   |  MA   |  1.30
</code></pre></div></div>
<p>One way to do so is to order the data first by <code>State</code> and then by <code>Orders</code>:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code data-lang="text">Customer | State | Orders
—--------+-------+-------
12345    |  CA   |  3.25
7844     |  CA   |  9.33
852353   |  MA   |  1.30
532432   |  MA   |  8.44
12345    |  MA   |  10.12
56232    |  WA   |  6.00
23442    |  WA   |  132.50
</code></pre></div></div>
<p>(Note: While there are specialized ways for computing this particular query other than fully sorting the entire input (e.g. "TopK"), they typically need the same multi-column comparison operation described below. Thus while we will use the simplified example in this series, it applies much more broadly)</p>
<h2>Basic Implementation</h2>
<p>Let us take the example of a basic sort kernel which takes a set of columns as input, and returns a list of indices identifying a sorted order.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code data-lang="python"><span class="o">&gt;</span> <span class="nf">lexsort_to_indices</span><span class="p">([</span>
    <span class="p">[</span><span class="sh">"</span><span class="s">MA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">MA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">CA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">WA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">WA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">CA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">MA</span><span class="sh">"</span><span class="p">]</span>
  <span class="p">])</span>

<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="nf">lexsort_to_indices</span><span class="p">([</span>
    <span class="p">[</span><span class="sh">"</span><span class="s">MA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">MA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">CA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">WA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">WA</span><span class="sh">"</span><span class="p">,</span>   <span class="sh">"</span><span class="s">CA</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">MA</span><span class="sh">"</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">10.10</span><span class="p">,</span> <span class="mf">8.44</span><span class="p">,</span> <span class="mf">3.25</span><span class="p">,</span> <span class="mf">6.00</span><span class="p">,</span> <span class="mf">132.50</span><span class="p">,</span> <span class="mf">9.33</span><span class="p">,</span> <span class="mf">1.30</span><span class="p">]</span>
  <span class="p">])</span>

<span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>
<p>This function returns a list of indices instead of sorting the columns directly because it:</p>
<ol>
<li>Avoids expensive copying data during the sorting process</li>
<li>Allows deferring copying of values until the latest possible moment</li>
<li>Can be used to reorder additional columns that weren’t part of the sort key</li>
</ol>
<p>A straightforward implementation of lexsort_to_indices uses a comparator function,</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code data-lang="text">   row
  index
        ┌─────┐   ┌─────┐   ┌─────┐     compare(left_index, right_index)
      0 │     │   │     │   │     │
       ┌├─────┤─ ─├─────┤─ ─├─────┤┐                   │             │
        │     │   │     │   │     │ ◀──────────────────┘             │
       └├─────┤─ ─├─────┤─ ─├─────┤┘                                 │
        │     │   │     │   │     │Comparator function compares one  │
        ├─────┤   ├─────┤   ├─────┤ multi-column row with another.   │
        │     │   │     │   │     │                                  │
        ├─────┤   ├─────┤   ├─────┤ The data types of the columns    │
        │     │   │     │   │     │  and the sort options are not    │
        └─────┘   └─────┘   └─────┘  known at compile time, only     │
                    ...                        runtime               │
                                                                     │
       ┌┌─────┐─ ─┌─────┐─ ─┌─────┐┐                                 │
        │     │   │     │   │     │ ◀────────────────────────────────┘
       └├─────┤─ ─├─────┤─ ─├─────┤┘
        │     │   │     │   │     │
        ├─────┤   ├─────┤   ├─────┤
    N-1 │     │   │     │   │     │
        └─────┘   └─────┘   └─────┘
        Customer    State    Orders
         UInt64      Utf8     F64
</code></pre></div></div>
<p>The comparator function compares each row a column at a time, based on the column types</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code data-lang="text">                         ┌────────────────────────────────┐
                         │                                │
                         ▼                                │
                     ┌ ─ ─ ─ ┐ ┌ ─ ─ ─ ┐                  │
                                                          │
            ┌─────┐  │┌─────┐│ │┌─────┐│                  │
left_index  │     │   │     │   │     │                   │
            └─────┘  │└─────┘│ │└─────┘│   Step 1: Compare State
                                                    (UInt64)
                     │       │ │       │

                     │       │ │       │
            ┌─────┐   ┌─────┐   ┌─────┐
 right_index│     │  ││     ││ ││     ││
            └─────┘   └─────┘   └─────┘    Step 2: If State values equal
                     │       │ │       │   compare Orders (F64)
            Customer   State     Orders                     │
             UInt64  │  Utf8 │ │  F64  │                    │
                      ─ ─ ─ ─   ─ ─ ─ ─                     │
                                    ▲                       │
                                    │                       │
                                    └───────────────────────┘
</code></pre></div></div>
<p>Pseudocode for this operation might look something like</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code data-lang="python"><span class="c1"># Takes a list of columns and returns the lexicographically
# sorted order as a list of indices
</span><span class="k">def</span> <span class="nf">lexsort_to_indices</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
  <span class="n">comparator</span> <span class="o">=</span> <span class="nf">build_comparator</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

  <span class="c1"># Construct a list of integers from 0 to the number of rows
</span>  <span class="c1"># and sort it according to the comparator
</span>  <span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">columns</span><span class="p">.</span><span class="nf">num_rows</span><span class="p">()].</span><span class="nf">sort_by</span><span class="p">(</span><span class="n">comparator</span><span class="p">)</span>

<span class="c1"># Build a function that given indexes (left_idx, right_idx)
# returns the comparison of the sort keys at the left
# and right indices respectively
</span><span class="k">def</span> <span class="nf">build_comparator</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">comparator</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
      <span class="c1"># call a compare function which performs
</span>      <span class="c1"># dynamic dispatch on type of left and right columns
</span>      <span class="n">ordering</span> <span class="o">=</span> <span class="nf">compare</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">left_idx</span><span class="p">,</span><span class="n">right_idx</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">ordering</span> <span class="o">!=</span> <span class="n">Equal</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ordering</span>
      <span class="p">}</span>
    <span class="c1"># All values equal
</span>    <span class="n">Equal</span>
  <span class="c1"># Return comparator function
</span>  <span class="n">comparator</span>

  <span class="c1"># compares the values in a single column at left_idx and right_idx
</span>  <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">):</span>
    <span class="c1"># Choose comparison based on type of column ("dynamic dispatch")
</span>    <span class="k">if</span> <span class="n">column</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="n">Int</span><span class="p">:</span>
     <span class="nf">cmp</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="n">left_idx</span><span class="p">].</span><span class="nf">as_int</span><span class="p">(),</span> <span class="n">column</span><span class="p">[</span><span class="n">right_idx</span><span class="p">].</span><span class="nf">as_int</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">column</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="n">Float</span><span class="p">:</span>
     <span class="nf">cmp</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="n">left_idx</span><span class="p">].</span><span class="nf">as_float</span><span class="p">(),</span> <span class="n">column</span><span class="p">[</span><span class="n">right_idx</span><span class="p">].</span><span class="nf">as_float</span><span class="p">())</span>
    <span class="bp">...</span>
</code></pre></div></div>
<p>Greater detail is beyond the scope of this post, but in general the more predictable the behavior of a block of code, the better its performance will be. In the case of this pseudocode,  there is clear room for improvement:</p>
<ol>
<li>
<code>comparator</code> performs a large number of unpredictable conditional branches, where the path execution takes depends on the data values</li>
<li>
<code>comparator</code> and <code>compare</code> use dynamic dispatch, which not only adds further conditional branches, but also function call overhead</li>
<li>
<code>comparator</code> performs a large number of reads of memory at unpredictable locations</li>
</ol>
<p>You can find the complete implementation of multi-column comparator construction in arrow-rs in <a href="https://github.com/apache/arrow-rs/blob/f629a2ebe08033e7b78585d82e98c50a4439e7a2/arrow/src/compute/kernels/sort.rs#L905-L1036" target="_blank" rel="noopener">sort.rs</a> and <a href="https://github.com/apache/arrow-rs/blob/f629a2e/arrow/src/array/ord.rs#L178-L313" target="_blank" rel="noopener">ord.rs</a>.</p>
<h1>Normalized Keys / Byte Array Comparisons</h1>
<p>Now imagine we had a way to represent each logical row of data as a sequence of bytes, and that byte-wise comparison of that sequence yielded the same result as comparing the actual column values using the code above. Such a representation would require no switching on column types, and the kernel would become</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code data-lang="python"><span class="k">def</span> <span class="nf">lexsort_to_indices</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
  <span class="n">rows</span> <span class="o">=</span> <span class="nf">convert_to_rows</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
  <span class="p">[</span><span class="mf">0.</span><span class="p">.</span><span class="n">columns</span><span class="p">.</span><span class="nf">num_rows</span><span class="p">()].</span><span class="nf">sort_by</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">rows</span><span class="p">[</span><span class="n">r</span><span class="p">]))</span>
</code></pre></div></div>
<p>While this approach does require converting to/from the byte array representation, it has some major advantages:</p>
<ul>
<li>Rows can be compared by comparing bytes in memory, which modern computer hardware excels at with the extremely well optimized <a href="https://www.man7.org/linux/man-pages/man3/memcmp.3.html" target="_blank" rel="noopener">memcmp</a>
</li>
<li>Memory accesses are largely predictable</li>
<li>There is no dynamic dispatch overhead</li>
<li>Extends straightforwardly to more sophisticated sorting strategies such as
<ul>
<li>Distribution-based sorting techniques such as radix sort</li>
<li>Parallel merge sort</li>
<li>External sort</li>
<li>...</li>
</ul>
</li>
</ul>
<p>You can find more information on how to leverage such representation in the "Binary String Comparison" section of the <a href="https://duckdb.org/2021/08/27/external-sorting.html" target="_blank" rel="noopener">DuckDB blog post</a> on the topic as well as <a href="https://dl.acm.org/doi/10.1145/1132960.1132964" target="_blank" rel="noopener">Graefe’s paper</a>. However, we found it wasn’t immediately obvious how to apply this technique to variable length string or dictionary encoded data, which we will explain in the next post in this series.</p>
<h2>Next up: Row Format</h2>
<p>This post has introduced the concept and challenges of multi column sorting, and shown why a comparable byte array representation, such as the <a href="https://docs.rs/arrow/27.0.0/arrow/row/index.html" target="_blank" rel="noopener">row format</a> introduced to the <a href="https://github.com/apache/arrow-rs" target="_blank" rel="noopener">Rust implementation</a> of <a href="https://arrow.apache.org/">Apache Arrow</a>, is such a compelling primitive.</p>
<p>In <a href="/blog/2022/11/07/multi-column-sorts-in-arrow-rust-part-2/">the next post</a> we explain how this encoding works, but if you just want to use it, check out the <a href="https://docs.rs/arrow/27.0.0/arrow/row/index.html" target="_blank" rel="noopener">docs</a> for getting started, and report any issues on our <a href="https://github.com/apache/arrow-rs/issues" target="_blank" rel="noopener">bugtracker</a>. As always, the <a href="https://github.com/apache/arrow-rs#arrow-rust-community" target="_blank" rel="noopener">Arrow community</a> very much looks forward to seeing what you build with it!</p>

      </main>
    </div>

    <hr>
<footer class="footer">
  <div class="row">
    <div class="col-md-9">
      <p>Apache Arrow, Arrow, Apache, the Apache logo, and the Apache Arrow project logo are either registered trademarks or trademarks of The Apache Software Foundation in the United States and other countries.</p>
      <p>© 2016-2025 The Apache Software Foundation</p>
    </div>
    <div class="col-md-3">
      <a class="d-sm-none d-md-inline pr-2" href="https://www.apache.org/events/current-event.html" target="_blank" rel="noopener">
        <img src="https://www.apache.org/events/current-event-234x60.png">
      </a>
    </div>
  </div>
</footer>

  </div>
</body>
</html>
