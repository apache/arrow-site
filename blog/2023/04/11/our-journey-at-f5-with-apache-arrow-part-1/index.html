<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above meta tags *must* come first in the head; any other head content must come *after* these tags -->
    
    <title>Our journey at F5 with Apache Arrow (part 1) | Apache Arrow</title>
    

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Our journey at F5 with Apache Arrow (part 1)" />
<meta name="author" content="Laurent Quérel" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Apache Arrow is a technology widely adopted in big data, analytics, and machine learning applications. In this article, we share F5’s experience with Arrow, specifically its application to telemetry, and the challenges we encountered while optimizing the OpenTelemetry protocol to significantly reduce bandwidth costs. The promising results we achieved inspired us to share our insights. This article specifically focuses on transforming relatively complex data structure from various formats into an efficient Arrow representation that optimizes both compression ratio, transport, and data processing. We also explore the trade-offs between different mapping and normalization strategies, as well as the nuances of streaming and batch communication using Arrow and Arrow Flight. Our benchmarks thus far have shown promising results, with compression ratio improvements ranging from 1.5x to 5x, depending on the data type (metrics, logs, traces), distribution, and compression algorithm. The approaches presented for addressing these challenges may be applicable to other Arrow domains as well. This article serves as the first installment in a two-part series. What is Apache Arrow Apache Arrow is an open-source project offering a standardized, language-agnostic in-memory format for representing structured and semi-structured data. This enables data sharing and zero-copy data access between systems, eliminating the need for serialization and deserialization when exchanging datasets between varying CPU architectures and programming languages. Furthermore, Arrow libraries feature an extensive set of high-performance, parallel, and vectorized kernel functions designed for efficiently processing massive amounts of columnar data. These features make Arrow an appealing technology for big data processing, data transport, analytics, and machine learning applications. The growing number of products and open-source projects that have adopted Apache Arrow at their core or offer Arrow support reflects the widespread recognition and appreciation of its benefits (refer to this article for an in-depth overview of the Arrow ecosystem and adoption). Over 11,000 GitHub users support this project, and 840+ are contributors who make this project an undeniable success. Very often people ask about the differences between Arrow and Apache Parquet or other columnar file formats. Arrow is designed and optimized for in-memory processing, while Parquet is tailored for disk-based storage. In reality, these technologies are complementary, with bridges existing between them to simplify interoperability. In both cases, data is represented in columns to optimize access, data locality and compressibility. However, the tradeoffs differ slightly. Arrow prioritizes data processing speed over the optimal data encoding. Complex encodings that don’t benefit from SIMD instruction sets are generally not natively supported by Arrow, unlike formats such as Parquet. Storing data in Parquet format and processing and transporting it in Arrow format has become a prevalent model within the big data community. Fig 1: Memory representations: row vs columnar data. Figure 1 illustrates the differences in memory representation between row-oriented and column-oriented approaches. The column-oriented approach groups data from the same column in a continuous memory area, which facilitates parallel processing (SIMD) and enhances compression performance. Why are we interested in Apache Arrow At F5, we’ve adopted OpenTelemetry (OTel) as the standard for all telemetry across our products, such as BIGIP and NGINX. These products may generate large volumes of metrics and logs for various reasons, from performance evaluation to forensic purposes. The data produced by these systems is typically centralized and processed in dedicated systems. Transporting and processing this data accounts for a significant portion of the cost associated with telemetry pipelines. In this context, we became interested in Apache Arrow. Instead of reinventing yet another telemetry solution, we decided to invest in the OpenTelemetry project, working on improvements to the protocol to significantly increase its efficiency with high telemetry data volumes. We collaborated with Joshua MacDonald from Lightstep to integrate these optimizations into an experimental OTel collector and are currently in discussions with the OTel technical committee to finalize a code donation. Fig 2: Performance improvement in the OpenTelemetry Arrow experimental project. This project has been divided into two phases. The first phase, which is nearing completion, aims to enhance the protocol’s compression ratio. The second phase, planned for the future, focuses on improving end-to-end performance by incorporating Apache Arrow throughout all levels, eliminating the need for conversion between old and new protocols. The results so far are promising, with our benchmarks showing compression ratio improvements ranging from x1.5 to x5, depending on the data type (metrics, logs, traces), distribution, and compression algorithm. For the second phase, our estimates suggest that data processing acceleration could range from x2 to x12, again depending on the data’s nature and distribution. For more information, we encourage you to review the specifications and the reference implementation. Arrow relies on a schema to define the structure of data batches that it processes and transports. The subsequent sections will discuss various techniques that can be employed to optimize the creation of these schemas. How to leverage Arrow to optimize network transport cost Apache Arrow is a complex project with a rapidly evolving ecosystem, which can sometimes be overwhelming for newcomers. Fortunately the Arrow community has published three introductory articles 1, 2, and 3 that we recommend for those interested in exploring this technology. This article primarily focuses on transforming data from an XYZ format into an efficient Arrow representation that optimizes both compression ratio and data processing. There are numerous approaches to this transformation, and we will examine how these methods can impact compression ratio, CPU usage, and memory consumption during the conversion process, among other factors. Fig 3: Optimization process for the definition of an Arrow schema. The complexity of your initial model significantly impacts the Arrow mapping choices you need to make. To begin, it’s essential to identify the properties you want to optimize for your specific context. Compression rate, conversion speed, memory consumption, speed and ease of use of the final model, compatibility, and extensibility are all factors that can influence your final mapping decisions. From there, you must explore multiple alternative schemas. The choice of the Arrow type and data encoding for each individual field will affect the performance of your schema. There are various ways to represent hierarchical data or highly dynamic data models, and multiple options need to be evaluated in coordination with the configuration of the transport layer. This transport layer should also be carefully considered. Arrow supports compression mechanisms and dictionary deltas that may not be active by default. After several iterations of this process, you should arrive at an optimized schema that meets the goals you initially set. It’s crucial to compare the performance of your different approaches using real data, as the distribution of data in each individual field may influence whether you use dictionary encoding or not. We will now examine these choices in greater detail throughout the remainder of this article. Arrow data type selection The principles of selecting an Arrow data type are quite similar to those used when defining a data model for databases. Arrow supports a wide range of data types. Some of these types are supported by all implementations, while others are only available for languages with the strongest Arrow community support (see this page for a comparison matrix of the different implementations). For primitive types, it is generally preferable to choose the type that offers the most concise representation and is closest to the semantics of your initial field. For example, while it’s possible to represent a timestamp with an int64, it’s more advantageous to use the native Arrow Timestamp type. This choice isn’t due to a more efficient binary representation, but rather because it will be easier to process and manipulate in your pipeline. Query engines such as DataFusion offer dedicated timestamp handling functions for columns of this type. The same choices can be made for primitive types such as date, time, duration, and interval. However, if your project requires maximum compatibility, it may be crucial in some cases to favor types with universal support instead of the most optimal type in terms of memory occupation. Fig 4: Data types supported by Apache Arrow. When selecting the Arrow data type, it’s important to consider the size of the data before and after compression. It’s quite possible that the size after compression is the same for two different types, but the actual size in memory may be two, four, or even eight times larger (e.g., uint8 vs. uint64). This difference will impact your ability to process large batches of data and will also significantly influence the speed of processing these data in memory (e.g., cache optimization, SIMD instruction efficiency). It’s also possible to extend these types using an extension type mechanism that builds upon one of the currently supported primitive types while adding specific semantics. This extension mechanism can simplify the use of this data in your own project, while remaining transparent to intermediate systems that will interpret this data as a basic primitive type. There are some variations in the encoding of primitive types, which we will explore next. Data encoding Another crucial aspect of optimizing your Arrow schema is analyzing the cardinality of your data. Fields that can have only a limited number of values will typically be more efficiently represented with a dictionary encoding. The maximum cardinality of a field determines the data type characteristics of your dictionary. For instance, for a field representing the status code of an HTTP transaction, it’s preferable to use a dictionary with an index of type ‘uint8’ and a value of type ‘uint16’ (notation: ‘Dictionary&lt;uint8, uint16&gt;’). This consumes less memory because the main array will be of type ‘[]uint8’. Even if the range of possible values is greater than 255, as long as the number of distinct values does not exceed 255, the representation remains efficient. Similarly, the representation of a ‘user-agent’ will be more efficient with a dictionary of type ‘Dictionary&lt;uint16, string&gt;’ (see figure 5). In this case, the main array will be of type ‘uint16’, allowing a compact representation in memory and during transfers at the cost of an indirection during reverse conversion. Fig 5: Dictionary encoding. Dictionary encoding is highly flexible in Apache Arrow, allowing the creation of encodings for any Arrow primitive type. The size of the indices can also be configured based on the context. In general, it is advisable to use dictionaries in the following cases: Representation of enumerations Representation of textual or binary fields with a high probability of having redundant values. Representation of fields with cardinalities known to be below 2^16 or 2^32. Sometimes, the cardinality of a field is not known a priori. For example, a proxy that transforms a data stream from a row-oriented format into a series of columnar-encoded batches (e.g., OpenTelemetry collector) may not be able to predict in advance whether a field will have a fixed number of distinct values. Two approaches are possible: 1) a conservative approach using the largest data type (e.g., ‘int64’, ‘string’, etc., instead of dictionary), 2) an adaptive approach that modifies the schema on the fly based on the observed cardinality of the field(s). In this second approach, without cardinality information, you can optimistically start by using a ‘Dictionary&lt;uint8, original-field-type&gt;’ dictionary, then detect a potential dictionary overflow during conversion, and change the schema to a ‘Dictionary&lt;uint16, original-field-type&gt;’ in case of an overflow. This technique of automatic management of dictionary overflows will be presented in greater detail in a future article. Recent advancements in Apache Arrow include the implementation of run-end encoding, a technique that efficiently represents data with sequences of repeated values. This encoding method is particularly beneficial for handling data sets containing long stretches of identical values, as it offers a more compact and optimized representation. In conclusion, dictionary encoding not only occupies less space in memory and during transfers but also significantly improves the compression ratio and data processing speed. However, this type of representation requires indirection when extracting the initial values (although this isn’t always necessary, even during some data processing operations). Additionally, it is important to manage dictionary index overflow, especially when the encoded field doesn’t have a well-defined cardinality. Hierarchical data Basic hierarchical data structures translate relatively well into Arrow. However, as we will see, there are some complications to handle in more general cases (see figure 6). While Arrow schemas do support nested structures, maps, and unions, some components of the Arrow ecosystem do not fully support them, which can make these Arrow data types unsuitable for certain scenarios. Additionally, unlike most languages and formats, such as Protobuf, Arrow doesn’t support the concept of a recursively defined schema. An Arrow schema is static in its definition, and the depth of its nested elements must be known in advance. There are multiple strategies to work around this limitation and we’ll explore these in the following sections. Fig 6: simple vs complex data model. Natural representation The most straightforward and intuitive approach to representing a simple hierarchical data model is to use Arrow’s list, map, and union data types. However, it’s important to note that some of these data types are not fully supported throughout the entire Arrow ecosystem. For example, the conversion of unions to Parquet is not directly supported and requires a transformation step (see denormalization &amp; flattening representation to decompose a sparse union into a nullable struct and type ids column). Similarly, lists and maps are not yet supported in DataFusion version 20 (nested structures are partially supported). Fig 7: initial data model. The following example is a Go program snippet of an Arrow schema using these different data types to represent the model above. import &quot;github.com/apache/arrow/go/v11/arrow&quot; const ( GaugeMetricCode arrow.UnionTypeCode = 0 SumMetricCode arrow.UnionTypeCode = 1 ) var ( // uint8Dictionary represent a Dictionary&lt;Uint8, String&gt; uint8Dictionary = &amp;arrow.DictionaryType{ IndexType: arrow.PrimitiveTypes.Uint8, ValueType: arrow.BinaryTypes.String, } // uint16Dictionary represent a Dictionary&lt;Uint16, String&gt; uint16Dictionary = &amp;arrow.DictionaryType{ IndexType: arrow.PrimitiveTypes.Uint16, ValueType: arrow.BinaryTypes.String, } Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;resource_metrics&quot;, Type: arrow.ListOf(arrow.StructOf([]arrow.Field{ {Name: &quot;scope&quot;, Type: arrow.StructOf([]arrow.Field{ // Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)). {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;version&quot;, Type: uint16Dictionary}, }...)}, {Name: &quot;metrics&quot;, Type: arrow.ListOf(arrow.StructOf([]arrow.Field{ {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;unit&quot;, Type: uint8Dictionary}, {Name: &quot;timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;data_point&quot;, Type: arrow.ListOf(arrow.StructOf([]arrow.Field{ {Name: &quot;metric&quot;, Type: arrow.DenseUnionOf( []arrow.Field{ {Name: &quot;gauge&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;data_point&quot;, Type: arrow.FLOAT64}, }...)}, {Name: &quot;sum&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;data_point&quot;, Type: arrow.FLOAT64}, {Name: &quot;is_monotonic&quot;, Type: arrow.BOOL}, }...)}, }, []arrow.UnionTypeCode{GaugeMetricCode, SumMetricCode}, )}, }...))}, }...))}, }...))}, }, nil) ) In this pattern, we use a union type to represent an inheritance relationship. There are two types of Arrow union that are optimized for different cases. The dense union type has a relatively succinct memory representation but doesn’t support vectorizable operations, making it less efficient during the processing phase. Conversely, a sparse union supports vectorization operations, but comes with a memory overhead directly proportional to the number of variants in the union. Dense and sparse unions have quite similar compression rates, with sometimes a slight advantage for sparse unions. In addition, sparse unions with a large number of variants should generally be avoided, as they can lead to excessive memory consumption. For more details on the memory representation of unions, you can consult this page. In certain scenarios, it may be more idiomatic to represent the inheritance relationship using multiple schemas (i.e., one schema per subtype), thereby avoiding the use of the union type. However, applying this approach to the aforementioned model may not be optimal, as the data preceding the inheritance relationship (i.e., ResourceMetrics, Scope, and Metrics) could potentially be duplicated numerous times. If the relationships between ResourceMetrics, Metrics, and DataPoint were 0..1 (zero-to-one) relationships, then the multi-schema approach would likely be the simplest and most idiomatic solution. Denormalization &amp; Flattening representations If the List type is not supported in your telemetry pipeline, you can denormalize your data model. This process is often used in the database world to remove a join between two tables for optimization purposes. In the Arrow world, denormalization is employed to eliminate the List type by duplicating some data. Once transformed, the previous Arrow schema becomes. Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;resource_metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;scope&quot;, Type: arrow.StructOf([]arrow.Field{ // Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)). {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;version&quot;, Type: uint16Dictionary}, }...)}, {Name: &quot;metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;unit&quot;, Type: uint8Dictionary}, {Name: &quot;timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;data_point&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;metric&quot;, Type: arrow.DenseUnionOf( []arrow.Field{ {Name: &quot;gauge&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;value&quot;, Type: arrow.FLOAT64}, }...)}, {Name: &quot;sum&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;value&quot;, Type: arrow.FLOAT64}, {Name: &quot;is_monotonic&quot;, Type: arrow.BOOL}, }...)}, }, []arrow.UnionTypeCode{GaugeMetricCode, SumMetricCode}, )}, }...)}, }...)}, }...)}, }, nil) List types are eliminated at all levels. The initial semantics of the model are preserved by duplicating the data of the levels below each data point value. The memory representation will generally be much larger than the previous one, but a query engine that does not support the List type will still be able to process this data. Interestingly, once compressed, this way of representing data may not necessarily be larger than the previous approach. This is because the columnar representation compresses very well when there is redundancy in the data. If the union type is not supported by some components of your pipeline, it is also possible to eliminate them by merging the union variants (the nested structure ‘metric’ is removed, see below). Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;resource_metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;scope&quot;, Type: arrow.StructOf([]arrow.Field{ // Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)). {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;version&quot;, Type: uint16Dictionary}, }...)}, {Name: &quot;metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;unit&quot;, Type: uint8Dictionary}, {Name: &quot;timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;data_point&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;value&quot;, Type: arrow.FLOAT64}, {Name: &quot;is_monotonic&quot;, Type: arrow.BOOL}, }...)}, }...)}, }...)}, }, nil) The final schema has evolved into a series of nested structures, where the fields of the union variants are merged into one structure. The trade-off of this approach is similar to that of sparse union - the more variants, the higher the memory occupation. Arrow supports the concept of bitmap validity to identify null values (1 bit per entry) for various data types, including those that do not have a unique null representation (e.g., primitive types). The use of bitmap validity makes the query part easier, and query engines such as DataFusion know how to use if efficiently, Columns with numerous nulls typically compress quite efficiently since the underlying arrays are generally initialized with 0’s. Upon compression, these extensive sequences of 0’s result in high compression efficiency, despite the memory overhead before compression in the case of sparse unions. Consequently, it is essential to select the appropriate trade-off based on your specific context. In some extreme situations where nested structures are not supported, a flattening approach can be used to address this problem. Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;scope_name&quot;, Type: uint16Dictionary}, {Name: &quot;scope_version&quot;, Type: uint16Dictionary}, {Name: &quot;metrics_name&quot;, Type: uint16Dictionary}, {Name: &quot;metrics_unit&quot;, Type: uint8Dictionary}, {Name: &quot;metrics_timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metrics_metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;metrics_data_point_value&quot;, Type: arrow.FLOAT64}, {Name: &quot;metrics_data_point_is_monotonic&quot;, Type: arrow.BOOL}, }, nil) The terminal fields (leaves) are renamed by concatenating the names of the parent structures to provide proper scoping. This type of structure is supported by all components of the Arrow ecosystem. This approach can be useful if compatibility is a crucial criterion for your system. However, it shares the same drawbacks as other alternative denormalization models. The Arrow ecosystem is evolving rapidly, so it is likely that support for List, Map, and Union data types in query engines will improve quickly. If kernel functions are sufficient or preferable for your application, it is usually possible to utilize these nested types. Adaptive/Dynamic representation Some data models can be more challenging to translate into an Arrow schema, such as the following Protobuf example. In this example, a collection of attributes is added to each data point. These attributes are defined using a recursive definition that most languages and formats, like Protobuf, support (see the ‘AnyValue’ definition below). Unfortunately, Arrow (like most classical database schemas) does not support such recursive definition within schemas. syntax = &quot;proto3&quot;; message Metric { message DataPoint { repeated Attribute attributes = 1; oneof value { int64 int_value = 2; double double_value = 3; } } enum MetricType { UNSPECIFIED = 0; GAUGE = 1; SUM = 2; } message Gauge { DataPoint data_point = 1; } message Sum { DataPoint data_point = 1; bool is_monotonic = 2; } string name = 1; int64 timestamp = 2; string unit = 3; MetricType type = 4; oneof metric { Gauge gauge = 5; Sum sum = 6; } } message Attribute { string name = 1; AnyValue value = 2; } // Recursive definition of AnyValue. AnyValue can be a primitive value, a list // of AnyValues, or a list of key-value pairs where the key is a string and // the value is an AnyValue. message AnyValue { message ArrayValue { repeated AnyValue values = 1; } message KeyValueList { message KeyValue { string key = 1; AnyValue value = 2; } repeated KeyValue values = 1; } oneof value { int64 int_value = 1; double double_value = 2; string string_value = 3; ArrayValue list_value = 4; KeyValueList kvlist_value = 5; } } If the definition of the attributes were non-recursive, it would have been possible to directly translate them into an Arrow Map type. To address this kind of issue and further optimize Arrow schema definitions, you can employ an adaptive and iterative method that automatically constructs the Arrow schema based on the data being translated. With this approach, fields are automatically dictionary-encoded according to their cardinalities, unused fields are eliminated, and recursive structures are represented in a specific manner. Another solution involves using a multi-schema approach, in which attributes are depicted in a separate Arrow Record, and the inheritance relation is represented by a self-referential relationship. These strategies will be covered in more depth in a future article. For those eager to learn more, the first method is utilized in the reference implementation of the OTel Arrow Adapter. Data transport Unlike to Protobuf, an Arrow schema is generally not known a priori by the two parties participating in an exchange. Before being able to exchange data in Arrow format, the sender must first communicate the schema to the receiver, as well as the contents of the dictionaries used in the data. Only after this initialization phase has been completed can the sender transmit batches of data in Arrow format. This process, known as Arrow IPC Stream, plays an essential role transporting Arrow data between systems. Several approaches can be employed to communicate these Arrow IPC Streams. The simplest method is to use Arrow Flight, which encapsulates Arrow IPC streams in a gRPC-based protocol. However, it is also possible to use your own implementation for specific contexts. Regardless of the solution you choose, it is crucial to understand that the underlying protocol must be stateful to take full advantage of the Arrow IPC stream approach. To achieve the best compression rates, it is vital to send schemas and dictionaries only once in order to amortize the cost and minimize data redundancy between batches. This necessitates a transport that supports stream-oriented communications, such as gRPC. Using a stateless protocol is possible for large batches because the overhead of the schema will be negligible compared to the compression gains achieved using dictionary encoding and columnar representation. However, dictionaries will have to be communicated for each batch, making this approach generally less efficient than a stream-oriented approach. Arrow IPC Stream also supports the concept of “delta dictionaries,” which allows for further optimization of batch transport. When a batch adds data to an existing dictionary (at the sender’s end), Arrow IPC enables sending the delta dictionary followed by the batch that references it. On the receiver side, this delta is used to update the existing dictionary, eliminating the need to retransmit the entire dictionary when changes occur. This optimization is only possible with a stateful protocol. To fully leverage the column-oriented format of Apache Arrow, it is essential to consider sorting and compression. If your data model is simple (i.e., flat) and has one or more columns representing a natural order for your data (e.g., timestamp), it might be beneficial to sort your data to optimize the final compression ratio. Before implementing this optimization, it is recommended to perform tests on real data since the benefits may vary. In any case, using a compression algorithm when sending your batches is advantageous. Arrow IPC generally supports the ZSTD compression algorithm, which strikes an excellent balance between speed and compression efficiency, especially for column-oriented data. Lastly, some implementations (e.g., Arrow Go) are not configured by default to support delta dictionaries and compression algorithms. Therefore, it is crucial to ensure that your code employs these options to maximize data transport efficiency. Experiments If your initial data is complex, it is advisable to conduct your own experiments to optimize the Arrow representation according to your data and goals (e.g., optimizing the compression ratio or enhancing the query-ability of your data in Arrow format). In our case, we developed an overlay for Apache Arrow that enables us to carry out these experiments with ease, without having to deal with the intrinsic complexity of Arrow APIs. However, this comes at the expense of a slower conversion phase compared to using Arrow APIs directly. While this library is not currently public, it may become available if there is sufficient interest. We also employed a “black box optimization” approach, which automatically finds the best combination to meet the objectives we aimed to optimize (refer to “Optimize your applications using Google Vertex AI Vizier” for a description of this approach). Conclusion and next steps Essentially, the key concept behind Apache Arrow is that it eliminates the need for serialization and deserialization, enabling zero-copy data sharing. Arrow achieves this by defining a language-agnostic, in-memory format that remains consistent across various implementations. Consequently, raw memory bytes can be transmitted directly over a network without requiring any serialization or deserialization, significantly enhancing data processing efficiency. Converting a data model to Apache Arrow necessitates adaptation and optimization work, as we have begun to describe in this article. Many parameters must be considered, and it is recommended to perform a series of experiments to validate the various choices made during this process. Handling highly dynamic data with Arrow can be challenging. Arrow requires the definition of a static schema, which can sometimes make representing this type of data complex or suboptimal, especially when the initial schema contains recursive definitions. This article has discussed several approaches to address this issue. The next article will be dedicated to a hybrid strategy that involves adapting the Arrow schema on-the-fly to optimize memory usage, compression ratio, and processing speed based on the data being represented. This approach is quite unique and deserves a separate article." />
<meta property="og:description" content="Apache Arrow is a technology widely adopted in big data, analytics, and machine learning applications. In this article, we share F5’s experience with Arrow, specifically its application to telemetry, and the challenges we encountered while optimizing the OpenTelemetry protocol to significantly reduce bandwidth costs. The promising results we achieved inspired us to share our insights. This article specifically focuses on transforming relatively complex data structure from various formats into an efficient Arrow representation that optimizes both compression ratio, transport, and data processing. We also explore the trade-offs between different mapping and normalization strategies, as well as the nuances of streaming and batch communication using Arrow and Arrow Flight. Our benchmarks thus far have shown promising results, with compression ratio improvements ranging from 1.5x to 5x, depending on the data type (metrics, logs, traces), distribution, and compression algorithm. The approaches presented for addressing these challenges may be applicable to other Arrow domains as well. This article serves as the first installment in a two-part series. What is Apache Arrow Apache Arrow is an open-source project offering a standardized, language-agnostic in-memory format for representing structured and semi-structured data. This enables data sharing and zero-copy data access between systems, eliminating the need for serialization and deserialization when exchanging datasets between varying CPU architectures and programming languages. Furthermore, Arrow libraries feature an extensive set of high-performance, parallel, and vectorized kernel functions designed for efficiently processing massive amounts of columnar data. These features make Arrow an appealing technology for big data processing, data transport, analytics, and machine learning applications. The growing number of products and open-source projects that have adopted Apache Arrow at their core or offer Arrow support reflects the widespread recognition and appreciation of its benefits (refer to this article for an in-depth overview of the Arrow ecosystem and adoption). Over 11,000 GitHub users support this project, and 840+ are contributors who make this project an undeniable success. Very often people ask about the differences between Arrow and Apache Parquet or other columnar file formats. Arrow is designed and optimized for in-memory processing, while Parquet is tailored for disk-based storage. In reality, these technologies are complementary, with bridges existing between them to simplify interoperability. In both cases, data is represented in columns to optimize access, data locality and compressibility. However, the tradeoffs differ slightly. Arrow prioritizes data processing speed over the optimal data encoding. Complex encodings that don’t benefit from SIMD instruction sets are generally not natively supported by Arrow, unlike formats such as Parquet. Storing data in Parquet format and processing and transporting it in Arrow format has become a prevalent model within the big data community. Fig 1: Memory representations: row vs columnar data. Figure 1 illustrates the differences in memory representation between row-oriented and column-oriented approaches. The column-oriented approach groups data from the same column in a continuous memory area, which facilitates parallel processing (SIMD) and enhances compression performance. Why are we interested in Apache Arrow At F5, we’ve adopted OpenTelemetry (OTel) as the standard for all telemetry across our products, such as BIGIP and NGINX. These products may generate large volumes of metrics and logs for various reasons, from performance evaluation to forensic purposes. The data produced by these systems is typically centralized and processed in dedicated systems. Transporting and processing this data accounts for a significant portion of the cost associated with telemetry pipelines. In this context, we became interested in Apache Arrow. Instead of reinventing yet another telemetry solution, we decided to invest in the OpenTelemetry project, working on improvements to the protocol to significantly increase its efficiency with high telemetry data volumes. We collaborated with Joshua MacDonald from Lightstep to integrate these optimizations into an experimental OTel collector and are currently in discussions with the OTel technical committee to finalize a code donation. Fig 2: Performance improvement in the OpenTelemetry Arrow experimental project. This project has been divided into two phases. The first phase, which is nearing completion, aims to enhance the protocol’s compression ratio. The second phase, planned for the future, focuses on improving end-to-end performance by incorporating Apache Arrow throughout all levels, eliminating the need for conversion between old and new protocols. The results so far are promising, with our benchmarks showing compression ratio improvements ranging from x1.5 to x5, depending on the data type (metrics, logs, traces), distribution, and compression algorithm. For the second phase, our estimates suggest that data processing acceleration could range from x2 to x12, again depending on the data’s nature and distribution. For more information, we encourage you to review the specifications and the reference implementation. Arrow relies on a schema to define the structure of data batches that it processes and transports. The subsequent sections will discuss various techniques that can be employed to optimize the creation of these schemas. How to leverage Arrow to optimize network transport cost Apache Arrow is a complex project with a rapidly evolving ecosystem, which can sometimes be overwhelming for newcomers. Fortunately the Arrow community has published three introductory articles 1, 2, and 3 that we recommend for those interested in exploring this technology. This article primarily focuses on transforming data from an XYZ format into an efficient Arrow representation that optimizes both compression ratio and data processing. There are numerous approaches to this transformation, and we will examine how these methods can impact compression ratio, CPU usage, and memory consumption during the conversion process, among other factors. Fig 3: Optimization process for the definition of an Arrow schema. The complexity of your initial model significantly impacts the Arrow mapping choices you need to make. To begin, it’s essential to identify the properties you want to optimize for your specific context. Compression rate, conversion speed, memory consumption, speed and ease of use of the final model, compatibility, and extensibility are all factors that can influence your final mapping decisions. From there, you must explore multiple alternative schemas. The choice of the Arrow type and data encoding for each individual field will affect the performance of your schema. There are various ways to represent hierarchical data or highly dynamic data models, and multiple options need to be evaluated in coordination with the configuration of the transport layer. This transport layer should also be carefully considered. Arrow supports compression mechanisms and dictionary deltas that may not be active by default. After several iterations of this process, you should arrive at an optimized schema that meets the goals you initially set. It’s crucial to compare the performance of your different approaches using real data, as the distribution of data in each individual field may influence whether you use dictionary encoding or not. We will now examine these choices in greater detail throughout the remainder of this article. Arrow data type selection The principles of selecting an Arrow data type are quite similar to those used when defining a data model for databases. Arrow supports a wide range of data types. Some of these types are supported by all implementations, while others are only available for languages with the strongest Arrow community support (see this page for a comparison matrix of the different implementations). For primitive types, it is generally preferable to choose the type that offers the most concise representation and is closest to the semantics of your initial field. For example, while it’s possible to represent a timestamp with an int64, it’s more advantageous to use the native Arrow Timestamp type. This choice isn’t due to a more efficient binary representation, but rather because it will be easier to process and manipulate in your pipeline. Query engines such as DataFusion offer dedicated timestamp handling functions for columns of this type. The same choices can be made for primitive types such as date, time, duration, and interval. However, if your project requires maximum compatibility, it may be crucial in some cases to favor types with universal support instead of the most optimal type in terms of memory occupation. Fig 4: Data types supported by Apache Arrow. When selecting the Arrow data type, it’s important to consider the size of the data before and after compression. It’s quite possible that the size after compression is the same for two different types, but the actual size in memory may be two, four, or even eight times larger (e.g., uint8 vs. uint64). This difference will impact your ability to process large batches of data and will also significantly influence the speed of processing these data in memory (e.g., cache optimization, SIMD instruction efficiency). It’s also possible to extend these types using an extension type mechanism that builds upon one of the currently supported primitive types while adding specific semantics. This extension mechanism can simplify the use of this data in your own project, while remaining transparent to intermediate systems that will interpret this data as a basic primitive type. There are some variations in the encoding of primitive types, which we will explore next. Data encoding Another crucial aspect of optimizing your Arrow schema is analyzing the cardinality of your data. Fields that can have only a limited number of values will typically be more efficiently represented with a dictionary encoding. The maximum cardinality of a field determines the data type characteristics of your dictionary. For instance, for a field representing the status code of an HTTP transaction, it’s preferable to use a dictionary with an index of type ‘uint8’ and a value of type ‘uint16’ (notation: ‘Dictionary&lt;uint8, uint16&gt;’). This consumes less memory because the main array will be of type ‘[]uint8’. Even if the range of possible values is greater than 255, as long as the number of distinct values does not exceed 255, the representation remains efficient. Similarly, the representation of a ‘user-agent’ will be more efficient with a dictionary of type ‘Dictionary&lt;uint16, string&gt;’ (see figure 5). In this case, the main array will be of type ‘uint16’, allowing a compact representation in memory and during transfers at the cost of an indirection during reverse conversion. Fig 5: Dictionary encoding. Dictionary encoding is highly flexible in Apache Arrow, allowing the creation of encodings for any Arrow primitive type. The size of the indices can also be configured based on the context. In general, it is advisable to use dictionaries in the following cases: Representation of enumerations Representation of textual or binary fields with a high probability of having redundant values. Representation of fields with cardinalities known to be below 2^16 or 2^32. Sometimes, the cardinality of a field is not known a priori. For example, a proxy that transforms a data stream from a row-oriented format into a series of columnar-encoded batches (e.g., OpenTelemetry collector) may not be able to predict in advance whether a field will have a fixed number of distinct values. Two approaches are possible: 1) a conservative approach using the largest data type (e.g., ‘int64’, ‘string’, etc., instead of dictionary), 2) an adaptive approach that modifies the schema on the fly based on the observed cardinality of the field(s). In this second approach, without cardinality information, you can optimistically start by using a ‘Dictionary&lt;uint8, original-field-type&gt;’ dictionary, then detect a potential dictionary overflow during conversion, and change the schema to a ‘Dictionary&lt;uint16, original-field-type&gt;’ in case of an overflow. This technique of automatic management of dictionary overflows will be presented in greater detail in a future article. Recent advancements in Apache Arrow include the implementation of run-end encoding, a technique that efficiently represents data with sequences of repeated values. This encoding method is particularly beneficial for handling data sets containing long stretches of identical values, as it offers a more compact and optimized representation. In conclusion, dictionary encoding not only occupies less space in memory and during transfers but also significantly improves the compression ratio and data processing speed. However, this type of representation requires indirection when extracting the initial values (although this isn’t always necessary, even during some data processing operations). Additionally, it is important to manage dictionary index overflow, especially when the encoded field doesn’t have a well-defined cardinality. Hierarchical data Basic hierarchical data structures translate relatively well into Arrow. However, as we will see, there are some complications to handle in more general cases (see figure 6). While Arrow schemas do support nested structures, maps, and unions, some components of the Arrow ecosystem do not fully support them, which can make these Arrow data types unsuitable for certain scenarios. Additionally, unlike most languages and formats, such as Protobuf, Arrow doesn’t support the concept of a recursively defined schema. An Arrow schema is static in its definition, and the depth of its nested elements must be known in advance. There are multiple strategies to work around this limitation and we’ll explore these in the following sections. Fig 6: simple vs complex data model. Natural representation The most straightforward and intuitive approach to representing a simple hierarchical data model is to use Arrow’s list, map, and union data types. However, it’s important to note that some of these data types are not fully supported throughout the entire Arrow ecosystem. For example, the conversion of unions to Parquet is not directly supported and requires a transformation step (see denormalization &amp; flattening representation to decompose a sparse union into a nullable struct and type ids column). Similarly, lists and maps are not yet supported in DataFusion version 20 (nested structures are partially supported). Fig 7: initial data model. The following example is a Go program snippet of an Arrow schema using these different data types to represent the model above. import &quot;github.com/apache/arrow/go/v11/arrow&quot; const ( GaugeMetricCode arrow.UnionTypeCode = 0 SumMetricCode arrow.UnionTypeCode = 1 ) var ( // uint8Dictionary represent a Dictionary&lt;Uint8, String&gt; uint8Dictionary = &amp;arrow.DictionaryType{ IndexType: arrow.PrimitiveTypes.Uint8, ValueType: arrow.BinaryTypes.String, } // uint16Dictionary represent a Dictionary&lt;Uint16, String&gt; uint16Dictionary = &amp;arrow.DictionaryType{ IndexType: arrow.PrimitiveTypes.Uint16, ValueType: arrow.BinaryTypes.String, } Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;resource_metrics&quot;, Type: arrow.ListOf(arrow.StructOf([]arrow.Field{ {Name: &quot;scope&quot;, Type: arrow.StructOf([]arrow.Field{ // Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)). {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;version&quot;, Type: uint16Dictionary}, }...)}, {Name: &quot;metrics&quot;, Type: arrow.ListOf(arrow.StructOf([]arrow.Field{ {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;unit&quot;, Type: uint8Dictionary}, {Name: &quot;timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;data_point&quot;, Type: arrow.ListOf(arrow.StructOf([]arrow.Field{ {Name: &quot;metric&quot;, Type: arrow.DenseUnionOf( []arrow.Field{ {Name: &quot;gauge&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;data_point&quot;, Type: arrow.FLOAT64}, }...)}, {Name: &quot;sum&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;data_point&quot;, Type: arrow.FLOAT64}, {Name: &quot;is_monotonic&quot;, Type: arrow.BOOL}, }...)}, }, []arrow.UnionTypeCode{GaugeMetricCode, SumMetricCode}, )}, }...))}, }...))}, }...))}, }, nil) ) In this pattern, we use a union type to represent an inheritance relationship. There are two types of Arrow union that are optimized for different cases. The dense union type has a relatively succinct memory representation but doesn’t support vectorizable operations, making it less efficient during the processing phase. Conversely, a sparse union supports vectorization operations, but comes with a memory overhead directly proportional to the number of variants in the union. Dense and sparse unions have quite similar compression rates, with sometimes a slight advantage for sparse unions. In addition, sparse unions with a large number of variants should generally be avoided, as they can lead to excessive memory consumption. For more details on the memory representation of unions, you can consult this page. In certain scenarios, it may be more idiomatic to represent the inheritance relationship using multiple schemas (i.e., one schema per subtype), thereby avoiding the use of the union type. However, applying this approach to the aforementioned model may not be optimal, as the data preceding the inheritance relationship (i.e., ResourceMetrics, Scope, and Metrics) could potentially be duplicated numerous times. If the relationships between ResourceMetrics, Metrics, and DataPoint were 0..1 (zero-to-one) relationships, then the multi-schema approach would likely be the simplest and most idiomatic solution. Denormalization &amp; Flattening representations If the List type is not supported in your telemetry pipeline, you can denormalize your data model. This process is often used in the database world to remove a join between two tables for optimization purposes. In the Arrow world, denormalization is employed to eliminate the List type by duplicating some data. Once transformed, the previous Arrow schema becomes. Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;resource_metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;scope&quot;, Type: arrow.StructOf([]arrow.Field{ // Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)). {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;version&quot;, Type: uint16Dictionary}, }...)}, {Name: &quot;metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;unit&quot;, Type: uint8Dictionary}, {Name: &quot;timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;data_point&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;metric&quot;, Type: arrow.DenseUnionOf( []arrow.Field{ {Name: &quot;gauge&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;value&quot;, Type: arrow.FLOAT64}, }...)}, {Name: &quot;sum&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;value&quot;, Type: arrow.FLOAT64}, {Name: &quot;is_monotonic&quot;, Type: arrow.BOOL}, }...)}, }, []arrow.UnionTypeCode{GaugeMetricCode, SumMetricCode}, )}, }...)}, }...)}, }...)}, }, nil) List types are eliminated at all levels. The initial semantics of the model are preserved by duplicating the data of the levels below each data point value. The memory representation will generally be much larger than the previous one, but a query engine that does not support the List type will still be able to process this data. Interestingly, once compressed, this way of representing data may not necessarily be larger than the previous approach. This is because the columnar representation compresses very well when there is redundancy in the data. If the union type is not supported by some components of your pipeline, it is also possible to eliminate them by merging the union variants (the nested structure ‘metric’ is removed, see below). Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;resource_metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;scope&quot;, Type: arrow.StructOf([]arrow.Field{ // Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)). {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;version&quot;, Type: uint16Dictionary}, }...)}, {Name: &quot;metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;unit&quot;, Type: uint8Dictionary}, {Name: &quot;timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;data_point&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;value&quot;, Type: arrow.FLOAT64}, {Name: &quot;is_monotonic&quot;, Type: arrow.BOOL}, }...)}, }...)}, }...)}, }, nil) The final schema has evolved into a series of nested structures, where the fields of the union variants are merged into one structure. The trade-off of this approach is similar to that of sparse union - the more variants, the higher the memory occupation. Arrow supports the concept of bitmap validity to identify null values (1 bit per entry) for various data types, including those that do not have a unique null representation (e.g., primitive types). The use of bitmap validity makes the query part easier, and query engines such as DataFusion know how to use if efficiently, Columns with numerous nulls typically compress quite efficiently since the underlying arrays are generally initialized with 0’s. Upon compression, these extensive sequences of 0’s result in high compression efficiency, despite the memory overhead before compression in the case of sparse unions. Consequently, it is essential to select the appropriate trade-off based on your specific context. In some extreme situations where nested structures are not supported, a flattening approach can be used to address this problem. Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;scope_name&quot;, Type: uint16Dictionary}, {Name: &quot;scope_version&quot;, Type: uint16Dictionary}, {Name: &quot;metrics_name&quot;, Type: uint16Dictionary}, {Name: &quot;metrics_unit&quot;, Type: uint8Dictionary}, {Name: &quot;metrics_timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metrics_metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;metrics_data_point_value&quot;, Type: arrow.FLOAT64}, {Name: &quot;metrics_data_point_is_monotonic&quot;, Type: arrow.BOOL}, }, nil) The terminal fields (leaves) are renamed by concatenating the names of the parent structures to provide proper scoping. This type of structure is supported by all components of the Arrow ecosystem. This approach can be useful if compatibility is a crucial criterion for your system. However, it shares the same drawbacks as other alternative denormalization models. The Arrow ecosystem is evolving rapidly, so it is likely that support for List, Map, and Union data types in query engines will improve quickly. If kernel functions are sufficient or preferable for your application, it is usually possible to utilize these nested types. Adaptive/Dynamic representation Some data models can be more challenging to translate into an Arrow schema, such as the following Protobuf example. In this example, a collection of attributes is added to each data point. These attributes are defined using a recursive definition that most languages and formats, like Protobuf, support (see the ‘AnyValue’ definition below). Unfortunately, Arrow (like most classical database schemas) does not support such recursive definition within schemas. syntax = &quot;proto3&quot;; message Metric { message DataPoint { repeated Attribute attributes = 1; oneof value { int64 int_value = 2; double double_value = 3; } } enum MetricType { UNSPECIFIED = 0; GAUGE = 1; SUM = 2; } message Gauge { DataPoint data_point = 1; } message Sum { DataPoint data_point = 1; bool is_monotonic = 2; } string name = 1; int64 timestamp = 2; string unit = 3; MetricType type = 4; oneof metric { Gauge gauge = 5; Sum sum = 6; } } message Attribute { string name = 1; AnyValue value = 2; } // Recursive definition of AnyValue. AnyValue can be a primitive value, a list // of AnyValues, or a list of key-value pairs where the key is a string and // the value is an AnyValue. message AnyValue { message ArrayValue { repeated AnyValue values = 1; } message KeyValueList { message KeyValue { string key = 1; AnyValue value = 2; } repeated KeyValue values = 1; } oneof value { int64 int_value = 1; double double_value = 2; string string_value = 3; ArrayValue list_value = 4; KeyValueList kvlist_value = 5; } } If the definition of the attributes were non-recursive, it would have been possible to directly translate them into an Arrow Map type. To address this kind of issue and further optimize Arrow schema definitions, you can employ an adaptive and iterative method that automatically constructs the Arrow schema based on the data being translated. With this approach, fields are automatically dictionary-encoded according to their cardinalities, unused fields are eliminated, and recursive structures are represented in a specific manner. Another solution involves using a multi-schema approach, in which attributes are depicted in a separate Arrow Record, and the inheritance relation is represented by a self-referential relationship. These strategies will be covered in more depth in a future article. For those eager to learn more, the first method is utilized in the reference implementation of the OTel Arrow Adapter. Data transport Unlike to Protobuf, an Arrow schema is generally not known a priori by the two parties participating in an exchange. Before being able to exchange data in Arrow format, the sender must first communicate the schema to the receiver, as well as the contents of the dictionaries used in the data. Only after this initialization phase has been completed can the sender transmit batches of data in Arrow format. This process, known as Arrow IPC Stream, plays an essential role transporting Arrow data between systems. Several approaches can be employed to communicate these Arrow IPC Streams. The simplest method is to use Arrow Flight, which encapsulates Arrow IPC streams in a gRPC-based protocol. However, it is also possible to use your own implementation for specific contexts. Regardless of the solution you choose, it is crucial to understand that the underlying protocol must be stateful to take full advantage of the Arrow IPC stream approach. To achieve the best compression rates, it is vital to send schemas and dictionaries only once in order to amortize the cost and minimize data redundancy between batches. This necessitates a transport that supports stream-oriented communications, such as gRPC. Using a stateless protocol is possible for large batches because the overhead of the schema will be negligible compared to the compression gains achieved using dictionary encoding and columnar representation. However, dictionaries will have to be communicated for each batch, making this approach generally less efficient than a stream-oriented approach. Arrow IPC Stream also supports the concept of “delta dictionaries,” which allows for further optimization of batch transport. When a batch adds data to an existing dictionary (at the sender’s end), Arrow IPC enables sending the delta dictionary followed by the batch that references it. On the receiver side, this delta is used to update the existing dictionary, eliminating the need to retransmit the entire dictionary when changes occur. This optimization is only possible with a stateful protocol. To fully leverage the column-oriented format of Apache Arrow, it is essential to consider sorting and compression. If your data model is simple (i.e., flat) and has one or more columns representing a natural order for your data (e.g., timestamp), it might be beneficial to sort your data to optimize the final compression ratio. Before implementing this optimization, it is recommended to perform tests on real data since the benefits may vary. In any case, using a compression algorithm when sending your batches is advantageous. Arrow IPC generally supports the ZSTD compression algorithm, which strikes an excellent balance between speed and compression efficiency, especially for column-oriented data. Lastly, some implementations (e.g., Arrow Go) are not configured by default to support delta dictionaries and compression algorithms. Therefore, it is crucial to ensure that your code employs these options to maximize data transport efficiency. Experiments If your initial data is complex, it is advisable to conduct your own experiments to optimize the Arrow representation according to your data and goals (e.g., optimizing the compression ratio or enhancing the query-ability of your data in Arrow format). In our case, we developed an overlay for Apache Arrow that enables us to carry out these experiments with ease, without having to deal with the intrinsic complexity of Arrow APIs. However, this comes at the expense of a slower conversion phase compared to using Arrow APIs directly. While this library is not currently public, it may become available if there is sufficient interest. We also employed a “black box optimization” approach, which automatically finds the best combination to meet the objectives we aimed to optimize (refer to “Optimize your applications using Google Vertex AI Vizier” for a description of this approach). Conclusion and next steps Essentially, the key concept behind Apache Arrow is that it eliminates the need for serialization and deserialization, enabling zero-copy data sharing. Arrow achieves this by defining a language-agnostic, in-memory format that remains consistent across various implementations. Consequently, raw memory bytes can be transmitted directly over a network without requiring any serialization or deserialization, significantly enhancing data processing efficiency. Converting a data model to Apache Arrow necessitates adaptation and optimization work, as we have begun to describe in this article. Many parameters must be considered, and it is recommended to perform a series of experiments to validate the various choices made during this process. Handling highly dynamic data with Arrow can be challenging. Arrow requires the definition of a static schema, which can sometimes make representing this type of data complex or suboptimal, especially when the initial schema contains recursive definitions. This article has discussed several approaches to address this issue. The next article will be dedicated to a hybrid strategy that involves adapting the Arrow schema on-the-fly to optimize memory usage, compression ratio, and processing speed based on the data being represented. This approach is quite unique and deserves a separate article." />
<link rel="canonical" href="https://arrow.apache.org/blog/2023/04/11/our-journey-at-f5-with-apache-arrow-part-1/" />
<meta property="og:url" content="https://arrow.apache.org/blog/2023/04/11/our-journey-at-f5-with-apache-arrow-part-1/" />
<meta property="og:site_name" content="Apache Arrow" />
<meta property="og:image" content="https://arrow.apache.org/img/arrow-logo_horizontal_black-txt_white-bg.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-04-11T00:00:00-04:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://arrow.apache.org/img/arrow-logo_horizontal_black-txt_white-bg.png" />
<meta property="twitter:title" content="Our journey at F5 with Apache Arrow (part 1)" />
<meta name="twitter:site" content="@ApacheArrow" />
<meta name="twitter:creator" content="@Laurent Quérel" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Laurent Quérel"},"dateModified":"2023-04-11T00:00:00-04:00","datePublished":"2023-04-11T00:00:00-04:00","description":"Apache Arrow is a technology widely adopted in big data, analytics, and machine learning applications. In this article, we share F5’s experience with Arrow, specifically its application to telemetry, and the challenges we encountered while optimizing the OpenTelemetry protocol to significantly reduce bandwidth costs. The promising results we achieved inspired us to share our insights. This article specifically focuses on transforming relatively complex data structure from various formats into an efficient Arrow representation that optimizes both compression ratio, transport, and data processing. We also explore the trade-offs between different mapping and normalization strategies, as well as the nuances of streaming and batch communication using Arrow and Arrow Flight. Our benchmarks thus far have shown promising results, with compression ratio improvements ranging from 1.5x to 5x, depending on the data type (metrics, logs, traces), distribution, and compression algorithm. The approaches presented for addressing these challenges may be applicable to other Arrow domains as well. This article serves as the first installment in a two-part series. What is Apache Arrow Apache Arrow is an open-source project offering a standardized, language-agnostic in-memory format for representing structured and semi-structured data. This enables data sharing and zero-copy data access between systems, eliminating the need for serialization and deserialization when exchanging datasets between varying CPU architectures and programming languages. Furthermore, Arrow libraries feature an extensive set of high-performance, parallel, and vectorized kernel functions designed for efficiently processing massive amounts of columnar data. These features make Arrow an appealing technology for big data processing, data transport, analytics, and machine learning applications. The growing number of products and open-source projects that have adopted Apache Arrow at their core or offer Arrow support reflects the widespread recognition and appreciation of its benefits (refer to this article for an in-depth overview of the Arrow ecosystem and adoption). Over 11,000 GitHub users support this project, and 840+ are contributors who make this project an undeniable success. Very often people ask about the differences between Arrow and Apache Parquet or other columnar file formats. Arrow is designed and optimized for in-memory processing, while Parquet is tailored for disk-based storage. In reality, these technologies are complementary, with bridges existing between them to simplify interoperability. In both cases, data is represented in columns to optimize access, data locality and compressibility. However, the tradeoffs differ slightly. Arrow prioritizes data processing speed over the optimal data encoding. Complex encodings that don’t benefit from SIMD instruction sets are generally not natively supported by Arrow, unlike formats such as Parquet. Storing data in Parquet format and processing and transporting it in Arrow format has become a prevalent model within the big data community. Fig 1: Memory representations: row vs columnar data. Figure 1 illustrates the differences in memory representation between row-oriented and column-oriented approaches. The column-oriented approach groups data from the same column in a continuous memory area, which facilitates parallel processing (SIMD) and enhances compression performance. Why are we interested in Apache Arrow At F5, we’ve adopted OpenTelemetry (OTel) as the standard for all telemetry across our products, such as BIGIP and NGINX. These products may generate large volumes of metrics and logs for various reasons, from performance evaluation to forensic purposes. The data produced by these systems is typically centralized and processed in dedicated systems. Transporting and processing this data accounts for a significant portion of the cost associated with telemetry pipelines. In this context, we became interested in Apache Arrow. Instead of reinventing yet another telemetry solution, we decided to invest in the OpenTelemetry project, working on improvements to the protocol to significantly increase its efficiency with high telemetry data volumes. We collaborated with Joshua MacDonald from Lightstep to integrate these optimizations into an experimental OTel collector and are currently in discussions with the OTel technical committee to finalize a code donation. Fig 2: Performance improvement in the OpenTelemetry Arrow experimental project. This project has been divided into two phases. The first phase, which is nearing completion, aims to enhance the protocol’s compression ratio. The second phase, planned for the future, focuses on improving end-to-end performance by incorporating Apache Arrow throughout all levels, eliminating the need for conversion between old and new protocols. The results so far are promising, with our benchmarks showing compression ratio improvements ranging from x1.5 to x5, depending on the data type (metrics, logs, traces), distribution, and compression algorithm. For the second phase, our estimates suggest that data processing acceleration could range from x2 to x12, again depending on the data’s nature and distribution. For more information, we encourage you to review the specifications and the reference implementation. Arrow relies on a schema to define the structure of data batches that it processes and transports. The subsequent sections will discuss various techniques that can be employed to optimize the creation of these schemas. How to leverage Arrow to optimize network transport cost Apache Arrow is a complex project with a rapidly evolving ecosystem, which can sometimes be overwhelming for newcomers. Fortunately the Arrow community has published three introductory articles 1, 2, and 3 that we recommend for those interested in exploring this technology. This article primarily focuses on transforming data from an XYZ format into an efficient Arrow representation that optimizes both compression ratio and data processing. There are numerous approaches to this transformation, and we will examine how these methods can impact compression ratio, CPU usage, and memory consumption during the conversion process, among other factors. Fig 3: Optimization process for the definition of an Arrow schema. The complexity of your initial model significantly impacts the Arrow mapping choices you need to make. To begin, it’s essential to identify the properties you want to optimize for your specific context. Compression rate, conversion speed, memory consumption, speed and ease of use of the final model, compatibility, and extensibility are all factors that can influence your final mapping decisions. From there, you must explore multiple alternative schemas. The choice of the Arrow type and data encoding for each individual field will affect the performance of your schema. There are various ways to represent hierarchical data or highly dynamic data models, and multiple options need to be evaluated in coordination with the configuration of the transport layer. This transport layer should also be carefully considered. Arrow supports compression mechanisms and dictionary deltas that may not be active by default. After several iterations of this process, you should arrive at an optimized schema that meets the goals you initially set. It’s crucial to compare the performance of your different approaches using real data, as the distribution of data in each individual field may influence whether you use dictionary encoding or not. We will now examine these choices in greater detail throughout the remainder of this article. Arrow data type selection The principles of selecting an Arrow data type are quite similar to those used when defining a data model for databases. Arrow supports a wide range of data types. Some of these types are supported by all implementations, while others are only available for languages with the strongest Arrow community support (see this page for a comparison matrix of the different implementations). For primitive types, it is generally preferable to choose the type that offers the most concise representation and is closest to the semantics of your initial field. For example, while it’s possible to represent a timestamp with an int64, it’s more advantageous to use the native Arrow Timestamp type. This choice isn’t due to a more efficient binary representation, but rather because it will be easier to process and manipulate in your pipeline. Query engines such as DataFusion offer dedicated timestamp handling functions for columns of this type. The same choices can be made for primitive types such as date, time, duration, and interval. However, if your project requires maximum compatibility, it may be crucial in some cases to favor types with universal support instead of the most optimal type in terms of memory occupation. Fig 4: Data types supported by Apache Arrow. When selecting the Arrow data type, it’s important to consider the size of the data before and after compression. It’s quite possible that the size after compression is the same for two different types, but the actual size in memory may be two, four, or even eight times larger (e.g., uint8 vs. uint64). This difference will impact your ability to process large batches of data and will also significantly influence the speed of processing these data in memory (e.g., cache optimization, SIMD instruction efficiency). It’s also possible to extend these types using an extension type mechanism that builds upon one of the currently supported primitive types while adding specific semantics. This extension mechanism can simplify the use of this data in your own project, while remaining transparent to intermediate systems that will interpret this data as a basic primitive type. There are some variations in the encoding of primitive types, which we will explore next. Data encoding Another crucial aspect of optimizing your Arrow schema is analyzing the cardinality of your data. Fields that can have only a limited number of values will typically be more efficiently represented with a dictionary encoding. The maximum cardinality of a field determines the data type characteristics of your dictionary. For instance, for a field representing the status code of an HTTP transaction, it’s preferable to use a dictionary with an index of type ‘uint8’ and a value of type ‘uint16’ (notation: ‘Dictionary&lt;uint8, uint16&gt;’). This consumes less memory because the main array will be of type ‘[]uint8’. Even if the range of possible values is greater than 255, as long as the number of distinct values does not exceed 255, the representation remains efficient. Similarly, the representation of a ‘user-agent’ will be more efficient with a dictionary of type ‘Dictionary&lt;uint16, string&gt;’ (see figure 5). In this case, the main array will be of type ‘uint16’, allowing a compact representation in memory and during transfers at the cost of an indirection during reverse conversion. Fig 5: Dictionary encoding. Dictionary encoding is highly flexible in Apache Arrow, allowing the creation of encodings for any Arrow primitive type. The size of the indices can also be configured based on the context. In general, it is advisable to use dictionaries in the following cases: Representation of enumerations Representation of textual or binary fields with a high probability of having redundant values. Representation of fields with cardinalities known to be below 2^16 or 2^32. Sometimes, the cardinality of a field is not known a priori. For example, a proxy that transforms a data stream from a row-oriented format into a series of columnar-encoded batches (e.g., OpenTelemetry collector) may not be able to predict in advance whether a field will have a fixed number of distinct values. Two approaches are possible: 1) a conservative approach using the largest data type (e.g., ‘int64’, ‘string’, etc., instead of dictionary), 2) an adaptive approach that modifies the schema on the fly based on the observed cardinality of the field(s). In this second approach, without cardinality information, you can optimistically start by using a ‘Dictionary&lt;uint8, original-field-type&gt;’ dictionary, then detect a potential dictionary overflow during conversion, and change the schema to a ‘Dictionary&lt;uint16, original-field-type&gt;’ in case of an overflow. This technique of automatic management of dictionary overflows will be presented in greater detail in a future article. Recent advancements in Apache Arrow include the implementation of run-end encoding, a technique that efficiently represents data with sequences of repeated values. This encoding method is particularly beneficial for handling data sets containing long stretches of identical values, as it offers a more compact and optimized representation. In conclusion, dictionary encoding not only occupies less space in memory and during transfers but also significantly improves the compression ratio and data processing speed. However, this type of representation requires indirection when extracting the initial values (although this isn’t always necessary, even during some data processing operations). Additionally, it is important to manage dictionary index overflow, especially when the encoded field doesn’t have a well-defined cardinality. Hierarchical data Basic hierarchical data structures translate relatively well into Arrow. However, as we will see, there are some complications to handle in more general cases (see figure 6). While Arrow schemas do support nested structures, maps, and unions, some components of the Arrow ecosystem do not fully support them, which can make these Arrow data types unsuitable for certain scenarios. Additionally, unlike most languages and formats, such as Protobuf, Arrow doesn’t support the concept of a recursively defined schema. An Arrow schema is static in its definition, and the depth of its nested elements must be known in advance. There are multiple strategies to work around this limitation and we’ll explore these in the following sections. Fig 6: simple vs complex data model. Natural representation The most straightforward and intuitive approach to representing a simple hierarchical data model is to use Arrow’s list, map, and union data types. However, it’s important to note that some of these data types are not fully supported throughout the entire Arrow ecosystem. For example, the conversion of unions to Parquet is not directly supported and requires a transformation step (see denormalization &amp; flattening representation to decompose a sparse union into a nullable struct and type ids column). Similarly, lists and maps are not yet supported in DataFusion version 20 (nested structures are partially supported). Fig 7: initial data model. The following example is a Go program snippet of an Arrow schema using these different data types to represent the model above. import &quot;github.com/apache/arrow/go/v11/arrow&quot; const ( GaugeMetricCode arrow.UnionTypeCode = 0 SumMetricCode arrow.UnionTypeCode = 1 ) var ( // uint8Dictionary represent a Dictionary&lt;Uint8, String&gt; uint8Dictionary = &amp;arrow.DictionaryType{ IndexType: arrow.PrimitiveTypes.Uint8, ValueType: arrow.BinaryTypes.String, } // uint16Dictionary represent a Dictionary&lt;Uint16, String&gt; uint16Dictionary = &amp;arrow.DictionaryType{ IndexType: arrow.PrimitiveTypes.Uint16, ValueType: arrow.BinaryTypes.String, } Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;resource_metrics&quot;, Type: arrow.ListOf(arrow.StructOf([]arrow.Field{ {Name: &quot;scope&quot;, Type: arrow.StructOf([]arrow.Field{ // Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)). {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;version&quot;, Type: uint16Dictionary}, }...)}, {Name: &quot;metrics&quot;, Type: arrow.ListOf(arrow.StructOf([]arrow.Field{ {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;unit&quot;, Type: uint8Dictionary}, {Name: &quot;timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;data_point&quot;, Type: arrow.ListOf(arrow.StructOf([]arrow.Field{ {Name: &quot;metric&quot;, Type: arrow.DenseUnionOf( []arrow.Field{ {Name: &quot;gauge&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;data_point&quot;, Type: arrow.FLOAT64}, }...)}, {Name: &quot;sum&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;data_point&quot;, Type: arrow.FLOAT64}, {Name: &quot;is_monotonic&quot;, Type: arrow.BOOL}, }...)}, }, []arrow.UnionTypeCode{GaugeMetricCode, SumMetricCode}, )}, }...))}, }...))}, }...))}, }, nil) ) In this pattern, we use a union type to represent an inheritance relationship. There are two types of Arrow union that are optimized for different cases. The dense union type has a relatively succinct memory representation but doesn’t support vectorizable operations, making it less efficient during the processing phase. Conversely, a sparse union supports vectorization operations, but comes with a memory overhead directly proportional to the number of variants in the union. Dense and sparse unions have quite similar compression rates, with sometimes a slight advantage for sparse unions. In addition, sparse unions with a large number of variants should generally be avoided, as they can lead to excessive memory consumption. For more details on the memory representation of unions, you can consult this page. In certain scenarios, it may be more idiomatic to represent the inheritance relationship using multiple schemas (i.e., one schema per subtype), thereby avoiding the use of the union type. However, applying this approach to the aforementioned model may not be optimal, as the data preceding the inheritance relationship (i.e., ResourceMetrics, Scope, and Metrics) could potentially be duplicated numerous times. If the relationships between ResourceMetrics, Metrics, and DataPoint were 0..1 (zero-to-one) relationships, then the multi-schema approach would likely be the simplest and most idiomatic solution. Denormalization &amp; Flattening representations If the List type is not supported in your telemetry pipeline, you can denormalize your data model. This process is often used in the database world to remove a join between two tables for optimization purposes. In the Arrow world, denormalization is employed to eliminate the List type by duplicating some data. Once transformed, the previous Arrow schema becomes. Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;resource_metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;scope&quot;, Type: arrow.StructOf([]arrow.Field{ // Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)). {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;version&quot;, Type: uint16Dictionary}, }...)}, {Name: &quot;metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;unit&quot;, Type: uint8Dictionary}, {Name: &quot;timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;data_point&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;metric&quot;, Type: arrow.DenseUnionOf( []arrow.Field{ {Name: &quot;gauge&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;value&quot;, Type: arrow.FLOAT64}, }...)}, {Name: &quot;sum&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;value&quot;, Type: arrow.FLOAT64}, {Name: &quot;is_monotonic&quot;, Type: arrow.BOOL}, }...)}, }, []arrow.UnionTypeCode{GaugeMetricCode, SumMetricCode}, )}, }...)}, }...)}, }...)}, }, nil) List types are eliminated at all levels. The initial semantics of the model are preserved by duplicating the data of the levels below each data point value. The memory representation will generally be much larger than the previous one, but a query engine that does not support the List type will still be able to process this data. Interestingly, once compressed, this way of representing data may not necessarily be larger than the previous approach. This is because the columnar representation compresses very well when there is redundancy in the data. If the union type is not supported by some components of your pipeline, it is also possible to eliminate them by merging the union variants (the nested structure ‘metric’ is removed, see below). Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;resource_metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;scope&quot;, Type: arrow.StructOf([]arrow.Field{ // Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)). {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;version&quot;, Type: uint16Dictionary}, }...)}, {Name: &quot;metrics&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;name&quot;, Type: uint16Dictionary}, {Name: &quot;unit&quot;, Type: uint8Dictionary}, {Name: &quot;timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;data_point&quot;, Type: arrow.StructOf([]arrow.Field{ {Name: &quot;value&quot;, Type: arrow.FLOAT64}, {Name: &quot;is_monotonic&quot;, Type: arrow.BOOL}, }...)}, }...)}, }...)}, }, nil) The final schema has evolved into a series of nested structures, where the fields of the union variants are merged into one structure. The trade-off of this approach is similar to that of sparse union - the more variants, the higher the memory occupation. Arrow supports the concept of bitmap validity to identify null values (1 bit per entry) for various data types, including those that do not have a unique null representation (e.g., primitive types). The use of bitmap validity makes the query part easier, and query engines such as DataFusion know how to use if efficiently, Columns with numerous nulls typically compress quite efficiently since the underlying arrays are generally initialized with 0’s. Upon compression, these extensive sequences of 0’s result in high compression efficiency, despite the memory overhead before compression in the case of sparse unions. Consequently, it is essential to select the appropriate trade-off based on your specific context. In some extreme situations where nested structures are not supported, a flattening approach can be used to address this problem. Schema = arrow.NewSchema([]arrow.Field{ {Name: &quot;scope_name&quot;, Type: uint16Dictionary}, {Name: &quot;scope_version&quot;, Type: uint16Dictionary}, {Name: &quot;metrics_name&quot;, Type: uint16Dictionary}, {Name: &quot;metrics_unit&quot;, Type: uint8Dictionary}, {Name: &quot;metrics_timestamp&quot;, Type: arrow.TIMESTAMP}, {Name: &quot;metrics_metric_type&quot;, Type: arrow.UINT8}, {Name: &quot;metrics_data_point_value&quot;, Type: arrow.FLOAT64}, {Name: &quot;metrics_data_point_is_monotonic&quot;, Type: arrow.BOOL}, }, nil) The terminal fields (leaves) are renamed by concatenating the names of the parent structures to provide proper scoping. This type of structure is supported by all components of the Arrow ecosystem. This approach can be useful if compatibility is a crucial criterion for your system. However, it shares the same drawbacks as other alternative denormalization models. The Arrow ecosystem is evolving rapidly, so it is likely that support for List, Map, and Union data types in query engines will improve quickly. If kernel functions are sufficient or preferable for your application, it is usually possible to utilize these nested types. Adaptive/Dynamic representation Some data models can be more challenging to translate into an Arrow schema, such as the following Protobuf example. In this example, a collection of attributes is added to each data point. These attributes are defined using a recursive definition that most languages and formats, like Protobuf, support (see the ‘AnyValue’ definition below). Unfortunately, Arrow (like most classical database schemas) does not support such recursive definition within schemas. syntax = &quot;proto3&quot;; message Metric { message DataPoint { repeated Attribute attributes = 1; oneof value { int64 int_value = 2; double double_value = 3; } } enum MetricType { UNSPECIFIED = 0; GAUGE = 1; SUM = 2; } message Gauge { DataPoint data_point = 1; } message Sum { DataPoint data_point = 1; bool is_monotonic = 2; } string name = 1; int64 timestamp = 2; string unit = 3; MetricType type = 4; oneof metric { Gauge gauge = 5; Sum sum = 6; } } message Attribute { string name = 1; AnyValue value = 2; } // Recursive definition of AnyValue. AnyValue can be a primitive value, a list // of AnyValues, or a list of key-value pairs where the key is a string and // the value is an AnyValue. message AnyValue { message ArrayValue { repeated AnyValue values = 1; } message KeyValueList { message KeyValue { string key = 1; AnyValue value = 2; } repeated KeyValue values = 1; } oneof value { int64 int_value = 1; double double_value = 2; string string_value = 3; ArrayValue list_value = 4; KeyValueList kvlist_value = 5; } } If the definition of the attributes were non-recursive, it would have been possible to directly translate them into an Arrow Map type. To address this kind of issue and further optimize Arrow schema definitions, you can employ an adaptive and iterative method that automatically constructs the Arrow schema based on the data being translated. With this approach, fields are automatically dictionary-encoded according to their cardinalities, unused fields are eliminated, and recursive structures are represented in a specific manner. Another solution involves using a multi-schema approach, in which attributes are depicted in a separate Arrow Record, and the inheritance relation is represented by a self-referential relationship. These strategies will be covered in more depth in a future article. For those eager to learn more, the first method is utilized in the reference implementation of the OTel Arrow Adapter. Data transport Unlike to Protobuf, an Arrow schema is generally not known a priori by the two parties participating in an exchange. Before being able to exchange data in Arrow format, the sender must first communicate the schema to the receiver, as well as the contents of the dictionaries used in the data. Only after this initialization phase has been completed can the sender transmit batches of data in Arrow format. This process, known as Arrow IPC Stream, plays an essential role transporting Arrow data between systems. Several approaches can be employed to communicate these Arrow IPC Streams. The simplest method is to use Arrow Flight, which encapsulates Arrow IPC streams in a gRPC-based protocol. However, it is also possible to use your own implementation for specific contexts. Regardless of the solution you choose, it is crucial to understand that the underlying protocol must be stateful to take full advantage of the Arrow IPC stream approach. To achieve the best compression rates, it is vital to send schemas and dictionaries only once in order to amortize the cost and minimize data redundancy between batches. This necessitates a transport that supports stream-oriented communications, such as gRPC. Using a stateless protocol is possible for large batches because the overhead of the schema will be negligible compared to the compression gains achieved using dictionary encoding and columnar representation. However, dictionaries will have to be communicated for each batch, making this approach generally less efficient than a stream-oriented approach. Arrow IPC Stream also supports the concept of “delta dictionaries,” which allows for further optimization of batch transport. When a batch adds data to an existing dictionary (at the sender’s end), Arrow IPC enables sending the delta dictionary followed by the batch that references it. On the receiver side, this delta is used to update the existing dictionary, eliminating the need to retransmit the entire dictionary when changes occur. This optimization is only possible with a stateful protocol. To fully leverage the column-oriented format of Apache Arrow, it is essential to consider sorting and compression. If your data model is simple (i.e., flat) and has one or more columns representing a natural order for your data (e.g., timestamp), it might be beneficial to sort your data to optimize the final compression ratio. Before implementing this optimization, it is recommended to perform tests on real data since the benefits may vary. In any case, using a compression algorithm when sending your batches is advantageous. Arrow IPC generally supports the ZSTD compression algorithm, which strikes an excellent balance between speed and compression efficiency, especially for column-oriented data. Lastly, some implementations (e.g., Arrow Go) are not configured by default to support delta dictionaries and compression algorithms. Therefore, it is crucial to ensure that your code employs these options to maximize data transport efficiency. Experiments If your initial data is complex, it is advisable to conduct your own experiments to optimize the Arrow representation according to your data and goals (e.g., optimizing the compression ratio or enhancing the query-ability of your data in Arrow format). In our case, we developed an overlay for Apache Arrow that enables us to carry out these experiments with ease, without having to deal with the intrinsic complexity of Arrow APIs. However, this comes at the expense of a slower conversion phase compared to using Arrow APIs directly. While this library is not currently public, it may become available if there is sufficient interest. We also employed a “black box optimization” approach, which automatically finds the best combination to meet the objectives we aimed to optimize (refer to “Optimize your applications using Google Vertex AI Vizier” for a description of this approach). Conclusion and next steps Essentially, the key concept behind Apache Arrow is that it eliminates the need for serialization and deserialization, enabling zero-copy data sharing. Arrow achieves this by defining a language-agnostic, in-memory format that remains consistent across various implementations. Consequently, raw memory bytes can be transmitted directly over a network without requiring any serialization or deserialization, significantly enhancing data processing efficiency. Converting a data model to Apache Arrow necessitates adaptation and optimization work, as we have begun to describe in this article. Many parameters must be considered, and it is recommended to perform a series of experiments to validate the various choices made during this process. Handling highly dynamic data with Arrow can be challenging. Arrow requires the definition of a static schema, which can sometimes make representing this type of data complex or suboptimal, especially when the initial schema contains recursive definitions. This article has discussed several approaches to address this issue. The next article will be dedicated to a hybrid strategy that involves adapting the Arrow schema on-the-fly to optimize memory usage, compression ratio, and processing speed based on the data being represented. This approach is quite unique and deserves a separate article.","headline":"Our journey at F5 with Apache Arrow (part 1)","image":"https://arrow.apache.org/img/arrow-logo_horizontal_black-txt_white-bg.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://arrow.apache.org/blog/2023/04/11/our-journey-at-f5-with-apache-arrow-part-1/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://arrow.apache.org/img/logo.png"},"name":"Laurent Quérel"},"url":"https://arrow.apache.org/blog/2023/04/11/our-journey-at-f5-with-apache-arrow-part-1/"}</script>
<!-- End Jekyll SEO tag -->


    <!-- favicons -->
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png" id="light1">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png" id="light2">
    <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="/img/apple-touch-icon.png" id="light3">
    <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="/img/apple-touch-icon-120x120.png" id="light4">
    <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="/img/apple-touch-icon-76x76.png" id="light5">
    <link rel="apple-touch-icon" type="image/png" sizes="60x60" href="/img/apple-touch-icon-60x60.png" id="light6">
    <!-- dark mode favicons -->
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16-dark.png" id="dark1">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32-dark.png" id="dark2">
    <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="/img/apple-touch-icon-dark.png" id="dark3">
    <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="/img/apple-touch-icon-120x120-dark.png" id="dark4">
    <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="/img/apple-touch-icon-76x76-dark.png" id="dark5">
    <link rel="apple-touch-icon" type="image/png" sizes="60x60" href="/img/apple-touch-icon-60x60-dark.png" id="dark6">

    <script>
      // Switch to the dark-mode favicons if prefers-color-scheme: dark
      function onUpdate() {
        light1 = document.querySelector('link#light1');
        light2 = document.querySelector('link#light2');
        light3 = document.querySelector('link#light3');
        light4 = document.querySelector('link#light4');
        light5 = document.querySelector('link#light5');
        light6 = document.querySelector('link#light6');

        dark1 = document.querySelector('link#dark1');
        dark2 = document.querySelector('link#dark2');
        dark3 = document.querySelector('link#dark3');
        dark4 = document.querySelector('link#dark4');
        dark5 = document.querySelector('link#dark5');
        dark6 = document.querySelector('link#dark6');

        if (matcher.matches) {
          light1.remove();
          light2.remove();
          light3.remove();
          light4.remove();
          light5.remove();
          light6.remove();
          document.head.append(dark1);
          document.head.append(dark2);
          document.head.append(dark3);
          document.head.append(dark4);
          document.head.append(dark5);
          document.head.append(dark6);
        } else {
          dark1.remove();
          dark2.remove();
          dark3.remove();
          dark4.remove();
          dark5.remove();
          dark6.remove();
          document.head.append(light1);
          document.head.append(light2);
          document.head.append(light3);
          document.head.append(light4);
          document.head.append(light5);
          document.head.append(light6);
        }
      }
      matcher = window.matchMedia('(prefers-color-scheme: dark)');
      matcher.addListener(onUpdate);
      onUpdate();
    </script>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic,900">

    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <script src="/javascript/main.js"></script>
    
    <!-- Matomo -->
<script>
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  /* We explicitly disable cookie tracking to avoid privacy issues */
  _paq.push(['disableCookies']);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="https://analytics.apache.org/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '20']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->

    
  </head>


<body class="wrap">
  <header>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
  
  <a class="navbar-brand no-padding" href="/"><img src="/img/arrow-inverse-300px.png" height="40px"/></a>
  
   <button class="navbar-toggler ml-auto" type="button" data-toggle="collapse" data-target="#arrow-navbar" aria-controls="arrow-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse justify-content-end" id="arrow-navbar">
      <ul class="nav navbar-nav">
        <li class="nav-item"><a class="nav-link" href="/overview/" role="button" aria-haspopup="true" aria-expanded="false">Overview</a></li>
        <li class="nav-item"><a class="nav-link" href="/faq/" role="button" aria-haspopup="true" aria-expanded="false">FAQ</a></li>
        <li class="nav-item"><a class="nav-link" href="/blog" role="button" aria-haspopup="true" aria-expanded="false">Blog</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#"
             id="navbarDropdownGetArrow" role="button" data-toggle="dropdown"
             aria-haspopup="true" aria-expanded="false">
             Get Arrow
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownGetArrow">
            <a class="dropdown-item" href="/install/">Install</a>
            <a class="dropdown-item" href="/release/">Releases</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow">Source Code</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#"
             id="navbarDropdownDocumentation" role="button" data-toggle="dropdown"
             aria-haspopup="true" aria-expanded="false">
             Documentation
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownDocumentation">
            <a class="dropdown-item" href="/docs">Project Docs</a>
            <a class="dropdown-item" href="/docs/format/Columnar.html">Format</a>
            <hr/>
            <a class="dropdown-item" href="/docs/c_glib">C GLib</a>
            <a class="dropdown-item" href="/docs/cpp">C++</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/blob/main/csharp/README.md">C#</a>
            <a class="dropdown-item" href="https://godoc.org/github.com/apache/arrow/go/arrow">Go</a>
            <a class="dropdown-item" href="/docs/java">Java</a>
            <a class="dropdown-item" href="/docs/js">JavaScript</a>
            <a class="dropdown-item" href="/julia/">Julia</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/blob/main/matlab/README.md">MATLAB</a>
            <a class="dropdown-item" href="/docs/python">Python</a>
            <a class="dropdown-item" href="/docs/r">R</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/blob/main/ruby/README.md">Ruby</a>
            <a class="dropdown-item" href="https://docs.rs/arrow/latest">Rust</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#"
             id="navbarDropdownSubprojects" role="button" data-toggle="dropdown"
             aria-haspopup="true" aria-expanded="false">
             Subprojects
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownSubprojects">
            <a class="dropdown-item" href="/adbc">ADBC</a>
            <a class="dropdown-item" href="/docs/format/Flight.html">Arrow Flight</a>
            <a class="dropdown-item" href="/docs/format/FlightSql.html">Arrow Flight SQL</a>
            <a class="dropdown-item" href="/datafusion">DataFusion</a>
            <a class="dropdown-item" href="/nanoarrow">nanoarrow</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#"
             id="navbarDropdownCommunity" role="button" data-toggle="dropdown"
             aria-haspopup="true" aria-expanded="false">
             Community
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownCommunity">
            <a class="dropdown-item" href="/community/">Communication</a>
            <a class="dropdown-item" href="/docs/developers/index.html">Contributing</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/issues">Issue Tracker</a>
            <a class="dropdown-item" href="/committers/">Governance</a>
            <a class="dropdown-item" href="/use_cases/">Use Cases</a>
            <a class="dropdown-item" href="/powered_by/">Powered By</a>
            <a class="dropdown-item" href="/visual_identity/">Visual Identity</a>
            <a class="dropdown-item" href="/security/">Security</a>
            <a class="dropdown-item" href="https://www.apache.org/foundation/policies/conduct.html">Code of Conduct</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#"
             id="navbarDropdownASF" role="button" data-toggle="dropdown"
             aria-haspopup="true" aria-expanded="false">
             ASF Links
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownASF">
            <a class="dropdown-item" href="https://www.apache.org/">ASF Website</a>
            <a class="dropdown-item" href="https://www.apache.org/licenses/">License</a>
            <a class="dropdown-item" href="https://www.apache.org/foundation/sponsorship.html">Donate</a>
            <a class="dropdown-item" href="https://www.apache.org/foundation/thanks.html">Thanks</a>
            <a class="dropdown-item" href="https://www.apache.org/security/">Security</a>
          </div>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </nav>

  </header>

  <div class="container p-4 pt-5">
    <div class="col-md-8 mx-auto">
      <main role="main" class="pb-5">
        
<h1>
  Our journey at F5 with Apache Arrow (part 1)
</h1>
<hr class="mt-4 mb-3">



<p class="mb-4 pb-1">
  <span class="badge badge-secondary">Published</span>
  <span class="published mr-3">
    11 Apr 2023
  </span>
  <br />
  <span class="badge badge-secondary">By</span>
  
    Laurent Quérel
  

  
</p>


        <!--

-->

<p>Apache Arrow is a technology widely adopted in big data, analytics, and machine learning applications. In this article, we share <a href="https://www.f5.com/">F5</a>’s experience with Arrow, specifically its application to telemetry, and the challenges we encountered while optimizing the OpenTelemetry protocol to significantly reduce bandwidth costs. The promising results we achieved inspired us to share our insights. This article specifically focuses on transforming relatively complex data structure from various formats into an efficient Arrow representation that optimizes both compression ratio, transport, and data processing. We also explore the trade-offs between different mapping and normalization strategies, as well as the nuances of streaming and batch communication using Arrow and Arrow Flight. Our benchmarks thus far have shown promising results, with compression ratio improvements ranging from 1.5x to 5x, depending on the data type (metrics, logs, traces), distribution, and compression algorithm. The approaches presented for addressing these challenges may be applicable to other Arrow domains as well. This article serves as the first installment in a two-part series.</p>

<h2 id="what-is-apache-arrow">What is Apache Arrow</h2>

<p><a href="https://arrow.apache.org/docs/index.html">Apache Arrow</a> is an open-source project offering a standardized, language-agnostic in-memory format for representing structured and semi-structured data. This enables data sharing and zero-copy data access between systems, eliminating the need for serialization and deserialization when exchanging datasets between varying CPU architectures and programming languages. Furthermore, Arrow libraries feature an extensive set of high-performance, parallel, and vectorized kernel functions designed for efficiently processing massive amounts of columnar data. These features make Arrow an appealing technology for big data processing, data transport, analytics, and machine learning applications. The growing number of <a href="https://arrow.apache.org/powered_by/">products and open-source projects</a> that have adopted Apache Arrow at their core or offer Arrow support reflects the widespread recognition and appreciation of its benefits (refer to this <a href="https://www.dremio.com/blog/apache-arrows-rapid-growth-over-the-years/">article</a> for an in-depth overview of the Arrow ecosystem and adoption). Over 11,000 GitHub users support this project, and 840+ are contributors who make this project an undeniable success.</p>

<p>Very often people ask about the differences between Arrow and <a href="https://parquet.apache.org/">Apache Parquet</a> or other columnar file formats. Arrow is designed and optimized for in-memory processing, while Parquet is tailored for disk-based storage. In reality, these technologies are complementary, with bridges existing between them to simplify interoperability. In both cases, data is represented in columns to optimize access, data locality and compressibility. However, the tradeoffs differ slightly. Arrow prioritizes data processing speed over the optimal data encoding. Complex encodings that don’t benefit from SIMD instruction sets are generally not natively supported by Arrow, unlike formats such as Parquet. Storing data in Parquet format and processing and transporting it in Arrow format has become a prevalent model within the big data community.</p>

<figure style="text-align: center;">
  <img src="/img/journey-apache-arrow/row-vs-columnar.svg" width="100%" class="img-responsive" alt="Memory representations: row vs columnar data." />
  <figcaption>Fig 1: Memory representations: row vs columnar data.</figcaption>
</figure>

<p>Figure 1 illustrates the differences in memory representation between row-oriented and column-oriented approaches. The column-oriented approach groups data from the same column in a continuous memory area, which facilitates parallel processing (SIMD) and enhances compression performance.</p>

<h2 id="why-are-we-interested-in-apache-arrow">Why are we interested in Apache Arrow</h2>

<p>At <a href="https://www.f5.com/">F5</a>, we’ve adopted <a href="https://opentelemetry.io/">OpenTelemetry</a> (OTel) as the standard for all telemetry across our products, such as BIGIP and NGINX. These products may generate large volumes of metrics and logs for various reasons, from performance evaluation to forensic purposes. The data produced by these systems is typically centralized and processed in dedicated systems. Transporting and processing this data accounts for a significant portion of the cost associated with telemetry pipelines. In this context, we became interested in Apache Arrow. Instead of reinventing yet another telemetry solution, we decided to invest in the OpenTelemetry project, working on improvements to the protocol to significantly increase its efficiency with high telemetry data volumes. We collaborated with <a href="https://github.com/jmacd">Joshua MacDonald</a> from <a href="https://lightstep.com/">Lightstep</a> to integrate these optimizations into an <a href="https://github.com/open-telemetry/experimental-arrow-collector">experimental OTel collector</a> and are currently in discussions with the OTel technical committee to finalize a code <a href="https://github.com/open-telemetry/community/issues/1332">donation</a>.</p>

<figure style="text-align: center;">
  <img src="/img/journey-apache-arrow/performance.svg" width="100%" class="img-responsive" alt="Performance improvement in the OpenTelemetry Arrow experimental project." />
  <figcaption>Fig 2: Performance improvement in the OpenTelemetry Arrow experimental project.</figcaption>
</figure>

<p>This project has been divided into two phases. The first phase, which is nearing completion, aims to enhance the protocol’s compression ratio. The second phase, planned for the future, focuses on improving end-to-end performance by incorporating Apache Arrow throughout all levels, eliminating the need for conversion between old and new protocols. The results so far are promising, with our benchmarks showing compression ratio improvements ranging from x1.5 to x5, depending on the data type (metrics, logs, traces), distribution, and compression algorithm. For the second phase, our estimates suggest that data processing acceleration could range from x2 to x12, again depending on the data’s nature and distribution. For more information, we encourage you to review the <a href="https://github.com/lquerel/oteps/blob/main/text/0156-columnar-encoding.md">specifications</a> and the <a href="https://github.com/f5/otel-arrow-adapter">reference implementation</a>.</p>

<p>Arrow relies on a schema to define the structure of data batches that it processes and transports. The subsequent sections will discuss various techniques that can be employed to optimize the creation of these schemas.</p>

<h2 id="how-to-leverage-arrow-to-optimize-network-transport-cost">How to leverage Arrow to optimize network transport cost</h2>

<p>Apache Arrow is a complex project with a rapidly evolving ecosystem, which can sometimes be overwhelming for newcomers. Fortunately the Arrow community has published three introductory articles <a href="https://arrow.apache.org/blog/2022/10/05/arrow-parquet-encoding-part-1/">1</a>, <a href="https://arrow.apache.org/blog/2022/10/08/arrow-parquet-encoding-part-2/">2</a>, and <a href="https://arrow.apache.org/blog/2022/10/17/arrow-parquet-encoding-part-3/">3</a> that we recommend for those interested in exploring this technology.</p>

<p>This article primarily focuses on transforming data from an XYZ format into an efficient Arrow representation that optimizes both compression ratio and data processing. There are numerous approaches to this transformation, and we will examine how these methods can impact compression ratio, CPU usage, and memory consumption during the conversion process, among other factors.</p>

<figure style="text-align: center;">
  <img src="/img/journey-apache-arrow/schema-optim-process.svg" width="100%" class="img-responsive" alt="Fig 3: Optimization process for the definition of an Arrow schema." />
  <figcaption>Fig 3: Optimization process for the definition of an Arrow schema.</figcaption>
</figure>

<p>The complexity of your initial model significantly impacts the Arrow mapping choices you need to make. To begin, it’s essential to identify the properties you want to optimize for your specific context. Compression rate, conversion speed, memory consumption, speed and ease of use of the final model, compatibility, and extensibility are all factors that can influence your final mapping decisions. From there, you must explore multiple alternative schemas.</p>

<p>The choice of the Arrow type and data encoding for each individual field will affect the performance of your schema. There are various ways to represent hierarchical data or highly dynamic data models, and multiple options need to be evaluated in coordination with the configuration of the transport layer. This transport layer should also be carefully considered. Arrow supports compression mechanisms and dictionary deltas that may not be active by default.</p>

<p>After several iterations of this process, you should arrive at an optimized schema that meets the goals you initially set. It’s crucial to compare the performance of your different approaches using real data, as the distribution of data in each individual field may influence whether you use dictionary encoding or not. We will now examine these choices in greater detail throughout the remainder of this article.</p>

<h2 id="arrow-data-type-selection">Arrow data type selection</h2>

<p>The principles of selecting an Arrow data type are quite similar to those used when defining a data model for databases. Arrow supports a wide range of data types. Some of these types are supported by all implementations, while others are only available for languages with the strongest Arrow community support (see this <a href="https://arrow.apache.org/docs/status.html">page</a> for a comparison matrix of the different implementations). For primitive types, it is generally preferable to choose the type that offers the most concise representation and is closest to the semantics of your initial field. For example, while it’s possible to represent a timestamp with an int64, it’s more advantageous to use the native Arrow Timestamp type. This choice isn’t due to a more efficient binary representation, but rather because it will be easier to process and manipulate in your pipeline. Query engines such as <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> offer dedicated timestamp handling functions for columns of this type. The same choices can be made for primitive types such as date, time, duration, and interval. However, if your project requires maximum compatibility, it may be crucial in some cases to favor types with universal support instead of the most optimal type in terms of memory occupation.</p>

<figure style="text-align: center;">
  <img src="/img/journey-apache-arrow/data-types.svg" width="100%" class="img-responsive" alt="Fig 4: Data types supported by Apache Arrow." />
  <figcaption>Fig 4: Data types supported by Apache Arrow.</figcaption>
</figure>

<p>When selecting the Arrow data type, it’s important to consider the size of the data before and after compression. It’s quite possible that the size after compression is the same for two different types, but the actual size in memory may be two, four, or even eight times larger (e.g., uint8 vs. uint64). This difference will impact your ability to process large batches of data and will also significantly influence the speed of processing these data in memory (e.g., cache optimization, SIMD instruction efficiency).</p>

<p>It’s also possible to extend these types using an <a href="https://arrow.apache.org/docs/format/Columnar.html#extension-types">extension type</a> mechanism that builds upon one of the currently supported primitive types while adding specific semantics. This extension mechanism can simplify the use of this data in your own project, while remaining transparent to intermediate systems that will interpret this data as a basic primitive type.</p>

<p>There are some variations in the encoding of primitive types, which we will explore next.</p>

<h2 id="data-encoding">Data encoding</h2>

<p>Another crucial aspect of optimizing your Arrow schema is analyzing the cardinality of your data. Fields that can have only a limited number of values will typically be more efficiently represented with a dictionary encoding.</p>

<p>The maximum cardinality of a field determines the data type characteristics of your dictionary. For instance, for a field representing the status code of an HTTP transaction, it’s preferable to use a dictionary with an index of type ‘uint8’ and a value of type ‘uint16’ (notation: ‘Dictionary&lt;uint8, uint16&gt;’). This consumes less memory because the main array will be of type ‘[]uint8’. Even if the range of possible values is greater than 255, as long as the number of distinct values does not exceed 255, the representation remains efficient. Similarly, the representation of a ‘user-agent’ will be more efficient with a dictionary of type ‘Dictionary&lt;uint16, string&gt;’ (see figure 5). In this case, the main array will be of type ‘uint16’, allowing a compact representation in memory and during transfers at the cost of an indirection during reverse conversion.</p>

<figure style="text-align: center;">
  <img src="/img/journey-apache-arrow/dictionary-encoding.svg" width="90%" class="img-responsive" alt="Fig 5: Dictionary encoding." />
  <figcaption>Fig 5: Dictionary encoding.</figcaption>
</figure>

<p>Dictionary encoding is highly flexible in Apache Arrow, allowing the creation of encodings for any Arrow primitive type. The size of the indices can also be configured based on the context.</p>

<p>In general, it is advisable to use dictionaries in the following cases:</p>
<ul>
  <li>Representation of enumerations</li>
  <li>Representation of textual or binary fields with a high probability of having redundant values.</li>
  <li>Representation of fields with cardinalities known to be below 2^16 or 2^32.</li>
</ul>

<p>Sometimes, the cardinality of a field is not known a priori. For example, a proxy that transforms a data stream from a row-oriented format into a series of columnar-encoded batches (e.g., OpenTelemetry collector) may not be able to predict in advance whether a field will have a fixed number of distinct values. Two approaches are possible: 
1) a conservative approach using the largest data type (e.g., ‘int64’, ‘string’, etc., instead of dictionary), 
2) an adaptive approach that modifies the schema on the fly based on the observed cardinality of the field(s). In this second approach, without cardinality information, you can optimistically start by using a ‘Dictionary&lt;uint8, original-field-type&gt;’ dictionary, then detect a potential dictionary overflow during conversion, and change the schema to a ‘Dictionary&lt;uint16, original-field-type&gt;’ in case of an overflow. This technique of automatic management of dictionary overflows will be presented in greater detail in a future article.</p>

<p>Recent advancements in Apache Arrow include the implementation of <a href="https://arrow.apache.org/docs/format/Columnar.html#run-end-encoded-layout">run-end encoding</a>, a technique that efficiently represents data with sequences of repeated values. This encoding method is particularly beneficial for handling data sets containing long stretches of identical values, as it offers a more compact and optimized representation.</p>

<p>In conclusion, dictionary encoding not only occupies less space in memory and during transfers but also significantly improves the compression ratio and data processing speed. However, this type of representation requires indirection when extracting the initial values (although this isn’t always necessary, even during some data processing operations). Additionally, it is important to manage dictionary index overflow, especially when the encoded field doesn’t have a well-defined cardinality.</p>

<h2 id="hierarchical-data">Hierarchical data</h2>

<p>Basic hierarchical data structures translate relatively well into Arrow. However, as we will see, there are some complications to handle in more  general cases (see figure 6). While Arrow schemas do support nested structures, maps, and unions, some components of the Arrow ecosystem do not fully support them, which can make these Arrow data types unsuitable for certain scenarios. Additionally, unlike most languages and formats, such as Protobuf, Arrow doesn’t support the concept of a recursively defined schema. An Arrow schema is static in its definition, and the depth of its nested elements must be known in advance. There are multiple strategies to work around this limitation and we’ll explore these in the following sections.</p>

<figure style="text-align: center;">
  <img src="/img/journey-apache-arrow/simple-vs-complex-data-model.svg" width="100%" class="img-responsive" alt="Fig 6: simple vs complex data model." />
  <figcaption>Fig 6: simple vs complex data model.</figcaption>
</figure>

<h3 id="natural-representation">Natural representation</h3>

<p>The most straightforward and intuitive approach to representing a simple hierarchical data model is to use Arrow’s list, map, and union data types. However, it’s important to note that some of these data types are not fully supported throughout the entire Arrow ecosystem. For example, the conversion of unions to Parquet is <a href="https://issues.apache.org/jira/browse/PARQUET-756">not directly supported</a> and requires a transformation step (see <a href="https://docs.google.com/document/d/11lG7Go2IgKOyW-RReBRW6r7HIdV1X7lu5WrDGlW5LbQ/edit#heading=h.nlplaj34c4ke">denormalization &amp; flattening representation</a> to decompose a sparse union into a nullable struct and type ids column). Similarly, lists and maps are <a href="https://arrow.apache.org/datafusion/user-guide/sql/sql_status.html">not yet supported</a> in DataFusion version 20 (nested structures are partially supported).</p>

<figure style="text-align: center;">
  <img src="/img/journey-apache-arrow/hierarchical-data-model.svg" width="80%" class="img-responsive" alt="Fig 7: initial data model." />
  <figcaption>Fig 7: initial data model.</figcaption>
</figure>

<p>The following example is a Go program snippet of an Arrow schema using these different data types to represent the model above.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"github.com/apache/arrow/go/v11/arrow"</span>


<span class="k">const</span> <span class="p">(</span>
  <span class="n">GaugeMetricCode</span> <span class="n">arrow</span><span class="o">.</span><span class="n">UnionTypeCode</span> <span class="o">=</span> <span class="m">0</span>
  <span class="n">SumMetricCode</span>   <span class="n">arrow</span><span class="o">.</span><span class="n">UnionTypeCode</span> <span class="o">=</span> <span class="m">1</span>
<span class="p">)</span>


<span class="k">var</span> <span class="p">(</span>
  <span class="c">// uint8Dictionary represent a Dictionary&lt;Uint8, String&gt;</span>
  <span class="n">uint8Dictionary</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arrow</span><span class="o">.</span><span class="n">DictionaryType</span><span class="p">{</span>
     <span class="n">IndexType</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">PrimitiveTypes</span><span class="o">.</span><span class="n">Uint8</span><span class="p">,</span>
     <span class="n">ValueType</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">BinaryTypes</span><span class="o">.</span><span class="n">String</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="c">// uint16Dictionary represent a Dictionary&lt;Uint16, String&gt;</span>
  <span class="n">uint16Dictionary</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arrow</span><span class="o">.</span><span class="n">DictionaryType</span><span class="p">{</span>
     <span class="n">IndexType</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">PrimitiveTypes</span><span class="o">.</span><span class="n">Uint16</span><span class="p">,</span>
     <span class="n">ValueType</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">BinaryTypes</span><span class="o">.</span><span class="n">String</span><span class="p">,</span>
  <span class="p">}</span>


  <span class="n">Schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">.</span><span class="n">NewSchema</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
     <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"resource_metrics"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">ListOf</span><span class="p">(</span><span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"scope"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
           <span class="c">// Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)).</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"name"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"version"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
        <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metrics"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">ListOf</span><span class="p">(</span><span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"name"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"unit"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint8Dictionary</span><span class="p">},</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"timestamp"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">TIMESTAMP</span><span class="p">},</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metric_type"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">UINT8</span><span class="p">},</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"data_point"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">ListOf</span><span class="p">(</span><span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
              <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metric"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">DenseUnionOf</span><span class="p">(</span>
                 <span class="p">[]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
                    <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"gauge"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
                       <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"data_point"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">},</span>
                    <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
                    <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"sum"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
                       <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"data_point"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">},</span>
                       <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"is_monotonic"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">BOOL</span><span class="p">},</span>
                    <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
                 <span class="p">},</span>
                 <span class="p">[]</span><span class="n">arrow</span><span class="o">.</span><span class="n">UnionTypeCode</span><span class="p">{</span><span class="n">GaugeMetricCode</span><span class="p">,</span> <span class="n">SumMetricCode</span><span class="p">},</span>
              <span class="p">)},</span>
           <span class="p">}</span><span class="o">...</span><span class="p">))},</span>
        <span class="p">}</span><span class="o">...</span><span class="p">))},</span>
     <span class="p">}</span><span class="o">...</span><span class="p">))},</span>
  <span class="p">},</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p>In this pattern, we use a union type to represent an inheritance relationship. There are two types of Arrow union that are optimized for different cases. The dense union type has a relatively succinct memory representation but doesn’t support vectorizable operations, making it less efficient during the processing phase. Conversely, a sparse union supports vectorization operations, but comes with a memory overhead directly proportional to the number of variants in the union. Dense and sparse unions have quite similar compression rates, with sometimes a slight advantage for sparse unions. In addition, sparse unions with a large number of variants should generally be avoided, as they can lead to excessive memory consumption. For more details on the memory representation of unions, you can consult this <a href="https://wesm.github.io/arrow-site-test/format/Layout.html#dense-union-type">page</a>.</p>

<p>In certain scenarios, it may be more idiomatic to represent the inheritance relationship using multiple schemas (i.e., one schema per subtype), thereby avoiding the use of the union type. However, applying this approach to the aforementioned model may not be optimal, as the data preceding the inheritance relationship (i.e., <code class="language-plaintext highlighter-rouge">ResourceMetrics</code>, <code class="language-plaintext highlighter-rouge">Scope</code>, and <code class="language-plaintext highlighter-rouge">Metrics</code>) could potentially be duplicated numerous times. If the relationships between <code class="language-plaintext highlighter-rouge">ResourceMetrics</code>, <code class="language-plaintext highlighter-rouge">Metrics</code>, and <code class="language-plaintext highlighter-rouge">DataPoint</code> were 0..1 (zero-to-one) relationships, then the multi-schema approach would likely be the simplest and most idiomatic solution.</p>

<h3 id="denormalization--flattening-representations">Denormalization &amp; Flattening representations</h3>

<p>If the <code class="language-plaintext highlighter-rouge">List</code> type is not supported in your telemetry pipeline, you can denormalize your data model. This process is often used in the database world to remove a join between two tables for optimization purposes. In the Arrow world, denormalization is employed to eliminate the <code class="language-plaintext highlighter-rouge">List</code> type by duplicating some data. Once transformed, the previous Arrow schema becomes.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">.</span><span class="n">NewSchema</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"resource_metrics"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
     <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"scope"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
        <span class="c">// Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)).</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"name"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"version"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
     <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
     <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metrics"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"name"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"unit"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint8Dictionary</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"timestamp"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">TIMESTAMP</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metric_type"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">UINT8</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"data_point"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metric"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">DenseUnionOf</span><span class="p">(</span>
              <span class="p">[]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
                 <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"gauge"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
                    <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"value"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">},</span>
                 <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
                 <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"sum"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
                    <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"value"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">},</span>
                    <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"is_monotonic"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">BOOL</span><span class="p">},</span>
                 <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
              <span class="p">},</span>
              <span class="p">[]</span><span class="n">arrow</span><span class="o">.</span><span class="n">UnionTypeCode</span><span class="p">{</span><span class="n">GaugeMetricCode</span><span class="p">,</span> <span class="n">SumMetricCode</span><span class="p">},</span>
           <span class="p">)},</span>
        <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
     <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
  <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
<span class="p">},</span> <span class="no">nil</span><span class="p">)</span>
</code></pre></div></div>

<p>List types are eliminated at all levels. The initial semantics of the model are preserved by duplicating the data of the levels below each data point value. The memory representation will generally be much larger than the previous one, but a query engine that does not support the <code class="language-plaintext highlighter-rouge">List</code> type will still be able to process this data. Interestingly, once compressed, this way of representing data may not necessarily be larger than the previous approach. This is because the columnar representation compresses very well when there is redundancy in the data.</p>

<p>If the union type is not supported by some components of your pipeline, it is also possible to eliminate them by merging the union variants (the nested structure ‘metric’ is removed, see below).</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">.</span><span class="n">NewSchema</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"resource_metrics"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
     <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"scope"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
        <span class="c">// Name and Version are declared as dictionaries (Dictionary&lt;Uint16, String&gt;)).</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"name"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"version"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
     <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
     <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metrics"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"name"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"unit"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint8Dictionary</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"timestamp"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">TIMESTAMP</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metric_type"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">UINT8</span><span class="p">},</span>
        <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"data_point"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">StructOf</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"value"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">},</span>
           <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"is_monotonic"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">BOOL</span><span class="p">},</span>
        <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
     <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
  <span class="p">}</span><span class="o">...</span><span class="p">)},</span>
<span class="p">},</span> <span class="no">nil</span><span class="p">)</span>
</code></pre></div></div>

<p>The final schema has evolved into a series of nested structures, where the fields of the union variants are merged into one structure. The trade-off of this approach is similar to that of sparse union - the more variants, the higher the memory occupation. Arrow supports the concept of bitmap validity to identify null values (1 bit per entry) for various data types, including those that do not have a unique null representation (e.g., primitive types). The use of bitmap validity makes the query part easier, and query engines such as DataFusion know how to use if efficiently, Columns with numerous nulls typically compress quite efficiently since the underlying arrays are generally initialized with 0’s. Upon compression, these extensive sequences of 0’s result in high compression efficiency, despite the memory overhead before compression in the case of sparse unions. Consequently, it is essential to select the appropriate trade-off based on your specific context.</p>

<p>In some extreme situations where nested structures are not supported, a flattening approach can be used to address this problem.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">.</span><span class="n">NewSchema</span><span class="p">([]</span><span class="n">arrow</span><span class="o">.</span><span class="n">Field</span><span class="p">{</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"scope_name"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"scope_version"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metrics_name"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint16Dictionary</span><span class="p">},</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metrics_unit"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">uint8Dictionary</span><span class="p">},</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metrics_timestamp"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">TIMESTAMP</span><span class="p">},</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metrics_metric_type"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">UINT8</span><span class="p">},</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metrics_data_point_value"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">FLOAT64</span><span class="p">},</span>
  <span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="s">"metrics_data_point_is_monotonic"</span><span class="p">,</span> <span class="n">Type</span><span class="o">:</span> <span class="n">arrow</span><span class="o">.</span><span class="n">BOOL</span><span class="p">},</span>
<span class="p">},</span> <span class="no">nil</span><span class="p">)</span>
</code></pre></div></div>

<p>The terminal fields (leaves) are renamed by concatenating the names of the parent structures to provide proper scoping. This type of structure is supported by all components of the Arrow ecosystem. This approach can be useful if compatibility is a crucial criterion for your system. However, it shares the same drawbacks as other alternative denormalization models.</p>

<p>The Arrow ecosystem is evolving rapidly, so it is likely that support for List, Map, and Union data types in query engines will improve quickly. If kernel functions are sufficient or preferable for your application, it is usually possible to utilize these nested types.</p>

<h3 id="adaptivedynamic-representation">Adaptive/Dynamic representation</h3>

<p>Some data models can be more challenging to translate into an Arrow schema, such as the following Protobuf example. In this example, a collection of attributes is added to each data point. These attributes are defined using a recursive definition that most languages and formats, like Protobuf, support (see the ‘AnyValue’ definition below). Unfortunately, Arrow (like most classical database schemas) does not support such recursive definition within schemas.</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span>


<span class="kd">message</span> <span class="nc">Metric</span> <span class="p">{</span>
 <span class="kd">message</span> <span class="nc">DataPoint</span> <span class="p">{</span>
   <span class="k">repeated</span> <span class="n">Attribute</span> <span class="na">attributes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="k">oneof</span> <span class="n">value</span> <span class="p">{</span>
     <span class="kt">int64</span> <span class="na">int_value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
     <span class="kt">double</span> <span class="na">double_value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="p">}</span>
 <span class="p">}</span>


 <span class="kd">enum</span> <span class="n">MetricType</span> <span class="p">{</span>
   <span class="na">UNSPECIFIED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="na">GAUGE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="na">SUM</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
 <span class="p">}</span>


 <span class="kd">message</span> <span class="nc">Gauge</span> <span class="p">{</span>
   <span class="n">DataPoint</span> <span class="na">data_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="p">}</span>


 <span class="kd">message</span> <span class="nc">Sum</span> <span class="p">{</span>
   <span class="n">DataPoint</span> <span class="na">data_point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="na">is_monotonic</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
 <span class="p">}</span>


 <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="kt">int64</span> <span class="na">timestamp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
 <span class="kt">string</span> <span class="na">unit</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
 <span class="n">MetricType</span> <span class="na">type</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
 <span class="k">oneof</span> <span class="n">metric</span> <span class="p">{</span>
   <span class="n">Gauge</span> <span class="na">gauge</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
   <span class="n">Sum</span> <span class="na">sum</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>


<span class="kd">message</span> <span class="nc">Attribute</span> <span class="p">{</span>
 <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="n">AnyValue</span> <span class="na">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Recursive definition of AnyValue. AnyValue can be a primitive value, a list</span>
<span class="c1">// of AnyValues, or a list of key-value pairs where the key is a string and</span>
<span class="c1">// the value is an AnyValue.</span>
<span class="kd">message</span> <span class="nc">AnyValue</span> <span class="p">{</span>
 <span class="kd">message</span> <span class="nc">ArrayValue</span> <span class="p">{</span>
   <span class="k">repeated</span> <span class="n">AnyValue</span> <span class="na">values</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="kd">message</span> <span class="nc">KeyValueList</span> <span class="p">{</span>
   <span class="kd">message</span> <span class="nc">KeyValue</span> <span class="p">{</span>
     <span class="kt">string</span> <span class="na">key</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
     <span class="n">AnyValue</span> <span class="na">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">repeated</span> <span class="n">KeyValue</span> <span class="na">values</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="p">}</span>


 <span class="k">oneof</span> <span class="n">value</span> <span class="p">{</span>
   <span class="kt">int64</span> <span class="na">int_value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kt">double</span> <span class="na">double_value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
   <span class="kt">string</span> <span class="na">string_value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">ArrayValue</span> <span class="na">list_value</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">KeyValueList</span> <span class="na">kvlist_value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If the definition of the attributes were non-recursive, it would have been possible to directly translate them into an Arrow Map type.</p>

<p>To address this kind of issue and further optimize Arrow schema definitions, you can employ an adaptive and iterative method that automatically constructs the Arrow schema based on the data being translated. With this approach, fields are automatically dictionary-encoded according to their cardinalities, unused fields are eliminated, and recursive structures are represented in a specific manner. Another solution involves using a multi-schema approach, in which attributes are depicted in a separate Arrow Record, and the inheritance relation is represented by a self-referential relationship. These strategies will be covered in more depth in a future article. For those eager to learn more, the first method is utilized in the reference implementation of the <a href="https://github.com/f5/otel-arrow-adapter">OTel Arrow Adapter</a>.</p>

<h2 id="data-transport">Data transport</h2>

<p>Unlike to Protobuf, an Arrow schema is generally not known a priori by the two parties participating in an exchange. Before being able to exchange data in Arrow format, the sender must first communicate the schema to the receiver, as well as the contents of the dictionaries used in the data. Only after this initialization phase has been completed can the sender transmit batches of data in Arrow format. This process, known as <a href="https://wesmckinney.com/blog/arrow-streaming-columnar/">Arrow IPC Stream</a>, plays an essential role transporting Arrow data between systems. Several approaches can be employed to communicate these Arrow IPC Streams. The simplest method is to use <a href="https://arrow.apache.org/docs/format/Flight.html">Arrow Flight</a>, which encapsulates Arrow IPC streams in a gRPC-based protocol. However, it is also possible to use your own implementation for specific contexts. Regardless of the solution you choose, it is crucial to understand that the underlying protocol must be stateful to take full advantage of the Arrow IPC stream approach. To achieve the best compression rates, it is vital to send schemas and dictionaries only once in order to amortize the cost and minimize data redundancy between batches. This necessitates a transport that supports stream-oriented communications, such as gRPC.</p>

<p>Using a stateless protocol is possible for large batches because the overhead of the schema will be negligible compared to the compression gains achieved using dictionary encoding and columnar representation. However, dictionaries will have to be communicated for each batch, making this approach generally less efficient than a stream-oriented approach.</p>

<p>Arrow IPC Stream also supports the concept of “delta dictionaries,” which allows for further optimization of batch transport. When a batch adds data to an existing dictionary (at the sender’s end), Arrow IPC enables sending the delta dictionary followed by the batch that references it. On the receiver side, this delta is used to update the existing dictionary, eliminating the need to retransmit the entire dictionary when changes occur. This optimization is only possible with a stateful protocol.</p>

<p>To fully leverage the column-oriented format of Apache Arrow, it is essential to consider sorting and compression. If your data model is simple (i.e., flat) and has one or more columns representing a natural order for your data (e.g., timestamp), it might be beneficial to sort your data to optimize the final compression ratio. Before implementing this optimization, it is recommended to perform tests on real data since the benefits may vary. In any case, using a compression algorithm when sending your batches is advantageous. Arrow IPC generally supports the ZSTD compression algorithm, which strikes an excellent balance between speed and compression efficiency, especially for column-oriented data.</p>

<p>Lastly, some implementations (e.g., Arrow Go) are not configured by default to support delta dictionaries and compression algorithms. Therefore, it is crucial to ensure that your code employs these options to maximize data transport efficiency.</p>

<h2 id="experiments">Experiments</h2>

<p>If your initial data is complex, it is advisable to conduct your own experiments to optimize the Arrow representation according to your data and goals (e.g., optimizing the compression ratio or enhancing the query-ability of your data in Arrow format). In our case, we developed an overlay for Apache Arrow that enables us to carry out these experiments with ease, without having to deal with the intrinsic complexity of Arrow APIs. However, this comes at the expense of a slower conversion phase compared to using Arrow APIs directly. While this library is not currently public, it may become available if there is sufficient interest.</p>

<p>We also employed a “black box optimization” approach, which automatically finds the best combination to meet the objectives we aimed to optimize (refer to “<a href="https://cloud.google.com/blog/products/ai-machine-learning/optimize-your-applications-using-google-vertex-ai-vizier">Optimize your applications using Google Vertex AI Vizier</a>” for a description of this approach).</p>

<h2 id="conclusion-and-next-steps">Conclusion and next steps</h2>

<p>Essentially, the key concept behind Apache Arrow is that it eliminates the need for serialization and deserialization, enabling zero-copy data sharing. Arrow achieves this by defining a language-agnostic, in-memory format that remains consistent across various implementations. Consequently, raw memory bytes can be transmitted directly over a network without requiring any serialization or deserialization, significantly enhancing data processing efficiency.</p>

<p>Converting a data model to Apache Arrow necessitates adaptation and optimization work, as we have begun to describe in this article. Many parameters must be considered, and it is recommended to perform a series of experiments to validate the various choices made during this process.</p>

<p>Handling highly dynamic data with Arrow can be challenging. Arrow requires the definition of a static schema, which can sometimes make representing this type of data complex or suboptimal, especially when the initial schema contains recursive definitions. This article has discussed several approaches to address this issue. The next article will be dedicated to a hybrid strategy that involves adapting the Arrow schema on-the-fly to optimize memory usage, compression ratio, and processing speed based on the data being represented. This approach is quite unique and deserves a separate article.</p>

      </main>
    </div>

    <hr/>
<footer class="footer">
  <div class="row">
    <div class="col-md-9">
      <p>Apache Arrow, Arrow, Apache, the Apache feather logo, and the Apache Arrow project logo are either registered trademarks or trademarks of The Apache Software Foundation in the United States and other countries.</p>
      <p>&copy; 2016-2023 The Apache Software Foundation</p>
    </div>
    <div class="col-md-3">
      <a class="d-sm-none d-md-inline pr-2" href="https://www.apache.org/events/current-event.html">
        <img src="https://www.apache.org/events/current-event-234x60.png"/>
      </a>
    </div>
  </div>
</footer>

  </div>
</body>
</html>
