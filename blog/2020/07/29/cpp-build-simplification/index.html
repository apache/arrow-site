<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above meta tags *must* come first in the head; any other head content must come *after* these tags -->
    
    <title>Making Arrow C++ Builds Simpler, Smaller, and Faster | Apache Arrow</title>
    

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Making Arrow C++ Builds Simpler, Smaller, and Faster" />
<meta name="author" content="pmc" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Over the last four and a half years, we&#39;ve worked to build a &quot;batteries-included&quot; development platform for high-performance analytics applications in C++. As the scope of the project has grown, we have sometimes taken on additional library dependencies to support a wide variety of systems and data processing tasks. While these dependencies give us leverage on hard problems, in some cases they have added complexity for projects that depend on Arrow. Some projects have thus been concerned about depending on the Arrow C++ library, particularly if their use of the Arrow library&#39;s features is limited. Indeed, in the earlier stages of the Arrow project development, dependency management issues did cause problems for early adopters. We want developers to trust that they can use and depend on our libraries, and that doing so doesn&#39;t add a burden for their own project maintenance or for their users. Over the last year, we have undertaken a number of significant projects to accommodate the different ways that people want to depend on Arrow C++. We&#39;ve aimed to make the build process simple by default, without requiring special environment setup, yet also highly configurable for those who need to specialize. This includes a zero-dependency option for projects that wish to use the Arrow C++ core but take on no transitive dependencies. We&#39;ve also worked to make builds faster and more compact, even as we continue to add new functionality. This post covers many of the efforts we&#39;ve made, both in the C++ libraries and in the Arrow Python and R packages that depend on them. Compared to a year ago, the build experience is much more reliable on a wider range of platforms, requires fewer dependencies, and yields smaller package sizes. Minimal default build options One rough edge for people using Arrow as a dependency was that many optional project components were enabled in the build by default, thus requiring any extra dependencies of those optional components. Rather than expecting users to disable optional components one by one, we have made the default for all optional components to be OFF so that the default configuration is a dependency-free minimal core build. The only third-party library enabled by default is jemalloc, the project&#39;s recommended memory allocator (except on Windows, where it is also disabled). Given that Arrow applications often process large volumes of data, we have found additionally that using memory allocators provided by projects like jemalloc and mimalloc yield significantly better performance over the default system allocators. Even so, this can also be disabled if desired. To demonstrate a minimal build, we have provided a Dockerfile which can be used to build the project requiring only CMake and a C++ compiler with zero dependencies. Additionally, we have included an example of including Arrow as an external project dependency in another CMake project. Flexible dependency configuration in CMake As part of improving our CMake-based build system, we have made the configuration of build dependencies both flexible and consistent for different users&#39; needs. In some cases, developers want Arrow to build against dependencies provided by an external package manager, such as apt in Debian-based Linux distributions. In other cases, developers may want to avoid any quirks of system libraries and build all dependencies together with the Arrow build. For each package, the ${Library}_SOURCE CMake option can be set to one of three values: SYSTEM, when the dependency is to be provided externally (such as by a Linux distribution or Homebrew) BUNDLED, when you want the dependency to be built from source while building Arrow, and then statically-linked with the resulting libraries AUTO, which tries the SYSTEM approach but falls back on BUNDLED if the dependency cannot be located We additionally have provided CONDA and BREW source types for the common scenarios when developers are using the conda or Homebrew package managers. These dependency sources can be configured on an individual dependency basis or globally using the ARROW_DEPENDENCY_SOURCE CMake option. AUTO is default, which enables builds to be faster by using pre-built system libraries where possible but still succeed even if all dependencies are not available on the system. Reduced external dependencies Another area of focus was to audit our dependencies. We went through and found places where we could drop external dependencies without losing useful functionality and without having to rewrite a lot or copy too much code into our codebase. We have eliminated Boost as a dependency of the core Arrow library, and in other components (Gandiva, Parquet, etc.), the use of Boost has been greatly reduced. In addition, when building Boost &quot;bundled&quot; in the Arrow build, we stripped down the Boost package we download to the minimum needed, cutting out 90 percent of the download size. We vendored a few small dependencies, such as the double-conversion and uriparser libraries, so that they do not need to be downloaded and built separately. We also compiled the Flatbuffers and Thrift definitions (which are needed to implement the Arrow and Parquet formats, respectively) and checked in the resulting C++ code to the Arrow repository. This means that Flatbuffers is no longer a build or runtime dependency of Arrow, and we only need the Thrift C++ library, not the Thrift compiler, which has additional dependencies on flex and bison. C++ library size reductions As the C++ codebase grows in size, so too does compilation times and the amount of binary code generated by the C++ compiler. Over the last several months, we have begun analyzing the Arrow libraries both compile times and generated code sizes. This has yielded both significant size reductions (more than 30 percent code size reduction since 0.17.0). We have also restructured header files to avoid including unneeded header files, thus lightening the load on C++ compilers and improving compilation times. Python wheels The expectation for binary wheel packages on the Python Package Index (PyPI) is that they are self-contained and have no external dependencies except on other Python packages. Additionally, each user of pyarrow may need different things from the project. Some users just want to read Parquet files and convert them to pandas data frames while others want to use Flight for moving around large datasets. Thus, the &quot;pyarrow&quot; wheel has from the beginning of the project been a fairly comprehensive build including as many optional components as is practical for us to maintain. A comprehensive wheel package has some downsides: most notably for users, it is large. Additionally, through a snafu relating to C++ shared libraries, for several releases the wheel packages would create two copies of each C++ library on disk, resulting in double the amount of disk usage. This has caused problems for people using pyarrow in space-constrained environments like AWS Lambda. In the 1.0.0 release, we have implemented some changes that have reduced the size of the wheels (both in .whl form and installed on disk) by about 75 percent: Working around the problems resulting in two copies of each shared library being created in the site-packages directory. Disabling Gandiva, which required the LLVM runtime, the largest statically-linked dependency. Gandiva is still available to conda users now--it&#39;s just not included in the wheels--and we hope to package it as a separate pyarrow-llvm package in the future. Reducing the size of the C++ shared libraries as discussed above Now pyarrow is about the size of NumPy and thus much easier for Python projects to take on as a hard dependency without worrying about large on-disk size. Looking ahead, we have discussed strategies for breaking up pyarrow into multiple wheel packages, sort of a &quot;hub and spoke&quot; model where some optional pieces are installed as separate wheels so people only needing some &quot;core&quot; functionality only have to install a small package. This would be a significant project, though, so for now we&#39;ve focused on improvements to the comprehensive wheel package. R packaging Packaging Arrow for R involves similar challenges to Python wheels, though the technical details are unique. Like how pip install pyarrow should just work everywhere, so should install.packages(&quot;arrow&quot;) in R, and we have invested significant effort to get there. Because the R package depends on a C++ library in active development, this is not trivial, particularly for all of the combinations of C++ compilers and standard libraries on Linux. In the initial CRAN release last year, version 0.14.1, only Windows and macOS binary packages worked out of the box. For Linux, you had to install the C++ library separately, before installing the R package. While Python wheels contain binary libraries even on Linux, CRAN only hosts source packages that must be compiled on the user&#39;s machine at install time. This led to an experience that was less than ideal for Linux users. Starting in version 0.16, a source package installation on Linux handles its C++ dependencies automatically. By default, the package executes a bundled script that downloads and builds the Arrow C++ library with no system dependencies beyond what R requires. On many common Linux distributions and versions, this can be sped up by setting an environment variable to download a prebuilt static C++ library for inclusion in the package. To accompany these improvements and to ensure that they succeeded on a wide range of platforms, we added extensive nightly builds to our continuous integration system. These are also easily extensible--all we need is a Docker image containing R, and we can plug new environments into our regular nightly testing. Since then, we&#39;ve continued to improve the installation experience and look for ways to reduce build time and package size. The C++ library improvements discussed above help the R package since most installations of the R package either build or otherwise include the C++ library. Within the R package itself, we&#39;ve looked for ways to include just what is needed and nothing more. These efforts have resulted in smaller downloads and installed package sizes. From 0.17.1 to 1.0.0, installed library sizes for macOS and Windows CRAN binaries are down 10 percent, and the prebuilt static C++ libraries for Linux are 33 percent smaller compared to 0.16.0, despite the addition of many new features. checking installed package size ... NOTE installed size is 38.1Mb sub-directories of 1Mb or more: R 3.2Mb libs 34.5Mb autobrew libs on master: 8.9mb macOS 1.0.0 checking installed package size ... NOTE installed size is 35.0Mb sub-directories of 1Mb or more: R 3.2Mb libs 31.3Mb windows 0.17.1: checking installed package size ... NOTE installed size is 27.9Mb sub-directories of 1Mb or more: R 3.2Mb libs 24.3Mb windows libs on 1.0.0: checking installed package size ... NOTE installed size is 24.9Mb sub-directories of 1Mb or more: R 3.2Mb libs 21.2Mb ubuntu-18.04 libarrow binaries: 0.16.0.2 18.84 MB 0.17.0 12.81 MB 1.0.0 12.45 MB --&gt; C Interface Finally, we have observed that some projects may wish to produce or consume a subset of the Arrow format and do not want to take on any additional code dependencies. There are also scenarios where two libraries need to share in-memory Arrow data structures but are unable to depend on a common Arrow library such as the reference C++ implementation. To address these use cases, we designed the C Interface to provide a lightweight way to exchange Arrow data at the C level without any memory copying. When using the C interface, a developer populates simple C data structures that contain the schema (data type) information about an Arrow data structure and the addresses of the pieces of memory that constitute the data. This permits libraries to be plugged together easily in-memory without any shared code (except the C interface structure definitions). Most programming languages have the ability to manipulate C structures and so this interface can even be used without having to write or compile C code. We have used the C interface to transfer data structures between Python and R in-memory using reticulate. One exciting use case for the Arrow C interface is to add Arrow import and export to database driver libraries which often contain a C API. Looking ahead As the project grows, we will continue working to make the build process as fast and reliable as possible. If you see ways we can improve it further, or if you run into trouble, please bring it up on our mailing list or report an issue." />
<meta property="og:description" content="Over the last four and a half years, we&#39;ve worked to build a &quot;batteries-included&quot; development platform for high-performance analytics applications in C++. As the scope of the project has grown, we have sometimes taken on additional library dependencies to support a wide variety of systems and data processing tasks. While these dependencies give us leverage on hard problems, in some cases they have added complexity for projects that depend on Arrow. Some projects have thus been concerned about depending on the Arrow C++ library, particularly if their use of the Arrow library&#39;s features is limited. Indeed, in the earlier stages of the Arrow project development, dependency management issues did cause problems for early adopters. We want developers to trust that they can use and depend on our libraries, and that doing so doesn&#39;t add a burden for their own project maintenance or for their users. Over the last year, we have undertaken a number of significant projects to accommodate the different ways that people want to depend on Arrow C++. We&#39;ve aimed to make the build process simple by default, without requiring special environment setup, yet also highly configurable for those who need to specialize. This includes a zero-dependency option for projects that wish to use the Arrow C++ core but take on no transitive dependencies. We&#39;ve also worked to make builds faster and more compact, even as we continue to add new functionality. This post covers many of the efforts we&#39;ve made, both in the C++ libraries and in the Arrow Python and R packages that depend on them. Compared to a year ago, the build experience is much more reliable on a wider range of platforms, requires fewer dependencies, and yields smaller package sizes. Minimal default build options One rough edge for people using Arrow as a dependency was that many optional project components were enabled in the build by default, thus requiring any extra dependencies of those optional components. Rather than expecting users to disable optional components one by one, we have made the default for all optional components to be OFF so that the default configuration is a dependency-free minimal core build. The only third-party library enabled by default is jemalloc, the project&#39;s recommended memory allocator (except on Windows, where it is also disabled). Given that Arrow applications often process large volumes of data, we have found additionally that using memory allocators provided by projects like jemalloc and mimalloc yield significantly better performance over the default system allocators. Even so, this can also be disabled if desired. To demonstrate a minimal build, we have provided a Dockerfile which can be used to build the project requiring only CMake and a C++ compiler with zero dependencies. Additionally, we have included an example of including Arrow as an external project dependency in another CMake project. Flexible dependency configuration in CMake As part of improving our CMake-based build system, we have made the configuration of build dependencies both flexible and consistent for different users&#39; needs. In some cases, developers want Arrow to build against dependencies provided by an external package manager, such as apt in Debian-based Linux distributions. In other cases, developers may want to avoid any quirks of system libraries and build all dependencies together with the Arrow build. For each package, the ${Library}_SOURCE CMake option can be set to one of three values: SYSTEM, when the dependency is to be provided externally (such as by a Linux distribution or Homebrew) BUNDLED, when you want the dependency to be built from source while building Arrow, and then statically-linked with the resulting libraries AUTO, which tries the SYSTEM approach but falls back on BUNDLED if the dependency cannot be located We additionally have provided CONDA and BREW source types for the common scenarios when developers are using the conda or Homebrew package managers. These dependency sources can be configured on an individual dependency basis or globally using the ARROW_DEPENDENCY_SOURCE CMake option. AUTO is default, which enables builds to be faster by using pre-built system libraries where possible but still succeed even if all dependencies are not available on the system. Reduced external dependencies Another area of focus was to audit our dependencies. We went through and found places where we could drop external dependencies without losing useful functionality and without having to rewrite a lot or copy too much code into our codebase. We have eliminated Boost as a dependency of the core Arrow library, and in other components (Gandiva, Parquet, etc.), the use of Boost has been greatly reduced. In addition, when building Boost &quot;bundled&quot; in the Arrow build, we stripped down the Boost package we download to the minimum needed, cutting out 90 percent of the download size. We vendored a few small dependencies, such as the double-conversion and uriparser libraries, so that they do not need to be downloaded and built separately. We also compiled the Flatbuffers and Thrift definitions (which are needed to implement the Arrow and Parquet formats, respectively) and checked in the resulting C++ code to the Arrow repository. This means that Flatbuffers is no longer a build or runtime dependency of Arrow, and we only need the Thrift C++ library, not the Thrift compiler, which has additional dependencies on flex and bison. C++ library size reductions As the C++ codebase grows in size, so too does compilation times and the amount of binary code generated by the C++ compiler. Over the last several months, we have begun analyzing the Arrow libraries both compile times and generated code sizes. This has yielded both significant size reductions (more than 30 percent code size reduction since 0.17.0). We have also restructured header files to avoid including unneeded header files, thus lightening the load on C++ compilers and improving compilation times. Python wheels The expectation for binary wheel packages on the Python Package Index (PyPI) is that they are self-contained and have no external dependencies except on other Python packages. Additionally, each user of pyarrow may need different things from the project. Some users just want to read Parquet files and convert them to pandas data frames while others want to use Flight for moving around large datasets. Thus, the &quot;pyarrow&quot; wheel has from the beginning of the project been a fairly comprehensive build including as many optional components as is practical for us to maintain. A comprehensive wheel package has some downsides: most notably for users, it is large. Additionally, through a snafu relating to C++ shared libraries, for several releases the wheel packages would create two copies of each C++ library on disk, resulting in double the amount of disk usage. This has caused problems for people using pyarrow in space-constrained environments like AWS Lambda. In the 1.0.0 release, we have implemented some changes that have reduced the size of the wheels (both in .whl form and installed on disk) by about 75 percent: Working around the problems resulting in two copies of each shared library being created in the site-packages directory. Disabling Gandiva, which required the LLVM runtime, the largest statically-linked dependency. Gandiva is still available to conda users now--it&#39;s just not included in the wheels--and we hope to package it as a separate pyarrow-llvm package in the future. Reducing the size of the C++ shared libraries as discussed above Now pyarrow is about the size of NumPy and thus much easier for Python projects to take on as a hard dependency without worrying about large on-disk size. Looking ahead, we have discussed strategies for breaking up pyarrow into multiple wheel packages, sort of a &quot;hub and spoke&quot; model where some optional pieces are installed as separate wheels so people only needing some &quot;core&quot; functionality only have to install a small package. This would be a significant project, though, so for now we&#39;ve focused on improvements to the comprehensive wheel package. R packaging Packaging Arrow for R involves similar challenges to Python wheels, though the technical details are unique. Like how pip install pyarrow should just work everywhere, so should install.packages(&quot;arrow&quot;) in R, and we have invested significant effort to get there. Because the R package depends on a C++ library in active development, this is not trivial, particularly for all of the combinations of C++ compilers and standard libraries on Linux. In the initial CRAN release last year, version 0.14.1, only Windows and macOS binary packages worked out of the box. For Linux, you had to install the C++ library separately, before installing the R package. While Python wheels contain binary libraries even on Linux, CRAN only hosts source packages that must be compiled on the user&#39;s machine at install time. This led to an experience that was less than ideal for Linux users. Starting in version 0.16, a source package installation on Linux handles its C++ dependencies automatically. By default, the package executes a bundled script that downloads and builds the Arrow C++ library with no system dependencies beyond what R requires. On many common Linux distributions and versions, this can be sped up by setting an environment variable to download a prebuilt static C++ library for inclusion in the package. To accompany these improvements and to ensure that they succeeded on a wide range of platforms, we added extensive nightly builds to our continuous integration system. These are also easily extensible--all we need is a Docker image containing R, and we can plug new environments into our regular nightly testing. Since then, we&#39;ve continued to improve the installation experience and look for ways to reduce build time and package size. The C++ library improvements discussed above help the R package since most installations of the R package either build or otherwise include the C++ library. Within the R package itself, we&#39;ve looked for ways to include just what is needed and nothing more. These efforts have resulted in smaller downloads and installed package sizes. From 0.17.1 to 1.0.0, installed library sizes for macOS and Windows CRAN binaries are down 10 percent, and the prebuilt static C++ libraries for Linux are 33 percent smaller compared to 0.16.0, despite the addition of many new features. checking installed package size ... NOTE installed size is 38.1Mb sub-directories of 1Mb or more: R 3.2Mb libs 34.5Mb autobrew libs on master: 8.9mb macOS 1.0.0 checking installed package size ... NOTE installed size is 35.0Mb sub-directories of 1Mb or more: R 3.2Mb libs 31.3Mb windows 0.17.1: checking installed package size ... NOTE installed size is 27.9Mb sub-directories of 1Mb or more: R 3.2Mb libs 24.3Mb windows libs on 1.0.0: checking installed package size ... NOTE installed size is 24.9Mb sub-directories of 1Mb or more: R 3.2Mb libs 21.2Mb ubuntu-18.04 libarrow binaries: 0.16.0.2 18.84 MB 0.17.0 12.81 MB 1.0.0 12.45 MB --&gt; C Interface Finally, we have observed that some projects may wish to produce or consume a subset of the Arrow format and do not want to take on any additional code dependencies. There are also scenarios where two libraries need to share in-memory Arrow data structures but are unable to depend on a common Arrow library such as the reference C++ implementation. To address these use cases, we designed the C Interface to provide a lightweight way to exchange Arrow data at the C level without any memory copying. When using the C interface, a developer populates simple C data structures that contain the schema (data type) information about an Arrow data structure and the addresses of the pieces of memory that constitute the data. This permits libraries to be plugged together easily in-memory without any shared code (except the C interface structure definitions). Most programming languages have the ability to manipulate C structures and so this interface can even be used without having to write or compile C code. We have used the C interface to transfer data structures between Python and R in-memory using reticulate. One exciting use case for the Arrow C interface is to add Arrow import and export to database driver libraries which often contain a C API. Looking ahead As the project grows, we will continue working to make the build process as fast and reliable as possible. If you see ways we can improve it further, or if you run into trouble, please bring it up on our mailing list or report an issue." />
<link rel="canonical" href="https://arrow.apache.org/blog/2020/07/29/cpp-build-simplification/" />
<meta property="og:url" content="https://arrow.apache.org/blog/2020/07/29/cpp-build-simplification/" />
<meta property="og:site_name" content="Apache Arrow" />
<meta property="og:image" content="https://arrow.apache.org/img/arrow-logo_horizontal_black-txt_white-bg.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-29T02:00:00-04:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://arrow.apache.org/img/arrow-logo_horizontal_black-txt_white-bg.png" />
<meta property="twitter:title" content="Making Arrow C++ Builds Simpler, Smaller, and Faster" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"pmc"},"dateModified":"2020-07-29T02:00:00-04:00","datePublished":"2020-07-29T02:00:00-04:00","description":"Over the last four and a half years, we&#39;ve worked to build a &quot;batteries-included&quot; development platform for high-performance analytics applications in C++. As the scope of the project has grown, we have sometimes taken on additional library dependencies to support a wide variety of systems and data processing tasks. While these dependencies give us leverage on hard problems, in some cases they have added complexity for projects that depend on Arrow. Some projects have thus been concerned about depending on the Arrow C++ library, particularly if their use of the Arrow library&#39;s features is limited. Indeed, in the earlier stages of the Arrow project development, dependency management issues did cause problems for early adopters. We want developers to trust that they can use and depend on our libraries, and that doing so doesn&#39;t add a burden for their own project maintenance or for their users. Over the last year, we have undertaken a number of significant projects to accommodate the different ways that people want to depend on Arrow C++. We&#39;ve aimed to make the build process simple by default, without requiring special environment setup, yet also highly configurable for those who need to specialize. This includes a zero-dependency option for projects that wish to use the Arrow C++ core but take on no transitive dependencies. We&#39;ve also worked to make builds faster and more compact, even as we continue to add new functionality. This post covers many of the efforts we&#39;ve made, both in the C++ libraries and in the Arrow Python and R packages that depend on them. Compared to a year ago, the build experience is much more reliable on a wider range of platforms, requires fewer dependencies, and yields smaller package sizes. Minimal default build options One rough edge for people using Arrow as a dependency was that many optional project components were enabled in the build by default, thus requiring any extra dependencies of those optional components. Rather than expecting users to disable optional components one by one, we have made the default for all optional components to be OFF so that the default configuration is a dependency-free minimal core build. The only third-party library enabled by default is jemalloc, the project&#39;s recommended memory allocator (except on Windows, where it is also disabled). Given that Arrow applications often process large volumes of data, we have found additionally that using memory allocators provided by projects like jemalloc and mimalloc yield significantly better performance over the default system allocators. Even so, this can also be disabled if desired. To demonstrate a minimal build, we have provided a Dockerfile which can be used to build the project requiring only CMake and a C++ compiler with zero dependencies. Additionally, we have included an example of including Arrow as an external project dependency in another CMake project. Flexible dependency configuration in CMake As part of improving our CMake-based build system, we have made the configuration of build dependencies both flexible and consistent for different users&#39; needs. In some cases, developers want Arrow to build against dependencies provided by an external package manager, such as apt in Debian-based Linux distributions. In other cases, developers may want to avoid any quirks of system libraries and build all dependencies together with the Arrow build. For each package, the ${Library}_SOURCE CMake option can be set to one of three values: SYSTEM, when the dependency is to be provided externally (such as by a Linux distribution or Homebrew) BUNDLED, when you want the dependency to be built from source while building Arrow, and then statically-linked with the resulting libraries AUTO, which tries the SYSTEM approach but falls back on BUNDLED if the dependency cannot be located We additionally have provided CONDA and BREW source types for the common scenarios when developers are using the conda or Homebrew package managers. These dependency sources can be configured on an individual dependency basis or globally using the ARROW_DEPENDENCY_SOURCE CMake option. AUTO is default, which enables builds to be faster by using pre-built system libraries where possible but still succeed even if all dependencies are not available on the system. Reduced external dependencies Another area of focus was to audit our dependencies. We went through and found places where we could drop external dependencies without losing useful functionality and without having to rewrite a lot or copy too much code into our codebase. We have eliminated Boost as a dependency of the core Arrow library, and in other components (Gandiva, Parquet, etc.), the use of Boost has been greatly reduced. In addition, when building Boost &quot;bundled&quot; in the Arrow build, we stripped down the Boost package we download to the minimum needed, cutting out 90 percent of the download size. We vendored a few small dependencies, such as the double-conversion and uriparser libraries, so that they do not need to be downloaded and built separately. We also compiled the Flatbuffers and Thrift definitions (which are needed to implement the Arrow and Parquet formats, respectively) and checked in the resulting C++ code to the Arrow repository. This means that Flatbuffers is no longer a build or runtime dependency of Arrow, and we only need the Thrift C++ library, not the Thrift compiler, which has additional dependencies on flex and bison. C++ library size reductions As the C++ codebase grows in size, so too does compilation times and the amount of binary code generated by the C++ compiler. Over the last several months, we have begun analyzing the Arrow libraries both compile times and generated code sizes. This has yielded both significant size reductions (more than 30 percent code size reduction since 0.17.0). We have also restructured header files to avoid including unneeded header files, thus lightening the load on C++ compilers and improving compilation times. Python wheels The expectation for binary wheel packages on the Python Package Index (PyPI) is that they are self-contained and have no external dependencies except on other Python packages. Additionally, each user of pyarrow may need different things from the project. Some users just want to read Parquet files and convert them to pandas data frames while others want to use Flight for moving around large datasets. Thus, the &quot;pyarrow&quot; wheel has from the beginning of the project been a fairly comprehensive build including as many optional components as is practical for us to maintain. A comprehensive wheel package has some downsides: most notably for users, it is large. Additionally, through a snafu relating to C++ shared libraries, for several releases the wheel packages would create two copies of each C++ library on disk, resulting in double the amount of disk usage. This has caused problems for people using pyarrow in space-constrained environments like AWS Lambda. In the 1.0.0 release, we have implemented some changes that have reduced the size of the wheels (both in .whl form and installed on disk) by about 75 percent: Working around the problems resulting in two copies of each shared library being created in the site-packages directory. Disabling Gandiva, which required the LLVM runtime, the largest statically-linked dependency. Gandiva is still available to conda users now--it&#39;s just not included in the wheels--and we hope to package it as a separate pyarrow-llvm package in the future. Reducing the size of the C++ shared libraries as discussed above Now pyarrow is about the size of NumPy and thus much easier for Python projects to take on as a hard dependency without worrying about large on-disk size. Looking ahead, we have discussed strategies for breaking up pyarrow into multiple wheel packages, sort of a &quot;hub and spoke&quot; model where some optional pieces are installed as separate wheels so people only needing some &quot;core&quot; functionality only have to install a small package. This would be a significant project, though, so for now we&#39;ve focused on improvements to the comprehensive wheel package. R packaging Packaging Arrow for R involves similar challenges to Python wheels, though the technical details are unique. Like how pip install pyarrow should just work everywhere, so should install.packages(&quot;arrow&quot;) in R, and we have invested significant effort to get there. Because the R package depends on a C++ library in active development, this is not trivial, particularly for all of the combinations of C++ compilers and standard libraries on Linux. In the initial CRAN release last year, version 0.14.1, only Windows and macOS binary packages worked out of the box. For Linux, you had to install the C++ library separately, before installing the R package. While Python wheels contain binary libraries even on Linux, CRAN only hosts source packages that must be compiled on the user&#39;s machine at install time. This led to an experience that was less than ideal for Linux users. Starting in version 0.16, a source package installation on Linux handles its C++ dependencies automatically. By default, the package executes a bundled script that downloads and builds the Arrow C++ library with no system dependencies beyond what R requires. On many common Linux distributions and versions, this can be sped up by setting an environment variable to download a prebuilt static C++ library for inclusion in the package. To accompany these improvements and to ensure that they succeeded on a wide range of platforms, we added extensive nightly builds to our continuous integration system. These are also easily extensible--all we need is a Docker image containing R, and we can plug new environments into our regular nightly testing. Since then, we&#39;ve continued to improve the installation experience and look for ways to reduce build time and package size. The C++ library improvements discussed above help the R package since most installations of the R package either build or otherwise include the C++ library. Within the R package itself, we&#39;ve looked for ways to include just what is needed and nothing more. These efforts have resulted in smaller downloads and installed package sizes. From 0.17.1 to 1.0.0, installed library sizes for macOS and Windows CRAN binaries are down 10 percent, and the prebuilt static C++ libraries for Linux are 33 percent smaller compared to 0.16.0, despite the addition of many new features. checking installed package size ... NOTE installed size is 38.1Mb sub-directories of 1Mb or more: R 3.2Mb libs 34.5Mb autobrew libs on master: 8.9mb macOS 1.0.0 checking installed package size ... NOTE installed size is 35.0Mb sub-directories of 1Mb or more: R 3.2Mb libs 31.3Mb windows 0.17.1: checking installed package size ... NOTE installed size is 27.9Mb sub-directories of 1Mb or more: R 3.2Mb libs 24.3Mb windows libs on 1.0.0: checking installed package size ... NOTE installed size is 24.9Mb sub-directories of 1Mb or more: R 3.2Mb libs 21.2Mb ubuntu-18.04 libarrow binaries: 0.16.0.2 18.84 MB 0.17.0 12.81 MB 1.0.0 12.45 MB --&gt; C Interface Finally, we have observed that some projects may wish to produce or consume a subset of the Arrow format and do not want to take on any additional code dependencies. There are also scenarios where two libraries need to share in-memory Arrow data structures but are unable to depend on a common Arrow library such as the reference C++ implementation. To address these use cases, we designed the C Interface to provide a lightweight way to exchange Arrow data at the C level without any memory copying. When using the C interface, a developer populates simple C data structures that contain the schema (data type) information about an Arrow data structure and the addresses of the pieces of memory that constitute the data. This permits libraries to be plugged together easily in-memory without any shared code (except the C interface structure definitions). Most programming languages have the ability to manipulate C structures and so this interface can even be used without having to write or compile C code. We have used the C interface to transfer data structures between Python and R in-memory using reticulate. One exciting use case for the Arrow C interface is to add Arrow import and export to database driver libraries which often contain a C API. Looking ahead As the project grows, we will continue working to make the build process as fast and reliable as possible. If you see ways we can improve it further, or if you run into trouble, please bring it up on our mailing list or report an issue.","headline":"Making Arrow C++ Builds Simpler, Smaller, and Faster","image":"https://arrow.apache.org/img/arrow-logo_horizontal_black-txt_white-bg.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://arrow.apache.org/blog/2020/07/29/cpp-build-simplification/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://arrow.apache.org/img/logo.png"},"name":"pmc"},"url":"https://arrow.apache.org/blog/2020/07/29/cpp-build-simplification/"}</script>
<!-- End Jekyll SEO tag -->


    <!-- favicons -->
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png" id="light1">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png" id="light2">
    <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="/img/apple-touch-icon.png" id="light3">
    <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="/img/apple-touch-icon-120x120.png" id="light4">
    <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="/img/apple-touch-icon-76x76.png" id="light5">
    <link rel="apple-touch-icon" type="image/png" sizes="60x60" href="/img/apple-touch-icon-60x60.png" id="light6">
    <!-- dark mode favicons -->
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16-dark.png" id="dark1">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32-dark.png" id="dark2">
    <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="/img/apple-touch-icon-dark.png" id="dark3">
    <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="/img/apple-touch-icon-120x120-dark.png" id="dark4">
    <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="/img/apple-touch-icon-76x76-dark.png" id="dark5">
    <link rel="apple-touch-icon" type="image/png" sizes="60x60" href="/img/apple-touch-icon-60x60-dark.png" id="dark6">

    <script>
      // Switch to the dark-mode favicons if prefers-color-scheme: dark
      function onUpdate() {
        light1 = document.querySelector('link#light1');
        light2 = document.querySelector('link#light2');
        light3 = document.querySelector('link#light3');
        light4 = document.querySelector('link#light4');
        light5 = document.querySelector('link#light5');
        light6 = document.querySelector('link#light6');

        dark1 = document.querySelector('link#dark1');
        dark2 = document.querySelector('link#dark2');
        dark3 = document.querySelector('link#dark3');
        dark4 = document.querySelector('link#dark4');
        dark5 = document.querySelector('link#dark5');
        dark6 = document.querySelector('link#dark6');

        if (matcher.matches) {
          light1.remove();
          light2.remove();
          light3.remove();
          light4.remove();
          light5.remove();
          light6.remove();
          document.head.append(dark1);
          document.head.append(dark2);
          document.head.append(dark3);
          document.head.append(dark4);
          document.head.append(dark5);
          document.head.append(dark6);
        } else {
          dark1.remove();
          dark2.remove();
          dark3.remove();
          dark4.remove();
          dark5.remove();
          dark6.remove();
          document.head.append(light1);
          document.head.append(light2);
          document.head.append(light3);
          document.head.append(light4);
          document.head.append(light5);
          document.head.append(light6);
        }
      }
      matcher = window.matchMedia('(prefers-color-scheme: dark)');
      matcher.addListener(onUpdate);
      onUpdate();
    </script>

    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <script src="/javascript/main.js"></script>
    
    <!-- Matomo -->
<script>
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  /* We explicitly disable cookie tracking to avoid privacy issues */
  _paq.push(['disableCookies']);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="https://analytics.apache.org/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '20']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->

    
    <link type="application/atom+xml" rel="alternate" href="https://arrow.apache.org/feed.xml" title="Apache Arrow" />
  </head>


<body class="wrap">
  <header>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
  
  <a class="navbar-brand no-padding" href="/"><img src="/img/arrow-inverse-300px.png" height="40px"></a>
  
   <button class="navbar-toggler ml-auto" type="button" data-toggle="collapse" data-target="#arrow-navbar" aria-controls="arrow-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse justify-content-end" id="arrow-navbar">
      <ul class="nav navbar-nav">
        <li class="nav-item"><a class="nav-link" href="/overview/" role="button" aria-haspopup="true" aria-expanded="false">Overview</a></li>
        <li class="nav-item"><a class="nav-link" href="/faq/" role="button" aria-haspopup="true" aria-expanded="false">FAQ</a></li>
        <li class="nav-item"><a class="nav-link" href="/blog" role="button" aria-haspopup="true" aria-expanded="false">Blog</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownGetArrow" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Get Arrow
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownGetArrow">
            <a class="dropdown-item" href="/install/">Install</a>
            <a class="dropdown-item" href="/release/">Releases</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownDocumentation" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Docs
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownDocumentation">
            <a class="dropdown-item" href="/docs">Project Docs</a>
            <a class="dropdown-item" href="/docs/format/Columnar.html">Format</a>
            <hr>
            <a class="dropdown-item" href="/docs/c_glib">C GLib</a>
            <a class="dropdown-item" href="/docs/cpp">C++</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/blob/main/csharp/README.md" target="_blank" rel="noopener">C#</a>
            <a class="dropdown-item" href="https://godoc.org/github.com/apache/arrow/go/arrow" target="_blank" rel="noopener">Go</a>
            <a class="dropdown-item" href="/docs/java">Java</a>
            <a class="dropdown-item" href="/docs/js">JavaScript</a>
            <a class="dropdown-item" href="/julia/">Julia</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/blob/main/matlab/README.md" target="_blank" rel="noopener">MATLAB</a>
            <a class="dropdown-item" href="/docs/python">Python</a>
            <a class="dropdown-item" href="/docs/r">R</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/blob/main/ruby/README.md" target="_blank" rel="noopener">Ruby</a>
            <a class="dropdown-item" href="https://docs.rs/arrow/latest" target="_blank" rel="noopener">Rust</a>
            <a class="dropdown-item" href="/swift">Swift</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownSource" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Source
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownSource">
            <a class="dropdown-item" href="https://github.com/apache/arrow" target="_blank" rel="noopener">Main Repo</a>
            <hr>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/c_glib" target="_blank" rel="noopener">C GLib</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/cpp" target="_blank" rel="noopener">C++</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/csharp" target="_blank" rel="noopener">C#</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-go" target="_blank" rel="noopener">Go</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-java" target="_blank" rel="noopener">Java</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-js" target="_blank" rel="noopener">JavaScript</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-julia" target="_blank" rel="noopener">Julia</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/matlab" target="_blank" rel="noopener">MATLAB</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/python" target="_blank" rel="noopener">Python</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/r" target="_blank" rel="noopener">R</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/tree/main/ruby" target="_blank" rel="noopener">Ruby</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-rs" target="_blank" rel="noopener">Rust</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow-swift" target="_blank" rel="noopener">Swift</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownSubprojects" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Subprojects
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownSubprojects">
            <a class="dropdown-item" href="/adbc">ADBC</a>
            <a class="dropdown-item" href="/docs/format/Flight.html">Arrow Flight</a>
            <a class="dropdown-item" href="/docs/format/FlightSql.html">Arrow Flight SQL</a>
            <a class="dropdown-item" href="https://datafusion.apache.org" target="_blank" rel="noopener">DataFusion</a>
            <a class="dropdown-item" href="/nanoarrow">nanoarrow</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownCommunity" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             Community
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownCommunity">
            <a class="dropdown-item" href="/community/">Communication</a>
            <a class="dropdown-item" href="/docs/developers/index.html">Contributing</a>
            <a class="dropdown-item" href="https://github.com/apache/arrow/issues" target="_blank" rel="noopener">Issue Tracker</a>
            <a class="dropdown-item" href="/committers/">Governance</a>
            <a class="dropdown-item" href="/use_cases/">Use Cases</a>
            <a class="dropdown-item" href="/powered_by/">Powered By</a>
            <a class="dropdown-item" href="/visual_identity/">Visual Identity</a>
            <a class="dropdown-item" href="/security/">Security</a>
            <a class="dropdown-item" href="https://www.apache.org/foundation/policies/conduct.html" target="_blank" rel="noopener">Code of Conduct</a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownASF" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
             ASF Links
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownASF">
            <a class="dropdown-item" href="https://www.apache.org/" target="_blank" rel="noopener">ASF Website</a>
            <a class="dropdown-item" href="https://www.apache.org/licenses/" target="_blank" rel="noopener">License</a>
            <a class="dropdown-item" href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener">Donate</a>
            <a class="dropdown-item" href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener">Thanks</a>
            <a class="dropdown-item" href="https://www.apache.org/security/" target="_blank" rel="noopener">Security</a>
          </div>
        </li>
      </ul>
    </div>
<!-- /.navbar-collapse -->
  </nav>

  </header>

  <div class="container p-4 pt-5">
    <div class="col-md-8 mx-auto">
      <main role="main" class="pb-5">
        
<h1>
  Making Arrow C++ Builds Simpler, Smaller, and Faster
</h1>
<hr class="mt-4 mb-3">



<p class="mb-4 pb-1">
  <span class="badge badge-secondary">Published</span>
  <span class="published mr-3">
    29 Jul 2020
  </span>
  <br>
  <span class="badge badge-secondary">By</span>
  
    <a class="mr-3" href="https://arrow.apache.org">The Apache Arrow PMC (pmc) </a>
  

  
</p>


        <!--

-->
<p>Over the last four and a half years, we've worked to build a
"batteries-included" development platform for high-performance analytics
applications in C++. As the scope of the project has grown, we have sometimes
taken on additional library dependencies to support a wide variety of systems
and data processing tasks.</p>
<p>While these dependencies give us leverage on hard problems, in some cases they
have added complexity for projects that depend on Arrow. Some projects have thus
been concerned about depending on the Arrow C++ library, particularly if their
use of the Arrow library's features is limited. Indeed, in the earlier stages of
the Arrow project development, dependency management issues did cause problems
for early adopters.</p>
<p>We want developers to trust that they can use and depend on our libraries, and
that doing so doesn't add a burden for their own project maintenance or for
their users. Over the last year, we have undertaken a number of significant
projects to accommodate the different ways that people want to depend on Arrow
C++. We've aimed to make the build process simple by default, without requiring
special environment setup, yet also highly configurable for those who need to
specialize. This includes a <em>zero-dependency option</em> for projects that wish to use
the Arrow C++ core but take on no transitive dependencies. We've also worked to
make builds faster and more compact, even as we continue to add new
functionality.</p>
<p>This post covers many of the efforts we've made, both in the C++ libraries and
in the Arrow Python and R packages that depend on them. Compared to a year ago,
the build experience is much more reliable on a wider range of platforms,
requires fewer dependencies, and yields smaller package sizes.</p>
<h2>Minimal default build options</h2>
<p>One rough edge for people using Arrow as a dependency was that many optional
project components were enabled in the build by default, thus requiring any
extra dependencies of those optional components. Rather than expecting users to
disable optional components one by one, we have made the default for all
optional components to be <code>OFF</code> so that the default configuration is a
dependency-free minimal core build.</p>
<p>The only third-party library enabled by default is
<a href="http://jemalloc.net/" target="_blank" rel="noopener">jemalloc</a>, the project's recommended memory allocator
(except on Windows, where it is also disabled). Given that Arrow applications
often process large volumes of data, we have found additionally that using
memory allocators provided by projects like jemalloc and
<a href="https://microsoft.github.io/mimalloc/" target="_blank" rel="noopener">mimalloc</a> yield significantly better
performance over the default system allocators. Even so, this can also be
disabled if desired.</p>
<p>To demonstrate a minimal build, we have provided a
<a href="https://github.com/apache/arrow/blob/master/cpp/examples/minimal_build/Dockerfile" target="_blank" rel="noopener">Dockerfile</a>
which can be used to build the project requiring only CMake and a C++ compiler
with zero dependencies. Additionally, we have included an
<a href="https://github.com/apache/arrow/tree/master/cpp/examples/minimal_build" target="_blank" rel="noopener">example</a>
of including Arrow as an external project dependency in another CMake project.</p>
<h2>Flexible dependency configuration in CMake</h2>
<p>As part of improving our CMake-based build system, we have made the
configuration of build dependencies both flexible and consistent for different
users' needs. In some cases, developers want Arrow to build against dependencies
provided by an external package manager, such as apt in Debian-based Linux
distributions. In other cases, developers may want to avoid any quirks of system
libraries and build all dependencies together with the Arrow build.</p>
<p>For each package, the <code>${Library}_SOURCE</code> CMake option can be set to one of three
values:</p>
<ul>
<li>
<code>SYSTEM</code>, when the dependency is to be provided externally (such as by a Linux distribution or Homebrew)</li>
<li>
<code>BUNDLED</code>, when you want the dependency to be built from source while building Arrow, and then statically-linked with the resulting libraries</li>
<li>
<code>AUTO</code>, which tries the <code>SYSTEM</code> approach but falls back on <code>BUNDLED</code> if the dependency cannot be located</li>
</ul>
<p>We additionally have provided <code>CONDA</code> and <code>BREW</code> source types for the common
scenarios when developers are using the conda or Homebrew package managers.
These dependency sources can be configured on an individual dependency basis or
globally using the <code>ARROW_DEPENDENCY_SOURCE</code> CMake option. <code>AUTO</code> is default,
which enables builds to be faster by using pre-built system libraries where
possible but still succeed even if all dependencies are not available on the
system.</p>
<h2>Reduced external dependencies</h2>
<p>Another area of focus was to audit our dependencies. We went through and found
places where we could drop external dependencies without losing useful
functionality and without having to rewrite a lot or copy too much code into our
codebase.</p>
<p>We have eliminated Boost as a dependency of the core Arrow library, and in other
components (Gandiva, Parquet, etc.), the use of Boost has been greatly reduced.
In addition, when building Boost "bundled" in the Arrow build, we stripped down
the Boost package we download to the minimum needed, cutting out 90 percent of
the download size.</p>
<p>We vendored a few small dependencies, such as the double-conversion and
uriparser libraries, so that they do not need to be downloaded and built
separately.</p>
<p>We also compiled the Flatbuffers and Thrift definitions (which are needed to
implement the Arrow and Parquet formats, respectively) and checked in the
resulting C++ code to the Arrow repository. This means that Flatbuffers is no
longer a build or runtime dependency of Arrow, and we only need the Thrift C++
library, not the Thrift compiler, which has additional dependencies on flex and
bison.</p>
<h2>C++ library size reductions</h2>
<p>As the C++ codebase grows in size, so too does compilation times and the amount
of binary code generated by the C++ compiler. Over the last several months, we
have begun analyzing the Arrow libraries both compile times and generated code
sizes. This has yielded both significant size reductions (more than 30 percent
code size reduction since 0.17.0). We have also restructured header files to
avoid including unneeded header files, thus lightening the load on C++ compilers
and improving compilation times.</p>
<h2>Python wheels</h2>
<p>The expectation for binary wheel packages on the Python Package Index (PyPI) is
that they are self-contained and have no external dependencies except on other
Python packages. Additionally, each user of pyarrow may need different things
from the project. Some users just want to read Parquet files and convert them to
pandas data frames while others want to use
<a href="/blog/2019/10/13/introducing-arrow-flight/">Flight</a> for
moving around large datasets. Thus, the "pyarrow" wheel has from the beginning
of the project been a fairly comprehensive build including as many optional
components as is practical for us to maintain.</p>
<p>A comprehensive wheel package has some downsides: most notably for users, it is large.
Additionally, through a snafu relating to C++ shared libraries, for several
releases the wheel packages would create two copies of each C++ library on disk,
resulting in double the amount of disk usage. This has caused problems for
people using pyarrow in space-constrained environments like AWS Lambda.</p>
<p>In the 1.0.0 release, we have implemented some changes that have reduced the
size of the wheels (both in <code>.whl</code> form and installed on disk) by about 75 percent:</p>
<ul>
<li>Working around the problems resulting in two copies of each shared library being created in the site-packages directory.</li>
<li>Disabling Gandiva, which required the LLVM runtime, the largest statically-linked dependency. Gandiva is still available to conda users now--it's just not included in the wheels--and we hope to package it as a separate <code>pyarrow-llvm</code> package in the future.</li>
<li>Reducing the size of the C++ shared libraries as discussed above</li>
</ul>
<p>Now pyarrow is about the size of NumPy and thus much easier for Python projects
to take on as a hard dependency without worrying about large on-disk size.</p>
<p>Looking ahead, we have discussed <a href="https://issues.apache.org/jira/browse/ARROW-8518" target="_blank" rel="noopener">strategies</a>
for breaking up pyarrow into multiple wheel packages, sort of a "hub and spoke"
model where some optional pieces are installed as separate wheels so people only
needing some "core" functionality only have to install a small package. This
would be a significant project, though, so for now we've focused on improvements
to the comprehensive wheel package.</p>
<h2>R packaging</h2>
<p>Packaging Arrow for R involves similar challenges to Python wheels, though the
technical details are unique. Like how <code>pip install pyarrow</code> should just work
everywhere, so should <code>install.packages("arrow")</code> in R, and we have invested
significant effort to get there. Because the R package depends on a C++ library
in active development, this is not trivial, particularly for all of the
combinations of C++ compilers and standard libraries on Linux.</p>
<p>In the initial CRAN release last year, version 0.14.1, only Windows and macOS
binary packages worked out of the box. For Linux, you had to install the C++
library separately, before installing the R package. While Python wheels contain
binary libraries even on Linux, CRAN only hosts source packages that must be
compiled on the user's machine at install time. This led to an experience that
was less than ideal for Linux users.</p>
<p>Starting in version 0.16, a source package installation on Linux handles its C++
dependencies automatically. By default, the package executes a <a href="https://github.com/apache/arrow/blob/master/r/inst/build_arrow_static.sh" target="_blank" rel="noopener">bundled
script</a>
that downloads and builds the Arrow C++ library with no system dependencies
beyond what R requires. On many common Linux distributions and versions, this
can be sped up by
<a href="/docs/r/articles/install.html">setting an environment variable</a>
to download a prebuilt static C++ library for inclusion in the package.</p>
<p>To accompany these improvements and to ensure that they succeeded on a wide
range of platforms, we added
<a href="https://github.com/apache/arrow/blob/bebcc5db3cc2890a9c53ebd53bc60863ae5ebb49/dev/tasks/tasks.yml#L1704-L1785" target="_blank" rel="noopener">extensive</a>
<a href="https://github.com/ursa-labs/arrow-r-nightly/blob/master/.github/workflows/test-binary.yml" target="_blank" rel="noopener">nightly builds</a>
to our continuous integration system. These are also easily extensible--all we
need is a Docker image containing R, and we can plug new environments into our
regular nightly testing.</p>
<p>Since then, we've continued to improve the installation experience and look for
ways to reduce build time and package size. The C++ library improvements
discussed above help the R package since most installations of the R package
either build or otherwise include the C++ library. Within the R package itself,
we've looked for ways to include just what is needed and nothing more. These
efforts have resulted in smaller downloads and installed package sizes. From
0.17.1 to 1.0.0, installed library sizes for macOS and Windows CRAN binaries are
down 10 percent, and the prebuilt static C++ libraries for Linux are 33 percent
smaller compared to 0.16.0, despite the addition of many new features.</p>
<!-- macOS build 0.17.1:

checking installed package size ... NOTE
  installed size is 38.1Mb
  sub-directories of 1Mb or more:
    R 3.2Mb
    libs 34.5Mb

autobrew libs on master: 8.9mb

macOS 1.0.0
checking installed package size ... NOTE
  installed size is 35.0Mb
  sub-directories of 1Mb or more:
    R 3.2Mb
    libs 31.3Mb

windows 0.17.1:
checking installed package size ... NOTE
  installed size is 27.9Mb
  sub-directories of 1Mb or more:
    R 3.2Mb
    libs 24.3Mb

windows libs on 1.0.0:
checking installed package size ... NOTE
  installed size is 24.9Mb
  sub-directories of 1Mb or more:
    R 3.2Mb
    libs 21.2Mb

ubuntu-18.04 libarrow binaries:
0.16.0.2 18.84 MB
0.17.0 	  12.81 MB
1.0.0      12.45 MB -->
<h2>C Interface</h2>
<p>Finally, we have observed that some projects may wish to produce or consume a
subset of the Arrow format and do not want to take on any additional code
dependencies. There are also scenarios where two libraries need to share
in-memory Arrow data structures but are unable to depend on a common Arrow
library such as the reference C++ implementation. To address these use cases, we
designed the <a href="/docs/format/CDataInterface.html">C Interface</a>
to provide a lightweight way to exchange Arrow data at the C level without any
memory copying.</p>
<p>When using the C interface, a developer populates simple C data structures that
contain the schema (data type) information about an Arrow data structure and the
addresses of the pieces of memory that constitute the data. This permits
libraries to be plugged together easily in-memory without any shared code
(except the C interface structure definitions). Most programming languages have
the ability to manipulate C structures and so this interface can even be used
without having to write or compile C code. We have used the C interface to
<a href="/docs/r/articles/python.html">transfer data structures between Python and R</a>
in-memory using <code>reticulate</code>.</p>
<p>One exciting use case for the Arrow C interface is to add Arrow import and
export to database driver libraries which often contain a C API.</p>
<h2>Looking ahead</h2>
<p>As the project grows, we will continue working to make the build process as
fast and reliable as possible. If you see ways we can improve it further, or if
you run into trouble, please bring it up on our
<a href="https://arrow.apache.org/community/#mailing-lists">mailing list</a> or
<a href="https://issues.apache.org/jira/browse/ARROW" target="_blank" rel="noopener">report an issue</a>.</p>

      </main>
    </div>

    <hr>
<footer class="footer">
  <div class="row">
    <div class="col-md-9">
      <p>Apache Arrow, Arrow, Apache, the Apache feather logo, and the Apache Arrow project logo are either registered trademarks or trademarks of The Apache Software Foundation in the United States and other countries.</p>
      <p>© 2016-2025 The Apache Software Foundation</p>
    </div>
    <div class="col-md-3">
      <a class="d-sm-none d-md-inline pr-2" href="https://www.apache.org/events/current-event.html" target="_blank" rel="noopener">
        <img src="https://www.apache.org/events/current-event-234x60.png">
      </a>
    </div>
  </div>
</footer>

  </div>
</body>
</html>
